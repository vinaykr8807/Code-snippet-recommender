Unnamed: 0,problem_title,python_solutions,difficulty,num_of_lines,code_length,comments,cyclomatic_complexity,indents,loop_count,line_length,identifiers,readability
0.0,two sum,"class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
         left = 0
         right = len(nums)
         while left < right:
             if target-nums[left] in nums and nums.index(target-nums[left]) != left:
                 return [left,nums.index(target-nums[left])]
             else:
                 left+=1",Easy,8,344,0.0,2,3.0,2.0,43.0,16.0,4.23
2.0,longest substring without repeating characters,"class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        i, j = 0, 0
        n = len(s)
        frequencyArray = [0]*(5 * 10**4)
        maxSize = 0
        while j < n:
            frequencyArray[ord(s[j]) - ord('a')] += 1
            mapSize = (5*10**4) - frequencyArray.count(0)
            
            if mapSize == j - i + 1:
                maxSize = max(maxSize, j - i + 1)
                j += 1
            
            elif mapSize < j - i + 1:
                while mapSize < j - i + 1:
                    frequencyArray[ord(s[i]) - ord('a')] -= 1
                    mapSize = (5*10**4) - frequencyArray.count(0)
                    i += 1
                j += 1
        return maxSize",Medium,20,721,0.0,4,4.0,4.0,36.05,30.0,3.2755
3.0,median of two sorted arrays,"class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        sum_list = nums1 + nums2
        sum_list.sort()
        sum_size = len(sum_list)

        if sum_size % 2 == 0:
            x = (sum_list[int(sum_size/2)] + sum_list[int((sum_size/2) - 1)]) / 2
        else:
            x = sum_list[int(sum_size/2)]

        return x",Hard,11,375,0.0,1,2.0,1.0,34.09090909090909,16.0,5.151818181818182
4.0,longest palindromic substring,"class Solution:
    def longestPalindrome(self, s: str) -> str:
        self.res = """";
        self.resLen = 0;
        for i in range(len(s)):
            self.getPalindrome(s,i,i);
            self.getPalindrome(s,i,i+1);
        return self.res;
    def getPalindrome(self,s,l,r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            if (r - l + 1) > self.resLen:
                self.res = s[l:r+1];
                self.resLen = len(self.res);
            l -= 1;
            r += 1;",Medium,14,501,0.0,3,3.0,3.0,35.785714285714285,30.0,3.419285714285716
5.0,zigzag conversion,"class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        a = ['' for i in range(numRows)]
        c = numRows
        inc = False
        for i in s:
            a[numRows-c] += i # If numRows = 3, the range of numRows-c is [0, 2] as c is in the range of [1, 3]
            if not inc:
                c -= 1
                if c == 1:
                    inc = True
            else:
                c += 1
                if c == numRows:
                    inc = False
        return ''.join(a)",Medium,17,563,1.0,4,3.0,7.0,33.11764705882353,34.0,3.239411764705882
6.0,reverse integer,"class Solution:
    def reverse(self, x: int) -> int:
        reverse = 0
        num, x = x, abs(x)
        while x:
            last = x % 10
            x //= 10
            reverse = reverse * 10 + last
            if not (reverse <= 2 ** 31 and reverse >= -2 ** 31):
                return 0
            
        return reverse if num > 0 else -reverse",Medium,11,357,0.0,1,3.0,3.0,32.45454545454545,19.0,4.939090909090909
7.0,string to integer (atoi),"class Solution:
    def myAtoi(self, s: str) -> int:
        s= s.strip("" "")
        if len(s) == 0:return 0
        s = list(s)
        sign = 1
        
        if s[0] == ""-"":
            sign = -1
            s.pop(0) # Removing the sign from the first term 
        elif s[0] == ""+"":
            sign = 1
            s.pop(0)
        else:
            pass
        
        if len(s) > 2 and not s[0].isdigit():
            return 0
        _ = ""0""
        
        for i in s:
            if i.isdigit():
                _+=i
            else:
                break
                
        return_val = int(_) * sign
        
        if return_val < -2147483648:
            return -2147483648
        
        elif return_val > 2147483647:
            return 2147483647
        
        else:
            return return_val",Medium,35,830,1.0,3,3.0,8.0,23.714285714285715,36.0,3.9457142857142857
8.0,palindrome number,"class Solution:
    def isPalindrome(self, x: int) -> bool:
        y = list(str(x))
        return y== list(reversed(y))",Easy,3,121,0.0,0,2.0,0.0,40.333333333333336,9.0,5.35
9.0,regular expression matching,"class Solution:
    @lru_cache
    def isMatch(self, s, p):
        if not p:   return not s
        if p[-1] == '*':
            return (self.isMatch(s, p[:-2])) or (s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p))
        return s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1])",Hard,6,321,0.0,0,2.0,2.0,53.5,28.0,2.265
10.0,container with most water,"class Solution:
    def maxArea(self, height: List[int]) -> int:
        """"""Uses two pointers. 
        Left pointer starts with 0th index and
        Right pointer starts at last index.
        Calculate the area and update if greater than
        area variable.
        If heigh[right] is greater than heigh[left], increment
        left, otherwise decrement right.
        """"""
        area = 0
        left = 0
        right = len(height) -1
        while left < right:
            side = min(height[left], height[right])
            width = right - left
            area = max(side * width, area)
            if height[right] > height[left]:
                left += 1
            else:
                right -= 1
        return area",Medium,21,736,0.0,2,3.0,4.0,35.04761904761905,22.0,4.345714285714286
11.0,integer to roman,"class Solution:
    def intToRoman(self, num: int) -> str:
        """"""
        Symbol       Value
        I             1     ones
        V             5     ones
        X             10    tens
        L             50    tens
        C             100   hundreds
        D             500   hundreds
        M             1000  thousands
        """"""
        # mode the number to get digits
        # based on the digits, append the letter to the ans
        # reverse the ans or use dequeue()
        letters = [[""I"", ""IV"", ""V"", ""IX""],
                  [""X"", ""XL"", ""L"", ""XC""],
                  [""C"", ""CD"", ""D"", ""CM""],
                  [""M"","""","""",""""]]
        place = 0 # value place. 0-> ones, 1->tens
        ans = deque()
        while num > 0:
            digit = num % 10            
            num //= 10
            lt = letters[place]
            if digit < 4:
                ans.appendleft(lt[0]*digit)
            elif digit == 4:
                ans.appendleft(lt[1])
            elif digit < 9:
                ans.appendleft(lt[2]+lt[0]*(digit-5))      
            elif digit == 9:
                ans.appendleft(lt[3])
            place += 1
        return """".join(ans)",Medium,34,1192,4.0,5,4.0,5.0,35.05882352941177,45.0,1.9647058823529413
12.0,roman to integer,"class Solution:
    def romanToInt(self, s: str) -> int:
        dic={""I"":1, ""V"":5, ""X"":10, ""L"":50, ""C"":100, ""D"":500, ""M"":1000 }
        m,total=dic[s[0]],0
        for i in s:
            n=dic[i]
            total = (total- 2*m + n) if(m<n) else (total+ n)
            m=n
        return total",Easy,8,295,0.0,1,3.0,2.0,36.875,27.0,3.74125
13.0,longest common prefix,"class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        result = """"
        
        strs.sort()
        
		# Loop over the characters in the first index of the array
        for char in range(len(strs[0])):
		
			#If the character is the same in both the first and last string at the same index, append to result and continue with the loop.
            if strs[0][char] == strs[-1][char]:
                result += strs[0][char]
                continue
            else:
				# Break out of the loop here.  Personally, I find this this easier to read, could also just return the result.
                break
                
        return result",Easy,17,675,3.0,-3,3.0,3.0,39.70588235294117,16.0,4.946470588235294
14.0,binary tree level order traversal,"class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        levels = []
        
        def order(node, level):
            if level >= len(levels):
                levels.append([])
            
            if node:
                levels[level].append(node.val)
            
                if node.left:
                    order(node.left, level + 1)
                
                if node.right:
                    order(node.right, level + 1)
        
        if not root:
            return []
        
        order(root, 0)
        return levels",Medium,21,593,0.0,4,3.0,5.0,28.23809523809524,18.0,5.238571428571428
15.0,binary tree zigzag level order traversal,"class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return root
        q = [root]
        level = []
        res = [[root.val]]
        x = 0
        while q and root:
            for node in q:
                if node.left:
                    level.append(node.left)
                if node.right:
                    level.append(node.right)
            temp = []
            for i in level:
                temp.append(i.val)
            x += 1
            if temp:
                if x % 2 != 0:
                    res.append(temp[::-1])
                else:
                    res.append(temp)
            q = level
            level = []
        return res",Medium,25,741,0.0,7,4.0,8.0,29.64,25.0,4.1724
16.0,maximum depth of binary tree,"class Solution:

    def maxDepth(self, root: Optional[TreeNode]):
        queue = []
        height = 0
        if not root:
            return 0
        queue.append(root)

        while queue:
            current_length = len(queue)
            height += 1
            for _ in range(0, current_length):
                popped_elem = queue.pop(0)
                if popped_elem.left:
                    queue.append(popped_elem.left)
                if popped_elem.right:
                    queue.append(popped_elem.right)

        return height",Easy,19,550,0.0,4,3.0,5.0,28.94736842105263,15.0,5.474736842105264
17.0,construct binary tree from preorder and inorder traversal,"class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def buildTree(preorder, inorder):
            if inorder:
                root = TreeNode(preorder.pop(0))
                root_index = inorder.index(root.val)
                root.left = buildTree(preorder,inorder[:root_index])
                root.right = buildTree(preorder,inorder[root_index+1:])
                return root
        return buildTree(preorder, inorder)",Medium,9,484,0.0,0,4.0,1.0,53.77777777777778,19.0,3.02
18.0,construct binary tree from inorder and postorder traversal,"class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        m = {}
        for i in range(len(inorder)):
            m[inorder[i]] = i
            
        def helper(in_l, in_r, inorder, po_l, po_r, postorder):
            if po_l >= po_r:
                return TreeNode(postorder[po_r])
            curr = TreeNode(postorder[po_r])
            idx = m[postorder[po_r]]
            num_right_tree = in_r - idx
            num_left_tree = idx - in_l
            if num_right_tree > 0:
                curr.right = helper(idx+1, in_r, inorder, po_r-num_right_tree, po_r-1, postorder)
            if num_left_tree > 0:
                curr.left = helper(in_l, idx-1, inorder, po_l, po_l+num_left_tree-1, postorder)
            return curr
        
        return helper(0, len(inorder)-1, inorder, 0, len(postorder)-1, postorder)",Medium,19,881,0.0,2,3.0,4.0,46.36842105263158,44.0,1.126842105263158
19.0,binary tree level order traversal ii,"class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if root is None: return
        queue = deque([root])
        op = []
        while queue:
            level = []
            for i in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            op.append(level)
        return op[::-1]",Medium,13,485,0.0,4,3.0,5.0,37.30769230769231,16.0,4.622307692307693
20.0,convert sorted array to binary search tree,"class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:

        def recur(start, end):
            if end < start:
                return None
            mid = floor((start+end)/2)
            node = TreeNode(nums[mid])
            node.left = recur(start, mid-1)
            node.right = recur(mid+1, end)
            return node
        
        return recur(0, len(nums)-1)",Easy,12,409,0.0,-1,3.0,1.0,34.083333333333336,16.0,5.2125
21.0,convert sorted list to binary search tree,"class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        if not head or not head.next:
            return TreeNode(head.val) if head else None
			
        slow, fast = head, head.next
        while fast.next and fast.next.next:
            slow, fast = slow.next, fast.next.next
        fast, slow.next = slow.next, None
		
        node = TreeNode(fast.val)
        node.left = self.sortedListToBST(head)
        node.right = self.sortedListToBST(fast.next)
        return node",Medium,13,503,0.0,1,2.0,3.0,38.69230769230769,19.0,4.437692307692308
22.0,balanced binary tree,"class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        
        if not root:
            return True
        
        def recur(node, level):
            if not node:
                return level-1
            left = recur(node.left, level+1)
            right = recur(node.right, level+1)
            if not left or not right:
                return 0
            if abs(left-right) > 1:
                return 0
            return max(left, right)
        
        level = recur(root, 1)
        
        if not level:
            return False
        return True",Easy,21,594,0.0,-1,3.0,5.0,28.285714285714285,20.0,5.3342857142857145
23.0,minimum depth of binary tree,"class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        import queue
        if not root:
            return 0

        q = queue.Queue()
        q.put((1, root))
        while not q.empty():
            level, node = q.get()
            if not node.left and not node.right:
                return level
            
            if node.left:
                q.put((level+1, node.left))
                
            if node.right:
                q.put((level+1, node.right))",Easy,17,500,0.0,4,3.0,5.0,29.41176470588235,16.0,5.332941176470588
24.0,path sum,"class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        f = False
        def util(root, c):
            nonlocal f
            if root:
                c += root.val
                util(root.left, c)
                util(root.right, c)
                if not root.left and not root.right and c == targetSum:
                    f= True
        util(root, 0)
        return f",Easy,12,420,0.0,2,3.0,2.0,35.0,20.0,4.55
25.0,path sum ii,"class Solution:
    def solve(self, root, S , curr , res):
        if(not root):
            return
        curr.append(root.val)
        
        
        if(root.val == S and not root.left and not root.right):
            res.append(list(curr))
            #remeber that when append lisi of list convert into a list
        self.solve(root.left, S - root.val , curr , res)
        
        self.solve(root.right, S - root.val , curr , res)
        
        #del curr[-1]
        curr.pop()
        
        
        
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        curr = []
        self.solve(root , targetSum , curr , res)
        return res",Medium,23,706,2.0,-1,3.0,2.0,30.695652173913043,28.0,4.397391304347826
26.0,flatten binary tree to linked list,"class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """"""
        Do not return anything, modify root in-place instead.
        """"""
        if not root:
            return None
        
        # left is the last node of the left subtree.
        # and similarly right is the last node of the right subtree
        left = self.flatten(root.left)
        right = self.flatten(root.right)
        
        if left:
            # First, we join the last node of left subtree to first node in right subtree
            # Then we move the left subtree to the right of the node, and delete the left subtree pointer
            left.right = root.right
            root.right = root.left
            root.left = None
        
        # if theres a right subtree, we return its last node, failing which the last node of the left subtree,
		# and if none are present (i.e. its a leaf node), we return the node itself.
        return right or left or root",Medium,22,971,6.0,-2,3.0,5.0,44.13636363636363,19.0,4.3077272727272735
27.0,distinct subsequences,"class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp = [[0 for i in range(m + 1)] for i in range(n + 1)]
        
        for i in range(0, m + 1):
            dp[i][0] = 1
        for i in range(1,m + 1):
            for j in range(1,n + 1):
                dp[i][j] += dp[i - 1][j] + (dp[i - 1][j - 1] if s[i - 1] == t[j - 1] else 0)
        return dp[m][n]",Hard,10,413,0.0,3,3.0,6.0,41.3,22.0,3.7230000000000008
29.0,populating next right pointers in each node ii,"class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if root == None:
            return None
        q = collections.deque([root])
        while len(q) > 0:
            size = len(q)
            prev = None
            for _ in range(size):
                node = q.popleft()
                if prev:
                    prev.next = node
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                prev = node
            prev.next = None
        return root",Medium,18,575,0.0,5,4.0,6.0,31.944444444444443,22.0,4.385000000000001
30.0,pascals triangle,"class Solution(object):
    def generate(self, numRows):
        """"""
        :type numRows: int
        :rtype: List[List[int]]
        """"""
        response = [[1]*i for i in range(1, numRows+1)]
        
        for i in range(2, numRows):
            for j in range(1,i):
                response[i][j] = response[i-1][j] + response[i-1][j-1]
                
        return response",Easy,12,385,0.0,2,3.0,3.0,32.083333333333336,14.0,5.4125
31.0,pascals triangle ii,"class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        l=[[1]*(i+1) for i in range(rowIndex+1)]
        
        if(rowIndex==0):
            l[0]=[1]
        
        else:
            l[0]=[1]
            l[1]=[1,1]
        
            for i in range(2,len(l)):
                for j in range(0,len(l[i])):
                    if(j==0 or j==len(l[i])+1):
                        continue
                    else:
                        l[i][j]=sum(l[i-1][j-1:j+1])
        return l[-1]",Easy,17,509,0.0,1,4.0,5.0,29.94117647058824,29.0,4.105294117647058
32.0,triangle,"class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        dp = [[-1] * n for x in range(n)]
        
        for j in range(n):
            dp[n-1][j] = triangle[n-1][j]
        i = n-2
        while(i>=0):
            j = i
            while(j>=0):
                down = triangle[i][j] + dp[i+1][j]
                dia = triangle[i][j] + dp[i+1][j+1]
                dp[i][j] = min(down,dia)
                j -= 1
            i -= 1
        return dp[0][0]",Medium,16,513,0.0,1,3.0,4.0,32.0625,23.0,4.574375000000001
33.0,best time to buy and sell stock,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price, max_profit = math.inf, 0
        for p in prices:
            if p < min_price:
                min_price = p
            elif p-min_price > max_profit:
                max_profit = p-min_price
        return max_profit",Easy,8,305,0.0,3,3.0,3.0,38.125,15.0,4.70875
34.0,best time to buy and sell stock ii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        @cache
        def trade(day_d):
            
            if day_d == 0:
                
                # Hold on day_#0 = buy stock at the price of day_#0
                # Not-hold on day_#0 = doing nothing on day_#0
                return -prices[day_d], 0
            
            prev_hold, prev_not_hold = trade(day_d-1)
            
            hold = max(prev_hold, prev_not_hold - prices[day_d] )
            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )
            
            return hold, not_hold
        
        # --------------------------------------------------
        last_day= len(prices)-1
        
        # Max profit must come from not_hold state (i.e., no stock position) on last day
        return trade(last_day)[1]",Medium,23,842,4.0,-1,3.0,1.0,36.60869565217392,22.0,4.545217391304347
35.0,best time to buy and sell stock iii,"class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        @cache
        def dfs(i, hasBought, transactions):
            if (i >= len(prices) or transactions >= 2):
                return 0
            maxProfit = 0
            if (hasBought):
                maxProfit = prices[i] + dfs(i + 1, False, transactions + 1)
            else:
                maxProfit = -prices[i] + dfs(i + 1, True, transactions)     
            return max(maxProfit, dfs(i + 1, hasBought, transactions))
        return dfs(0, False, 0)",Hard,12,535,0.0,0,3.0,2.0,44.583333333333336,27.0,3.1075
36.0,binary tree maximum path sum,"class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        return self.maxPathSumHelper(root)[2]

    def maxPathSumHelper(self, root: TreeNode):
        """"""
            (alo, connected, sum)
        """"""
        if root == None:
            return (False, False, 0)
        
        (l_alo, l_connected, l_subtree) = self.maxPathSumHelper(root.left)
        (r_alo, r_connected, r_subtree) = self.maxPathSumHelper(root.right)
        
        max_sum = max( \
            (root.val + l_subtree + r_subtree) if r_connected and l_connected else root.val, \
            (root.val + l_subtree) if l_connected else root.val, \
            (root.val + r_subtree) if r_connected else root.val, \
            root.val
         )
        
        
        if (l_alo and l_subtree > max_sum) or (r_alo and r_subtree > max_sum):
            if l_alo and not r_alo:
                return (True, False, l_subtree)
            elif not l_alo and r_alo:
                return (True, False, r_subtree)
            else:
                return (True, False, max(l_subtree, r_subtree))
        else:",Hard,29,1097,0.0,0,3.0,7.0,37.82758620689656,40.0,2.4155172413793107
37.0,valid palindrome,"class Solution:
    def isPalindrome(self, s: str) -> bool:
        Snew = """"
        for char in s:
            if char.isalnum():
                Snew += char.lower()
        return Snew == Snew[::-1]",Easy,6,202,0.0,2,3.0,2.0,33.666666666666664,14.0,5.2700000000000005
38.0,word ladder ii,"class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        """"""
        cog
        + log
          + 
        + dog
        """"""
        def ppath(p):
            if d.get(p):
                path.append(p)
                if d[p][1]==-1:
                    print(path[::-1])
                    ans.append([v for v in path[::-1]])
                else:
                    for v in d:
                        if d[v][0]+1==d[p][0] and sum([1 for i in range(k) if v[i]!=p[i]])<=1:
                            ppath(v)
                path.pop(-1)
            pass
            
        n, k = len(wordList), len(wordList[0])
        
        # build tries
        tries = {}
        for i in range(n):
            for j in range(k):
                w = wordList[i][:j] + ""?"" + wordList[i][j+1:]
                tries[w] = tries.get(w, [])                
                tries[w].append(wordList[i])
            pass
        
        print(beginWord, endWord)
        print(""[build] tries: "", tries)
        
        # bfs (only closing node after 1-level)
        q = [beginWord]
        d = {q[0]: (0, -1)}
        flag = False
        while len(q)>0:
            u = q.pop(0)
            for j in range(k):
                w = u[:j] + ""?"" + u[j+1:]
                for v in tries.get(w, []): # for all v adjacent u
                    if not d.get(v):
                        d[v] = (d[u][0]+1, u)
                        q.append(v)
                    if v==endWord:
                        break
                if d.get(endWord):
                    break
            if d.get(endWord):
                    break
                        
        print(""\n[bfs] d: "", d)
        
        print(""\npath: "")
        
        path = []
        ans = []
        ppath(endWord)
        print(""="" * 20)
        return ans

print = lambda *a,**aa: ()",Hard,64,1910,3.0,11,4.0,17.0,29.84375,74.0,-0.8659375000000011
39.0,word ladder,"class Solution:
    def ladderLength(self, beginWord: 'str', endWord: 'str', wordList: 'List[str]') -> 'int':
        wordSet = set(wordList)
        if endWord not in wordSet:
            return 0
        wordDict = {1:[beginWord]}
        output = 1
        while True:
            words = wordDict[output] 
            wordDict[output + 1] = []
            for word in words:
                for i in range(len(word)):
                    for j in string.ascii_lowercase:
                        wordChange = word[:i] + j + word[i+1:]
                        if wordChange == endWord:
                            return output + 1
                        if wordChange in wordSet:
                            wordDict[output+1].append(wordChange)
                            wordSet.remove(wordChange)
            if wordDict[output+1] == []:
                break
            output += 1
        return 0",Hard,22,908,0.0,5,4.0,8.0,41.27272727272727,33.0,2.4454545454545453
40.0,longest consecutive sequence,"class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        lengthLong=0
        prevMap = {}
        for i, n in enumerate(nums):
            prevMap[n]=i
        for i, n in enumerate(nums):
            count=1
            while n+1 in prevMap:
                count+=1
                n+=1
            lengthLong=max(lengthLong,count)
        return lengthLong",Medium,12,385,0.0,3,3.0,3.0,32.083333333333336,18.0,4.952500000000001
41.0,sum root to leaf numbers,"class Solution:
def sumNumbers(self, root: Optional[TreeNode]) -> int:
    
    def path(root,local):
        nonlocal res
        if root is None:
            return 
        if root.left is None and root.right is None:
            res.append(local*10+root.val)
            return
        
        path(root.left,local*10+root.val)
        path(root.right,local*10+root.val)
    
    res = []
    path(root,0)
    return sum(res)",Medium,16,430,0.0,0,2.0,2.0,26.875,13.0,6.16125
42.0,surrounded regions,"class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        
        m = len(board)
        n = len(board[0])
        for i in range(m):
            for j in range(n):
                visited = set()
                if board[i][j]=='O':
                    bfs_arr = [(i,j)]
                    visited.add((i,j))
                    surrounded = True
                    while len(bfs_arr)>0:
                        curr = bfs_arr.pop()
                        if curr[0]==0 or curr[0]==m-1 or curr[1]==0 or curr[1]==n-1:
                            surrounded = False
                        
                        for shift in [(+1,0),(-1,0),(0,+1),(0,-1)]:
                            ind_i = curr[0]+shift[0]
                            ind_j = curr[1] + shift[1]                            
                            if ind_i>=0 and ind_i<m and ind_j>=0 and ind_j<n and board[ind_i][ind_j] == 'O' and (ind_i, ind_j) not in visited:
                                bfs_arr.append((ind_i,ind_j ))
                                visited.add((ind_i, ind_j))

                    for val in visited:
                        if surrounded:
                            board[val[0]][val[1]] = 'X'",Medium,29,1305,0.0,9,5.0,13.0,45.0,62.0,-1.09
43.0,palindrome partitioning,"class Solution:
    def partition(self, s: str) -> List[List[str]]:
        part = [[] for _ in range(len(s))]
        def sub_part(l, r):
            if 0 <= l <= r < len(s) and s[l]==s[r]:
                part[l].append(s[l:r+1])
                sub_part(l-1, r+1)
                
		# find all palindromes
        for i in range(len(s)):
            sub_part(i,i)
            sub_part(i-1,i)
			
        # generate output
		res=[]
		
        def dfs(i, tmp):
            if i >=len(s):
                res.append(tmp)
			else:
				for p in part[i]:
					dfs(i + len(p), tmp + [p])        
        
		dfs(0, [])
        return res",Medium,24,632,2.0,4,2.0,5.0,26.33333333333333,32.0,4.15
44.0,palindrome partitioning ii,"class Solution:
    def minCut(self, s: str) -> int:
        if len(s)<=1: return 0
        dp = []
        for x in range(-1,len(s)):
            dp.append(x)
        for i in range(len(s)):
            for j in range(i,len(s)):
                if s[i:j]==s[j:i:-1]:
                    dp[j+1]=min(dp[j+1],dp[i]+1)
        return dp[len(s)]
    
    def minCut1(self, s: str) -> int:
        if len(s)<=1: return 0
        self.memo=[None]*(len(s)+1)
        self.memo[0]=[[]]
        ps = self.partition(s)
        min_len=float(""inf"")
        for p in ps:
            min_len=min(min_len,len(p))
        return min_len - 1
    
    def partition(self,s):
        l = len(s)
        if self.memo[l]: return self.memo[l]
        result=[]
        for i in range(l-1,-1,-1):
            current=s[i:]
            if current==current[::-1]:
                prevs=self.partition(s[:i])
                for prev in prevs:
                    result+=[prev+[current]]
        self.memo[l]=result
        return result",Hard,33,1014,0.0,6,3.0,11.0,30.727272727272727,58.0,0.8945454545454545
45.0,clone graph,"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        
        return clone(node, {})

def clone(node, dict):
    if node not in dict:
        dict[node] = Node(node.val, [])
        for n in node.neighbors:
            dict[node].neighbors.append(clone(n, dict))
    return dict[node]",Medium,12,350,0.0,1,2.0,3.0,29.166666666666668,14.0,5.795
46.0,gas station,"class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas)<sum(cost): return -1
        n=len(gas)
        minn=float('inf')  #Variable to track the largest cumulative gas deficit
        debt=0 #Variable indicating the gas deficit at each station
        for i in range(n):
            debt+=gas[i]-cost[i]
            if debt<minn:
                minn=debt
                index=i
        return index+1 if index <n-1 else 0 #return the station right after the one with the largest cumulative deficit",Medium,11,554,3.0,1,3.0,4.0,50.36363636363637,19.0,3.447272727272728
47.0,candy,"class Solution:
    def candy(self, ratings: List[int]) -> int:
        '''
        1. According to solution 2, use two arrays initialized by n 1's where n is length of ratings array,
                - one to check whether ratings[i]<ratings[i+1] starting from the leftmost position, if so then in the array set the value of index (i+1) = 1 + the value of index i
                - other to check whether ratings[i+1]<ratings[i] starting from the rightmost position, if so then in the array set the value of index i = 1 + the value of index (i+1)
        2. If those two arrays are LeftToRight and RightToLeft respectively, then the result will be sum of all maximum(LeftToRight[i], RightToLeft[i]) for 0<=i<=n-1.
        '''
        
        res_1 = [1]*len(ratings)                                        #array for LeftToRight checking
        res_2 = [1]*len(ratings)                                        #array for RightToLeft checking
        res=0                                                           #initial value of minimum no. of candies
        
        #we can check whether ratings[0]<ratings[1] and ratings[n-1]<ratings[n-2] in the same iteration
        #in the following way we can change the values of index i of both LeftToRight array and RightToLeft array in single iteration
        for i in range(0,len(ratings)-1):
            if ratings[i+1]>ratings[i] and res_1[i+1]<=res_1[i]:               
                res_1[i+1]=res_1[i]+1
            if ratings[len(ratings)-1-i]<ratings[len(ratings)-1-i-1] and res_2[len(ratings)-1-i]>=res_2[len(ratings)-1-i]:
                res_2[len(ratings)-1-i-1]=res_2[len(ratings)-1-i]+1
            
        for i in range(0,len(ratings)):
            res+=max(res_1[i], res_2[i])                                        #getting the maximum of LeftToRight[i] and RightToLeft[i] and adding it to the minimum value
            
        return res",Hard,24,1911,7.0,4,5.0,10.0,79.625,40.0,-1.4262500000000014
48.0,single number,"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
            return [x for x in nums if nums.count(x)==1][0]",Easy,2,127,0.0,0,2.0,2.0,63.5,8.0,3.365
49.0,single number ii,"class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return (sum(set(nums))*3-sum(nums))//2",Medium,2,114,0.0,0,2.0,0.0,57.0,5.0,4.25
50.0,copy list with random pointer,"class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        def copyList(node):
            if not node:
                return node
            
            newNode = Node(node.val)
            newNodes[node] = newNode
            newNode.next = copyList(node.next)
            newNode.random = newNodes[node.random]
            
            return newNode
        
        newNodes = {None: None}
        return copyList(head)",Medium,14,466,0.0,-1,3.0,1.0,33.285714285714285,13.0,5.5842857142857145
51.0,word break,"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        t = [0 for _ in range(n)]
        for i in range(n):
            for j in range(i+1):
                word = s[j:i+1]
                if word in wordDict:
                    t[i] += t[j-1] if j > 0 else 1
        return t[n-1]",Medium,9,332,0.0,2,3.0,5.0,36.888888888888886,16.0,4.78
52.0,word break ii,"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        self.res = []
        
        def helper(s,dic,path):
            if not s:
                self.res.append(' '.join(path))
                return
            if s in dic:
                return
            for i in range(1,len(s)+1):
                if s[:i] in wd:
                    helper(s[i:],dic,path+[s[:i]])
                else:
                    dic.add(s[:i])
        wd = set(wordDict)  
        dic = set()
        helper(s,dic,[])
        return self.res",Hard,18,564,0.0,1,3.0,4.0,31.33333333333333,27.0,4.240000000000001
53.0,linked list cycle,"class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        # if linkedlist empty
        if not head:
            return False
        
        # fast, slow nodes
        fast = slow = head
        
        # counter for fast and slow
        cnt = 0
        
        # while before end of linkedlist
        while fast:
            # advance fast
            fast = fast.next

            # every other loop
            if cnt % 2:
                # advance slow
                slow = slow.next
            
            # if fast and slow point to the same node, we have a loop
            if fast is slow:
                return True
            
            # increment cnt
            cnt += 1
        
        return False",Easy,29,751,9.0,2,3.0,9.0,25.89655172413793,17.0,6.029310344827586
54.0,linked list cycle ii,"class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        if not head or not head.next:
            return None
        
        s = set()
        
        while head:
            
            if head in s:
                return head
            
            s.add(head)
            head = head.next
            
        return head",Medium,16,383,0.0,1,3.0,3.0,23.9375,10.0,6.605625
55.0,reorder list,"class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        curr = head
        lst_ref = []
        while curr:
            lst_ref.append(curr)
            curr = curr.next
        if len(lst_ref) <= 2:
            return
        half_len, rem = divmod(len(lst_ref), 2)
        if rem:
            for a, b in zip(lst_ref[:half_len:1],
                            lst_ref[len(lst_ref) - 1: half_len:-1]):
                a.next = b
            for a, b in zip(lst_ref[len(lst_ref) - 1: half_len + 1:-1],
                            lst_ref[1:half_len:1]):
                a.next = b
            lst_ref[half_len + 1].next = lst_ref[half_len]
        else:
            for a, b in zip(lst_ref[:half_len:1],
                            lst_ref[len(lst_ref) - 1: half_len - 1:-1]):
                a.next = b
            for a, b in zip(lst_ref[len(lst_ref) - 1: half_len:-1],
                            lst_ref[1:half_len:1]):
                a.next = b
        lst_ref[half_len].next = None",Medium,25,1017,0.0,7,4.0,7.0,40.68,51.0,0.5787999999999993
56.0,binary tree preorder traversal,"class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
	    ans = []
	    stack = [root]

	    while stack:
		    node = stack.pop()
		    if node:
			    ans.append(node.val)
			    stack.append(node.right)
			    stack.append(node.left)
	    return ans",Easy,11,287,0.0,2,1.0,2.0,26.09090909090909,10.0,6.471818181818182
57.0,binary tree postorder traversal,"class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if not root:
            return res
        def dfs(node):
            if not node:
                return
            dfs(node.left)
            dfs(node.right)
            res.append(node.val)
            pass
        dfs(root)
        return res",Easy,13,362,0.0,0,3.0,2.0,27.846153846153847,9.0,6.413846153846154
58.0,lru cache,"class ListNode:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.next = None
        self.prev = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
		# a hashmap stores key to ListNode(key, value) pair
        self.map = dict()
        # dummy nodes to mitigate edge cases
        self.head = ListNode(0, 0)
        self.tail = ListNode(0, 0)
        # init the doubly linked list with [head<->tail]
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if (key in self.map):
            curr = self.map.get(key)
            self.removeX(curr)
            self.addX(curr)
            return curr.val
        return -1

    def put(self, key: int, value: int) -> None:
        if (key in self.map):
            self.removeX(self.map[key])
        
        self.map[key] = ListNode(key, value)
        self.addX(self.map[key])
            
        if (len(self.map) > self.capacity):
            # remove the first(LRU) element in the list
            n = self.head.next
            self.removeX(n)
            self.map.pop(n.key, None)              

        
    def addX(self, head):
        # set the current head pointer's prev to tail's prev pointer
        head.prev = self.tail.prev
        # set the current head pointer's next to tail pointer
        head.next = self.tail
        # set the tail pointer's old prev's next to the current head pointer
        self.tail.prev.next = head
        # set the tail pointer's old prev pointer to the new prev(head) pointer
        self.tail.prev = head
    
    def removeX(self, head):
        # set the old prev's next pointer to current head's next pointer
        head.prev.next = head.next
        # set old next's prev pointer to current head's prev pointer
        head.next.prev = head.prev",Medium,56,1897,10.0,2,2.0,3.0,33.875,52.0,1.9112500000000008
59.0,insertion sort list,"class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        
        # No need to sort for empty list or list of size 1
        if not head or not head.next:
            return head
        
        nodes = []
        cur = head
        while head:
            nodes.append(head)
            head = head.next
            
        # Sort nodes by their values ascendingly
        nodes = sorted(nodes, key=lambda node: node.val)

        # Re-organize list
        cur = head = nodes[0]
        for node in nodes[1:]:
            cur.next = node
            cur = cur.next
        cur.next = None
            
        return head",Medium,23,653,3.0,2,3.0,4.0,28.39130434782609,21.0,5.164782608695653
60.0,sort list,"class Solution(object):
    def sortList(self, head):
        if not head or not head.next:
            return head
        fast, slow = head.next, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        start = slow.next
        slow.next = None
        l, r = self.sortList(head), self.sortList(start)
        return self.merge(l, r)
        
        
    def merge(self, l, r):
        if not l or not r:
            return l or r
        dummy = p = ListNode(0)
        while l and r:
            if l.val < r.val:
                p.next = l
                l = l.next
            else:
                p.next = r
                r = r.next
            p = p.next
        p.next = l or r
        return dummy.next",Medium,27,771,0.0,2,3.0,5.0,28.55555555555556,32.0,3.9300000000000006
61.0,max points on a line,"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        def solve(p1, p2):
            if p2[0] == p1[0]:
                return math.inf, p1[0]
            m = (p2[1] - p1[1]) / (p2[0] - p1[0])
            b = p2[1] - m*p2[0]
            return m, b
        
        n = len(points)
        if n == 1:
            return 1
        lines = defaultdict(set)
        for i in range(n):
            for j in range(i+1, n):
                m, b = solve(points[i], points[j])
                lines[(m,b)].add(i)
                lines[(m,b)].add(j)
                
        return max([len(v) for v in lines.values()])",Hard,19,637,0.0,1,3.0,5.0,33.526315789473685,29.0,3.842631578947368
62.0,evaluate reverse polish notation,"class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        def calculate(num1, num2, operator):
            if operator=='+':
                return num1+num2
            if operator=='-':
                return num2-num1
            if operator=='*':
                return num1*num2
            if operator=='/':
                return int(num2/num1)
            return 0
        

        stack=[]
        for i in range(len(tokens)):
            if tokens[i] == '+' or tokens[i] == '-' or tokens[i] == '*' or tokens[i] == '/':
                num1=stack.pop()
                num2=stack.pop()
                stack.append(calculate(num1, num2, tokens[i]))
            else:
                stack.append(int(tokens[i]))
        return stack.pop()",Medium,22,763,0.0,1,3.0,6.0,34.68181818181818,44.0,2.238636363636364
63.0,reverse words in a string,"class Solution:
    def reverseWords(self, s: str) -> str:
        s=s.split()
        a=s[::-1]
        return(' '.join(a))",Medium,4,124,0.0,0,2.0,0.0,31.0,9.0,6.19
64.0,maximum product subarray,"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        f = lambda x, y:  y if x == 0 else x * y 
        return max(max(accumulate(nums, f)), max(accumulate(nums[::-1], f)))",Medium,3,192,0.0,0,2.0,1.0,64.0,16.0,2.5200000000000005
65.0,find minimum in rotated sorted array,"class Solution:
    def findMin(self, nums: List[int]) -> int:
        # Binary search
        lo = 0
        hi = len(nums) - 1
        global_min = inf
        while lo <= hi:
            mid = (lo + hi) // 2
            # Update minimum if needed
            global_min = min(nums[mid], global_min)
            # Case: if the pivot index is within the top half and the top half array is unsorted
            # e.g. [4,5,6,7|mid|8,0,1,2]
            if nums[mid] > nums[hi]:
                lo = mid + 1
            # Case: if the pivot index is within the top half but the top half of array is sorted
            # e.g. [5,6,7,8|mid|0,1,2,3]
            elif mid + 1 < len(nums) and nums[mid + 1] < nums[mid]:
                return nums[mid + 1]
            else:
                hi = mid - 1
        return global_min",Medium,20,822,6.0,2,3.0,6.0,41.1,36.0,2.641000000000001
66.0,find minimum in rotated sorted array ii,"class Solution:
    def findMin(self, nums: List[int]) -> int:
        len_nums = len(nums)
        len_nums1, len_nums2 = len_nums - 1,  len_nums - 2
        for i in range(len_nums // 2):
            if nums[i] > nums[i + 1]:
                return nums[i + 1]
            if nums[len_nums2 - i] > nums[len_nums1 - i]:
                return nums[len_nums1 - i]
        return nums[0]",Hard,9,386,0.0,1,3.0,3.0,42.888888888888886,14.0,4.500000000000001
67.0,min stack,"class MinStack:

    def __init__(self):
        self.myStack = list()
        self.min = math.inf

    def push(self, val: int) -> None:
        self.myStack.append(val)
        if val < self.min:
            self.min = val

    def pop(self) -> None:
        if len(self.myStack) == 0:
            return
        self.myStack.pop()
        if len(self.myStack) == 0:
            self.min = math.inf
            return
        self.min = min(self.myStack)

    def top(self) -> int:
        if len(self.myStack) == 0:
            return
        return self.myStack[-1]

    def getMin(self) -> int:
        if len(self.myStack) == 0:
            return
        return self.min",Medium,28,677,0.0,0,2.0,5.0,24.178571428571427,35.0,4.203928571428572
68.0,intersection of two linked lists,"class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        Set=set()
        curr= headA
        while curr:
            Set.add(curr)
            curr=curr.next
        curr=headB
        while curr:
            if curr in Set:
                return curr
            curr=curr.next
        return None",Easy,12,359,0.0,2,3.0,3.0,29.916666666666668,15.0,5.5075
69.0,find peak element,"class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        return nums.index(max(nums))",Medium,2,107,0.0,0,2.0,0.0,53.5,5.0,4.565
70.0,maximum gap,"class Solution:
    def maximumGap(self, num):
        if len(num) < 2:    return 0
        num.sort()
        return max(abs(n2 - n1) for n1, n2 in zip(num[1:], num[:-1]))",Hard,4,172,0.0,1,2.0,2.0,43.0,9.0,5.050000000000001
71.0,compare version numbers,"class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = list(map(int, version1.split(""."")))
        v2 = list(map(int, version2.split(""."")))
        
        
        for i in range(max(len(v1),len(v2))):
            
            if i<len(v1):
                v1.append(0)
            if i<len(v2):
                v2.append(0)
            if v1[i] > v2[i]:
                return 1
            elif v1[i] < v2[i]:
                return -1
            
        return 0",Medium,17,510,0.0,3,3.0,5.0,30.0,21.0,4.840000000000001
72.0,fraction to recurring decimal,"class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator*denominator<0:
            ans=""-""
        else:
            ans=""""
        q=abs(numerator)//abs(denominator)
        r=abs(numerator)%abs(denominator)
        d=set()
        decimal=[]
        if r==0:
            ans=ans+str(q)
            return ans
        else:
            flag=False
            while r!=0:
                if r not in d:
                    n=r*10
                    q1=n//abs(denominator)
                    d.add(r)
                    decimal.append((q1,r))
                    r=n%abs(denominator)
                else:
                    r1=r
                    flag=True
                    break
        ans+=str(q)+'.'
        if flag==False:
            for Q,R in decimal:
                ans+=str(Q)
        if flag==True:
            for i in range(0,len(decimal)):
                if decimal[i][1]!=r1:
                    ans+=str(decimal[i][0])
                else:
                    break
            ans+='('
            for x in range(i,len(decimal)):
                ans+=str(decimal[x][0])
            ans+=')'         
       return ans",Medium,40,1201,0.0,7,4.0,10.0,30.025,56.0,1.037749999999999
73.0,two sum ii input array is sorted,"class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        # O(n), O(1)
        left = 0
        right = len(numbers) - 1

        while left < right:
            add = numbers[left] + numbers[right]
            if add == target:
                return [left + 1, right + 1]
            elif add > target:
                right -= 1
            else:
                left += 1",Medium,13,409,1.0,3,3.0,3.0,31.46153846153846,23.0,4.548461538461539
74.0,excel sheet column title,"class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
         
        column_title = """"
        while columnNumber > 0:
            columnNumber, remainder = divmod(columnNumber - 1, 26)
            column_title = chr(65 + remainder) + column_title
        return column_title",Easy,7,296,0.0,1,3.0,1.0,42.285714285714285,12.0,4.754285714285715
75.0,majority element,"class Solution:
    def majorityElement(self, nums: List[int]) -> int: 
        n = len(nums)
        d = {}
        for i in nums:
            d[i] = d.get(i, 0) + 1
        for x, v in d.items():
            if v>n/2:
             return x",Easy,8,241,0.0,3,3.0,3.0,30.125,14.0,5.5287500000000005
76.0,excel sheet column number,"class Solution(object):
    def titleToNumber(self, s):
        return reduce(lambda a,b:a*26+b, map(lambda x:ord(x)-ord('A')+1, s))",Easy,2,132,0.0,0,2.0,0.0,66.0,8.0,3.140000000000001
77.0,factorial trailing zeroes,"class Solution:
    def trailingZeroes(self, n: int) -> int:
        x = 1
        res = 0
        while 5**x < 10**4+1:
            res += n//5**x
            x += 1
        return res",Medium,7,185,0.0,1,3.0,1.0,26.428571428571427,11.0,6.281428571428571
78.0,binary search tree iterator,"class BSTIterator:   
    
    def __init__(self, root: Optional[TreeNode]):
        self.nodes = []
        self.inorder(root)
        
    def inorder(self, root):
        if root is None:
            return
        self.inorder(root.left)
        self.nodes.append(root.val)
        self.inorder(root.right)

    def next(self) -> int:
        return self.nodes.pop(0)
        

    def hasNext(self) -> bool:
        return len(self.nodes) > 0
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()",Medium,25,600,4.0,-1,2.0,1.0,24.0,17.0,6.24
79.0,dungeon game,"class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        dp = [[0 for i in range(len(dungeon[0]))] for i in range(len(dungeon))]
        for i in reversed(range(len(dungeon))):
            for j in reversed(range(len(dungeon[0]))):
                if i==len(dungeon)-1 and j==len(dungeon[0])-1: dp[i][j] = min(dungeon[i][j], 0); continue
                val = max(dp[i][j+1] if j<len(dungeon[0])-1 else float(""-inf""), dp[i+1][j] if i<len(dungeon)-1 else float(""-inf""))
                dp[i][j] = 0 if dungeon[i][j] + val>0 else dungeon[i][j] + val
        return max(-dp[0][0], -dungeon[0][0], 0) + 1",Hard,8,634,0.0,2,3.0,8.0,79.25,25.0,0.0675000000000007
80.0,largest number,"class Solution:
    
    def compare(self,n1,n2):
        if str(n1)+str(n2)>str(n2)+str(n1):
            return True
        else:
            return False
    
    def largestNumber(self, nums: List[int]) -> str:
        
        if len(list(set(nums)))==1 and nums[0]==0:
            return ""0""
        
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                
                if not self.compare(nums[i],nums[j]):
                    nums[i],nums[j]=nums[j],nums[i]
        
        return ''.join(map(str,nums))",Medium,19,554,0.0,2,3.0,5.0,29.157894736842103,27.0,4.37578947368421
81.0,repeated dna sequences,"class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        if len(s)<10: return []
        ht=collections.defaultdict(int)
        res=set()
        while len(s)>=10:
            ht[s[:10]]+=1
            if ht[s[:10]]>1: res.add(s[:10])
            s=s[1:]            
        return list(res)",Medium,9,320,0.0,2,3.0,3.0,35.55555555555556,20.0,4.5
82.0,best time to buy and sell stock iv,"class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        
        if k == 0: return 0
        
        t0 = [0] * (k+1)
        t1 = [float('-inf')] * k
        
        for p in prices:
            for tr in range(k):
                t0[tr] = max(t0[tr], t1[tr] + p)
                t1[tr] = max(t1[tr], t0[tr-1] - p)
        return t0[-2]",Hard,12,366,0.0,2,3.0,3.0,30.5,19.0,5.055
83.0,rotate array,"class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        for _ in range(k):
            nums.insert(0, nums.pop())",Medium,6,222,0.0,1,2.0,2.0,37.0,10.0,5.49
84.0,reverse bits,"class Solution:
    def reverseBits(self, n: int) -> int:
        return int(str(bin(n)[2:]).rjust(32,'0')[::-1], 2)",Easy,2,116,0.0,0,2.0,0.0,58.0,10.0,3.66
85.0,number of 1 bits,"class Solution:
    def hammingWeight(self, n: int) -> int:
        return len([c for c in f""{n: b}"" if c==""1""])",Easy,2,112,0.0,1,2.0,2.0,56.0,9.0,3.88
86.0,house robber,"class Solution:
    def rob(self, nums: List[int]) -> int:
        dp= [0] * len(nums)
        if len(nums) == 1:
            return nums[0]
        for i in range(len(nums)):
            dp[i] = max(dp[i-2]+nums[i],dp[i-1])
        return max(dp)",Medium,7,247,0.0,1,3.0,2.0,35.285714285714285,13.0,5.284285714285715
87.0,binary tree right side view,"class Solution:
    def rightSideView(self, root: TreeNode):
        rightside = {}
        self.seeTree(root, rightside, 1)
        numbers = [value for value in rightside.values()]
        return numbers
                
    def seeTree(self, root: TreeNode, rightside: dict, nodo: int):
        if root == None:
            return
        if root.val != None:
            rightside[nodo] = root.val
            self.seeTree(root.left, rightside, nodo + 1)
            self.seeTree(root.right, rightside, nodo + 1)
        return",Medium,14,531,0.0,0,3.0,3.0,37.92857142857143,26.0,3.806428571428572
88.0,number of islands,"class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        rows,cols = len(grid),len(grid[0])
        islands = 0
        visit = set()
        # using dfs in 2 methods
        # firstone
        def dfs(r,c):
            if r <0 or r >= rows or c <0 or c >= len(grid[0]) or grid[r][c]!=""1"" :
                return 
            if (r,c) not in visit:
                visit.add((r,c))
                dfs(r+1,c)
                dfs(r-1,c)
                dfs(r,c+1)
                dfs(r,c-1)

        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == ""1"" and (r,c) not in visit:
                    dfs(r,c)
                    islands+=1
        return islands",Medium,24,764,2.0,4,3.0,6.0,31.83333333333333,37.0,3.0950000000000006
89.0,bitwise and of numbers range,"class Solution:
def rangeBitwiseAnd(self, left: int, right: int) -> int:
    
    k = 0
    while left!=right:
        left>>=1
        right>>=1
        k+=1
    
    return left<<k",Medium,9,182,0.0,1,2.0,1.0,20.22222222222222,19.0,6.1
90.0,happy number,"class Solution:
    def isHappy(self, n: int) -> bool:
        while n != 1:
            n = sum([int(i) ** 2 for i in str(n)])
            if n == 4:
                return False
        
        return True",Easy,7,208,0.0,1,3.0,3.0,29.714285714285715,12.0,5.885714285714286
91.0,remove linked list elements,"class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if not head:
            return head
        # print(head.val)
        if head.val == val:
            head = self.removeElements(head.next, val)
        else:
            head.next =  self.removeElements(head.next, val)
        return head",Easy,9,352,1.0,1,3.0,2.0,39.11111111111112,17.0,4.58
92.0,count primes,"class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 3:
            return 0
        
        primes = [1]*n
        primes[0] = primes[1] = 0
        for i in range(2,int(n**0.5)+1):
            if primes[i] != 0:
                for j in range(2*i,n,i):
                    primes[j] = 0
        return sum(primes)
        
    def countPrimesOptimized(self, n: int) -> int:
        if n < 3:
            return 0
        
        primes = [1]*n
        primes[0] = primes[1] = 0
        for i in range(2,int(n**0.5)+1):
            if primes[i]:
                primes[i*i:n:i] = [0]*len(primes[i*i:n:i])
                #print(i,primes[i*i:n:i])
        return sum(primes)",Medium,23,696,1.0,4,3.0,7.0,30.26086956521739,38.0,3.096521739130435
93.0,isomorphic strings,"class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        MAX_CHARS = 256
        n = len(s)
        m = len(t)
        if n != m:
            return False
        marked = [False] * MAX_CHARS
        map = [-1] * MAX_CHARS

        for i in range(n):
            if map[ord(s[i])] == -1:
                if marked[ord(t[i])] == True:
                    return False
                marked[ord(t[i])] = True
                map[ord(s[i])] = t[i]
            
            elif map[ord(s[i])] != t[i]:
                return False
        return True",Easy,19,567,0.0,2,3.0,5.0,29.84210526315789,27.0,4.314210526315789
94.0,reverse linked list,"class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        prev = None
        while head:
            head.next,head,prev = prev,head.next,head
        return prev",Easy,6,213,0.0,1,2.0,1.0,35.5,12.0,5.425000000000001
95.0,course schedule,"class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        STATUS_VISITING = 0
        STATUS_VISITED = 1
        
        def no_cycle(node):        
            if node in status:
                if status[node] == STATUS_VISITED:
                    return True
                else:
                    return False
            
            status[node] = STATUS_VISITING
            for child in adj[node]:
                if not no_cycle(child):
                    return False
            
            status[node] = STATUS_VISITED
            return True
        
        adj = defaultdict(list)
        nodes = set()
        for a, b in prerequisites:
            adj[b].append(a)
            nodes.add(b)
            
        status = {}
        for node in nodes:
            if not no_cycle(node):
                return False           
            
        return True",Medium,31,930,0.0,2,4.0,7.0,30.0,27.0,4.239999999999999
96.0,minimum size subarray sum,"class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        lb = 0
        ub = 0
        wSum = nums[0]
        numLen = len(nums)
        ans = []
        while lb<numLen:
            # print(lb, ub, wSum)
            if wSum >= target:
                ans.append(ub-lb+1)
            
            if wSum < target and ub+1< numLen:
                ub+=1
                wSum += nums[ub]
            else:
                wSum -= nums[lb]
                lb+=1
                
        # print(ans)
        if ans:
            return min(ans)
        return 0",Medium,22,592,2.0,3,3.0,4.0,26.90909090909091,28.0,4.498181818181818
97.0,course schedule ii,"class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        ans = []
        d = {}
        indegree = {}
        for i in range(numCourses):
            d[i] = []
            indegree[i] = 0
        
        for i in prerequisites:
            d[i[0]].append(i[1])
            indegree[i[1]] += 1
        
        queue = []
        for i in indegree:
            if indegree[i] == 0:
                queue.append(i)
        
        while queue:
            curr = queue.pop(0)
            ans.insert(0,curr)
            for i in d[curr]:
                if indegree[i] > 0:
                    indegree[i]-= 1
                    if indegree[i] == 0:
                        queue.append(i)
        
        for i in indegree:
            if indegree[i] != 0:
                return []
        return(ans)",Medium,30,859,0.0,9,3.0,10.0,28.633333333333333,35.0,3.2030000000000003
98.0,word search ii,"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        #  My Effort - Passed all test cases, yet backtracking line doesn't work
        cntBoard = collections.Counter(''.join([e for row in board for e in row ]))
        cntW = [collections.Counter(w) for w in words]
        idxBoard = collections.defaultdict(list)
        m, n = len(board), len(board[0])
        for i in range(m):
            for j in range(n):
                idxBoard[board[i][j]].append((i,j))
        # print(idxBoard)
        dirs = [(0,1), (0,-1), (-1,0), (1,0)]
        # dirs = [(0,1), (0,-1), (1,0), (-1,0)] # fail some test cases

        def dfs(x, y, w, i):
            if i == len(w):
                return True
            for a, b in dirs:
                nx, ny = x + a, y + b
                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and board[nx][ny] == w[i]:
                    visited.add((nx, ny))
                    return dfs(nx, ny, w, i+1) # if I don't add return, the recursive function call returns None or False
                    # visited.remove((nx, ny)) # However, if I add return, this line is never executed, backtracking doesn't work but we actually need backtracking

        ans = []
        
        for w in words:
            if collections.Counter(w) - cntBoard:
                continue
            for x, y in idxBoard[w[0]]:
                visited = set()
                visited.add((x,y))
                result = dfs(x, y, w, 1)
                if result:
                    ans.append(w)
                    break
        return ans",Hard,36,1622,5.0,3,3.0,15.0,45.05555555555556,78.0,-2.015000000000001
99.0,house robber ii,"class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        
        if n == 1:
            return nums[0]
        
        if n == 2:
            return max(nums[0], nums[1])
        
        # result1: don't consider the first house
        # result2: don't consider the last house
        result1 = self.robRange(nums, 1, n-1)
        result2 = self.robRange(nums, 0, n-2)
        return max(result1, result2)
    
    def robRange(self, nums, start, end):
        dp = [0] * len(nums)
        dp[start] = nums[start]
        dp[start + 1] = max(nums[start], nums[start + 1])
        
        for i in range(start + 2, end + 1):
            dp[i] = max(dp[i -2] + nums[i], dp[i - 1])
        
        return dp[end]",Medium,24,747,2.0,0,2.0,3.0,31.125,36.0,3.55875
100.0,shortest palindrome,"class Solution:
    def shortestPalindrome(self, s: str) -> str:
        i,l = 0,len(s)
        for j in range(l-1,-1,-1):
            if s[i]==s[j]: i+=1
        if i==l: return s
        return s[i:][::-1] + self.shortestPalindrome(s[:i]) + s[i:]",Hard,6,248,0.0,2,2.0,3.0,41.333333333333336,25.0,3.539999999999999
101.0,kth largest element in an array,"class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        n = len(nums)
        k = n - k

        def quickSort(l=0, r=n-1):
            p, pivot = l, nums[r]
            for i in range(l, r):
                if nums[i] <= pivot:
                    nums[i], nums[p] = nums[p], nums[i]
                    p += 1

            nums[p], nums[r] = pivot, nums[p]

            if k > p:
                return quickSort(p + 1, r)
            elif k < p:
                return quickSort(l, p - 1)
            return nums[k]

        return quickSort()",Medium,20,576,0.0,1,3.0,4.0,28.8,34.0,3.768
102.0,combination sum iii,"class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
    
        res = []
        
        self.backtrack(k, n, [],0,1, res)
        
        return res
    
    def backtrack(self, k, n, cur, comb, ind, res):
        
        if comb > n:
            return 
        elif comb == n and len(cur) == k:
            res.append([]+cur)
        else:
            
            for i in range(ind,10):
                cur.append(i)
                
                self.backtrack(k, n, cur, comb+i, i+1, res)
                cur.pop()",Medium,21,558,0.0,2,3.0,3.0,26.571428571428573,37.0,3.608571428571429
103.0,contains duplicate,"class Solution(object):
    def containsDuplicate(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        #1
        # a = list(set(nums))
        # nums.sort()
        # a.sort()
        # return False if a==nums else True
        
        #2
        hash_table = {}
        for num in nums:
            hash_table[num] = hash_table.get(num, 0)+1
            
        return False if max(hash_table.values()) == 1 else True
        
#         #3
#         from collections import Counter
#         return False if set(Counter(nums).values()) == {1} else True",Easy,21,599,9.0,-1,3.0,4.0,28.52380952380953,21.0,5.572857142857143
104.0,the skyline problem,"class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        if not buildings:
            return []
        if len(buildings) == 1:
            return [[buildings[0][0], buildings[0][2]],[buildings[0][1], 0]]

        mid = (len(buildings)-1) // 2
        left = self.getSkyline(buildings[0:mid+1])
        right = self.getSkyline(buildings[mid+1:])

        return self.merge(left, right)

    def merge(self, left, right):
        i = j = h1 = h2 = 0
        ret = []
        while i < len(left) and j < len(right):
            if left[i][0] < right[j][0]:
                h1 = left[i][1]
                new = [left[i][0], max(h1, h2)]
                if not ret or ret[-1][1] != new[1]:
                    ret.append(new)
                i += 1
            elif left[i][0] > right[j][0]:
                h2 = right[j][1]
                new = [right[j][0], max(h1, h2)]
                if not ret or ret[-1][1]!=new[1]:
                    ret.append(new)
                j+=1
            else:
                h1 = left[i][1]
                h2 = right[j][1]
                new = [right[j][0], max(h1, h2)]
                if not ret or ret[-1][1] != new[1]:
                    ret.append([right[j][0],max(h1, h2)])
                i += 1
                j += 1

        while i < len(left):
            if not ret or ret[-1][1] != left[i][1]:
                ret.append(left[i][:])
            i+=1

        while j < len(right):
            if not ret or ret[-1][1] != right[j][1]:
                ret.append(right[j][:])
            j+=1

        return ret",Hard,48,1605,0.0,9,3.0,12.0,33.4375,72.0,-0.9293750000000004
106.0,contains duplicate iii,"class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        if not nums or k<1 or t<0 or (t==0 and len(nums)==len(set(nums))): return False
        for i in range(len(nums)):
            for j in range(1,k+1):
                if (i+j)>=len(nums): break
                if abs(nums[i+j]-nums[i])<=t: return True
        return False",Hard,7,381,0.0,2,3.0,5.0,54.42857142857143,27.0,2.1014285714285714
107.0,maximal square,"class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        
        for y, row in enumerate(matrix):
            count_x = 1
            for x, val in enumerate(row):
                if val is '1':
                    matrix[y][x] = count_x
                    count_x += 1
                else:
                    matrix[y][x] = 0
                    count_x = 1

        # transpose
        best = 0
        matrix = list(zip(*matrix))
        popper = list()
        for i in range(10000):
            flag = False
            for j, col in enumerate(matrix):
                count = 0
                for val in col:
                    if val > i: 
                        count += 1
                        if count > i:
                            best = i + 1
                            flag = True
                            break
                    else:
                        count = 0
                if flag:
                    break
                else:
                    popper.append(j)
            if flag:
                matrix = [col for j, col in enumerate(matrix) if j not in popper]
                popper.clear()
            else:
                break
        
        return best ** 2",Medium,40,1246,1.0,7,4.0,12.0,31.15,40.0,2.5765
108.0,count complete tree nodes,"class Solution:
    
    def count(self,node):

        if node is None: # travelled beyond a leaf
            return 0

        return 1 + self.count(node.left) + self.count(node.right) # all other cases
    
    def countNodes(self, root: Optional[TreeNode]) -> int:
        return self.count(root)",Medium,10,300,2.0,-1,2.0,1.0,30.0,8.0,6.52
109.0,rectangle area,"class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        def get_coordinates(x1,x2,y1,y2):
            return {0:[x1,y1],1:[x2,y1],2:[x2,y2],3:[x1,y2]}
        
        first = get_coordinates(ax1,ax2,ay1,ay2)
        second = get_coordinates(bx1,bx2,by1,by2)
        
        def left_overlap(a,b):
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]>=a[1][0]:
                return abs(b[0][0]-a[1][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]>=b[1][0]:
                return abs(a[0][0]-b[1][0])
            if b[0][0]>=a[0][0] and b[0][0]<a[1][0] and b[1][0]<a[1][0]:
                return abs(b[1][0]-b[0][0])
            if a[0][0]>=b[0][0] and a[0][0]<b[1][0] and a[1][0]<b[1][0]:
                return abs(a[1][0]-a[0][0])
        
        def top_overlap(a,b):
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]>=a[2][1]:
                return abs(b[0][1]-a[2][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]>=b[2][1]:
                return abs(a[0][1]-b[2][1])
            if b[0][1]>=a[0][1] and b[0][1]<a[2][1] and b[2][1]<a[2][1]:
                return abs(b[2][1]-b[0][1])
            if a[0][1]>=b[0][1] and a[0][1]<b[2][1] and a[2][1]<b[2][1]:
                return abs(a[2][1]-a[0][1])
        
        l=left_overlap(first,second)
        t=top_overlap(first, second)
        
        total_area = (first[1][0]-first[0][0])*(first[2][1]-first[0][1])
        total_area+=(second[1][0]-second[0][0])*(second[2][1]-second[0][1])
        if l is not None and t is not None:
            total_area -=l*t
        return total_area",Medium,35,1699,0.0,0,3.0,9.0,48.54285714285714,98.0,-4.348857142857144
111.0,invert binary tree,"class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        
        temp = root.left
        root.left = root.right
        root.right = temp
        
        self.invertTree(root.left)
        self.invertTree(root.right)
        
        return root",Easy,12,334,0.0,0,2.0,1.0,27.83333333333333,9.0,6.475
112.0,basic calculator ii,"class Solution:
    def calculate(self, s: str) -> int:
        #pre-processing to tokenize string 
        s = s.replace("" "", """") #remove white space
        
        tokens = []
        lo = hi = 0
        while hi <= len(s):
            if hi == len(s) or s[hi] in ""+-*/"": 
                tokens.append(s[lo:hi]) #tokenize number
                if hi < len(s): tokens.append(s[hi]) #tokenize operator
                lo = hi + 1
            hi += 1
        
        #dijkstra's two-stack algo
        opd, opr = [], [] #operand &amp; operator stacks 
        sign = 1
        for token in tokens: 
            if token in ""+-*/"": 
                opr.append(token)
                if token == ""-"": sign = -1
            else: 
                token = sign*int(token)
                sign = 1
                if opr and opr[-1] in ""*/"":
                    op = opr.pop()
                    x = opd.pop()
                    if op == ""*"": token = x * token
                    elif op == ""/"": token = int(x / token) #not floor division 
                opd.append(token)
            
        return sum(opd)",Medium,31,1112,7.0,9,4.0,9.0,35.87096774193548,49.0,1.371612903225806
113.0,summary ranges,"class Solution:
    def summaryRanges(self, a: List[int]) -> List[str]:
        if not a:
            return []
        ans=[]
        n=len(a)
        start=a[0]
        flag=0
        for i in range(n-1):
            if a[i]+1==a[i+1]:
                flag=1
            else:
                if flag==1 and start!=a[i]:
                    ans.append(str(start)+'->'+str(a[i]))
                else:
                    ans.append(str(start))
                start=a[i+1]
        if flag==1 and start!=a[i+1]:
            ans.append(str(start)+'->'+str(a[i+1]))
        else:
            ans.append(str(start))
        return ans",Easy,21,632,0.0,4,3.0,5.0,30.09523809523809,32.0,3.671428571428571
114.0,majority element ii,"class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        return [v for v in set(nums) if nums.count(v)>math.floor(len(nums)/3)]",Medium,2,155,0.0,0,2.0,2.0,77.5,6.0,2.3050000000000006
115.0,kth smallest element in a bst,"class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        node_vals = []

        def traverse_inorder(node):
            if node is None:
                return
            traverse_inorder(node.left)
            node_vals.append(node.val)
            traverse_inorder(node.right)

        traverse_inorder(root)

        return node_vals[k - 1]",Medium,13,380,0.0,0,2.0,1.0,29.23076923076923,10.0,6.249230769230769
116.0,power of two,"class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        return n &amp; (n-1) == 0",Easy,4,137,0.0,0,2.0,1.0,34.25,11.0,5.6975
117.0,number of digit one,"class Solution:
    def countDigitOne(self, n: int) -> int:
        if n < 1: return 0

        # i = 0
        p = 1 # 10 ** i
        c = 0 # count of 1s less than 10 ** i
        
        result = 0
        for char in str(n)[::-1]:
            d = int(char)
            # if d == 0: pass
            if d == 1:
                result += c + n%(p) + 1
            elif d > 1:
                result += p + d*c
            c += p + (c<<3)+c # c = p + 8*c + c
            p = (p<<3)+p+p # p *= 10
            # i += 1
        return result",Hard,19,540,7.0,4,3.0,5.0,28.42105263157895,36.0,3.702105263157895
118.0,palindrome linked list,"class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:

        slow_node = head
        fast_node = slow_node
        prev_node = None
        while fast_node is not None:

            if fast_node.next is None:
                # list is odd length (don't add another node to reversed 1st half list - the next node is the odd mid-point)
                fast_node = fast_node.next
                slow_node = slow_node.next
            else:
                # list is even length (add another node to reversed 1st half list)
                fast_node = fast_node.next.next
                temp_node = slow_node
                slow_node = slow_node.next
                temp_node.next = prev_node
                prev_node = temp_node

        # At this point prev_node points to the head of reversed 1st half of list and slow_node points to head of remaining half of list

        while slow_node is not None:
            if slow_node.val != prev_node.val:
                return False
            slow_node = slow_node.next
            prev_node = prev_node.next

        return True",Easy,28,1108,3.0,3,3.0,4.0,39.57142857142857,23.0,3.8985714285714295
119.0,lowest common ancestor of a binary search tree,"class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        cur =root
        while cur:
            if p.val > cur.val and q.val>cur.val:
                cur=cur.right
            elif p.val<cur.val and q.val<cur.val:
                cur=cur.left
            else:
                return cur",Medium,9,354,0.0,3,3.0,3.0,39.333333333333336,20.0,4.1000000000000005
120.0,lowest common ancestor of a binary tree,"class Solution:
    def __init__(self):
        self.seen = collections.defaultdict(TreeNode)
        
    def get_list(self, cur, prev, target):
        if not cur:
            return None
        
        self.seen[cur.val] = cur
        
        new_cur = TreeNode(cur.val)
        new_cur.left = prev
        
        if new_cur.val == target.val:
            return new_cur
        
        _next = cur.left
        head_from_left = self.get_list(_next, new_cur, target)
        if head_from_left:
            return head_from_left
        
        _next = cur.right
        head_from_right = self.get_list(_next, new_cur, target)
        if head_from_right:
            return head_from_right
        
        new_cur.left = None
        
        return None

    
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        head1 = self.get_list(root, None, p)
        head2 = self.get_list(root, None, q)
        
        it1, it2 = head1, head2
        
        while it1.val != it2.val:
            if not it1.left:
                it1 = head2
            else:
                it1 = it1.left
            
            if not it2.left:
                it2 = head1
            else:
                it2 = it2.left
        
        return self.seen[it1.val]",Medium,48,1310,0.0,2,3.0,7.0,27.291666666666668,53.0,1.94375
121.0,delete node in a linked list,"class Solution:
    def deleteNode(self, node):
        """"""
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """"""            
        node.val = node.next.val
        node.next = node.next.next",Medium,7,255,0.0,0,3.0,1.0,36.42857142857143,10.0,5.541428571428572
122.0,product of array except self,"class Solution:
    def productExceptSelf(self, n: List[int]) -> List[int]:
        ans = [1] * len(n)
        
        pre, pos = 1, 1
        
        for i in range(len(n)):
            ans[i] = pre
            pre *= n[i]
            
        for i in range(len(n)-1, -1, -1):
            ans[i] *= pos
            pos *= n[i]
            
        return ans",Medium,14,362,0.0,2,3.0,2.0,25.857142857142858,17.0,5.672857142857143
123.0,sliding window maximum,"class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        l,r = 0,0
        q = []
        
        while True:
            if not q:
                q.append(nums[l])
            else:
                while q and nums[r]>=q[-1]:
                    q.pop()
                q.append(nums[r])         
            if r-l+1==k:
                break
            r+=1
          
        ans = []
        
        while r!=len(nums):
            maxi = q[0]
            ans.append(maxi)	
            if r+1<len(nums):
                while q and (len(q)==0 or nums[r+1]>q[-1]):
                    q.pop()
                q.append(nums[r+1])  
            if nums[l]==q[0]:
                q.pop(0)
            l+=1
            r+=1
        return ans",Hard,29,783,0.0,7,4.0,8.0,27.0,39.0,3.01
124.0,search a 2d matrix ii,"class Solution:
    def binarysrc(self,arr,k):
        l=0
        r=len(arr)-1
        while l<=r:
            m=(l+r)//2
            if arr[m]==k:
                return m
            elif k>arr[m]:
                l=m+1
            else:
                r=m-1
        else:
            return -1  
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        for i in range(len(matrix)):
            if target>=matrix[i][0] and target<=matrix[i][-1]:
                if self.binarysrc(matrix[i],target)!=-1:
                    return True
        return False",Medium,19,584,0.0,3,3.0,6.0,30.73684210526316,35.0,3.3736842105263163
125.0,different ways to add parentheses,"class Solution:
    def diffWaysToCompute(self, input: str) -> List[int]:
        ops={
            '+':lambda x,y:x+y,
            '-':lambda x,y:x-y,
            '*':lambda x,y:x*y
        }
        def ways(s):
            ans=[]
            for i in range(len(s)):
                if s[i] in '+-*':
                    ans+=[ops[s[i]](l,r) for l,r in itertools.product(ways(s[0:i]),ways(s[i+1:]))]
            if not ans:
                ans.append(int(s))
            return ans
        return ways(input)",Medium,15,510,0.0,3,3.0,5.0,34.0,28.0,3.78
126.0,valid anagram,"class Solution:
    def isAnagram(self, s, t):
        return Counter(s) == Counter(t)",Easy,2,86,0.0,0,2.0,0.0,43.0,7.0,5.3100000000000005
127.0,binary tree paths,"class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        self.ans = []
        
        def recurse(node, s):
            if node is None:
                return True
            
            s += str(node.val)
            left = recurse(node.left, s + ""->"")
            right = recurse(node.right, s + ""->"")
            
            if left and right:
                self.ans.append(s)
            
        recurse(root, '')
     
        return self.ans",Easy,17,493,0.0,1,3.0,2.0,29.0,18.0,5.3500000000000005
129.0,single number iii,"class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        counter = collections.Counter(nums)
        res = sorted(counter, key=lambda x:counter[x])
        return [res[0], res[1]]",Medium,6,247,0.0,0,2.0,1.0,41.16666666666666,12.0,4.9750000000000005
130.0,ugly number,"class Solution:
    def isUgly(self, n: int) -> bool:
        if n == 0:      # CRITICAL edge case!
            return False
        a = n
        for d in [2, 3, 5]:  # means -- taking out all ""banned"" factors from the input number
            while a % d == 0:
                a //= d
        return a == 1",Easy,8,308,2.0,2,3.0,3.0,38.5,21.0,4.215000000000001
131.0,ugly number ii,"class Solution:
    def find_upper(self, d, n_list, beg):
        re = 1
        for i in range(beg, len(n_list)):
            re = n_list[i]
            if (d < n_list[i]):
                break
        return(re)
            
    def nthUglyNumber(self, n: int) -> int:
        re = 1
        ll = [1]
        for i in range(n-1):
            new_n = ll[len(ll)-1]
            min_n = new_n * 10
            
            d2 = self.find_upper(new_n//2, ll, len(ll)//2) * 2
            if (d2 < min_n):
                min_n = d2
            d3 = self.find_upper(new_n//3, ll, len(ll)//3) * 3
            if (d3 < min_n):
                min_n = d3 
            d5 = self.find_upper(new_n//5, ll, len(ll)//5) * 5
            if (d5 < min_n):
                min_n = d5
                
            ll.append(min_n)
            re = min_n
            
        return(re)",Medium,29,869,0.0,4,3.0,6.0,29.96551724137931,39.0,2.9831034482758625
132.0,missing number,"class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        #nums.sort()
        list1=[x for x in range(0,len(nums)+1) if x not in nums]
        print(list1[0])
        return list1[0]",Easy,5,202,1.0,0,2.0,2.0,40.4,7.0,5.5840000000000005
133.0,integer to english words,"class Solution:
    def numberToWords(self, num: int) -> str:
        ones = {1:'One', 2:'Two', 3:'Three', 4:'Four', 5:'Five', 
                6:'Six', 7:'Seven', 8:'Eight', 9:'Nine'}
        teens = {10:'Ten', 11:'Eleven', 12:'Twelve', 13:'Thirteen', 14:'Fourteen', 15:'Fifteen',
                 16:'Sixteen', 17:'Seventeen', 18:'Eighteen', 19:'Nineteen'}
        tens = {2:'Twenty', 3:'Thirty', 4:'Forty', 5:'Fifty', 
                6:'Sixty', 7:'Seventy', 8:'Eighty', 9:'Ninety'}
        comas = {0:'', 1:'Thousand', 2:'Million', 3:'Billion'}

        def threeDigit(n):
            res = ''
            if n // 100:
                res += (ones[n//100]+' Hundred ')
                if n%100 == 0:
                    return res
                n %= 100
            
            if int(n) == 0:
                return res
            elif n < 10:
                res += (ones[n]+' ')
            elif n < 20:
                res += (teens[n]+' ')
            elif n%10 == 0:
                res += (tens[n//10]+' ')
            else:
                res += (tens[n//10]+' '+ones[n%10]+' ')
            return res
        
        if num == 0:
            return 'Zero'
        if num < 1000:
            return threeDigit(num).strip()

        numdiv, res = [], ''        
        while num > 0:
            numdiv.insert(0, num%1000)
            num //= 1000
        #num: 1234567 => [1,234,567]
        
        for i in range(len(numdiv)):
            part = threeDigit(numdiv[i])
            if part == '':
                continue
            else:
                res += (part+comas[len(numdiv)-1-i]+' ')
        
        return res.rstrip()",Hard,48,1653,1.0,5,3.0,14.0,34.4375,119.0,-5.439375000000002
134.0,h index,"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort(reverse = True)
        
        for indx, citation in enumerate(citations):
            if indx >= citation:
                return indx
        return len(citations)",Medium,7,257,0.0,1,3.0,2.0,36.71428571428572,11.0,5.355714285714286
135.0,h index ii,"class Solution:
    def hIndex(self, citations: List[int]) -> int:
        while citations and citations[0]<len(citations):
            citations.pop(0)
        return len(citations)",Medium,4,182,0.0,1,2.0,1.0,45.5,7.0,5.025
136.0,first bad version,"class Solution:
    def firstBadVersion(self, n: int) -> int:
        left  = 1
        while n >= left:
            mid = (n + left) // 2
            if isBadVersion(mid) and not isBadVersion(mid-1):
                return mid
            elif not isBadVersion(mid) :
                left = mid + 1
            else:
                n = mid -1",Easy,10,344,0.0,3,3.0,3.0,34.4,15.0,5.0440000000000005
137.0,perfect squares,"class Solution:
    def numSquares(self, n: int) -> int:
        #check whether n is perfect square
        if int(n**0.5)**2==n:
            return 1
        #collect the possible perfect squares used to construct n
        ps=set()
        i=1
        while i**2<=n:
            ps.add(i**2)
            i+=1
        #create two ends of the bfs
        begin=set()
        begin.add(0)
        end=set()
        end.add(n)
        step=0
        while begin and end:
            step+=1
            temp=set()
            high=max(end)
            for i in begin:
                for j in ps:
                    #check if begin reaches end
                    if (i+j) in end:
                        return step
                    #if i+j>high, it's not possible to be a part of the answer
                    elif i+j<high:
                        temp.add(i+j)
            begin=temp
            step+=1
            temp=set()
            low=min(begin)
            for i in end:
                for j in ps:
                    #check if end reaches begin
                    if (i-j) in begin:
                        return step
                    #if i-j<low, it's not possible to be a part of the answer
                    elif i-j>low:
                        temp.add(i-j)
            end=temp
        return -1",Medium,42,1327,7.0,8,4.0,15.0,31.59523809523809,41.0,2.616428571428571
138.0,expression add operators,"class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        
        def fn(i, expr, total, last):
            """"""Populate ans with expression evaluated to target.""""""
            if i == len(num): 
                if total == target: ans.append(expr)
            else: 
                for ii in range(i, len(num) if num[i] != ""0"" else i+1): 
                    val = int(num[i:ii+1])
                    if i == 0: fn(ii+1, num[i:ii+1], val, val)
                    else: 
                        fn(ii+1, expr + ""*"" + num[i:ii+1], total - last + last * val, last * val)
                        fn(ii+1, expr + ""+"" + num[i:ii+1], total + val, val)
                        fn(ii+1, expr + ""-"" + num[i:ii+1], total - val, -val)
                    
        ans = []
        fn(0, """", 0, 0)
        return ans",Hard,18,837,0.0,4,4.0,5.0,46.5,50.0,0.3350000000000008
139.0,move zeroes,"class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        start = 0 
        second = 1

       
        while second < len(nums): 
           
            if(nums[start] == 0 and nums[second] !=0):
               nums[start], nums[second] = nums[second], nums[start]
               start+=1
            if(nums[start] != 0 ):
                start +=1
            second+=1",Easy,13,391,0.0,2,3.0,3.0,30.07692307692308,22.0,4.793076923076924
140.0,find the duplicate number,"class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        
        freq = Counter(nums)
        return freq.most_common(1)[0][0]",Medium,4,147,0.0,0,2.0,0.0,36.75,6.0,5.9725
141.0,game of life,"class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """"""
        Do not return anything, modify board in-place instead.
        """"""
        rows, cols = len(board),  len(board[0])     
        def transform(row, col, temp_board):
            nonlocal rows, cols
            neighbors = 0
            for r, c in [(row-1, col-1), (row, col-1), (row+1, col-1), (row-1, col), (row+1, col), (row-1, col+1), (row, col+1), (row+1, col+1)]:
                if 0 <= c < cols and 0 <= r < rows:
                    neighbors += temp_board[r][c]
                    
            if board[row][col] == 1:
                if neighbors < 2 or neighbors > 3:
                    return 0
                else:
                    return 1
            else:
                return 1 if neighbors == 3 else 0
        # Take a snapshot of the current board for calculation
        temp_board = [row[:] for row in board]
        for row in range(rows):
            for col in range(cols):
                board[row][col] = transform(row, col, temp_board)",Medium,24,1065,1.0,3,4.0,13.0,44.375,58.0,-0.1737500000000018
142.0,word pattern,"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s=s.split()
        if(len(s)!=len(pattern)):
            return False
        d=dict()
        for i,j in zip(list(pattern),s):
            if i not in d:
                if j not in d.values():
                    d[i]=j
                else:
                    return False
            else:
                if d[i]!=j:
                    return False
        return True",Easy,15,457,0.0,1,4.0,5.0,30.466666666666665,21.0,4.8580000000000005
143.0,nim game,"class Solution:
    def canWinNim(self, n: int) -> bool:
        
        return n % 4",Easy,3,86,0.0,0,2.0,0.0,28.666666666666668,5.0,6.8
144.0,bulls and cows,"class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bulls = 0
        fqs, fqg = {}, {} #frequency table 
        for s, g in zip(secret, guess): 
            if s == g: bulls += 1
            fqs[s] = 1 + fqs.get(s, 0)
            fqg[g] = 1 + fqg.get(g, 0)
        cows = sum(min(v, fqg.get(k, 0)) for k, v in fqs.items()) - bulls
        return f""{bulls}A{cows}B""",Medium,9,393,1.0,2,3.0,3.0,43.66666666666666,27.0,3.1100000000000003
145.0,longest increasing subsequence,"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        lis = [nums[0]]
        for num in nums[1:]:
            if lis and num > lis[-1]:
                lis.append(num)
            else:
                index = bisect_left(lis, num)
                lis[index] = num
        return len(lis)",Medium,9,310,0.0,2,3.0,2.0,34.44444444444444,14.0,5.2
146.0,remove invalid parentheses,"class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        self.ans = []
        self.minMoves = float('inf')
        
        @lru_cache(None)
        def rec(s, count):
            if not s or count > self.minMoves:
                return
            elif self.isValid(s):
                if count == self.minMoves:
                    self.ans.append(s)
                else:
                    self.minMoves = count
                    self.ans = [s]
            
            for i in range(len(s)):
                if s[i] in '()':
                    rec(s[:i] + s[i+1:], count+1)
                    
        rec(s, 0)
        return self.ans or ['']
            
            
    def isValid(self, s):
        l, r = 0, 0
        for i in range(len(s)):
            if s[i] == '(': l += 1
            elif s[i] == ')': r += 1
                
            if r > l: return False
            
        return r == l",Hard,32,947,0.0,6,4.0,9.0,29.59375,46.0,2.1365625
147.0,additive number,"class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        n = len(num)
        for i in range(1, n//2+1):
            x = num[:i]
            if x.startswith(""0"") and len(x) > 1: break #no leading zero 
            for j in range(i+1, min(n-i, (n+i)//2)+1): #i <= n-j and j-i <= n-j
                yy = num[i:j]
                if yy.startswith(""0"") and len(yy) > 1: break #no leading zero
                
                ii, xx = i, x
                while num.startswith(yy, ii):
                    ii += len(yy)
                    xx, yy = yy, str(int(xx) + int(yy))
                if ii == len(num): return True 
                
        return False",Medium,16,675,3.0,3,4.0,6.0,42.1875,36.0,2.3031250000000005
148.0,best time to buy and sell stock with cooldown,"class Solution:
    def solve(self, prices, index, opt):
        if index >= len(prices):
            return 0
        if (index, opt) in self.dp:
            return self.dp[(index, opt)]
        if opt == 0:
            buy = self.solve(prices, index+1, 1) - prices[index]
            cool = self.solve(prices, index+1, 0)
            self.dp[(index, opt)] = max(buy, cool)
        else:
            sell = self.solve(prices, index+2, 0) + prices[index]
            cool = self.solve(prices, index+1, 1)
            self.dp[(index, opt)] = max(sell, cool)
        return self.dp[(index, opt)]
        
    def maxProfit(self, prices: List[int]) -> int:
        self.dp = {}
        return self.solve(prices, 0, 0)",Medium,18,714,0.0,0,3.0,3.0,39.66666666666666,42.0,2.0500000000000007
149.0,minimum height trees,"class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        
        if n<2:
            return range(n)
        
        graph=defaultdict(set)
        indegree=[0]*n
        for u,v in edges:
            graph[u].add(v)
            graph[v].add(u)
            indegree[u]+=1
            indegree[v]+=1
        
        queue=[]
        for i in range(n):
            if indegree[i]==1:
                queue.append(i)
        
        count=n
        
        while count>2:
            new_queue=[]
            
            for current in queue:
                
                for neighbour in graph[current]:
                    indegree[neighbour]-=1
                    graph[neighbour].remove(current)
                    if indegree[neighbour]==1:
                        new_queue.append(neighbour)
                
                count-=1
            queue=new_queue
        
        return queue",Medium,35,952,0.0,7,3.0,8.0,27.2,34.0,3.552
150.0,burst balloons,"class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        size = len(nums)        
        
        t = [[-1 for p in range(0,size+1)]
            for q in range(0,size+1)]
        
        return self.solve(nums,1,size-1,t)
        
    def solve(self,arr,i,j,t):
        if i >= j:
            return 0
        
        if t[i][j] > 0:
            return t[i][j]
        
        ans = float('-inf')
        
        for k in range(i,j):
            if t[i][k] != -1:
                left = t[i][k]
            else:
                left = self.solve(arr,i,k,t)
                t[i][k] = left
                
            if t[k+1][j] != -1:
                right = t[k+1][j]
            else:
                right = self.solve(arr,k+1,j,t)
                t[k+1][j] = right
                
            temp = left + right + (arr[i-1]*arr[k]*arr[j])
            
            ans = max(ans,temp)
            
        t[i][j] = ans
        return t[i][j]",Hard,37,1002,0.0,2,3.0,7.0,27.08108108108108,48.0,2.4627027027027024
151.0,super ugly number,"class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        ugly = [1]
        seen = set()
        x = []
        heapq.heapify(x)
        while len(ugly) != n:
            for i in primes:
                if ugly[-1]*i not in seen:
                    seen.add(ugly[-1]*i)
                    heapq.heappush(x,ugly[-1]*i)
            ugly.append(heapq.heappop(x))
        return ugly[-1]",Medium,12,421,0.0,3,3.0,4.0,35.083333333333336,15.0,4.9825
152.0,count of smaller numbers after self,"class Solution:
  def countSmaller(self, nums: List[int]) -> List[int]:
    l = len(nums)
    arr, ans = sorted(nums), [0] * l
    if l > 99:
      for i in range(l-1):
          ans[i] = bisect_left(arr, nums[i]) # binary search index
          del arr[ans[i]]
    else:
      for i in range(l):
          ans[i] = arr.index(nums[i]) # linear search index
          del arr[ans[i]]
    return ans",Hard,12,397,2.0,3,2.0,3.0,33.083333333333336,17.0,5.1025
153.0,remove duplicate letters,"class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        mp = {c: i for i, c in enumerate(s)}
        stack = []
        for i, c in enumerate(s): 
            if c not in stack: 
                while stack and c < stack[-1] and i < mp[stack[-1]]: stack.pop()
                stack.append(c)
        return """".join(map(str, stack))",Medium,8,352,0.0,3,3.0,4.0,44.0,16.0,4.08
154.0,maximum product of word lengths,"class Solution:
    def maxProduct(self, words: List[str]) -> int:
        n = len(words)
        hashmap = dict()
        i = 0
        ans = 0
        for word in words:
            hashmap[i] = set(word)
            i += 1
        
        for i in range(0, n - 1):
            a = hashmap[i]
            for j in range(i + 1, n):
                b = hashmap[j]
                if not len(a.intersection(b)):
                    ans = max(ans, len(words[i]) * len(words[j]))
        return ans",Medium,16,496,0.0,4,3.0,4.0,31.0,21.0,4.69
155.0,bulb switcher,"class Solution:
    def bulbSwitch(self, n: int) -> int:
        bulb_on = 0
        v = 2
        while n >= 1:
            bulb_on += 1
            n -= v + 1
            v += 2
        return bulb_on",Medium,8,202,0.0,1,3.0,1.0,25.25,13.0,6.1875
156.0,create maximum number,"class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        
        def find_k_max_number_in_an_array(nums, k):
            drop_possible = len(nums) - k
            n = len(nums)
            stack = []
            for i, val in enumerate(nums):
                while stack and drop_possible and stack[-1] < val:
                    drop_possible -= 1
                    stack.pop()
                
                stack.append(val)
            
            return stack[:k]
                
        
        def merge_two_array(arr1, arr2):
            #print(arr1, arr2)
            return [max(arr1, arr2).pop(0) for _ in arr1 + arr2]

        def compare_two_array(arr1, arr2):
            """"""
            determine whether arr1 is greater than arr2
            """"""
            if not arr2:
                return True
            i = j = 0
            n = len(arr1)
            while i < n and j < n:
                if arr1[i] > arr2[j]:
                    return True
                elif arr1[i] < arr2[j]:
                    return False
                i += 1
                j += 1
            
            return True
        
        ans = 0
        for i in range(k + 1):
            p = k - i
            
            if i > len(nums1) or p > len(nums2):
                continue
            
            # get this two array by solving function find_k_max_number_in_an_array
            # using similar concept of 402. Remove K Digits
            first_arr = find_k_max_number_in_an_array(nums1, i)
            second_arr = find_k_max_number_in_an_array(nums2, p)
            
            # merge two array with everytime taking lexicographily larger list
            # https://leetcode.com/problems/create-maximum-number/discuss/77286/Short-Python-Ruby-C%2B%2B
            # see explanation
            curr_arr = merge_two_array(first_arr, second_arr)
            #print(curr_arr)
            
            # can be directly use python max function
            if compare_two_array(curr_arr, ans):
                ans = curr_arr
            # ans = max(ans, curr_arr) if ans else curr_arr
            
            #print(ans)
        
        return ans",Hard,64,2221,10.0,2,4.0,11.0,34.703125,57.0,1.21671875
157.0,coin change,"class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # min number of coins summing up to current amount i
        memo = [-666]*(amount + 1)
        return self.dp(coins, amount, memo)
    
    def dp(self, coins, amount, memo):
        if (amount == 0): return 0
        if (amount < 0): return -1
        
        if (memo[amount] != -666):
            return memo[amount]
        
        res = sys.maxsize
        for coin in coins:
            subProblem = self.dp(coins, amount - coin, memo)
            if (subProblem == -1):
                continue
            res = min(subProblem + 1, res)
        
        memo[amount] = res if res != sys.maxsize else -1
        return memo[amount]",Medium,21,729,1.0,0,3.0,6.0,34.714285714285715,35.0,3.2357142857142867
158.0,wiggle sort ii,"class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        if len(nums)>1:
            nums.sort()
            temp=nums[:]
            r=len(nums)-1
            ind=1
            while r>=0:
                nums[ind]=temp[r]
                ind+=2
                if ind>=len(nums):
                    ind=0
                r-=1",Medium,12,346,0.0,4,4.0,3.0,28.83333333333333,21.0,4.824999999999999
159.0,power of three,"class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and math.isclose(round(math.log(n, 3)), math.log(n, 3), rel_tol = 0.000000000000001)",Easy,2,167,0.0,0,2.0,0.0,83.5,11.0,1.2650000000000006
160.0,count of range sum,"class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        def find(l,r):
            if l > r:
                return 0
            m = (l+r)//2
            left = [0]
            s = 0
            for i in range(m-1,l-1,-1):
                s += nums[i]
                left.append(s)
            right = [0]
            s = 0
            for i in range(m+1,r+1):
                s += nums[i]
                right.append(s)
            right.sort()
            ans = 0
            for i in left:
                ans += (bisect.bisect_right(right,upper-i-nums[m]) - bisect.bisect_left(right,lower-i-nums[m]))
            return ans + find(l,m-1)+find(m+1,r)
        return find(0, len(nums)-1)",Hard,21,737,0.0,2,4.0,4.0,35.095238095238095,33.0,3.1814285714285715
161.0,odd even linked list,"class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head: return head
        p1 = head
        p2 = p1.next
        t = p2
        while p1.next and p2.next:
            p1.next = p2.next
            p1 = p1.next
            p2.next = p1.next
            p2 = p2.next
        p1.next = t
        return head",Medium,12,342,0.0,1,3.0,2.0,28.5,15.0,5.695000000000001
162.0,longest increasing path in a matrix,"class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        m, n = len(matrix), len(matrix[0])
        indegree = defaultdict(int)
        graph = defaultdict(list)
        queue = deque()
        
        for r in range(m):
            for c in range(n):
                for r1, c1 in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:
                    if 0 <= r1 < m and 0 <= c1 < n and matrix[r1][c1] > matrix[r][c]:
                        graph[(r1, c1)].append((r, c))
                        indegree[(r, c)] += 1
                        
                if indegree[(r, c)] == 0: queue.append((r, c, 1))
                    
        while queue:
            r, c, d = queue.popleft()
            
            for r1, c1 in graph[(r, c)]:
                indegree[(r1, c1)] -= 1
                if indegree[(r1, c1)] == 0:
                    queue.append((r1, c1, d+1))
                    
        return d",Hard,24,942,0.0,8,4.0,8.0,39.25,57.0,0.0474999999999994
163.0,patching array,"class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0 
        while prefix < n: 
            if k < len(nums) and nums[k] <= prefix + 1: 
                prefix += nums[k]
                k += 1
            else: 
                ans += 1
                prefix += prefix + 1
        return ans",Hard,10,344,0.0,2,3.0,2.0,34.4,21.0,4.504
164.0,verify preorder serialization of a binary tree,"class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        preorder = preorder.split(',')
        n = len(preorder)
        idx, enough = 0, True                    # static `idx`, `enough` node to build a binary tree
        def dfs():
            nonlocal n, idx, enough 
            if idx >= n: enough = False; return  # if not enough node to build a binary tree
            if preorder[idx] == '#': return 
            if preorder[idx] != '#':
                idx += 1                         # say this is `idx_1`
                dfs()                            # build left tree
                idx += 1                         # now, `idx` is not `idx_1 + 1` because `idx` is static and it's increasing during recursion. Hope this solve your confusion
                dfs()                            # build right tree
        dfs()
        return enough and idx >= n-1             # all characters are visited and they are enough to build a tree",Medium,15,980,9.0,1,5.0,4.0,65.33333333333333,30.0,1.1199999999999992
165.0,reconstruct itinerary,"class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        edges = collections.defaultdict(list)
        n = len(tickets)
        
        for i in range(len(tickets)):
            edges[tickets[i][0]].append(tickets[i][1])
        for k in edges:
            edges[k].sort()
        
        itinerary_list = ['JFK']
        self.traverse(edges, itinerary_list, n)
        return itinerary_list
    
    
    def traverse(self, edges, itinerary_list, n):
        if len(itinerary_list) == n+1:
            return True
        cur_node = itinerary_list[-1]
        
        for i in range(len(edges[cur_node])):
            if edges[cur_node][i] != '#':
                temp = edges[cur_node][i]
                itinerary_list.append(temp)
                edges[cur_node][i] = '#'
                if self.traverse(edges, itinerary_list, n):
                    return True
                edges[cur_node][i] = temp
                itinerary_list.pop()
        return False",Hard,29,1005,2.0,3,3.0,6.0,34.6551724137931,30.0,3.601034482758621
166.0,increasing triplet subsequence,"class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
		m1 = float(""inf"")
		m2 = float(""inf"")
        for i in nums:
            if i<m1:
                m1 = i
            elif i<m2 and i>m1:
                m2 = i
            elif i>m2: return True
        return False",Medium,10,291,0.0,3,3.0,4.0,29.1,17.0,5.321
167.0,self crossing,"class Solution:
    def isSelfCrossing(self, x: List[int]) -> bool:
        def intersect(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real
            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real
        
        def overlap(p1, p2, p3, p4):
            v1 = p2 - p1
            if v1.real == 0:
                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real
            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag
                
        uv = complex(0, 1)
        p = complex(0, 0)
        segments = deque()
        for s in x:
            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))
            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):
                    return True
            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):
                    return True
            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):
                    return True
            if len(segments) == 6:
                segments.popleft()
            p = np
            uv *= complex(0, 1)
        return False",Hard,29,1291,0.0,0,3.0,7.0,44.51724137931034,82.0,-2.386551724137931
168.0,palindrome pairs,"class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        def isPal(word):
            return word == word[::-1]
        palPairs = []
        wordDict = {}
        for i, word in enumerate(words):
            wordDict[word] = i
        for i, word in enumerate(words):
            for j in range(0, len(word)):
                prefix, suffix = word[:j], word[j:] # find all suffix and prefix
                if prefix[::-1] in wordDict and wordDict[prefix[::-1]] != i and isPal(suffix):
                    palPairs.append([i, wordDict[prefix[::-1]]]) # check if reverse prefix in dict and suffix palindrome
                if suffix[::-1] in wordDict and wordDict[suffix[::-1]] != i and isPal(prefix):
                    palPairs.append([wordDict[suffix[::-1]], i]) # check if reverse suffix in dict and prefix palindrome
                if len(palPairs) > 0 and words[palPairs[-1][1]] == '': # tricky part for prefix or suffix is ''. for example, if '1' + '' is palindrome, then '' + '1' should also be palindrome. and add '' + '1' manually
                    pair = palPairs[-1]
                    palPairs.append([pair[1], pair[0]])
        return palPairs",Hard,18,1198,4.0,5,4.0,11.0,66.55555555555556,52.0,-1.570000000000002
169.0,house robber iii,"class Solution:
    def rob(self, root: TreeNode) -> int:
        
        @lru_cache(None)
        def fn(node): 
            """"""Return max money from sub-tree rooted at node.""""""
            if not node: return 0 
            ans = node.val 
            if node.left: ans += fn(node.left.left) + fn(node.left.right)
            if node.right: ans += fn(node.right.left) + fn(node.right.right)
            return max(ans, fn(node.left) + fn(node.right))
        
        return fn(root)",Medium,12,486,0.0,0,3.0,3.0,40.5,13.0,4.875
170.0,counting bits,"class Solution:
    def countBits(self, n: int) -> List[int]:
        lst=[]
        for x in range(0,n+1):
            if x>1:
                lst.append(lst[x//2]+(x%2))
            else:
                lst.append(x)
        return lst",Easy,8,238,0.0,2,3.0,2.0,29.75,11.0,5.9225
171.0,power of four,"class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        arr=[]
        for i in range(100):
            arr.append(4**i)
        if n in arr:
            return True
        else:
            return False",Easy,8,217,0.0,1,3.0,2.0,27.125,9.0,6.41875
172.0,integer break,"class Solution:
    def integerBreak(self, n: int) -> int:
    	return 3**(n//3-((n-3*(n//3))<=1))*((n-3*(n//3))+3*((n-3*(n//3))<=1)) if n>3 else n-1",Medium,2,149,0.0,-1,1.0,1.0,74.5,10.0,2.295
173.0,reverse string,"class Solution:
    def reverseString(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        n = len(s)-1
        for i in range(n,-1,-1):
            s.append(s[i])
            s.pop(i)",Easy,8,251,0.0,1,3.0,2.0,31.375,10.0,5.93625
174.0,reverse vowels of a string,"class Solution:
    def reverseVowels(self, s: str) -> str:
        s = list(s)
        vowel = list('AEIOU')
        left_counter, right_counter = 0, len(s) - 1
        l_val, r_val = None, None
        while left_counter<right_counter:
            if s[left_counter].upper() in vowel:
                l_val = left_counter
            elif l_val is None:
                left_counter += 1
            if s[right_counter].upper() in vowel:
                r_val = right_counter
            elif r_val is None:
                right_counter -= 1
            if l_val is not None and r_val is not None:
                s[l_val], s[r_val] = s[r_val], s[l_val]
                l_val = r_val = None
                left_counter +=1
                right_counter -=1
            if left_counter > right_counter:
                break
        return """".join(s)",Easy,22,853,0.0,6,4.0,7.0,38.77272727272727,33.0,2.6104545454545454
175.0,top k frequent elements,"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        
        nTof = {}
        
        for i in nums:
            if nTof.get(i) is None:
                nTof[i] = 1
            else:
                nTof[i] += 1
        
        unique = list(nTof.keys())
        
        def partition(unique, l, r):
            pivot, p = nTof[unique[r]], r
            
            i = l
            while i < p:
                if nTof[unique[i]] > pivot:
                    unique[i], unique[p-1] = unique[p-1], unique[i]
                    unique[p], unique[p-1] = unique[p-1], unique[p]
                    i -= 1
                    p -= 1
                i += 1
            return p
            
        def quickSelect(unique, l, r, k):
            p = partition(unique, l, r)
            
            if p > k:
                quickSelect(unique, l, p-1, k)
            if p < k:
                quickSelect(unique, p+1, r, k)

            return unique[k:]
            
        return quickSelect(unique, 0, len(unique)-1, len(unique)-k)",Medium,36,1075,0.0,4,3.0,6.0,29.86111111111111,55.0,1.3925
176.0,intersection of two arrays,"class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1).intersection(set(nums2)))",Easy,2,149,0.0,0,2.0,0.0,74.5,7.0,2.475
177.0,intersection of two arrays ii,"class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums = []
        n1 = len(nums1)
        n2 = len(nums2)
        loc1= []
        loc2= []
        for i in range(n1):
            loc1.append(0)
        for j in range(n2):
            loc2.append(0)
        for i in range(n1):
            for j in range(n2):
                if nums1[i] == nums2[j] and loc1[i]==0 and loc2[j]==0:
                    nums.append(nums1[i])
                    loc1[i] = 1
                    loc2[j] = 1
        return nums",Easy,17,556,0.0,5,3.0,5.0,32.705882352941174,28.0,3.776470588235294
178.0,russian doll envelopes,"class Solution:
    def maxEnvelopes(self, en: List[List[int]]) -> int:
        def bs(t,n,v):
            i = 0
            j = n-1
            while i<=j:
                m = (i+j)//2
                if t[m][1] == v:
                    return m
                elif v<t[m][1]:
                    j = m-1
                else:
                    i = m+1
            return i
        en.sort(key = lambda x:(x[0],-x[1]))
        t = [en[0]]
        c = 1
        for i in range(len(en)):
            if t[-1][1] < en[i][1]:
                t.append(en[i])
                c += 1
            else:
                x = bs(t,c,en[i][1])
                t[x] = en[i]
        return len(t)",Hard,24,687,0.0,3,4.0,5.0,28.625,37.0,3.30375
179.0,count numbers with unique digits,"class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
    	if n == 0:
    		return 1
    	g, h = 10, 9
    	for i in range(n-1):
    		g += 9*h
    		h *= (8-i)
    	return(g)
		
- Python 3
- Junaid Mansuri",Medium,11,227,0.0,1,1.0,2.0,20.63636363636364,15.0,6.5227272727272725
180.0,max sum of rectangle no larger than k,"class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        # initialize rows and columns values and determine transposed flag if needed 
        rows = len(matrix) # m 
        cols = len(matrix[0]) # n 
        transposed_matrix_flag = False
        transposed_matrix = list()

        # consider a power of 10 as siginficant 
        # if cols is significantly larger than rows in our implementation
        # we will do the significantly larger work^2
        # If this were to occur, we should flip our set up 
        if cols > (10*rows) : 
            # set transpose flag to true 
            transposed_matrix_flag = True
            # loop over columns amount 
            for row in range(cols) : 
                # generate rows 
                transposed_row = list()
                # for column in matrix is actually the rows 
                for col in matrix : 
                    # append the row item at the row index to the row 
                    transposed_row.append(col[row])
                # put the transposed row into the transposed matrix 
                transposed_matrix.append(transposed_row)

        # if transposed flag 
        if transposed_matrix_flag :
            # set the transpose and adjust rows and cols as needed  
            matrix = transposed_matrix 
            rows = len(matrix)
            cols = len(matrix[0])

        # minimum value start for maximal sum 
        maximum_sum = -math.inf

        # loop all columns 
        for col_index in range(cols) : 
            # generate a temporary row 
            temp_row = [0] * rows
            # loop columns from col index to cols 
            # col_index_2 is then our bound column index 
            for col_index_2 in range(col_index, cols) : 
                # set that column sums and the column sum 
                column_sums = [0]
                column_sum = 0
                # loop every row index in range rows 
                for row_index in range(rows) :
                    # temp row at the row index is the matrix at the row and the bound col index 
                    temp_row[row_index] += matrix[row_index][col_index_2]
                    # column sum gets this valuation added 
                    column_sum += temp_row[row_index]
                    # difference is determined 
                    difference = column_sum - k
                    # index is determined by bisection 
                    index = bisect.bisect_left(column_sums, difference)
                    # if index is in range of column sums so far 
                    if index < len(column_sums) : 
                        # if column sums at that index is the difference 
                        if column_sums[index] == difference : 
                            # this is the maximal result, return it 
                            return k
                        else : 
                            # otherwise maximum sum is set to maximum of itself and difference of column sum and column sums at index 
                            maximum_sum = max(maximum_sum, column_sum - column_sums[index])
                    # do an insort of column sum into column sums, at most row times 
                    bisect.insort(column_sums, column_sum)
        # if you never returned k, you should return as good as you got 
        return maximum_sum",Hard,68,3392,32.0,6,4.0,26.0,49.88235294117647,48.0,1.3905882352941177
181.0,water and jug problem,"class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        def eucid(x,y):
            if x<y: x,y=y,x
            while x!=y!=0:
                remainder=x%y
                x,y=y,remainder
            return x
        e=eucid(x,y)
        if not e: return not z
        return (x+y)>=z and z%e==0",Medium,10,327,0.0,1,3.0,3.0,32.7,31.0,3.717000000000001
182.0,valid perfect square,"class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num**.5%1 == 0",Easy,2,94,0.0,0,2.0,0.0,47.0,8.0,4.8500000000000005
183.0,largest divisible subset,"class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        dp = []
        for i, x in enumerate(nums): 
            dp.append([x])
            for ii in range(i): 
                if x % nums[ii] == 0: 
                    dp[-1] = max(dp[-1], dp[ii] + [x], key=len)
        return max(dp, key=len)",Medium,9,352,0.0,3,3.0,3.0,39.11111111111112,19.0,4.220000000000001
184.0,sum of two integers,"class Solution:
    def getSum(self, a: int, b: int) -> int:
        return sum([a,b])",Medium,2,86,0.0,0,2.0,0.0,43.0,8.0,5.21
185.0,super pow,"class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        b=int(''.join(map(str,b)))
        res = 1    
        a = a % 1337
        if (a == 0) :
            return 0
        while (b>0) :
            if ((b &amp; 1) == 1):
                res=(res*a)%1337
            b=b>>1      
            a=(a*a)%1337
        return res",Medium,12,346,0.0,2,3.0,3.0,28.83333333333333,26.0,4.505
186.0,find k pairs with smallest sums,"class Solution:
    def kSmallestPairs(self, nums1, nums2, k: int):
        temp=[]
        res=[]
        tot=[]
        end=0
        for i in nums1:
            for j in nums2:
                temp.append([i,j])
                tot.append(sum([i,j]))
        for i,v in sorted(zip(temp,tot),key = lambda x: x[1]):
            if end<k:
                res.append(i)
                end+=1
        return res",Medium,14,410,0.0,4,3.0,4.0,29.285714285714285,23.0,4.644285714285714
187.0,guess number higher or lower,"class Solution:
    def guessNumber(self, n: int) -> int:
        l, r = 1, n
        while l <= r:
            mid = (l + r) // 2
            val = guess(mid)
            if val == -1:
                r = mid - 1
            
            elif val == 1:
                l = mid + 1

            elif val == 0:
                return mid",Easy,13,336,0.0,4,3.0,4.0,25.846153846153847,27.0,4.553846153846154
188.0,guess number higher or lower ii,"class Solution:
    def getMoneyAmount(self, n: int) -> int:
        
        new=[[0 for i in range(0,n+1)] for i in range(0,n+1)]
        for gap in range(1,n+1):
            for j in range(gap,n+1):
                i=j-gap
                if gap==1:
                    new[i][j]=min(i,j)
                    continue
                if i==0 or j==0:
                    continue
                mini=8765432
                for k in range(i,j+1):
                    if k==i:
                        ans=i+new[i+1][j]
                    elif k==j:
                        ans=j+new[i][j-1]
                    else:
                        ans=k+max(new[k+1][j],new[i][k-1])
                    mini=min(ans,mini)
                new[i][j]=mini
        print(new)
        return new[1][-1]",Medium,23,794,0.0,5,4.0,9.0,34.52173913043478,45.0,1.853043478260869
189.0,wiggle subsequence,"class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if not nums:
            return 0
        less = [1]*len(nums)
        more = [1]*len(nums)
        res_l = 1
        res_m = 1
        
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i] > nums[j] and more[i] < less[j]+1:
                    more[i] = less[j]+1
                    res_m = more[i]
                
                elif nums[i] < nums[j] and less[i] < more[j]+1:
                    less[i] = more[j]+1
                    res_l = less[i]
        return max(res_l,res_m)",Medium,18,610,0.0,4,4.0,5.0,33.888888888888886,24.0,4.069999999999999
190.0,combination sum iv,"class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        nums.sort()
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for comb_sum in range(target+1):
            for num in nums:
                if comb_sum - num >= 0:
                    dp[comb_sum] = dp[comb_sum] + dp[comb_sum-num]
        return dp[target]",Medium,9,366,0.0,3,3.0,4.0,40.66666666666666,15.0,4.48
191.0,kth smallest element in a sorted matrix,"class Solution:
    
    import heapq
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        
        heap = []
        for arr in matrix:
            heapq.heappush(heap,(arr[0],0,arr))
            
        while k > 0 and heap:
            val,idx,arr = heapq.heappop(heap)
            ans = val
            if idx+1<len(arr):
                heapq.heappush(heap,(arr[idx+1],idx+1,arr))
            k-=1
        return ans",Medium,15,444,0.0,3,3.0,3.0,29.6,24.0,4.5760000000000005
192.0,linked list random node,"class Solution:

    def __init__(self, head: ListNode):
        """"""
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """"""
        self.res = []
        
        while head:
            self.res.append(head.val)
            head = head.next
        

    def getRandom(self) -> int:
        """"""
        Returns a random node's value.
        """"""
        return random.choice(self.res)",Medium,18,477,0.0,1,2.0,1.0,26.5,10.0,6.4350000000000005
193.0,ransom note,"class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        note_freq = collections.Counter(ransomNote)
        mag_freq = collections.Counter(magazine)
        
        for letter in note_freq:
            if note_freq[letter] > mag_freq[letter]:
                return False
        return True",Easy,8,328,0.0,1,3.0,2.0,41.0,12.0,4.87
194.0,shuffle an array,"class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        a = nums[0]+nums[1]+nums[len(nums)-1]
        nums.sort()
        for i in range(len(nums)-2):
            l = i+1
            h = len(nums)-1
            while l<h:
                b = nums[i]+nums[l]+nums[h]
                if b > target:
                    h -= 1
                else:
                    l += 1
                if abs(target - b)<abs(target - a):
                    a = b
        return a",Medium,15,503,0.0,4,4.0,4.0,33.53333333333333,22.0,4.302
195.0,mini parser,"class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        stack = []
        integerStr = ''
        
        for c in s:
            if c == '[':
                stack.append(NestedInteger())
            elif c == ']':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
                poppedList = stack.pop()
                if len(stack)==0:
                    return poppedList
                stack[-1].add(poppedList)
            elif c == ',':
                if len(integerStr)>0:
                    stack[-1].add(NestedInteger(int(integerStr)))
                integerStr = ''
            else:
                integerStr += c
                
        return NestedInteger(int(s))",Medium,23,795,0.0,6,4.0,7.0,34.56521739130435,34.0,2.889130434782607
196.0,lexicographical numbers,"class Solution:
    def dfs(self, cur, n, res):
        if cur > n:
            return
        
        res.append(cur)
        for i in range(0, 10):
            self.dfs(cur * 10 + i, n, res)
    
    def lexicalOrder(self, n: int) -> List[int]:
        res = []
        
        for i in range(1, 10):
            self.dfs(i, n, res)
        
        return res",Medium,15,364,0.0,2,2.0,3.0,24.266666666666666,20.0,5.5760000000000005
197.0,first unique character in a string,"class Solution:
    def firstUniqChar(self, s: str) -> int:
        counts = dict()
        
        for letter in s:
            counts[letter] = counts.get(letter, 0) + 1
        
        for i in range(len(s)):
            if counts[s[i]] == 1:
                return i
        return -1
        
        '''
        # SUPER slow solution
        for i in range(len(s)):
            if s.count(s[i]) == 1:
                return i
        return -1
        '''",Easy,18,463,1.0,2,3.0,5.0,25.72222222222222,19.0,5.525
198.0,longest absolute file path,"class Solution:
    def lengthLongestPath(self, input: str) -> int:
        longest = 0
        path = []
        i = 0
        while i < len(input):
            length = 0
            depth = 0
            is_file = False
            in_path_component = False
            whitespaces = 0
            while i < len(input) and input[i] != '\n':
                if input[i] == '\t':
                    depth += 1
                elif input[i] == ' ':
                    if in_path_component:
                        # We may have whitespaces in folder and file names:
                        length += 1
                    else:
                        # Some test cases seem to use 4 whitespaces instead of one tab character:
                        whitespaces += 1
                        if whitespaces == 4:
                            depth += 1
                            whitespaces = 0
                elif input[i] == '.':
                    in_path_component = True
                    is_file = True
                    length += 1
                elif input[i] != '\n' and input[i] != '\t':
                    in_path_component = True
                    length += 1
                i += 1

            # Move back up the file tree to where we currently are:
            while depth < len(path):
                path.pop()

            if is_file:
                # We may have leading whitespaces which could be mistaken with depth. Add these too.
                length += (depth-len(path))*4
                # We may have leading whitespaces in case we saw a number of whitespaces which was not a multiple of 4. Add these too.
                length += whitespaces
                longest = max(longest, sum(path) + length)
            else:
                path.append(length+1)  # +1 as we need to take the separator ""/"" into account.
            i += 1
        return longest",Medium,46,1898,6.0,10,4.0,10.0,41.26086956521739,62.0,-0.5134782608695652
199.0,find the difference,"class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        for i in t:
            if s.count(i)!=t.count(i):
                return i",Easy,4,155,0.0,2,3.0,3.0,38.75,10.0,5.2125
200.0,elimination game,"class Solution:
    def lastRemaining(self, n: int) -> int:
        return 1 if n==1 else 2*(1+n//2-self.lastRemaining(n//2))
    
    def lastRemaining1(self, n: int) -> int:
        """"""""
        removing from left to right [1 2 3 4 5 6 7 8 9]==[2 4 6 8]==2*[1 2 3 4]
        """"""
        def helper(n,is_left):
            if n == 1: return 1
            if is_left: return 2*helper(n//2,False)
            if n%2==1: return 2*helper(n//2,True)
            return 2*helper(n//2,2)-1
        return helper(n,True)
    
    def lastRemaining2(self, n: int) -> int:
        if n==0: return
        st1,st2,left=list(range(1,n+1)),[],True
        while len(st1)>1:
            if not left:
                st1=st1[::-1]
            for i in range(1,len(st1),2):
                st2.append(st1[i])
            st1=list(st2) if left else list(st2[::-1])
            st2=[]
            left = not left
        return st1[0]",Medium,26,917,0.0,1,3.0,9.0,35.26923076923077,61.0,0.4857692307692307
201.0,perfect rectangle,"class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        area = 0
        corner = set()
        X0 = Y0 = inf
        X1 = Y1 = -inf
        for x0, y0, x1, y1 in rectangles: 
            area += (x1-x0)*(y1-y0)
            X0 = min(x0, X0)
            Y0 = min(y0, Y0)
            X1 = max(x1, X1)
            Y1 = max(y1, Y1)
            corner ^= {(x0, y0), (x0, y1), (x1, y0), (x1, y1)}
        return area == (X1-X0)*(Y1-Y0) and corner == {(X0, Y0), (X0, Y1), (X1, Y0), (X1, Y1)}",Hard,13,521,0.0,1,3.0,1.0,40.07692307692308,45.0,1.653076923076922
202.0,is subsequence,"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        for i in range(len(s)): 
            if s[i] in t: 
                t =  t[t.index(s[i])+1:]
            else: 
                return False
        return True",Easy,7,237,0.0,1,3.0,2.0,33.857142857142854,12.0,5.512857142857144
203.0,utf 8 validation,"class Solution:
    def validUtf8(self, data: List[int]) -> bool:
        i=0
        while i<len(data):
            x=bin(data[i])[2:]
            if len(x)!=8:
                #Means it's a 1 byte
                i+=1
                continue
            cnt=0
            j=0
            while j<len(x) and x[j]=='1':
                cnt+=1#Count num of 1 or bytes 1(num of 1 must be 2,3 or 4)
                j+=1
            if cnt<=1 or cnt>4 or i+cnt>len(data):#cnt means number if bytes
                return False
            i+=1
            cnt-=1#because 1 one byte is used by current num
            while cnt>0:
                y=bin(data[i])[2:]
                if len(y)!=8 or not y.startswith('10'):
                    return False
                i+=1
                cnt-=1
        return True",Medium,24,814,4.0,3,4.0,7.0,33.916666666666664,38.0,2.8875
204.0,decode string,"class Solution:
    def decodeString(self, s: str) -> str:
        def helper(sub):
            res = ''                               # empty new string initailaized
			i = 0                                 # every time we get a valid new substring, we need to traverse through all of it 
            while i < len(sub):
                if sub[i].isdigit():           # if its a digit, we know the next would be an opening bracket,then our substring
                    d = ''                          # To find the whole number we do another while loop 
                    while sub[i].isdigit():
                        d += sub[i]
                        i += 1
                    st = [""[""]                # preemptively intializing with ""["" because we already know a number will always be followed by a opening bracket 
                    new_sub = ''         # We know that the next x characters will be the substring we need for recursion 
                    i += 1                    # This increment is because we already added '[' to the stack which would have been the open bracket at i
                    while st:                            # Now we get the substring using stack approach, just basic bracket validation
                        if sub[i+1] == ""["":         # i+1 to prevent going out of bounds since we are doing i+=1 after the check 
                            st.append(""["")           # I think not doing i+=1 right before ""while st"" and doing i+=1 will then let you check using sub[i]
                        if sub[i+1] == ""]"":
                            st.pop()
                        new_sub += sub[i]
                        i += 1
                    for j in range(int(d)):              # Now, we have whole substring and hence we need to execute that substring the amount of times the number we obtained
                        res += helper(new_sub)    # recursively call the function on that particular substring
                elif sub[i].isalpha():              # if the character of the current string is an alphabet add it to res
                    res += sub[i]
                i += 1 
            return res                 # Return the res generated after traversing throughout the current string 
        
        return helper(s)             # returns the result of the total string",Medium,28,2343,15.0,6,7.0,14.0,83.67857142857143,42.0,-1.9110714285714288
205.0,longest substring with at least k repeating characters,"class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        c_counts = []
        pc = None
        n = 0
        for c in s:
            if pc is None:
                pc = s
                n = 1
            else:
                if pc == c:
                    n += 1
                else:
                    c_counts.append((pc, n))
                    n = 1
            pc = c
        if pc:
            c_counts.append((pc, n))
        
        max_sub = 0
        for left in range(len(c_counts)):
            chars = {}
            for right in range(left, len(c_counts)):
                if not chars.get(c_counts[right][0]):
                    chars[c_counts[right][0]] = 0
                chars[c_counts[right][0]] += c_counts[right][1]
                if min(chars.values()) > k - 1:
                    max_sub = max(max_sub, sum(chars.values()))
        return max_sub",Medium,28,903,0.0,8,4.0,8.0,32.25,38.0,2.577499999999999
206.0,rotate function,"class Solution:
    def maxRotateFunction(self, A: List[int]) -> int:
        total = sum(A)
        ans = cur = sum(i * n for i, n in enumerate(A))
        for i in range(len(A)-1, 0, -1):
            cur += total - len(A) * A[i]
            ans = max(ans, cur)
        return ans",Medium,7,281,0.0,1,3.0,2.0,40.142857142857146,15.0,4.647142857142858
207.0,integer replacement,"class Solution:
    def integerReplacement(self, n: int) -> int:
        if n==1: return 0
        if n%2==0: return self.integerReplacement(n//2) + 1
        return min(self.integerReplacement(n-1),self.integerReplacement(n+1))+1",Medium,4,230,0.0,0,2.0,2.0,57.5,14.0,3.305
208.0,random pick index,"class Solution:

    def __init__(self, nums: List[int]):
        self.val_index = collections.defaultdict(list)
        
        for i, num in enumerate(nums):
            self.val_index[num].append(i)

    def pick(self, target: int) -> int:
        return random.choice(self.val_index[target])",Medium,9,296,0.0,1,2.0,1.0,32.888888888888886,11.0,5.760000000000001
209.0,evaluate division,"class Solution:
    def calcEquation(self, e: List[List[str]], v: List[float], q: List[List[str]]) -> List[float]:
    	V, e, k = {j: False for i in q for j in i}, sorted(i[0]+[i[1]] for i in zip(e,v)), 0
    	for i,[n,d,v] in enumerate(e):
    		if not (V[n] or V[d]): V[n], k = [1,k], k+1
    		[V[n],V[d]] = [V[n],[V[n][0]/v,k-1]] if V[n] else [[V[d][0]*v,k-1],V[d]]
    	return [-1 if not (V[n] and V[d] and V[n][1] == V[d][1]) else V[n][0]/V[d][0] for [n,d] in q]
		
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,11,520,0.0,2,1.0,8.0,47.27272727272727,35.0,2.065454545454545
210.0,nth digit,"class Solution:
    def findNthDigit(self, n: int) -> int:
    	s, d = 0, 0
    	while s < n:
    		s += (d+1)*9*10**d
    		d += 1
    	n -= s-d*9*10**(d-1)
    	r, s = n % d, 10**(d-1)+n//d
    	return str(s)[r-1] if r > 0 else str(s-1)[-1]
				
				
- Python 3
- Junaid Mansuri",Medium,12,280,0.0,1,1.0,2.0,23.33333333333333,17.0,6.08
212.0,remove k digits,"class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
    	n, N, j = list(num), [], k
    	for _ in range(len(num)-k):
    		i = n.index(min(n[:j+1]))
    		N.append(n[i])
    		j -= i
    		del n[:i+1]
    	return """".join(N).lstrip(""0"") or ""0""
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,12,309,0.0,1,1.0,1.0,25.75,17.0,5.862500000000001
213.0,frog jump,"class Solution:
    def canCross(self, s: List[int]):
		# memory variable
        mem = dict()
		
		# k = jump variable; i = current index; s = stones list; mem = memory dictionary
        def frog(s, k, i, mem):
			# unique key
            key = str(s[i]) + "":"" + str(k) + "":"" + str(i)

            if i == len(s)-1:
                return True
            if key in mem:
                return mem[key]
			# possible jumps
            jumps = [k-1, k, k+1]

            result = False

            for jump in jumps:
                if jump and s[i]+jump in s:
                    result = frog(s,jump,s.index(s[i]+jump,i),mem)
                mem[key] = result 

            return mem[key]
        
        frog(s, 0, 0, mem)
        
        return True in mem.values()",Hard,28,774,4.0,1,2.0,4.0,27.642857142857142,36.0,3.892142857142858
214.0,sum of left leaves,"class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        # Store only left children in stack
        self.stack = []
            
        # Add left children of rightmost diagonal to stack
        self.explore_right_add_left(root)
        
        total = 0
        # We have left children
        while self.stack:
            # Explore the right diagonal from next left child
             while self.stack and self.stack[-1] and self.stack[-1].right:
                # Explore right children and add all left children on this diagonal to stack
                self.explore_right_add_left(self.stack.pop())
				
            # If there is a node still at top of stack, it must be a left child with no direct right child
            if self.stack:
                if self.stack[-1].left:
					# has left child, so add left child to explore
                    self.stack.append(self.stack.pop().left)
                else:
                    # is a left leaf
                    total += self.stack.pop().val

        return total
    
    def explore_right_add_left(self, node):
		"""""" Explore right children and add left children to stack.""""""
        while node:
            if node.left:
                self.stack.append(node.left)
            node = node.right",Easy,32,1295,8.0,6,3.0,7.0,40.46875,20.0,4.1378125
216.0,queue reconstruction by height,"class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        res = []
		# Sort the array, with descending order for height and ascending order for the number of taller persons ahead
        people_sorted = sorted(people, key=lambda p: (p[0], -p[1]), reverse=True)
		# Add persons to the result, at respective indices
        for p in people_sorted:
            res.insert(p[1], p)
        return res",Medium,8,438,2.0,1,2.0,3.0,54.75,17.0,3.2725
217.0,trapping rain water ii,"class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        m, n = len(heightMap), len(heightMap[0])
        
        pq = []
        for i in range(m): 
            heappush(pq, (heightMap[i][0], i, 0))
            heappush(pq, (heightMap[i][n-1], i, n-1))
        for j in range(1, n-1): 
            heappush(pq, (heightMap[0][j], 0, j))
            heappush(pq, (heightMap[m-1][j], m-1, j))
        
        ans = most = 0 
        while pq: 
            ht, i, j = heappop(pq)
            most = max(most, ht)
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if 0 < ii < m-1 and 0 < jj < n-1 and heightMap[ii][jj] != -1: 
                    ans += max(0, most - heightMap[ii][jj])
                    heappush(pq, (heightMap[ii][jj], ii, jj))
                    heightMap[ii][jj] = -1 # mark ""visited""
        return ans",Hard,21,889,1.0,5,3.0,5.0,42.333333333333336,53.0,0.4499999999999975
218.0,longest palindrome,"class Solution:
    def longestPalindrome(self, s: str) -> int:
        hashmap = {}
        if len(s) == 0:
            return 0
        for i in s:
            if i not in hashmap:
                hashmap[i] = 1
            else:
                hashmap[i]+= 1
        #Longest odd chars + even chars
        longest_odd_char = 0
        even_chars = 0
        print(hashmap)
        for i in hashmap.keys():
            if hashmap[i]%2 == 1: #odd char string
                if hashmap[i] > longest_odd_char:
                    longest_odd_char = hashmap[i]
            else:
                even_chars += hashmap[i]
        return longest_char + even_chars",Easy,20,661,2.0,5,3.0,6.0,33.05,27.0,3.9255
219.0,split array largest sum,"class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:        
        #return self.bruteForce(nums,m)
        #self.cache=collections.defaultdict(dict)
        #return self.memo(0,nums,m)
        low,high,res=max(nums),sum(nums),-1
        while low<=high:
            pivot=(low+high)//2
            if self.isValid(nums,m,pivot):
                res,high=pivot,pivot-1
            else:
                low=pivot+1
        return res
    
    def isValid(self,nums,m,pivot):
        chunk,current=0,0
        for v in nums:
            current+=v
            if current>pivot:
                chunk,current=chunk+1,v
        return chunk + 1 <= m
    
    def memo(self,i,nums,m):
        if not nums: return 0
        if m == 1: return sum(nums[i:])
        if i in self.cache and m in self.cache[i]:
            return self.cache[i][m]
        self.cache[i][m]=float(""inf"")
        for j in range(1,len(nums)+1):
            left,right=sum(nums[i:i+j]),self.memo(i+j,nums,m-1)
            self.cache[i][m]=min(self.cache[i][m],max(left,right))
            if left>right: break
        return self.cache[i][m]
    
    def bruteForce(self,nums,m):
        if not nums: return 0
        if m == 1: return sum(nums)
        min_value=float(""inf"")
        for i in range(1,len(nums)+1):
            left,right=sum(nums[:i]),self.bruteForce(nums[i:],m-1)
            min_value=min(min_value,max(left,right))
        return min_value",Hard,41,1451,3.0,1,3.0,15.0,35.390243902439025,89.0,-2.205121951219514
220.0,fizz buzz,"class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        total = []
        for i in range(1,n+1):
            if i % 3 == 0 and i % 5 == 0:
                total.append(""FizzBuzz"")
                continue
            if i % 3 == 0:
                total.append(""Fizz"")
                continue
            if i % 5 == 0:
                total.append(""Buzz"")
                continue
            total.append(str(i))
            
        return total",Easy,15,463,0.0,1,4.0,4.0,30.866666666666667,23.0,4.622
221.0,arithmetic slices,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def totSlices(nums,slices): # For total number of same difference consecutive integers
            count = 2
            co = nums[1]-nums[0]
            for i in range(2,n):
                pre = nums[i]-nums[i-1]
                if  pre == co:
                    count += 1
                else:
                    if count>2:
                        slices.append(count)
                    co = pre
                    count = 2  
                    
            if count>2:
                slices.append(count)
                
            return slices
        
        
        def totCombination(maxSlice,combination): #For combination of maximum slice integer
            combination = [0]*(maxSlice+1)
            st = 1
                
            for i in range(3,maxSlice+1):
                combination[i] = combination[i-1]+st
                st+=1
                
            return combination
                
        n = len(nums)
        
        if n < 3:
            return 0
        
        total = 0
        
        slices = totSlices(nums,[])
        
        if slices == []:
            return 0
            
        combination = totCombination(max(slices),[])
            
        for i in slices:
            total += combination[i]
                
        return total",Medium,49,1404,2.0,4,4.0,11.0,28.6530612244898,46.0,2.421224489795918
222.0,third maximum number,"class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        
        # Remove redundant element
        nums = set(nums)
        
        # Convert it back to list to use sort
        nums = list(nums)
        
        # Sort the list
        nums.sort()
        
        # Return the third one from the last if not exist then return the last one
        return nums[-3] if len(nums) >= 3 else nums[-1]",Easy,13,414,4.0,-2,2.0,2.0,31.846153846153847,9.0,6.3938461538461535
223.0,add strings,"class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        if ""0"" in (num1, num2):
            return num2 if num1 == ""0"" else num1
        
        class MyStr(str):
            dic = {str(v): v for v in range(10)}
            
            def __getitem__(self, index):
                try:
                    return MyStr.dic[super().__getitem__(index)]
                except IndexError:
                    return 0
        
        num1, num2 = MyStr(num1), MyStr(num2)
        carry, s = 0, """"
        for idx in range(-1, -1-max(len(num1), len(num2)), -1):
            o_sum = num1[idx] + num2[idx] + carry
            carry = o_sum // 10
            s = f'{o_sum % 10}{s}'
                
        return f'1{s}' if carry else s",Easy,21,757,0.0,-1,3.0,5.0,36.04761904761905,32.0,3.435714285714285
224.0,partition equal subset sum,"class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total = sum(nums)
        if total % 2 != 0: return False 
        target = total // 2
        dp = [False]*(target + 1)
        dp[0] = True
        for num in nums:
            for i in range(target, num-1, -1):
                dp[i] = dp[i] or dp[i-num]
				if dp[target]: return True
        return dp[target]",Medium,11,390,0.0,2,2.0,4.0,35.45454545454545,17.0,4.869090909090909
225.0,pacific atlantic water flow,"class Solution:
    def flow(self, q: List[List[int]], canFlowFrom: List[List[bool]], heights: List[List[int]]):
		# directions that we can water can flow from
        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        while len(q) != 0:
            inds = q.pop(0)
            for direction in directions:
                i = inds[0] + direction[0]
                j = inds[1] + direction[1]
				# check if coordinates are valid and that they haven't been visited
                if i >= 0 and j >= 0 and i < len(heights) and j < len(heights[i]) and heights[inds[0]][inds[1]] <= heights[i][j] and not canFlowFrom[i][j]:
                        q.append([i, j])
                        canFlowFrom[i][j] = True
            
        
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m = len(heights)
        n = len(heights[0])
        flowToAtlantic = [[False] * n for i in range(m)]
        flowToPacific = [[False] * n for i in range(m)]
        atlanticQ = []
        pacificQ = []
        # add edges touching ocean
        for i in range(m):
            pacificQ.append([i, 0])
            flowToPacific[i][0] = True
            atlanticQ.append([i, n - 1])
            flowToAtlantic[i][n - 1] = True
		# add edges touching ocean
        for j in range(n):
            pacificQ.append([0, j])
            flowToPacific[0][j] = True
            atlanticQ.append([m - 1, j])
            flowToAtlantic[m - 1][j] = True
        # flow from edges updwards to validate if can flow to specific ocean for each coordinate
        self.flow(atlanticQ, flowToAtlantic, heights)
        self.flow(pacificQ, flowToPacific, heights)
        res = []
        for i in range(m):
            for j in range(n):
				# if we can reach both oceans, then we can add it to the result list
                if flowToAtlantic[i][j] and flowToPacific[i][j]:
                    res.append([i, j])
        return res",Medium,43,1936,6.0,8,3.0,25.0,45.02325581395349,63.0,-0.772093023255815
226.0,battleships in a board,"class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        if not board:
            return 0
        counter = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == ""X"":
                    self.dfs(board, i, j)
                    counter += 1
        return counter
    
    def dfs(self, board, i, j):
        if i < 0 or j < 0 or i >= len(board) or j >= len(board[i]) or board[i][j] != ""X"":
            return
        board[i][j] = ""#""
        self.dfs(board, i+1, j)
        self.dfs(board, i-1, j)
        self.dfs(board, i, j+1)
        self.dfs(board, i, j-1)",Medium,19,657,1.0,3,3.0,5.0,34.578947368421055,37.0,2.867894736842106
227.0,strong password checker,"class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        lengthOfPassword=len(password)
        
        #IF PASSWORD IS LESS THAN 2 CHARACTER
        if lengthOfPassword<3:
            return 6-lengthOfPassword

        isLower=False
        isUpper=False
        isDigit=False

        repeatedCharacters=[]
        lastCharacter=''
        numberOfRepeatedCharacter=-1

        #LOOP TO CHECK ALL CONTITIONS
        for i in range(lengthOfPassword):

            #CHECKING FOR UPPER<LOER CASE AND DIGIT IN PASSWORD
            if not isUpper and password[i].isupper():
                isUpper=True
            elif not isLower and password[i].islower():
                isLower=True
            elif not isDigit and password[i].isdigit():
                isDigit=True

            #COUNTING TOTAL REPEATATION 
            if lastCharacter==password[i]:
                repeatedCharacters[numberOfRepeatedCharacter]+=1
            else:
                numberOfRepeatedCharacter+=1
                repeatedCharacters.append(1)
                lastCharacter=password[i]
         #<END OF FIRST FOR LOOP>
        cases=int(not isUpper)+int(not isLower)+int(not isDigit)                    
        #LOGIC

        if lengthOfPassword<6:
            #LESS THAN 6 CHARACTERS
            return cases if cases>6-lengthOfPassword else 6-lengthOfPassword
            
        elif lengthOfPassword<=20:        
            #ATLEAST 6 CHARACTER AND ATMOST 20 CHARACTERS
            totalRepeats=0
            for i in repeatedCharacters:
                totalRepeats+=int(i/3)
            return cases if cases>totalRepeats else totalRepeats
            
        elif lengthOfPassword>20:
            extra=lengthOfPassword-20
            totalchanges=0
            while extra!=0:
                #Negitive Value
                pos=-1
                #Modulo should be more than 2
                value=5.99
                countUnique=0
                for i in range(len(repeatedCharacters)):
                    if repeatedCharacters[i]<3:
                        countUnique+=1
                        continue
                    else:
                        if repeatedCharacters[i]%3==0:
                            pos=i
                            value=repeatedCharacters[i]
                            break
                        elif repeatedCharacters[i]%3<value%3:
                            pos=i
                            value=repeatedCharacters[i]

                if value%3==0:
                    if extra-1>=0:
                        repeatedCharacters[pos]-=1
                        extra-=1
                        totalchanges+=1
                    else:
                        break
                elif value%3==1:
                    if extra-2>=0:
                        repeatedCharacters[pos]-=2
                        extra-=2
                        totalchanges+=2
                    else:
                        break
                elif value%3==2:
                    if extra-3>=0:
                        repeatedCharacters[pos]-=3
                        extra-=3
                        totalchanges+=3
                    else:
                        break
                if countUnique>=len(repeatedCharacters):
                    break
            totalRepeats=0
            for number in repeatedCharacters:
                if number>=3:
                    totalRepeats+=int(number/3)
            first=totalchanges+extra
            second=totalRepeats if totalRepeats>cases else cases
            result=int(first+second)

            return result",Hard,102,3636,10.0,15,4.0,30.0,35.64705882352941,113.0,-5.248235294117647
228.0,maximum xor of two numbers in an array,"class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32)[::-1]:
            ans <<= 1
            prefix = {num >> i for num in nums}
            ans += any(ans^1^p in prefix for p in prefix)
        return ans",Medium,7,266,0.0,1,3.0,3.0,38.0,16.0,4.740000000000001
229.0,reconstruct original digits from english,"class Solution:
    def originalDigits(self, s: str) -> str:
        freq = Counter(s)
        nums = [""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine""]
        
        ans = [0]*10
        for c, i in (""g"", 8), (""u"", 4), (""w"", 2), (""x"", 6), (""z"", 0), (""s"", 7), (""v"", 5), (""h"", 3), (""i"", 9), (""o"", 1): 
            ans[i] = freq[c]
            freq -= Counter(nums[i]*freq[c])
        return """".join(sorted(str(i)*x for i, x in enumerate(ans)))",Medium,9,475,0.0,1,3.0,2.0,52.77777777777778,41.0,0.9099999999999984
230.0,longest repeating character replacement,"class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        res = 0
        left = 0
        count = {}
        maxf = 0
        for right in range(len(s)):
            count[s[right]] = 1 + count.get(s[right],0)
            maxf = max(maxf, count[s[right]])
    
            while (right-left+1) - maxf > k:
                count[s[left]] -= 1
                left+=1
            res = max(res, right-left+1)
        return(res)",Medium,14,452,0.0,2,3.0,2.0,32.285714285714285,22.0,4.594285714285714
231.0,construct quad tree,"class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        if not grid:
            return
        node = Node()
        grid_sum, n = sum(map(sum, grid)), len(grid)
        if grid_sum == (n * n) or grid_sum == 0:
            node.val, node.isLeaf = grid_sum // (n * n), True
            return node
        node.isLeaf, node.val = False, 1
        node.topLeft = self.construct([[j for j in i[:n//2]] for i in grid[:n//2]])
        node.topRight = self.construct([[j for j in i[n//2:]] for i in grid[:n//2]])
        node.bottomLeft = self.construct([[j for j in i[:n//2]] for i in grid[n//2:]])
        node.bottomRight = self.construct([[j for j in i[n//2:]] for i in grid[n//2:]])
        return node",Medium,14,728,0.0,4,3.0,10.0,52.0,36.0,1.3000000000000007
232.0,n ary tree level order traversal,"class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return None
        
        queue = collections.deque([root])
        res = []
        
        while queue:
            i, l = 0, len(queue)                # l is the number of nodes in current level
            temp_res = []                       # temp_res record node.val at current level
            
            while i < l:                        # i: to iterate through this level
                cur = queue.popleft()
                temp_res.append(cur.val)
                for c in cur.children:          
                    queue.append(c)
                i += 1
            res.append(temp_res)                # After dealing a level, add temp_res which recorded current level to final res
        
        return res",Medium,20,840,4.0,3,4.0,4.0,42.0,20.0,3.960000000000001
233.0,flatten a multilevel doubly linked list,"class Solution:
    def flatten(self, head: 'Node') -> 'Node':
        if head is None:
            return None

        return self.dfs(head)

    def dfs(self, node):
        original_next = node.next
        tail = node

        if node.child:
            node.next = self.dfs(node.child)
            node.next.prev = node
            node.child = None
            tail = node.next
            while tail.next:
                tail = tail.next

        if original_next:
            tail.next = self.dfs(original_next)
            tail.next.prev = tail

        return node",Medium,23,576,0.0,2,2.0,4.0,25.043478260869566,20.0,5.506086956521739
234.0,minimum genetic mutation,"class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        res = []
        def is_valid_mutate(a, b):
            return sum(1 if a[i] != b[i] else 0 for i in range(len(a))) == 1
        
        def helper(start, bank, count, res):
            if not bank:
                return
            
            for i in range(len(bank)):
                curr = bank[i]
				# curr gene can be mutated from start
                if not is_valid_mutate(curr, start):
                    continue
                
				# we found the mutation from curr to end
                if curr == end:
                    res.append(count + 1)
                    return
                # we put leftover gene bank without curr 
                # and see our curr gene as start can be mutate to leftover gene bank
                helper(curr, bank[:i] + bank[i+1:], count + 1, res)
                    
        helper(start, bank, 0, res)
        return min(res) if res else -1",Medium,25,996,4.0,0,4.0,7.0,39.84,37.0,2.6343999999999994
235.0,number of segments in a string,"class Solution:
    def countSegments(self, s: str) -> int:
        count = 0
        for i in range(len(s)):
            if s[i] != "" "" and (i==0 or s[i-1]== "" ""):
                count+=1

        return count",Easy,7,211,0.0,2,2.0,2.0,30.142857142857142,16.0,5.4471428571428575
236.0,non overlapping intervals,"class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        # removing minimum number of intervals is equivalent to
        # keeping the maximum number of intervals, which can be
        # solved greedily. We can sort by finish time and schedule by
        # earliest non-conflicting finish time to leave for more space
        # for subsequent intervals.
        intervals.sort(key = lambda x: x[1])
        n_keep, prev_end = 1, intervals[0][1]
        for i in range(1, len(intervals)):
            cur_start, cur_end = intervals[i]
            if cur_start >= prev_end:
                n_keep += 1
                prev_end = cur_end
        return len(intervals)-n_keep",Medium,14,710,5.0,2,3.0,4.0,50.71428571428572,20.0,3.3357142857142863
237.0,find right interval,"class Solution:
    def findRightInterval(self, I: List[List[int]]) -> List[int]:
        N, S, A, D, k = len(I), sorted(i[0] for i in I), [-1]*len(I), {j[0]:i for i,j in enumerate(I)}, 0
        for L,R in sorted(I, key = lambda x: x[1]):
            k = bisect.bisect_left(S,R,k)
            if k < N: A[D[L]] = D[S[k]]
        return A
		
		
- Junaid Mansuri",Medium,9,361,0.0,3,2.0,4.0,40.11111111111112,27.0,3.39
238.0,path sum iii,"class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        cnt = 0
        if not root:
            return cnt
        
        def counter(n: TreeNode, s=0):
            nonlocal cnt
            if not n:
                return
            s += n.val
            if s == targetSum:
                cnt += 1
            counter(n.left, s)
            counter(n.right, s)
                        
        def dfs(n: TreeNode):
            if not n:
                return
            counter(n)
            dfs(n.left)
            dfs(n.right)
        
        dfs(root)
        return cnt",Medium,24,615,0.0,1,3.0,4.0,25.625,25.0,4.95375
240.0,k th smallest in lexicographical order,"class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        
        def fn(x): 
            """"""Return node counts in denary trie.""""""
            ans, diff = 0, 1
            while x <= n: 
                ans += min(n - x + 1, diff)
                x *= 10 
                diff *= 10 
            return ans 
        
        x = 1
        while k > 1: 
            cnt = fn(x)
            if k > cnt: k -= cnt; x += 1
            else: k -= 1; x *= 10 
        return x",Hard,17,488,0.0,1,3.0,6.0,28.705882352941178,29.0,4.276470588235294
242.0,find all duplicates in an array,"class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        nums.sort()
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                res.append(nums[i])
        return res",Medium,7,241,0.0,2,3.0,2.0,34.42857142857143,11.0,5.501428571428572
243.0,string compression,"class Solution:
    def compress(self, C: List[str]) -> int:
    	if len(C) <= 1: return
    	c, i, _ = 1, 0, C.append("" "")
    	while C[i] != "" "":
    		if C[i] == C[i+1]: c += 1
    		elif c > 1: C[i+2-c:i+1], i, c = list(str(c)), i + 1 - c + len(list(str(c))), 1
    		i += 1
    	del C[-1]
			

- Junaid Mansuri",Medium,11,315,0.0,4,1.0,4.0,28.63636363636364,29.0,4.222727272727273
244.0,add two numbers ii,"class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        result = self.getNumberByIterList(l1) + self.getNumberByIterList(l2)
        divisor = 10
        if result == 0:
            return ListNode(0)
        head, prev = None, None
        while result > 0:
            result, remainder = divmod(result, divisor)
            head = ListNode(remainder, prev)
            prev = head
        return head

    
    def getNumberByIterList(self, li):
        number = 0 
        while li is not None:
            number = number * 10 + li.val
            li = li.next
        return number",Medium,19,624,0.0,1,3.0,3.0,32.8421052631579,30.0,3.8042105263157895
245.0,arithmetic slices ii subsequence,"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        dp = [defaultdict(int) for _ in range(len(nums))]
        res = 0
        for i in range(len(nums)):
            for j in range(i):
                dp[i][nums[i] - nums[j]] += dp[j][nums[i] - nums[j]] + 1
                res += dp[j][nums[i] - nums[j]]
        return res",Hard,8,359,0.0,2,3.0,3.0,44.875,11.0,4.56125
246.0,number of boomerangs,"class Solution:
    def dist(self, p1, p2):
        return sqrt(pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2))
    
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        res = 0
        
        for i in range(len(points)):
            ""cache for every point""
            dist_cache = collections.defaultdict(int)
            
            for j in range(len(points)):
                if i == j:
                    continue
                    
                dist_cache[self.dist(points[i], points[j])] += 1
            
            
            for key in dist_cache:
                """"""
                The formula for generating permutations given n object where we are allowed to choose r of them, is: P(n, r) = n! / (n-r)! 
                In our case we have: n = dist_cache[key] (where key is some distance). Also we can choose 2 elements at a time: r = 2. So formula now: P(n, 2) = n! / (n-2)!
                Using some mathematical transformations: n! / (n-2)! = n * (n-1) * (n-2)! / (n-2)! = n * (n-1)
                This logic applies to each point.
                """"""
                res += dist_cache[key] * (dist_cache[key] - 1)
        
        return res",Medium,27,1195,0.0,3,4.0,9.0,44.25925925925926,36.0,1.996666666666666
247.0,find all numbers disappeared in an array,"class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        return {x for x in range(1,len(nums)+1)} - set(nums)",Easy,2,144,0.0,0,2.0,1.0,72.0,6.0,2.8
248.0,delete node in a bst,"class Solution:    
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if root.val == key:
            # first case - no childrens
            if not root.left and not root.right:
                return None
            
            # second case - there is one of chlidren (left or right)
            if not root.left:
                return root.right
            
            if not root.right:
                return root.left
            
            # third case - there are both childrens (left and right)
            tmp = root.left
            while tmp.right:
                tmp = tmp.right
            
            root.val = tmp.val
            root.left = self.deleteNode(root.left, root.val)
            
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        else:
            root.right = self.deleteNode(root.right, key)
        
        return root",Medium,30,998,3.0,3,3.0,7.0,33.266666666666666,28.0,3.966
249.0,sort characters by frequency,"class Solution:
    def frequencySort(self, s: str) -> str:
        a = Counter(s)
        b = """"
        abc = sorted(a, reverse = True,  key = a.get)
        for i in abc:
            for j in range(a[i]):
                b+=i
        return b",Medium,8,245,0.0,2,3.0,2.0,30.625,15.0,5.4437500000000005
250.0,minimum number of arrows to burst balloons,"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        ans, prev = 0, -inf
        for x, y in sorted(points, key=lambda x: x[1]): 
            if prev < x: 
                ans += 1
                prev = y
        return ans",Medium,7,260,0.0,2,3.0,2.0,37.142857142857146,17.0,4.6571428571428575
251.0,minimum moves to equal array elements,"class Solution:
    def minMoves(self, nums: List[int]) -> int:
        return sum(nums) - min(nums)*len(nums)",Medium,2,110,0.0,0,2.0,0.0,55.0,5.0,4.43
252.0,4sum ii,"class Solution:
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:
        AB = [a+b for a in A for b in B]
        CD = [c+d for c in C for d in D]
                
        # Two sum from AB and CD
        counts = 0
        CD_count = collections.Counter(CD)
        for num in AB:
            counts += CD_count.get(-num, 0)
                
        return counts",Medium,11,406,1.0,1,3.0,5.0,36.90909090909091,18.0,4.67818181818182
253.0,assign cookies,"class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        i = j = 0
        out = 0
        while i < len(g) and j < len(s):
            if g[i] <= s[j]:
                i += 1
                out += 1
            j += 1
        return out",Easy,11,309,0.0,2,3.0,2.0,28.09090909090909,19.0,5.271818181818182
254.0,132 pattern,"class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        prev_greater = [-1] * len(nums)
        stack = []
        for i, n in enumerate(nums):
            # Use >= so that PGE is strictly greater as opposed to greater or equal
            while stack and n >= nums[stack[-1]]:
                stack.pop()
            if stack:
                prev_greater[i] = stack[-1]
            stack.append(i)
            
        mins = [0]
        for i in range(1, len(nums)):
            mins.append(mins[-1])
            if nums[i] < nums[mins[-1]]:
                mins[-1] = i
            
        for i in range(1, len(nums)):
            if ((pg := prev_greater[i]) != -1 and
                nums[mins[pg]] < nums[i] and # nums[i] < nums[pg] by the definition of PGE
                mins[pg] != pg): # mins[pg] <= pg, so only need to check if mins[pg] != pg
                return True
        return False",Medium,23,928,3.0,6,3.0,8.0,40.34782608695652,35.0,2.448695652173913
255.0,circular array loop,"class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        seen = set() # visited &amp; no cycle 
        for i, x in enumerate(nums): 
            if i in seen: continue 
            temp = set() # visited in this round 
            while True: 
                ii = (i + nums[i])% len(nums)
                if ii in seen or nums[ii] * x < 0 or ii == i: # no cycle 
                    seen |= temp 
                    break 
                if ii in temp and ii != i: return True 
                temp.add(i := ii)
        return False",Medium,13,561,3.0,2,4.0,5.0,43.15384615384615,22.0,3.676153846153846
256.0,poor pigs,"class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        # Calculate the max time for a pig to test buckets...
        # Note that, max time will not be (minutesToTest / minutesToDie)...
        # Thinking about all pigs drinking all buckets at last, but no one died immediately, so the poison bucket is the last bucket...
        max_time = minutesToTest / minutesToDie + 1
        # Initialize the required minimum number of pigs...
        req_pigs = 0
        # To find the minimum number of pigs, find the minimum req_pigs such that Math.pow(max_time, req_pigs) >= buckets...
        while (max_time) ** req_pigs < buckets:
            # Increment until it will be greater or equals to bucket...
            req_pigs += 1
        # Return the required minimum number of pigs...
        return req_pigs",Hard,13,857,7.0,0,3.0,2.0,65.92307692307692,21.0,2.0669230769230778
257.0,repeated substring pattern,"class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        a = s[0]
        x = len(s)
        for i in range(1,len(s)):
            if a == s[i:i+len(a)]:
                c = int(len(s)/len(a))
                if a * c == s:
                    return True
            else:
                pass
            a += s[i]
        return False",Easy,12,360,0.0,2,3.0,3.0,30.0,21.0,4.9
258.0,hamming distance,"class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
    	xb, yb = bin(min(x,y))[2:], bin(max(x,y))[2:]
    	return list(yb[:(len(yb)-len(xb))]).count('1') + sum([1 for i in range(len(xb)) if xb[-1-i] != yb[-1-i]])
		
		
- Junaid Mansuri",Easy,6,254,0.0,0,1.0,2.0,42.333333333333336,16.0,4.53
259.0,minimum moves to equal array elements ii,"class Solution:
    def minMoves2(self, n: List[int]) -> int:
    	return (lambda x,y: sum(abs(i-x[y]) for i in x))(sorted(n), len(n)//2)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,6,186,0.0,0,1.0,1.0,31.0,8.0,6.35
260.0,island perimeter,"class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        
            p = 0
            for i in range(len(grid)):
                for j in range(len(grid[i])):
                    if grid[i][j]:
                        p += 4 - (i and grid[i-1][j])*2 - (j and grid[i][j - 1])*2
            return p",Easy,8,327,0.0,3,4.0,3.0,40.875,10.0,4.90125
261.0,can i win,"class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:

        @lru_cache(maxsize=None)
        def can_win(choices, remainder):
            if choices[-1] >= remainder: return True

            for index in range(len(choices)):
                if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]): return True

            return False

        summed_choices =  maxChoosableInteger * (maxChoosableInteger + 1) / 2
        if summed_choices < desiredTotal: return False
        if summed_choices == desiredTotal: return maxChoosableInteger % 2

        return can_win(tuple(range(1, maxChoosableInteger + 1)), desiredTotal)",Medium,16,691,0.0,0,2.0,5.0,43.1875,27.0,3.293125
262.0,count the repetitions,"class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        cnt = idx = 0 
        count = []
        index = []
        for i in range(n1): 
            for ch in s1: 
                if ch == s2[idx]: 
                    idx += 1
                    if idx == len(s2): 
                        cnt += 1
                        idx = 0 
            count.append(cnt)
            index.append(idx)
            for ii in range(i): 
                if index[ii] == idx: 
                    prev = count[ii]
                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))
                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]
                    return (prev + repeat + post) // n2
        return count[-1]//n2",Hard,20,769,0.0,5,4.0,6.0,38.45,36.0,2.3995
263.0,unique substrings in wraparound string,"class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        dp=[0 for i in range(26)]
        if p=="""":
            return 0
        count=1
        pre=ord(p[0])-ord('a')
        dp[pre]=1
        for i in p[1:]:
            cur=ord(i)-ord('a')
            if (pre+1)%26==cur:
                count+=1
                dp[cur]=max(dp[cur],count)
            else:
                count=1
                dp[cur]=max(dp[cur],count)
            pre=cur
        return sum(dp)",Medium,17,498,0.0,2,3.0,4.0,29.294117647058822,28.0,4.263529411764706
264.0,validate ip address,"class Solution:
    def validate_ipv4(self,IP:str)->str:
        for x in IP.split("".""):
            if len(x)==0 or len(x)>3: return ""Neither""
            if not x.isdigit() or not 0<=int(x)<=255 or (x[0]==""0"" and len(x)!=1): return ""Neither""
        return ""IPv4""
    
    def validate_ipv6(self,IP:str)->str:
        hex_digits=""0123456789abcdefABCDEF""
        for x in IP.split("":""):
            if len(x)==0 or len(x)>4 or not all(c in hex_digits for c in x): return ""Neither""
        return ""IPv6"" 
        
    def validIPAddress(self, IP: str) -> str:
        """"""
        O(n) time complexity
        O(1) space complexity
        """"""
        if ""."" in IP and IP.count(""."")==3:
            return self.validate_ipv4(IP)
        elif "":"" in IP and IP.count("":"")==7:
            return self.validate_ipv6(IP)
        else:
            return ""Neither""",Medium,23,857,0.0,0,3.0,8.0,37.26086956521739,47.0,1.766521739130436
265.0,concatenated words,"class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        
        wordset = set(words)
        
        @cache
        def f(word,i):
            if i >= len(word):
                return True
            j = i+1
            while j <= len(word):
                if word[i:j] in wordset and j-i != len(word) and f(word,j):
                    return True
                j += 1
            return False
        
        return [word for word in words if any(word) and f(word,0)]",Hard,16,523,0.0,0,3.0,5.0,32.6875,21.0,4.778125
266.0,matchsticks to square,"class Solution:
    def makesquare(self, matchsticks) -> bool:
        total_circumference = sum(matchsticks)
        side = total_circumference/4

        if int(side) != side:
            return False
			
        matchsticks.sort()
        
        paths = [0]*4
        h = {}
		
        if matchsticks[-1] > side:
            return False
        
        def r():
            if not matchsticks:
                return True

            num = matchsticks.pop()

            ret = False
            for x in range(4):
                if paths[x] + num <= side:
                    paths[x] += num
                    ret |= r()
                    if ret:
                        return True
                    paths[x] -= num
                    if not paths[x]:
                        break

            matchsticks.append(num)
            return ret
        return r()",Medium,35,877,0.0,1,3.0,7.0,25.057142857142857,25.0,5.004857142857143
267.0,ones and zeroes,"class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        arr = sorted([(len(i), sum([1 for j in i if j == '0'])) for i in strs])
        arr = [(i[1], i[0]-i[1], i[0]) for i in arr] # N0, N1, len
        
        ptr = 0
        larr = len(arr)
        print(larr)
        memo = {}

        def dfs(n0: int, n1: int, ptr: int):
            # print((n0, n1, ptr))
            if (n0, n1, ptr) in memo:
                return memo[(n0, n1, ptr)]

            if ptr == larr:
                return 0

            if n0 + n1 < arr[ptr][2]:
                return 0
            
            nextp = ptr + 1

            if not (n0 >= arr[ptr][0] and n1 >= arr[ptr][1]):
                return dfs(n0, n1, nextp)

            take = 1 + dfs(n0 - arr[ptr][0], n1 - arr[ptr][1], nextp)

            if arr[ptr][2] == 1:
                ntake = 0
            else:
                ntake = dfs(n0, n1, nextp)

            ans = take if take > ntake else ntake
            memo[(n0,n1,ptr)] = ans
            return ans
        
        return dfs(m, n, 0)",Medium,37,1081,2.0,0,3.0,11.0,29.216216216216218,68.0,0.47054054054054
268.0,heaters,"class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        houses.sort()
        heaters.sort()
        total, size = len(houses), len(heaters)
		#dummy solution to check if heater with radius r, to cover all houses
        def valid_radius(r):
            house_offset = 0
            heater_offset = 0
            while house_offset < total:
                #case 1: current house is covered by current house, simply pass
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
				#case 2 house cannot be covered, and locates on left side of heater, we can never find a heater to cover this house
                if houses[house_offset] < heaters[heater_offset]:
                    return False
                    break
				#case 3 go ahead to further heater, find the closest heater to cover the house or find no such heater valid
                while heater_offset < size and abs(houses[house_offset] - heaters[heater_offset]) > r:
                    heater_offset += 1
                if heater_offset >= size:return False
                if abs(houses[house_offset] - heaters[heater_offset]) <= r:
                    house_offset += 1
                    continue
                else:
                    return False
                    break
            return True
		#binary search to get radius
        low, high = 0, max(abs(heaters[0] - houses[0]), abs(heaters[0] - houses[-1]))
        mid = (low + high)//2
        while high - low > 1:
            if valid_radius(mid):
                high = mid
            else:low = mid
            mid = (low + high)//2

        return low if valid_radius(low) else high",Medium,38,1754,5.0,0,4.0,10.0,46.1578947368421,51.0,0.7057894736842094
269.0,number complement,"class Solution:
    def findComplement(self, num: int) -> int:
        return int("""".join([""1"" if i == ""0"" else ""0"" for i in list(bin(num))[2:]]),2)",Easy,2,148,0.0,1,2.0,2.0,74.0,10.0,2.16
270.0,total hamming distance,"class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        nums_len = len(nums)
        
        
        if (nums_len == 0):
            return 0
        
        current_bit = 1
        ret = 0
        max_ = max(nums) 

                
        while (current_bit <= max_):
            counter = 0
            
            
            for number in nums:
                if (number &amp; current_bit):
                    counter += 1
                    
            ret += counter * (nums_len - counter)
            current_bit <<= 1
            
        return ret",Medium,24,596,0.0,3,3.0,4.0,24.83333333333333,24.0,5.005000000000001
271.0,generate random point in a circle,"class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius 
        self.x_center = x_center
        self.y_center = y_center

    def randPoint(self) -> List[float]:
        radius = self.radius*sqrt(random.random()) # sample radius as r*sqrt(x) 
        theta = 2*pi*random.random() # sample angle as unif [0, 2*pi) 
        return self.x_center + radius*cos(theta), self.y_center + radius*sin(theta)",Medium,10,462,2.0,0,2.0,1.0,46.2,17.0,4.101999999999999
272.0,largest palindrome product,"class Solution:
    def largestPalindrome(self, n: int) -> int:
        return [0, 9, 987, 123, 597, 677, 1218, 877, 475][n]

        
    def isPalindrome(x):
        return str(x) == str(x)[::-1]

    def solve(n):
        best = 0
        for i in range(10**n-1, 0, -1):
            for j in range(max(i, (best-1)//i+1), 10**n):
                if isPalindrome(i*j):
                    #print(i, j, i*j)
                    best = i*j
        return best",Hard,15,458,1.0,1,3.0,3.0,30.53333333333333,31.0,3.952
273.0,sliding window median,"class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        
        # Init
        medians = []
        n = len(nums)
        
        # Make median indexes
        m1,m2 = (k//2,k//2) if k%2 else ((k//2)-1,k//2)
       
        # Sort the array and find the first median
        arr = sorted(nums[:k])
        medians.append(float((arr[m1] + arr[m2])/2))
        
        # Find rest medians
        for i in range(0,n-k): 
            arr.remove(nums[i])
            bisect.insort(arr, nums[i+k])
            medians.append(float((arr[m1] + arr[m2])/2))
        
        # return
        return medians",Hard,21,644,5.0,0,3.0,2.0,30.666666666666668,18.0,5.460000000000001
274.0,magical string,"class Solution:
    def magicalString(self, n: int) -> int:
        if n==0: return 0
        if n<=3: return 1
        s,index = [1,2,2],2
        while len(s)<n:
            s+=[3-s[-1]]*s[index]
            index+=1
        return s[:n].count(1)",Medium,8,248,0.0,1,3.0,3.0,31.0,22.0,4.7700000000000005
275.0,license key formatting,"class Solution:
    def licenseKeyFormatting(self, S: str, K: int) -> str:
    	S = """".join([i for i in S if i != '-']).upper()
    	L = len(S)
    	t = L%K
    	if t == 0:
    		t = K
    	T = S[0:t] + '-'
    	for i in range(t,L,K):
    		T = T + S[i:i+K] + '-'
    	return(T[0:-1])
		
- Python 3
- Junaid Mansuri",Easy,13,315,0.0,2,1.0,5.0,24.23076923076923,24.0,5.239230769230769
276.0,smallest good base,"class Solution:
    def smallestGoodBase(self, n: str) -> str:
        n = int(n)
        for p in range(int(log2(n)), 1, -1): 
            k = int(n**(1/p))
            if (k**(p+1)-1)//(k-1) == n: return str(k)
        return str(n-1)",Hard,6,236,0.0,1,3.0,2.0,39.333333333333336,14.0,4.82
277.0,max consecutive ones,"class Solution(object):
    def findMaxConsecutiveOnes(self, nums):
        l, output = 0,0
        
        for r, number in enumerate(nums):
            
            if number == 0:
                l = r+1
            
            output = max(output, r-l+1)
        
        return output",Easy,11,291,0.0,2,3.0,2.0,26.454545454545453,15.0,5.819090909090909
278.0,predict the winner,"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:
        
        N = len(nums)
        if N % 2 == 0: return True # can always win by picking larger one of odd or even subarray
        
		# DP
        dp = nums[:]
        for i in range(1, N):
            for j in range(N - i):
                dp[j] = max(nums[j] - dp[j + 1], nums[j + i] - dp[j])
        
        return dp[0] >= 0",Medium,12,408,2.0,2,2.0,3.0,34.0,19.0,4.88
279.0,zuma game,"class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        hand = ''.join(sorted(hand))
        
        @cache
        def fn(board, hand):
            """"""Return min number of balls to insert.""""""
            if not board: return 0
            if not hand: return inf 
            ans = inf 
            for i, ch in enumerate(hand): 
                if i == 0 or hand[i-1] != ch: # pruning 1
                    hh = hand[:i] + hand[i+1:]
                    for j in range(0, len(board)): 
                        if ch == board[j] or j and board[j-1] == board[j]: # pruning 2
                            bb, nn = """", board[:j] + ch + board[j:]
                            while bb != nn:
                                bb, nn = nn, """"
                                for k, grp in groupby(bb): 
                                    x = len(list(grp))
                                    if x < 3: nn += k*x
                            ans = min(ans, 1 + fn(bb, hh))
            return ans 
        
        return (lambda x: x if x < inf else -1)(fn(board, hand))",Hard,24,1088,2.0,5,5.0,10.0,45.333333333333336,54.0,-1.7763568394002505e-15
280.0,increasing subsequences,"class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        for i in range(2, len(nums)+1):
            for x in set(itertools.combinations(nums, i)):
                if all(a <= b for a, b in zip(x, x[1:])):
                    res.append(x)
        return res",Medium,7,310,0.0,3,3.0,4.0,44.285714285714285,16.0,4.054285714285715
281.0,construct the rectangle,"class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        sqrt_val = int(math.sqrt(area))
        l = w = sqrt_val
        while (l * w) != area and l > 0 and w > 0:
            l += 1
            w = area // l
            
        return [l, w] if w > 1 else (area, 1)",Easy,8,293,0.0,1,3.0,2.0,36.625,17.0,4.763750000000001
282.0,reverse pairs,"class Solution(object):
    def reversePairs(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def merge(array,start,mid,end):
            leftArray=array[start:mid+1]
            rightArray=array[mid+1:end+1]
            i,j=0,0
            m,n=len(leftArray),len(rightArray)
            for k in range(start,end+1):
                if j>=n or (i<m and leftArray[i]<rightArray[j]):
                    array[k]=leftArray[i]
                    i+=1
                else:
                    array[k]=rightArray[j]
                    j+=1
        def merge_sort(array,start,end):
            pairs=0
            if start<end:
                mid=start+(end-start)//2
                pairs+=merge_sort(array,start,mid)
                pairs+=merge_sort(array,mid+1,end)
                j=mid+1
                for i in range(start,mid+1):
                    while j<=end and array[i]>array[j]*2:
                        j+=1
                    pairs+=j-mid-1
                merge(array,start,mid,end)
            return pairs
        pairs=merge_sort(nums,0,len(nums)-1)
        return pairs",Hard,32,1139,0.0,4,4.0,5.0,35.59375,61.0,0.2165624999999984
283.0,target sum,"class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        def findtarget(nums,currsum, length,target,memo):
            if((length,currsum) in memo):
                return memo[(length,currsum)]
            if(length == len(nums)):
                if(currsum == target):
                    memo[(length,currsum)] = 1
                    return 1
                else:
                    memo[(length,currsum)] = 0
                    return 0
            memo[(length,currsum)] = findtarget(nums,currsum+nums[length],length+1,target,memo)+findtarget(nums,currsum-nums[length],length+1,target,memo)
            return memo[(length,currsum)]
        return findtarget(nums,0,0,target,{})",Medium,14,724,0.0,-4,4.0,3.0,51.71428571428572,43.0,1.0457142857142865
284.0,teemo attacking,"class Solution:
    def findPoisonedDuration(self, t: List[int], duration: int) -> int:
        if not t:
            return 0
        n = len(t)
        return sum(min(t[t2] - t[t1], duration) for t1, t2 in zip(range(0, n - 1), range(1, n))) + duration",Easy,5,253,0.0,0,2.0,2.0,50.6,14.0,3.9259999999999993
285.0,next greater element i,"class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        dict_greater = {}

        stack = [nums2[0]]
        for num in nums2[1:]:

            if num < stack[-1]:
                stack.append(num)

            while len(stack) > 0 and num > stack[-1]:
                dict_greater[stack.pop()] = num
            stack.append(num)

        while len(stack) > 0:
            dict_greater[stack.pop()] = -1

        return [dict_greater[j] for j in nums1 if j in dict_greater]",Easy,17,526,0.0,4,2.0,6.0,30.94117647058824,20.0,4.855294117647058
286.0,random point in non overlapping rectangles,"class Solution:

    def __init__(self, rects: List[List[int]]):
        self.rects = rects # store rectangles
        self.wt = [0] # weighted sampling 
        for x1, y1, x2, y2 in rects: 
            wt = (x2 - x1 + 1) * (y2 - y1 + 1) # wt ~ number of points 
            self.wt.append(self.wt[-1] + wt) 

    def pick(self) -> List[int]:
        n = randint(1, self.wt[-1]) # nth point
        k = bisect_left(self.wt, n)-1 # kth rectangle
        offset = n - self.wt[k] - 1 # offset from x1, y1
        x1, y1, x2, _ = self.rects[k]
        return [x1 + offset % (x2 - x1 + 1), y1 + offset // (x2 - x1 + 1)]",Medium,14,615,6.0,1,2.0,1.0,43.92857142857143,24.0,3.706428571428571
287.0,diagonal traverse,"class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix: return []
        temp = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if len(temp)-1<i+j: temp.append([matrix[i][j]])
                else: temp[i+j].append(matrix[i][j])
        res,i = [],0
        for item in temp:
            if i%2==0: res += item[::-1]
            else: res += item
            i += 1
        return res",Medium,13,491,0.0,5,3.0,6.0,37.76923076923077,26.0,3.520769230769232
288.0,keyboard row,"class Solution:
    def findWords(self, w: List[str]) -> List[str]:
    	L = [set('qwertyuiop'),set('asdfghjkl'),set('zxcvbnm')]
    	D, A = {j:i for i in range(3) for j in L[i]}, []
    	for i,j in enumerate([i.lower() for i in w]):
    		if set(j).issubset(L[D[j[0]]]): A.append(w[i])
    	return A
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Easy,10,349,0.0,2,1.0,5.0,34.9,15.0,5.179
289.0,find mode in binary search tree,"class Solution:
    def findMode(self, root: TreeNode) -> List[int]:
        dic = dict()
        if root is None:
            return []
        def inorder(root,dic):
            if root is None:
                return
            else:
                left = inorder(root.left,dic)
                if root.val in dic:
                    dic[root.val] += 1
                else:
                    dic[root.val] = 1
                
                right = inorder(root.right,dic)
                
            return dic
        dic = inorder(root,dic)
        max_val = float('-inf')
        val = 0
        lis = []
        for key,value in dic.items():
            if value == max_val:
                val = key
                lis.append(val)
            elif value > max_val:
                lis = []
                max_val = value
                val = key
                lis.append(val)
	```",Easy,31,903,0.0,4,4.0,6.0,29.12903225806452,36.0,3.298387096774193
290.0,ipo,"class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        projects = sorted([(c, p) for p, c in zip(profits, capital)])
        i, N = 0, len(projects)
        profits_maxheap = []
        cur_capital = w
        while k > 0:
            while i < N and cur_capital >= projects[i][0]:
                heapq.heappush(profits_maxheap, -projects[i][1])
                i += 1
            if not profits_maxheap:
                break
            cur_capital -= heapq.heappop(profits_maxheap)
            k -= 1
        return cur_capital",Hard,14,599,0.0,2,3.0,4.0,42.785714285714285,31.0,2.7492857142857146
291.0,next greater element ii,"class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        old_len = len(nums)
        
        nums += nums
        
        res = [-1] * len(nums)
        for idx in range(len(nums) -1, -1, -1):
            while stack and nums[idx] >= stack[-1]:
                stack.pop()
            
            if stack:
                res[idx] = stack[-1]
            
            stack.append(nums[idx])
        
        return res[:old_len]",Medium,17,484,0.0,3,3.0,3.0,28.47058823529412,18.0,5.27764705882353
292.0,base 7,"class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return str(num)
        res = ''
        x = abs(num)
        while x > 0:
            res = str(x%7) + res
            x //= 7
        return '-' + res if num < 0 else res",Easy,9,268,0.0,1,3.0,3.0,29.77777777777778,16.0,5.48
293.0,relative ranks,"class Solution:
    def findRelativeRanks(self, nums: List[int]) -> List[str]:
        awarded_medals = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""]
        nums_with_indx = sorted([(i, s) for i, s in enumerate(nums)], key=lambda t: t[1], reverse=True)
        for rank, t in enumerate(nums_with_indx):
            pos, score = t
            nums[pos] = awarded_medals[rank] if rank < 3 else str(rank + 1)
        
        return nums",Easy,8,436,0.0,2,3.0,3.0,54.5,22.0,2.595
294.0,perfect number,"class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
    	if num <= 1: return False
    	s, q = 0, num**.5
    	for i in range(2,1+int(q)):
    		if num%i == 0: s += i + num//i
    	if int(q) == q: s -= int(q)
    	return s == num - 1
		
		
- Python 3
- Junaid Mansuri",Easy,11,283,0.0,3,1.0,4.0,25.727272727272727,26.0,4.844545454545455
295.0,most frequent subtree sum,"class Solution:
    def traversal(self, node, d, max_freq):
        if node == None:
            return 0
        
        _sum = self.traversal(node.left, d, max_freq) + self.traversal(node.right, d, max_freq) + node.val

        d[_sum] = d.get(_sum, 0) + 1
        
        max_freq[0] = max(max_freq[0], d[_sum])
        
        return _sum
        
        
    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:
        d = {}
        max_freq = [0]
        
        self.traversal(root, d, max_freq)

        ans = []
        for key in d:
            if d[key] == max_freq[0]:
                ans.append(key)
        
        return ans",Medium,25,664,0.0,1,2.0,3.0,26.56,32.0,4.2296000000000005
296.0,fibonacci number,"class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        fibs = [0,1]
        for i in range(2, n+1):
            fibs.append(fibs[-1] + fibs[-2])


        return fibs[-1]",Easy,9,213,0.0,1,2.0,2.0,23.666666666666668,13.0,6.390000000000001
298.0,freedom trail,"class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        char_pos = defaultdict(set)
        for i, c in enumerate(ring):
            char_pos[c].add(i)
        
        def minStep(fromm, to):
            if fromm == to:
                return 0
            minSteps = abs(fromm - to)
            minSteps = min(minSteps, abs(len(ring) - minSteps))
            return minSteps
        
        n = len(key)
        dp = [0] * len(ring)
        for p in char_pos[key[0]]:
            dp[p] = minStep(0, p)
        prev_char = key[0]
        for c in key[1:]:
            if prev_char == c:
                continue
            for next_pos in char_pos[c]:
                dp[next_pos] = min(dp[prev_pos] + minStep(prev_pos, next_pos) for prev_pos in char_pos[prev_char])
            prev_char = c
        return min(dp[p] for p in char_pos[prev_char]) + len(key)",Hard,24,888,0.0,3,3.0,8.0,37.0,35.0,2.8100000000000005
299.0,find largest value in each tree row,"class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        levels = {}
        def dfs(node, level):
            if not node:return
            if level not in levels.keys():levels[level] = [node.val]
            else:levels[level].append(node.val)
            if node.right:dfs(node.right, level+1)
            if node.left:dfs(node.left, level+1)
        dfs(root, 1)
        return ([max(value) for value in levels.values()])",Medium,10,451,0.0,3,3.0,5.0,45.1,17.0,3.881
300.0,longest palindromic subsequence,"class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        memo = {}
        
        def helper(s: str, i: int, j:int, memo: dict):
            if (i,j) in memo:
                return memo[(i,j)]
            
            if i==j:
                memo[(i,j)] = 1
                return 1
            
            if i>j:
                memo[(i,j)] = 0
                return 0
            
            if s[i] == s[j]:
                sub = helper(s, i+1, j-1, memo)
                memo[(i+1,j-1)] = sub
                return sub + 2
            
            left = helper(s, i, j-1, memo)
            memo[(i,j-1)] = left
            right = helper(s, i+1, j, memo)
            memo[(i+1,j)] = right
            return max(left, right)
        
        return helper(s, 0, len(s)-1, memo)",Medium,27,812,0.0,-1,4.0,4.0,30.07407407407408,53.0,1.8133333333333328
301.0,super washing machines,"class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        total = sum(machines)
        if total % len(machines): return -1 # impossible 
        avg = total // len(machines)
        
        ans = prefix = 0
        for i, x in enumerate(machines): 
            ans = max(ans, abs(prefix), x - avg)
            prefix += x - avg
        return ans",Hard,10,370,1.0,1,3.0,2.0,37.0,16.0,4.870000000000001
302.0,coin change ii,"class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [[0] * (amount + 1) for i in range(len(coins) + 1)]
        for i in range(len(coins) + 1):
            for j in range(amount + 1):
                if j == 0:
                    dp[i][j] = 1
                elif i == 0:
                    dp[i][j] = 0
        for i in range(1 , len(coins) + 1):
            for j in range(1 , amount + 1):
                if coins[i - 1] <= j:
                    dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i - 1]]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[-1][-1]",Medium,15,628,0.0,7,4.0,8.0,41.86666666666667,30.0,2.572
303.0,random flip matrix,"class Solution:

    def __init__(self, m: int, n: int):
        self.cols = n
        self.nums = m * n
        
        self.tail = self.nums - 1
        self.indexes = {}
        

    def flip(self) -> List[int]:
        ind = random.randint(0, self.tail)
        rc = self.indexes.get(ind, ind)
        self.indexes[ind] = self.indexes.get(self.tail, self.tail)
        self.tail -= 1
        
        return [rc // self.cols, rc % self.cols]
        

    def reset(self) -> None:
        self.tail = self.nums - 1
        self.indexes = {}",Medium,21,546,0.0,0,2.0,0.0,26.0,24.0,5.14
305.0,longest uncommon subsequence i,"class Solution:
    def findLUSlength(self, a: str, b: str) -> int:
        if len(a) != len(b):
            return max(len(a), len(b))
        return -1 if a == b else len(a)",Easy,4,175,0.0,0,2.0,2.0,43.75,13.0,4.6425
306.0,longest uncommon subsequence ii,"class Solution:
    def findLUSlength(self, strs: List[str]) -> int:
        
        def fn(p, s):
            """"""Return True if p is a subsequence of s.""""""
            ss = iter(s)
            return all(ch in ss for ch in p)
        
        ans = -1 
        for i, s in enumerate(strs): 
            for ii in range(len(strs)): 
                if i != ii and len(s) <= len(strs[ii]) and fn(s, strs[ii]): break 
            else: ans = max(ans, len(s))
        return ans",Medium,13,476,0.0,0,3.0,5.0,36.61538461538461,20.0,4.524615384615386
307.0,continuous subarray sum,"class Solution:
    def checkSubarraySum(self, N: List[int], K: int) -> bool:
    	L, S, s = len(N), set([0]), 0
    	for i in range(L-1):
    		if (N[i]+N[i+1]) == 0 or (K and not (N[i]+N[i+1]) % K): return True
    	if K == 0: return False
    	for n in N:
    		a, s = s, (s + n) % K
    		if s in S and a != s: return True
    		else: S.add(s)
    	return False
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,14,414,0.0,2,1.0,5.0,29.571428571428573,28.0,4.3585714285714285
308.0,longest word in dictionary through deleting,"class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        def isSubsequence(a: str, b: str) -> bool:
            i = 0
            for c in a:
                if (i := b.find(c, i)) == -1:
                    return False
                i += 1
            return True
        
        heap = [(-len(word), word) for word in d]
        heapq.heapify(heap)
        while heap:
            word = heapq.heappop(heap)[1]
            if isSubsequence(word, s):
                return word
        return ''",Medium,16,528,0.0,1,3.0,6.0,33.0,28.0,3.990000000000001
309.0,contiguous array,"class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        acc = 0  # Stores the value for the current position in the nums

        # Why we have diff_dict?
        # we need to know how many elements before we had the difference value matching the current value at question

        # Example:
        # If at any point we have {0: 15, -1: 14, -2: 13}
        # and we have the acc as -1 on the 16th index, then the sequence must have been
        # 13 14 15 16
        # 1  1  1  0
        # Thus there is a combination that is valid between indexes 15-16
        # Next, if the acc is -2 on 16th index, then the sequence must have been
        # 13 14 15 16 17
        # 1  1  1  0  0
        # Thus there is a larger combination between indexes 14-17
        diff_dict = {0: -1}  # we have -1 here to make start index count
        # if we wouldn't the first starting value wouldn't be included in the calculation

        max_length = 0  # This stores the maximum value result
        for index, num in enumerate(nums):

            # FYI: To make negation of summation work we are saying that 0 is actually -1
            # (we could have easily said 1 is 2 and 0 is -2)
            # The important thing here is that we have something that we can use to count the discrepency.
            if num == 1:
                acc += 1
            else:
                acc -= 1

            if acc in diff_dict:  # There is a specific index that provides the longest subarray with the current acc
                length = index - diff_dict[acc]
                # Thus current index - first index to provide the same difference
                # is the maximum length for an array including the current index
                max_length = max(max_length, length)
            else:
                # We have never encountered an index with such a difference between values,
                # let's just store it for now.
                # If in the future we encounter another one, we will use this as the first one and calculate maximum
                # If the question were to ask for the minimum,
                # then we would update the dict with the newest index independent of whether it exists or not
                diff_dict[acc] = index
        return max_length",Medium,43,2290,27.0,4,3.0,22.0,53.25581395348837,37.0,2.166976744186048
310.0,beautiful arrangement,"class Solution:
    def countArrangement(self, N: int) -> int:        
        n_list = [i+1 for i in range(N)]

        a = 0
        def search_ba(rest_ns, curr_ns):
            if not rest_ns:
                # Found beautiful arrangement
                nonlocal a
                a +=1
                return

            i = len(curr_ns) + 1
            for j in range(len(rest_ns)):
                n = rest_ns[j]
                if (n % i)==0 or (i % n)==0:
                    # Found number from `rest_ns` fit for next position of `curr_ns`
                    search_ba(rest_ns[:j]+rest_ns[j+1:], curr_ns + [n])


        search_ba(n_list, [])
        return a",Medium,21,671,2.0,2,3.0,6.0,31.95238095238096,25.0,4.404285714285715
311.0,random pick with weight,"class Solution:

    def __init__(self, w: List[int]):
        self.prefix = [0]
        for x in w: self.prefix.append(self.prefix[-1] + x)

    def pickIndex(self) -> int:
        r = randint(1, self.prefix[-1])
        return bisect_left(self.prefix, r)-1",Medium,8,258,0.0,1,2.0,1.0,32.25,11.0,5.817500000000001
312.0,minesweeper,"class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        i, j = click[0], click[1]
        
        # If a mine ('M') is revealed, then the game is over - change it to 'X'.
        if board[i][j] == ""M"":
            board[i][j] = ""X""
        # Else, proceed to *reveal* it.
        else:
            self.reveal(board, i, j)
        
        # Return the updated board.
        return board
    # End of updateBoard(...)
        
        
    def reveal(self, board, i, j):
        
        # We only need to check if the point on the board is an ""E'""
        if board[i][j] == ""E"":
            
            # Count number of adjacent mines
            n_adj_mines = self.countAdjMine(board, i, j)
            
            # If an empty square ('E') *with no adjacent mines is revealed*...
            if n_adj_mines == 0:
                
                # Then change it to revealed blank ('B')...
                board[i][j] = ""B""
                
                # ... and all of its adjacent unrevealed squares should be revealed recursively.
                for di, dj in [(1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1), (1,-1)]:
                    newi, newj = i+di, j+dj
                    if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                        self.reveal(board, newi, newj)
            
            # Else, if an empty square ('E') with at least one adjacent mine is revealed...
            else:
                # If the point contains a digit, we update the digit.
                if board[i][j].isdigit():
                     board[i][j] = str(int(board[i][j]) + n_adj_mines)
                
                # Else if the point is not a digit, we fill it with the digit that
                # represents the number of adjacent mines
                else:
                    board[i][j] = str(n_adj_mines)
    # End of reveal(...)
    
            
    # Helper function to count adjacent mines
    def countAdjMine(self, board, i, j):
        count = 0
        for di, dj in [(1,0), (1,1), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1), (1,-1)]:
            newi, newj = i+di, j+dj
            if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                if board[newi][newj] == ""M"":
                    count += 1
        return count
    # End of helpr function to count adj mines.",Medium,58,2393,16.0,7,3.0,15.0,41.25862068965517,110.0,-4.673275862068964
313.0,minimum absolute difference in bst,"class Solution(object):
    def getMinimumDifference(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """"""

        def get_values(values, root):
            if root is not None:
                values.append(root.val)
                values = get_values(values, root.left)
                values = get_values(values, root.right)
            return values

        values_list = get_values([], root)

        if len(values_list) != len(set(values_list)):
            return 0

        values_list.sort()
        minimum_diff = values_list[1] - values_list[0]

        for i in range(1, len(values_list)):
            diff = values_list[i] - values_list[i - 1]
            if diff < minimum_diff:
                minimum_diff = diff

        return minimum_diff",Easy,27,792,0.0,2,2.0,12.0,29.33333333333333,25.0,4.62
314.0,k diff pairs in an array,"class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        ans, seen = set(), set()
        for x in nums: 
            if x - k in seen: ans.add(x)
            if x + k in seen: ans.add(x+k)
            seen.add(x)
        return len(ans)",Medium,7,261,0.0,3,3.0,3.0,37.285714285714285,13.0,4.984285714285715
315.0,complex number multiplication,"class Solution:
    def complexNumberMultiply(self, a: str, b: str) -> str:
        k1=a.split('+')
        k2=b.split('+')
        (xa,ya)=(k1[0],k1[1][:-1])
        (xb,yb)=(k2[0],k2[1][:-1])
        return(str(int(xa)*int(xb)+int(ya)*int(yb)*-1)+'+'+str(int(xa)*int(yb)+int(ya)*int(xb))+'i')",Medium,6,294,0.0,0,2.0,0.0,49.0,17.0,3.77
316.0,convert bst to greater tree,"class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        val = 0
        node, stack = root, []
        while stack or node: 
            if node: 
                stack.append(node)
                node = node.right
            else: 
                node = stack.pop()
                node.val = val = node.val + val 
                node = node.left 
        return root",Medium,12,394,0.0,2,3.0,2.0,32.833333333333336,17.0,5.045
317.0,minimum time difference,"class Solution:
    def time2min(self, t):
        return int(t[:2]) * 60 + int(t[3:])
    
    def findMinDifference(self, timePoints: List[str]) -> int:
        
        new = [self.time2min(t) for t in timePoints]
        new.sort()
        offset = 60*24
        new.extend([n+offset for n in new])
        
        diff = []
        for i in range(len(new)-1):
            diff.append(new[i+1] - new[i])
        
        return min(diff)",Medium,15,442,0.0,0,2.0,7.0,29.466666666666665,13.0,5.928
318.0,single element in a sorted array,"class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        return self.helper(nums)
    
    def helper(self, nums):
        if len(nums)==1:
            return nums[0]
        mid = len(nums)//2
        if nums[mid]!=nums[mid-1] and nums[mid]!=nums[mid+1]:
            return nums[mid]
        else:
            if mid%2==0:
                if nums[mid]==nums[mid-1]:
                    return self.helper(nums[:mid-1])
                else:
                    return self.helper(nums[mid:])
            else:
                if nums[mid]==nums[mid-1]:
                    return self.helper(nums[mid+1:])
                else:
                    return self.helper(nums[:mid])",Medium,20,704,0.0,-1,4.0,5.0,35.2,35.0,3.1519999999999992
319.0,reverse string ii,"class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        res = ''
        for i in range(len(s)//(2*k)):
            res += s[2*k*i:2*k*i+k][::-1] + s[2*k*i+k:2*k*(i+1)]
        
        remainder = len(s) % (2*k)
        
        if remainder <= k and remainder > 0:
            res += s[-remainder:][::-1]
        elif remainder > k:
            res += s[-remainder:-remainder+k][::-1] + s[-remainder+k:]
        
        return res",Easy,13,450,0.0,3,3.0,3.0,34.61538461538461,30.0,3.5246153846153856
320.0,01 matrix,"class Solution:
    def updateMatrix(self, A: List[List[int]]) -> List[List[int]]:
    	M, N, Q = len(A), len(A[0]), []
    	B = [[0]*N for _ in range(M)]
    	for i,j in itertools.product(range(M),range(N)):
    		if not A[i][j]: continue
    		b = 1
    		for k,l in [[i-1,j],[i,j+1],[i+1,j],[i,j-1]]:
    			if not (k in [-1,M] or l in [-1,N] or A[k][l]): B[i][j], b = 1, 0
    		if b: Q.append((i,j))
    	for a in range(2):
	    	for i,j in Q:
	    		m = math.inf
	    		for k,l in [[i-1,j],[i,j+1],[i+1,j],[i,j-1]]:
	    			if not (k in [-1,M] or l in [-1,N]) and B[k][l] > 0: m = min(m,B[k][l])
	    		if m != math.inf: B[i][j] = m + 1
    		if a == 1: return B
    		Q.reverse()
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,21,735,0.0,10,1.0,12.0,35.0,59.0,0.2899999999999991
321.0,diameter of binary tree,"class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        return self.dfs(root)[1]
    
    def dfs(self, root):
        if not root:
            return 0, -sys.maxsize
        l_depth, l_diameter = self.dfs(root.left)
        r_depth, r_diameter = self.dfs(root.right)
        
        return max(l_depth, r_depth) + 1, max(l_diameter, r_diameter, l_depth + r_depth)",Easy,12,434,0.0,-1,2.0,2.0,36.16666666666666,18.0,4.885
322.0,remove boxes,"class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def dp(l, r, count = 0):
            if l > r: return 0
            // Initial count for the letter at boxes[l]
            count += 1
            ptr = l + 1
            while ptr <= r and boxes[l] == boxes[ptr]:
                ptr += 1
                count += 1
            points = (count ** 2) + dp(ptr, r)
            for i in range(ptr + 1, r + 1):
                if boxes[l] == boxes[i]:
                    points = max(points, dp(i, r, count) + dp(ptr, i - 1))
            return points

        return dp(0, len(boxes) - 1)",Hard,18,628,0.0,2,3.0,5.0,34.888888888888886,35.0,3.0600000000000005
323.0,number of provinces,"class Solution:
    
    def find(self, x: int) -> int:
        """"""
        C = cities
        
        Time: O(1) amortized time
        """"""
        if self.parents[x] != x:
            self.parents[x] = self.find(self.parents[x])
        return self.parents[x]

    def union(self, x: int, y: int) -> bool:
        """"""
        C = cities
        
        Time: O(1) amortized time
        """"""
        x_rep = self.find(x)
        y_rep = self.find(y)
        
        if x_rep == y_rep:
            return False
        
        if self.ranks[x_rep] > self.ranks[y_rep]:
            self.parents[y_rep] = x_rep
        elif self.ranks[x_rep] < self.ranks[y_rep]:
            self.parents[x_rep] = y_rep
        else:
            self.parents[y_rep] = x_rep
            self.ranks[x_rep] += 1
            
        return True
        
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        """"""
        C = number of cities
        
        Time: O(C^2)
        - We go over each C^2 pair. The union for each operation is O(1) amortized.
        
        Space: O(2C + logC) = O(C)
        - We keep track of C parents and ranks
        - The find operation will take at most logC recursion space.
        """"""
        total_cities = len(isConnected)
        total_provinces = total_cities

        self.parents = list(range(total_cities))
        self.ranks = [0] * total_cities

        for i in range(total_cities):
            for j in range(total_cities):
                if isConnected[i][j] == 1 and self.union(i, j):
                    total_provinces -= 1

        return total_provinces",Medium,56,1615,0.0,4,3.0,8.0,28.839285714285715,53.0,1.6844642857142844
324.0,student attendance record i,"class Solution:
    def checkRecord(self, s: str) -> bool:
        a, l = 0, 0
        for i in range(len(s)):
            if s[i] == 'A':
                a += 1
                if l < 3:
                    l = 0
            elif s[i] == 'L':
                if l == 0:
                    l += 1
                elif l > 0 and s[i-1] == 'L':
                    l += 1
                else:
                    l = 0
            else:
                if l < 3:
                    l = 0
            if (a > 1 or l > 2):
                return False
            else:
                pass
        return True",Easy,22,609,0.0,7,4.0,8.0,27.681818181818183,42.0,2.6486363636363635
325.0,student attendance record ii,"class Solution:
    def checkRecord(self, n: int) -> int:
        self.dp = defaultdict(int)

        self.dp[0] = 1
        self.dp[1] = 2
        self.dp[2] = 4
        self.dp[3] = 7

        self.helper(n)
        total = self.dp[n]

        for i in range(1, n + 1):
            total += self.dp[i - 1] * self.dp[n - i] 

        return total % ((10 ** 9) + 7)

    def helper(self, i):
        if i < 0:
            return 0
        if i in self.dp:
            return self.dp[i]

        self.dp[i] = (2 * self.helper(i - 1) - self.helper(i - 4)) % ((10 ** 9) + 7)
        
        return self.dp[i]",Hard,25,606,0.0,0,2.0,3.0,24.24,20.0,5.6984
326.0,optimal division,"class Solution:
    def optimalDivision(self, nums: List[int]) -> str:
        n=len(nums)
        new=[[(0,"""") for i in range(0,n)] for i in range(0,n)]
        for i in range(0,n):
            new[i][i]=(nums[i],str(nums[i]))
        for i in range(0,n-1):
            for j in range(i+1,n):
                new[i][j]=(new[i][j-1][0]/nums[j],new[i][j-1][1]+""/""+str(nums[j]))
        ans=[(0,"""")]*n
        ans[0]=(nums[0],str(nums[0])
        for i in range(1,n):
            for j in range(0,i):
                if (ans[i][0]<ans[j][0]/new[j+1][i][0]):
                    if i-j>=2:
                        ans[i]=(ans[j][0]/new[j+1][i][0],ans[j][1]+""/""+""(""+new[j+1][i][1]+"")"")
                    else:
                        ans[i]=(ans[j][0]/new[j+1][i][0],ans[j][1]+""/""+new[j+1][i][1])
        return ans[-1][1]",Medium,18,820,0.0,7,4.0,9.0,45.55555555555556,38.0,1.4399999999999995
327.0,brick wall,"class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        edge = []
        for w in wall: 
            prefix = 0
            for k in range(len(w)-1): 
                prefix += w[k]
                edge.append(prefix)
        
        ans = cnt = 0
        prev = None
        for x in sorted(edge): 
            cnt = 1 if x != prev else cnt+1 # reset counter 
            ans = max(ans, cnt)
            prev = x
        return len(wall) - ans",Medium,15,471,1.0,3,3.0,4.0,31.4,19.0,4.954000000000001
328.0,next greater element iii,"class Solution:
    def nextGreaterElement(self, n: int) -> int:
    	n = [int(i) for i in str(n)]
    	for i in range(2,len(n)+1):
    		b, f = 1, n[-i]
    		for j in range(1,10-f):
    			if f + j in n[-i+1:]:
    				b = 0
    				break
    		if b == 1: continue
    		n[n.index(f+j,-i)], n[-i] = f, f + j
    		n[-i+1:] = sorted(n[-i+1:])
    		n = int("""".join([str(i) for i in n]))
    		return n if n < 2**31 else -1
    	return -1
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,18,487,0.0,1,1.0,7.0,27.05555555555556,29.0,4.545
329.0,reverse words in a string iii,"class Solution:
    def reverseWords(self, s: str) -> str:
        l1=s.split()
        l=[]
        for i in l1:
            c=i[::-1]
            l.append(c)
        for i in l:
            c=' '.join(l)
        return c
            
        ``",Easy,11,246,0.0,2,3.0,2.0,22.363636363636363,13.0,6.387272727272727
330.0,logical or of two binary grids represented as quad trees,"class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        if quadTree1.isLeaf and quadTree2.isLeaf:                                    # case 1: both are leaf nodes
            node = Node(quadTree1.val | quadTree2.val, 1, None, None, None, None)
            return node
        elif quadTree1.isLeaf and not quadTree2.isLeaf:                              # case 2: node 1 is leaf node, node 2 is not
            node = Node(0, 0, 
                        self.intersect(quadTree1, quadTree2.topLeft), 
                        self.intersect(quadTree1, quadTree2.topRight), 
                        self.intersect(quadTree1, quadTree2.bottomLeft), 
                        self.intersect(quadTree1, quadTree2.bottomRight))
        elif not quadTree1.isLeaf and quadTree2.isLeaf:                              # case 3: node 2 is leaf node, node 1 is not
            node = Node(0, 0, 
                        self.intersect(quadTree1.topLeft, quadTree2), 
                        self.intersect(quadTree1.topRight, quadTree2), 
                        self.intersect(quadTree1.bottomLeft, quadTree2), 
                        self.intersect(quadTree1.bottomRight, quadTree2))
        else:                                                                        # case 4: neither nodes are leaf 
            node = Node(0, 0, 
                        self.intersect(quadTree1.topLeft, quadTree2.topLeft), 
                        self.intersect(quadTree1.topRight, quadTree2.topRight), 
                        self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft), 
                        self.intersect(quadTree1.bottomRight, quadTree2.bottomRight))
            
        if node.topLeft.isLeaf and node.topRight.isLeaf and node.bottomLeft.isLeaf \
            and node.bottomRight.isLeaf and node.topLeft.val == node.topRight.val \
            == node.bottomLeft.val == node.bottomRight.val:                          # shrink quad nodes to one leaf node is values in 4 areas are the same
            return Node(node.topLeft.val, 1, None, None, None, None)
        return node",Medium,28,2121,5.0,1,6.0,4.0,75.75,68.0,-3.8375
331.0,maximum depth of n ary tree,"class Solution:
    def maxDepth(self, root: 'Node') -> int:
        
        def dfs(root: 'Node', length: int):
            if root is None:
                return
                
            length += 1
            
            if not root.children:
                result.append(length)
            else:
                for child in root.children:
                    dfs(child, length)
                
        result = []
        dfs(root, length=0)
        
        if not result:
            return 0
        
        return max(result)",Easy,21,546,0.0,2,3.0,4.0,26.0,19.0,5.46
332.0,subarray sum equals k,"class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        
        if len(nums)==0:
            return 0
        rSum=0
        count=0
        res_map={}
        res_map[0]=1
        for i in range(len(nums)):
            rSum+=nums[i]
            
            compliment=rSum-k
            if compliment in res_map:
                count = count + res_map[compliment]
            if rSum in res_map:
                res_map[rSum]=res_map[rSum]+1
            else:
                res_map[rSum]=1
        return count",Medium,19,543,0.0,3,3.0,4.0,28.57894736842105,24.0,4.667894736842106
333.0,array partition,"class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return sum(nums[::2])",Easy,3,117,0.0,0,2.0,0.0,39.0,7.0,5.67
334.0,binary tree tilt,"class Solution:
    def findTilt(self, root: TreeNode) -> int:
        cur_sum = [0]
        def helper(node: TreeNode):
            if not node: return 0
            lt = helper(node.left)
            rt = helper(node.right)
            cur_sum[0] += abs(lt-rt)
            return node.val + lt + rt
        helper(root)
        return cur_sum[0]",Easy,10,347,0.0,-1,3.0,1.0,34.7,12.0,5.557
335.0,find the closest palindrome,"class Solution:
    def nearestPalindromic(self, n: str) -> str:
        sz = len(n)
        cand = n[:sz//2] + (n[sz//2] if sz&amp;1 else """") + n[0:sz//2][::-1]
        
        def fn(carry): 
            digits = list(map(int, n))[:(sz+1)//2]
            i = (sz-1)//2
            while i >= 0 and carry: 
                digits[i] += carry 
                carry = digits[i] // 10 
                digits[i] = (digits[i] + 10) % 10 
                i -= 1
            half = (str(carry)+''.join(map(str, digits))).lstrip('0')
            if len(half) < len(digits): return '9'*(sz-1) or '0'
            if len(half) > len(digits): return '1' + '0'*(sz-1) + '1'
            half = half or '0'
            if sz&amp;1: return half + half[:-1:][::-1]
            else: return half + half[::-1]
            
        large = fn(1)
        small = fn(-1)
        # print(cand, ""|"", large, ""|"", small)
        if cand == n: return min(small, large, key=lambda x: (abs(int(x)-int(n)), int(x)))
        return min(cand, large, small, key=lambda x: (abs(int(x)-int(n)), int(x)))",Hard,24,1072,1.0,1,3.0,6.0,44.66666666666666,59.0,-0.120000000000001
336.0,array nesting,"class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        ans = 0 
        for i in range(len(nums)): 
            cnt = 0
            while nums[i] != -1: 
                cnt += 1
                nums[i], i = -1, nums[i]
            ans = max(ans, cnt)
        return ans",Medium,9,291,0.0,2,3.0,2.0,32.333333333333336,16.0,5.19
337.0,reshape the matrix,"class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        newList = []
        
        #convert to 1-D list
        for i in mat:
            for j in i:
                newList.append(j)

        elements = len(newList)        #total no. of elements

        resMat = []
        
        #if the no. of elements of the new required matrix size (r x c) are not equal to total number of elements, we need to return the original matrix
        if r*c != elements:
            return mat
        else:
            for i in range(0,len(newList),c):
                resMat.append(newList[i:i+c])
            return resMat",Easy,19,669,3.0,2,3.0,5.0,35.21052631578947,22.0,4.451052631578948
338.0,permutation in string,"class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        d1={}
        d2={}
        if(len(s1)>len(s2)):
            return False
        sl = len(s1)
        left = 0
        right = sl-1
        
        for i in s1:
            if(i not in d1):
                d1[i] = 1
            else:
                d1[i] +=1
        
        for i in range(left,right+1):
            if(s2[i] not in d2):
                d2[s2[i]] = 1
            else:
                d2[s2[i]] +=1
        
        if(d1 == d2):
            return True
            
        while(right < len(s2)-1):
            right+=1
            if(s2[right] not in d2):
                d2[s2[right]] = 1
            else:
                d2[s2[right]] +=1
            
            if(d2[s2[left]] == 1):
                del d2[s2[left]]
            else:
                d2[s2[left]]-=1
            left+=1
            if(d1 == d2):
                return True
            
            
        return False",Medium,41,997,0.0,-1,3.0,10.0,24.317073170731707,47.0,2.991463414634146
339.0,subtree of another tree,"class Solution:
    
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        if root is None:
            return False
        
        def add_hash(node):
            if not node:
                return hash('#')
            node.hash = hash(add_hash(node.left) + hash(node.val) + add_hash(node.right))
            return node.hash
        
        add_hash(root)
        add_hash(subRoot)
        return self.rec(root, subRoot)

    def rec(self, root, subRoot):
        if root is None:
            return False
        
        if root.hash == subRoot.hash and self.isEqual(root, subRoot):
                return True
        
        return self.rec(root.left, subRoot) or self.rec(root.right, subRoot)
    
    def isEqual(self, subroot1, subroot2):
        if subroot1 is None or subroot2 is None:
            return subroot1 is None and subroot2 is None
        else:
            return subroot1.val == subroot2.val and self.isEqual(subroot1.left, subroot2.left) and self.isEqual(subroot1.right, subroot2.right)",Easy,29,1059,1.0,-3,3.0,5.0,36.51724137931034,33.0,3.453448275862069
340.0,distribute candies,"class Solution:
    def distributeCandies(self, candies: List[int]) -> int:
        average = len(candies) // 2
        kind = len(set(candies))
        if average >= kind :
            return kind
        else:
            return average",Easy,7,238,0.0,0,3.0,1.0,34.0,11.0,5.66
341.0,out of boundary paths,"class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        
        @cache
        def fn(i, j, mv): 
            """"""Return out of boundary paths.""""""
            if not (0 <= i < m and 0 <= j < n): return 1 
            if mv == 0: return 0
            return (fn(i-1, j, mv-1) + fn(i, j-1, mv-1) + fn(i, j+1, mv-1) + fn(i+1, j, mv-1)) % 1_000_000_007
        
        return fn(startRow, startColumn, maxMove)",Medium,10,470,0.0,-2,3.0,2.0,47.0,37.0,2.0100000000000007
342.0,shortest unsorted continuous subarray,"class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        sortednums = sorted(nums)
        if sortednums == nums:
            return 0
        start = 0
        end = len(nums)-1
        for i in range(len(nums)):
            if nums[i]!=sortednums[i]:
                start = i
                break
        for i in range(len(nums)-1,0,-1):
            if nums[i]!=sortednums[i]:
                end = i
                break
        return len(nums[start:end+1])",Medium,15,492,0.0,2,3.0,5.0,32.8,23.0,4.448
343.0,delete operation for two strings,"class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp=[[0 for _ in range(len(word2)+1)]for _ in range(len(word1)+1)]
        for i in range(1,len(dp)):
            for j in range(1,len(dp[0])):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]+1
                else:
                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])
        return len(word1)+len(word2)-2*dp[-1][-1]",Medium,9,439,0.0,3,4.0,5.0,48.77777777777778,20.0,3.1900000000000004
344.0,erect the fence,"class Solution:
    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:
        def clockwise(p1,p2,p3):
            x1,y1=p1
            x2,y2=p2
            x3,y3=p3
            
            return ((y3-y2)*(x2-x1)-(y2-y1)*(x3-x2))
        trees.sort()
        upper=[]
        lower=[]
        for t in trees:
            while len(upper)>1 and clockwise(upper[-2],upper[-1],t)>0:
                upper.pop()
            while len(lower)>1 and clockwise(lower[-2],lower[-1],t)<0:
                lower.pop()
            upper.append(tuple(t))
            lower.append(tuple(t))
            
        return list(set(upper+lower))",Hard,19,644,0.0,2,3.0,3.0,33.89473684210526,27.0,3.949473684210527
345.0,n ary tree preorder traversal,"class Solution:
    def __init__(self):     # initializing the answer list
        self.ans=[]
		
    def preorder(self, root: 'Node') -> List[int]:
        if not root:             # if leaf Node
            return
        self.ans.append(root.val)   # append the root value
        for i in root.children:    # iterate over every children 
            self.preorder(i)
        return self.ans        # return ans",Easy,10,414,5.0,0,3.0,3.0,41.4,9.0,5.394000000000001
346.0,n ary tree postorder traversal,"class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        st = [root]
        l = []
        while st:
            node = st.pop()
            if node:
                l.insert(0,node.val)
                if node.children:
                    for i in node.children:
                        st.append(i)
        return l",Easy,11,338,0.0,4,4.0,4.0,30.727272727272727,13.0,5.454545454545454
347.0,tag validator,"class Solution:
    def isValid(self, code: str) -> bool:
        prefix = suffix = False 
        stack = []
        i = 0 
        while i < len(code): 
            if code[i:i+2] == '</': 
                ii = i = i+2
                for i in range(i, len(code)): 
                    if code[i] == '>': break 
                else: return False 
                if i == len(code)-1: suffix = True 
                tag = code[ii:i]
                if not stack or stack[-1] != tag: return False 
                stack.pop()
                if not stack and not suffix: return False 
            elif code[i:i+3] == '<![': 
                ii = i = i+3
                buffer = 1
                for i in range(i, len(code)): 
                    if code[i] == '[': 
                        if buffer: 
                            buffer = 0 
                            if code[ii:i] != ""CDATA"": return False 
                    elif code[i:i+3] == ']]>': 
                        if buffer: return False 
                        break 
                else: return False 
            elif code[i] == '<': 
                ii = i = i+1
                for i in range(i, len(code)): 
                    if code[i] == '>': break 
                else: return False 
                if ii == 1: prefix = True 
                tag = code[ii:i]
                if not (all(map(str.isupper, tag)) and 1 <= len(tag) <= 9): return False 
                stack.append(tag)
            i += 1
        return prefix and suffix and not stack",Hard,38,1534,0.0,8,4.0,19.0,40.36842105263158,94.0,-3.753157894736842
348.0,fraction addition and subtraction,"class Solution:
    def fractionAddition(self, expression: str) -> str:
        n, d = 0, 1
        nums = (int(x) for x in re.findall(""[+-]?\d+"", expression))
        for nn, dd in zip(*[iter(nums)]*2):
            n = n*dd + nn*d
            d *= dd
        g = gcd(n, d)
        return f""{n//g}/{d//g}""",Medium,8,305,0.0,1,3.0,2.0,38.125,16.0,4.728750000000001
349.0,valid square,"class Solution:
    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
    	D = [(i[0]-j[0])**2+(i[1]-j[1])**2 for i,j in itertools.combinations([p1,p2,p3,p4],2)]
    	return False if not D else [D.count(min(D)),D.count(max(D))] == [4,2]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,7,326,0.0,0,1.0,2.0,46.57142857142857,22.0,3.548571428571429
350.0,longest harmonious subsequence,"class Solution:
    def findLHS(self, nums: List[int]) -> int:
        
        c = Counter(nums)
        res = 0
        for x in set(nums):
            
            less, big = x - 1, x + 1
            if less in c or big in c:
                res = max(res, c[less] + c[x], c[big] + c[x])
        return res",Easy,10,310,0.0,2,3.0,2.0,31.0,15.0,5.41
351.0,range addition ii,"class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        if not ops:
            return m*n
        return min(op[0] for op in ops)*min(op[1] for op in ops)",Easy,4,192,0.0,0,2.0,3.0,48.0,10.0,4.56
352.0,minimum index sum of two lists,"class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
    	D = {j:i for i,j in enumerate(list2)}
    	L = sorted([[i+D[j],j] for i,j in enumerate(list1) if j in D])
    	return [r[1] for r in L if r[0] == L[0][0]]
		
		
- Python 3
- Junaid Mansuri",Easy,8,288,0.0,0,1.0,5.0,36.0,16.0,5.1000000000000005
353.0,non negative integers without consecutive ones,"class Solution:
    def findIntegers(self, n: int) -> int:
        # fn - count of numbers with size of n in bin representation which satisfy the rule
        # for example: fn[3] = 5 => *** = {'000', '001', '010', '100', '101'}
        # fn[2] = 3 => ** = {'00', '01', '10'}
        # fn[6] = {'10****', '0*****'} = fn[4] + fn[5]
        # fn[0] is trick for loop to append 1 to result if max_n has '1' in last bit
        fn = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269]
        # another words fn is count of numbers which satisfy the rule and less then 2^n for n >= 1
        
        nstr = bin(n)[2:]
        p = nstr.find('11')
        tmp = list(nstr)
        if p >= 0:
            for i in range(p + 1, len(tmp)):
                tmp[i] = '10'[(i - p) % 2]
        
        max_n = ''.join(tmp)
        # max_n - bin representation of max number that satisfy the rule
        # bin(n) = '10011010' -> max_n = '10010101'
        # bin(n) = '1100' -> max_n = '1010'
        
        # main idea:
        #  n = 154 = 10011010 -> max_n = 10010101 = 10000000 + 10000 + 100 + 1
        # 10000000 => {10000000} + {0*******} -> 1 + fn[7] = 35
        # 10000 => {10000} + {0****} - {00000} (just used in prev step) -> 1 + fn[4] - 1 = fn[4] = 8
        # 100 => {100} + {0**} - {000} -> fn[2] = 3
        # 1 or fn[0]
        # ans = 35 + 8 + 3 + 1 = 47
        
        ans = fn[len(max_n) - 1] + 1
        for i in range(2, len(max_n)):
            if max_n[i] == '1':
                ans += fn[len(max_n) - i - 1]
        
        return ans
	```",Hard,36,1677,16.0,5,3.0,8.0,46.583333333333336,101.0,-4.1325
354.0,can place flowers,"class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        l = None
        for i in range(len(flowerbed)):
            if n>len(flowerbed) or n==0:
                return n==0
            if not flowerbed[i] and not l and (i==len(flowerbed)-1  or (i<len(flowerbed)-1 and not flowerbed[i+1])):
                n-=1
                flowerbed[i] = 1
            l = flowerbed[i]
        return n==0",Easy,10,430,0.0,2,3.0,3.0,43.0,28.0,3.03
355.0,construct string from binary tree,"class Solution:
    def tree2str(self, root: TreeNode) -> str:
        def rec(node: TreeNode) -> str:
            out = str(node.val)
            
            if node.left:
                out += f""({rec(node.left)})""
            elif node.right:
                out += ""()""
                
            if node.right:
                out += f""({rec(node.right)})""
                
            return out
    
        return rec(root)",Easy,15,435,0.0,2,3.0,3.0,29.0,15.0,5.590000000000001
356.0,find duplicate file in system,"class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        mp = {} # mapping from content to file 
        for path in paths: 
            files = path.split()
            for i in range(1, len(files)): 
                f, c = files[i].split(""("")
                mp.setdefault(c[:-1], []).append(files[0] + ""/"" + f) 
        return [x for x in mp.values() if len(x) > 1]",Medium,8,401,1.0,2,3.0,4.0,50.125,15.0,3.7287500000000007
357.0,valid triangle number,"class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        count=0
        for i in range(len(nums)-2):
            k=i+2
            for j in range(i+1,len(nums)-1):
                if nums[i]==0: continue
                while k<len(nums) and nums[i] + nums[j] > nums[k]:
                    k+=1
                count+=k-j-1
        return count",Medium,11,387,0.0,3,3.0,4.0,35.18181818181818,19.0,4.573636363636364
358.0,merge two binary trees,"class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if root1 == root2 == None:
            return None
        
        if root1 and root2 == None:
            return root1
        
        if root2 and root1 == None:
            return root2

        if root1 and root2:
            root = TreeNode(root1.val + root2.val)
            root.left = self.mergeTrees(root1.left, root2.left)
            root.right = self.mergeTrees(root1.right, root2.right)
            return root",Easy,15,521,0.0,1,3.0,4.0,34.733333333333334,28.0,3.834000000000001
359.0,task scheduler,"class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = {} # frequency table 
        for x in tasks: freq[x] = 1 + freq.get(x, 0)
        mx = max(freq.values()) # highest frequency
        cnt = sum(v == mx for v in freq.values()) # occurrences of most frequent tasks
        return max(len(tasks), (mx-1)*(n+1) + cnt)",Medium,6,357,3.0,1,2.0,2.0,59.5,17.0,2.8850000000000007
360.0,add one row to tree,"class Solution:
    def addOneRow(self, root: Optional[TreeNode], v: int, d: int) -> Optional[TreeNode]:
        temp=root
        def hii(temp,d):
            
            if d==2 and temp:
                x=TreeNode(v)
                y=TreeNode(v)
                x.left=temp.left
                y.right=temp.right
                temp.left=x
                temp.right=y
                return root
            else:
                if temp:
                    hii(temp.left,d-1)
                    hii(temp.right,d-1)
            return root
        
        if d==1:
            x=TreeNode(v)
            x.left=root
            return x
        
        return hii(temp,d)",Medium,24,682,0.0,0,4.0,3.0,28.416666666666668,33.0,3.9025
361.0,maximum product of three numbers,"class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        
        nums.sort()
        return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])",Easy,4,179,0.0,0,2.0,0.0,44.75,6.0,5.2525
362.0,k inverse pairs array,"class Solution:
    def kInversePairs(self, n: int, k: int) -> int:
        curr = [0 for _ in range(k+1)]
        prev = [0 for _ in range(k+1)]
        for i in range(1,n+1):
            value = 0
            for j in range(k+1):
                if j == 0:
                    curr[j] = 1
                    value += prev[j]
                else:
                    if j >= i:
                        value-=prev[j-i]
                    value+=prev[j]
                    curr[j] = value
            curr,prev = prev,curr
        return prev[-1] % (10**9+7)",Hard,16,562,0.0,4,4.0,6.0,35.125,29.0,3.45875
363.0,course schedule iii,"class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        prefix = 0 
        pq = [] # max-heap 
        for x, y in sorted(courses, key=lambda x: x[1]): 
            prefix += x
            heappush(pq, -x)
            while prefix > y: prefix += heappop(pq)
        return len(pq)",Hard,8,312,1.0,2,3.0,2.0,39.0,17.0,4.53
364.0,smallest range covering elements from k lists,"class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        hi = -inf
        pq = []
        for i, num in enumerate(nums): 
            heappush(pq, (num[0], i, 0))
            hi = max(hi, num[0])
        
        ans = [-inf, inf]
        while pq: 
            ans = min(ans, [pq[0][0], hi], key=lambda x: (x[1]-x[0], x[0]))
            _, i, j = heappop(pq)
            if j+1 == len(nums[i]): break 
            hi = max(hi, nums[i][j+1])
            heappush(pq, (nums[i][j+1], i, j+1))
        return ans",Hard,15,542,0.0,2,3.0,3.0,36.13333333333333,36.0,2.848
365.0,sum of square numbers,"class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        # Fermat theorem on sum of two squares
        x = 2
        while x*x <= c: 
            if c % x == 0: 
                mult = 0
                while c % x == 0: 
                    mult += 1
                    c //= x
                if x % 4 == 3 and mult &amp; 1: return False 
            x += 1
        return c % 4 != 3",Medium,12,400,1.0,3,4.0,4.0,33.333333333333336,26.0,4.0200000000000005
366.0,exclusive time of functions,"class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        ans = [0] * n
        stk, start = [], None
        for log in logs:
            jid, kw, ts = log.split(':')
            jid, ts = int(jid), int(ts)
            if kw == 'start':
                if stk:
                    ans[stk[-1]] += (ts - start)
                stk.append(jid)
                start = ts
            else:
                ans[stk.pop()] += (ts - start + 1)
                start = ts + 1
        return ans",Medium,15,521,0.0,3,4.0,3.0,34.733333333333334,29.0,3.5540000000000003
367.0,average of levels in binary tree,"class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        lst=[root]
        flst=[]
        avg=[]
        sm,ct=0,0
        while lst:
            x=lst.pop(0)
            sm+=x.val
            ct+=1
            if x.left:
                flst.append(x.left)
            if x.right:
                flst.append(x.right)
            if lst==[]:
                lst=flst[:]
                flst=[]
                av=sm/ct
                avg.append(round(av,5))
                sm=0
                ct=0
        return avg",Easy,21,561,0.0,4,3.0,4.0,26.714285714285715,28.0,4.375714285714285
368.0,shopping offers,"class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        #Approach: At every decision making node, we have an option to choose one of 
        #many available sale special offers! Once we run out of offers to choose from,
        #we will simply have to buy the remaining items needed at regular price described
        #from price array!
        
        #To keep track of the special offer I used so far, I will utilize a boolean array
        #s.t. b_arr[i] = 1 if already used 0 else!
        num_specials = len(special)
        b_arr = [0 for _ in range(num_specials)]
        
        #i will also use nonlocal variable to keep track of amount spent so far!
        #i will periodically update this as I recurse and also when I backtrack!
        amount_spent = 0
        #n will store the original number of items I need to buy!
        n = sum(needs)
        ans = float(inf)
        #paramter:
        #1. rem. total elements to buy!
        #2. array describing number of rem. items by item type!
        def helper(remaining, a):
            nonlocal b_arr, num_specials, amount_spent, ans, special, price
            #base case: rem. items == 0! We reach this base case if we are able to buy
            #every item type according to our needs just from using special offers and not 
            #paying at regular price!
            if(remaining == 0):
                #update answer!
                ans = min(amount_spent, ans)
                return
            
            #if not base case, that means we still have items to buy!
            #consider iterating through each and every special offer! 
            #check that it's available!
            #if available, check that speical offer does not require buying items more than need!
            #If so, deduct amount of items by each item type and update remaining amount
            #and recurse on it!
            #When recursing, restore state of b_arr, amount_spent, as well as array a!
            special_valid = False
            for i in range(num_specials):
                #ith offer already used!
                if(b_arr[i] == 1):
                    continue
                #run a loop to check if ith offer amount to buy never exceeds the
                #current needs!
                is_valid = True
                for j in range(len(a)):
                    #check if ith special offer causes overbuying! If so, set is_valid flag off!
                    if(a[j] < special[i][j]):
                        is_valid = False
                        break
                #check if flag is not set!
                if(not is_valid):
                    continue
                special_valid = True
                #otherwise, if current ith special offer is valid for all item types,
                #go ahead and update remaining items, state of array a, as well as amount spent!
                amount_spent += special[i][-1]
                
                #set the boolean array on to indicate we used up ith offer!
                b_arr[i] = 1
                overall_remaining = remaining
                for b in range(len(a)):
                    a[b] -= special[i][b]
                    overall_remaining -= special[i][b]
                
                #go ahead and recurse!
                helper(overall_remaining, a)
                
                #once we return from rec. call, set the flag back off,
                #update amount spent, as well as state of array a when
                #backtracking to parent caller in recursion!
                b_arr[i] = 0
                #update amount spent!
                amount_spent -= special[i][-1]
                
                for c in range(len(a)):
                    a[c] += special[i][c]
            #check if even a single special offer can be used by using special_valid boolean flag!
            #If not, then we have to buy remaining items and update amount_paid so far! 
            if(not special_valid):
                new_amount_paid = amount_spent
                for d in range(len(a)):
                    if(a[d] > 0):
                        new_amount_paid += (a[d] * price[d])
                ans = min(ans, new_amount_paid)
                        
        
        helper(n, needs)
        #edge case: without using any special offer, buying at regular price might be the best
        #option!
        without = 0
        for z in range(len(price)):
            without += (price[z] * needs[z])
        return min(ans, without)",Medium,94,4582,40.0,1,4.0,26.0,48.74468085106383,91.0,-2.187021276595745
369.0,decode ways ii,"class Solution:
    def numDecodings(self, s: str) -> int:
        
        @cache 
        def fn(i): 
            """"""Return decode ways.""""""
            if i == len(s): return 1 
            if s[i] == ""0"": return 0 
            if i == len(s)-1: return 9 if s[i] == '*' else 1
            if s[i] == ""*"": 
                ans = 9*fn(i+1)
                if s[i+1] == ""*"": ans += 15*fn(i+2)
                else: 
                    ans += fn(i+2)
                    if s[i+1] <= ""6"": ans += fn(i+2)
            else: 
                ans = fn(i+1)
                if s[i+1] == ""*"": 
                    if s[i] == ""1"": ans += 9*fn(i+2)
                    elif s[i] == ""2"": ans += 6*fn(i+2)
                elif int(s[i:i+2]) <= 26: ans += fn(i+2)
            return ans % 1_000_000_007
        
        return fn(0)",Hard,23,820,0.0,5,4.0,11.0,35.65217391304348,58.0,0.4513043478260865
370.0,solve the equation,"class Solution:
    def solveEquation(self, equation: str) -> str:
        s = ''
        x, i = 0, 0
        rev = False
		
        for c in equation:
            if c in '+-':
				if s:
					i += int(s or 0) * (rev or -1)
                s = c
            elif c == 'x':
                x -= int(s+'1' if s in '+-' else s) * (rev or -1)
                s = ''
            elif c == '=':
			    if s:
					i -= int(s or 0)
					s = ''
                rev = True
            else:
                s += c
        else:
		    if s:
				i += int(s or 0) * (rev or -1)
            return f'x={i//x}' if x else 'No solution' if i else 'Infinite solutions'",Medium,24,650,0.0,7,2.0,10.0,27.08333333333333,36.0,3.4225000000000003
371.0,maximum average subarray i,"class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        sums, ans = 0, float(""-inf"")
        i = 0
        for j in range(len(nums)):
            sums += nums[j]
            if j-i+1 == k:
                ans = max(ans, sums)
                sums -= nums[i]
                i = i+1
        return ans / k",Easy,10,336,0.0,2,3.0,2.0,33.6,21.0,4.576
372.0,set mismatch,"class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        a = Counter(nums)
        Fsm = sum(nums)
        Csm = (len(nums) * (len(nums)+1))//2
        tp = a.most_common(1)
        return [tp[0][0], Csm - (Fsm - tp[0][0])]",Easy,6,249,0.0,0,2.0,0.0,41.5,10.0,5.1450000000000005
373.0,maximum length of pair chain,"class Solution:
def findLongestChain(self, pairs: List[List[int]]) -> int:
    n=len(pairs)
    dp=[1]*n
    pairs=sorted(pairs,key=lambda k:k[0])
    for i in range(1,n):
        for j in range(0,i):
            if pairs[i][0]>pairs[j][1] and dp[i]<dp[j]+1:
                dp[i]=dp[j]+1
    return max(dp)",Medium,9,307,0.0,3,2.0,3.0,34.111111111111114,19.0,4.73
374.0,palindromic substrings,"class Solution:
    def countSubstrings(self, s: str) -> int:
        count = 0
   
        for l in range(len(s)):
            count += Solution.check(l,l,s)
            count += Solution.check(l,l+1,s)
            
        return count
    
    @staticmethod
    def check(l, r, s):
        count = 0
        while(l>=0 and r<len(s)):
            if s[l] == s[r]:
                count +=1
            else:
                break
            l-=1
            r+=1
        return count",Medium,20,486,0.0,0,3.0,3.0,24.3,29.0,4.7330000000000005
375.0,replace words,"class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        s = sentence.split()
        dictionary.sort(key=lambda x:len(x))
        for i,j in enumerate(s):
            for v in dictionary:
                if j.startswith(v):
                    s[i] = v
                    break
        return ' '.join(s)",Medium,9,346,0.0,2,3.0,3.0,38.44444444444444,15.0,4.740000000000001
376.0,dota2 senate,"class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        d, r = senate.count(""D""), senate.count(""R"")
        killedR, killedD = 0, 0
        deleted = set()
        while d and r:
            for idx,letter in enumerate(senate):
                if idx in deleted: continue
                if letter == ""R"" and killedR == 0:
                    killedD += 1
                    d -= 1
                elif letter == ""D"" and killedD == 0:
                    killedR += 1
                    r -= 1
                elif letter == ""R"" and killedR > 0:
                    deleted.add(idx)
                    killedR -= 1
                else:
                    deleted.add(idx)
                    killedD -= 1
        return ""Dire"" if d else ""Radiant""",Medium,20,774,0.0,5,4.0,7.0,38.7,42.0,1.7769999999999992
377.0,2 keys keyboard,"class Solution:
    def minSteps(self, n: int) -> int:
        ans=0
        for d in range(2,n+1):
            while n%d==0:
                ans+=d
                n/=d
            if n<d:
                break
        return ans",Medium,9,230,0.0,2,3.0,3.0,25.55555555555556,16.0,5.8
378.0,find duplicate subtrees,"class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        
        def fn(node): 
            """"""Return serialized sub-tree rooted at node.""""""
            if not node: return "" ""
            left, right = fn(node.left), fn(node.right)
            srl = "","".join((str(node.val), left, right))
            if seen.get(srl, 0) == 1: ans.append(node)
            seen[srl] = 1 + seen.get(srl, 0)
            return srl
        
        ans, seen = [], {}
        fn(root)
        return ans",Medium,14,523,0.0,-1,3.0,2.0,37.35714285714285,24.0,4.117857142857143
379.0,two sum iv input is a bst,"class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
		#Generates node values depth-first from right-to-left
        def dftRtoL(root):
            if root.right: yield from dftRtoL(root.right)
            yield root.val
            if root.left: yield from dftRtoL(root.left)
        
		#Generates node values depth-first from left-to-right
        def dftLtoR(root):
            if root.left: yield from dftLtoR(root.left)
            yield root.val
            if root.right: yield from dftLtoR(root.right)
        
        pl, pr = dftLtoR(root), dftRtoL(root)
        l, r = next(pl), next(pr)
        
		#If the node values are equal then all nodes have been checked and there is no solution
        while l != r:
			#l+r is too small, decrease l
            if l + r < k:
                l = next(pl)
			#l+r is too big, increase r
            elif l + r > k:
                r = next(pr)
			#l+r == k, the solution is found
            else: return True
        return False",Easy,27,1013,6.0,6,2.0,8.0,37.51851851851852,34.0,2.9833333333333325
380.0,maximum binary tree,"class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if nums == []:
            return None
        else:
            node = TreeNode(max(nums))
        node.left = self.constructMaximumBinaryTree(nums[:nums.index(max(nums))])
        node.right = self.constructMaximumBinaryTree(nums[nums.index(max(nums))+1:])
        return node",Medium,8,373,0.0,0,3.0,1.0,46.625,15.0,4.12375
381.0,print binary tree,"class Solution:
    def printTree(self, root: TreeNode) -> List[List[str]]:
        ht = lambda node: 1 + max(ht(node.left), ht(node.right)) if node else 0 # height of binary tree 
        m = ht(root) # rows 
        n = 2**m - 1 # columns 
        
        def dfs(node, i, lo=0, hi=n): 
            """"""Populate ans via dfs.""""""
            if not node: return 
            mid = lo + hi >> 1
            ans[i][mid] = str(node.val)
            dfs(node.left, i+1, lo, mid) or dfs(node.right, i+1, mid+1, hi)

        ans = [[""""]*n for _ in range(m)]
        dfs(root, 0)
        return ans",Medium,15,591,3.0,0,3.0,3.0,39.4,29.0,3.4940000000000007
382.0,robot return to origin,"class Solution:
    def judgeCircle(self, moves: str) -> bool:
        x,y=0,0
        for i in range(len(moves)):
            if (moves[i] == 'L'):
                x += 1;
            if (moves[i] == 'R'):
                x -= 1;
            if (moves[i] == 'U'):
                y += 1;
            if (moves[i] == 'D'):
                y -= 1;
        return x==0 and y==0",Easy,12,375,0.0,5,3.0,5.0,31.25,35.0,3.2075000000000005
383.0,find k closest elements,"class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        li=[]
        ans=[]
        for i in range(len(arr)):
            diff=abs(arr[i]-x)
            heapq.heappush(li,[diff,arr[i]])
        for i in range(k):
            diff,val=heapq.heappop(li)
            ans.append(val)
        ans.sort()
        return ans",Medium,11,366,0.0,2,3.0,5.0,33.27272727272727,18.0,4.905454545454545
384.0,split array into consecutive subsequences,"class Solution:
    def isPossible(self, nums: List[int]) -> bool:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0) # frequency table of nums
        
        seen = deque()
        for i, x in enumerate(nums):
            if i == 0 or nums[i-1] != x: 
                if (n := freq[x] - freq.get(x-1, 0)) > 0: seen.extend([x]*n)
                elif any(x - seen.popleft() < 3 for _ in range(-n)): return False 
                if not freq.get(x+1, 0) and any(x - seen.popleft() < 2 for _ in range(freq[x])): return False 
        return True",Medium,11,564,1.0,4,3.0,8.0,51.27272727272727,27.0,2.3054545454545456
385.0,image smoother,"class Solution:
    def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:
        m, n = len(M), len(M[0])
        # Calculate sums in the same row.
        for i in range(m):
            tmp = M[i][0]
            for j in range(1, n):
                value = M[i][j]
                M[i][j - 1] += value
                M[i][j] += tmp
                tmp = value

        # Calculate the sums by columns.
        for j in range(n):
            tmp = M[0][j]
            for i in range(1, m):
                value = M[i][j]
                M[i - 1][j] += value
                M[i][j] += tmp
                tmp = value
        
        # Calulate the number of cells.
        for i in range(m):
            x = 3 - (1 if i == 0 else 0) - (1 if i == m - 1 else 0)
            for j in range(n):
                y = 3 - (1 if j == 0 else 0) - (1 if j == n - 1 else 0)
                M[i][j] //= x * y
        return M",Easy,27,928,3.0,6,3.0,10.0,34.370370370370374,41.0,2.386666666666666
386.0,maximum width of binary tree,"class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        L=[[root]]
        V=[[0]]
        while L[-1]:
            R=[]
            S=[]
            for i in range(len(L[-1])):
                if L[-1][i].left:
                    S.append(2*V[-1][i])
                    R.append(L[-1][i].left)
                if L[-1][i].right:
                    S.append(2*V[-1][i]+1)
                    R.append(L[-1][i].right)
            V.append(S)
            L.append(R)
        v=[S[-1]-S[0]+1 for S in V if S]
        return max(v)",Medium,19,596,0.0,4,4.0,7.0,31.36842105263158,15.0,5.1968421052631575
387.0,strange printer,"class Solution:
    def strangePrinter(self, s: str) -> int:
        s = """".join(ch for i, ch in enumerate(s) if i == 0 or s[i-1] != ch)
        
        @cache
        def fn(lo, hi): 
            """"""Return min ops to print s[lo:hi].""""""
            if lo == hi: return 0
            ans = 1 + fn(lo+1, hi)
            for mid in range(lo+1, hi): 
                if s[lo] == s[mid]: 
                    ans = min(ans, fn(lo, mid) + fn(mid+1, hi))
            return ans 
        
        return fn(0, len(s))",Hard,14,510,0.0,0,3.0,5.0,36.42857142857143,31.0,3.441428571428572
388.0,non decreasing array,"class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        changes = 0
        for i, j in zip(range(0, len(nums) - 1), range(1, len(nums))):
            if nums[j] < nums[i]:
                lchanges, rchanges = 0, 0
                for x in reversed(range(0, j)):
                    if nums[x] > nums[j]:
                        lchanges += 1
                        if lchanges == 2:
                            break;
                    else:
                        break
                for y in range(j, len(nums)):
                    if nums[y] < nums[i]:
                        rchanges += 1
                        if rchanges == 2:
                            break
                    else:
                        break
                changes += min(lchanges, rchanges)
                if changes >= 2:
                    return False
        return True",Medium,23,895,0.0,4,5.0,9.0,38.91304347826087,41.0,1.8578260869565213
389.0,beautiful arrangement ii,"class Solution:
    def constructArray(self, n: int, k: int) -> List[int]:
        t=[i for i in range(1,n+1)]
        for j in range(1,k):
            t[j:]=t[j:][::-1]
        return t",Medium,5,186,0.0,1,2.0,2.0,37.2,16.0,4.872
390.0,kth smallest number in multiplication table,"class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
        pq = [(1, 1, 1)]    # Priority queue (table[i][j], i, j)
        seen = set((1,1))   # Visited nodes
        
        # Traverse the first k-1 nodes
        for i in range(1, k):
            # Pop ith smallest node
            cur, a, b = heappop(pq)
            
            # Add right node if it hasn't been seen to pq
            if a < m and (a+1, b) not in seen: 
                heappush(pq, (cur+b, a+1, b))
                seen.add((a+1, b))
            
            # Add left node if it hasn't been seen to pq
            if b < n and (a, b+1) not in seen: 
                heappush(pq, (cur+a, a, b+1))
                seen.add((a, b+1))
        
        # Next node in priority queue is the kth smallest node
        return heappop(pq)[0]",Hard,21,835,7.0,3,3.0,5.0,39.76190476190476,35.0,2.8414285714285725
391.0,trim a binary search tree,"class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
        # iterative
        if root is None: return None
        
        while root and (root.val < L or root.val > R):
            if root.val < L: root = root.right
            else: root = root.left
        
        lnode = rnode = root
        while lnode.left:
            if lnode.left.val < L:
                lnode.left = lnode.left.right
            else: lnode = lnode.left
        while rnode.right:
            if rnode.right.val > R:
                rnode.right = rnode.right.left
            else: rnode = rnode.right
        return root",Medium,18,635,1.0,6,3.0,7.0,35.27777777777778,32.0,3.125
392.0,maximum swap,"class Solution:
    def maximumSwap(self, num: int) -> int:
        num = str(num)
        
        for i in range(len(num)):
            max_number = max([k for k in num[i:]])
            index = max([k for k in range(i, len(num)) if num[k]==max_number])
            
            if int(num[i])<int(max_number):
			    # String does not support item assignment, so using slicing for swapping the elements.
                num = num[:i] + num[index] + num[i+1:index] + num[i] + num[index+1:]
                break
                
        return int(num)",Medium,13,554,1.0,2,3.0,6.0,42.61538461538461,21.0,3.804615384615385
393.0,second minimum node in a binary tree,"class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        if not root.left:
            return -1

        if not root:
            return -1
        left=self.findSecondMinimumValue(root.left)
        right = self.findSecondMinimumValue(root.right)
        if root.right.val>root.val:
            if left==-1:
                return root.right.val
            else:
                return min(left,root.right.val)
        elif root.left.val>root.val:
            if right==-1:
                return root.left.val
            else:
                return min(right,root.left.val)
        else:
            if left==-1:
                return right
            if right==-1:
                return left
            return min(left, right)",Easy,24,765,0.0,0,3.0,8.0,31.875,35.0,3.45125
394.0,bulb switcher ii,"class Solution:
    # Operations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)
    states = {
        'N': 0b000,
        'A': 0b111,
        'O': 0b101,
        'E': 0b010,
        'T': 0b001,
        'AT': 0b111 ^ 0b001,
        'OT': 0b101 ^ 0b001,
        'ET': 0b010 ^ 0b001,
    }
    steps = {
        0: ['N'],
        1: ['A', 'O', 'E', 'T'],
        2: ['N', 'A', 'O', 'E', 'AT', 'OT', 'ET'],
        3: states.keys(),
    }
    def flipLights(self, n: int, m: int) -> int:
        n, m = min(n, 3), min(m, 3)
        mask = (1 << n) - 1
        ans = set()
        for s in self.steps[m]:
            ans.add((0b111 ^ self.states[s]) &amp; mask)
        return len(ans)",Medium,24,709,1.0,1,2.0,1.0,29.541666666666668,57.0,1.5012499999999989
395.0,number of longest increasing subsequence,"class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        lis = [[1, 1] for _ in nums] # longest increasing subsequence (length &amp; count)
        for i, x in enumerate(nums): 
            for ii in range(i): 
                if nums[ii] < x: 
                    if lis[ii][0] + 1 > lis[i][0]: lis[i] = [1 + lis[ii][0], lis[ii][1]]
                    elif lis[ii][0] + 1 == lis[i][0]: lis[i][1] += lis[ii][1]
        mx, _ = max(lis, default=(0, 0))
        return sum(y for x, y in lis if x == mx)",Medium,9,523,1.0,5,3.0,8.0,58.11111111111112,30.0,1.3299999999999983
396.0,longest continuous increasing subsequence,"class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        curlen = 0
        maxlen = 0
        if not nums:
            return 0
        for i in nums:
            if nums[i] < nums[i+1]:
                curlen +=1
                maxlen = curlen
        return maxlen",Easy,10,291,0.0,2,3.0,3.0,29.1,13.0,5.781
397.0,cut off trees for golf event,"class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        a = []
        n = len(forest)
        m = len(forest[0])
        for i in range(n):
            for j in range(m):
                if forest[i][j] > 1:
                    a.append(forest[i][j])
        a.sort()
        
        s = 0
        ux = 0
        uy = 0
        for h in a:
            if forest[ux][uy] == h:
                continue        
            dist = [[None] * m for i in range(n)]
            q = deque()
            q.append((ux, uy))
            dist[ux][uy] = 0
            found = False
            while q and not found:
                ux, uy = q.popleft()
                d = [(-1, 0), (0, 1), (1, 0), (0, -1)]
                for dx, dy in d:
                    vx = ux + dx
                    vy = uy + dy
                    if vx < 0 or vx >= n or vy < 0 or vy >= m:
                        continue
                    if forest[vx][vy] == 0:
                        continue
                    if dist[vx][vy] is None:
                        dist[vx][vy] = dist[ux][uy] + 1
						# It's important to stop here! Otherwise there will be TLE
                        if forest[vx][vy] == h:
                            s += dist[vx][vy]
                            ux = vx
                            uy = vy
                            found = True
                            break
                        q.append((vx, vy))
            if not found:
                return -1
        return s",Hard,44,1514,1.0,7,4.0,21.0,34.40909090909091,63.0,-0.0168181818181842
398.0,valid parenthesis string,"class Solution:
    def valid(self, s, stack=[]):
        i, l = 0, len(s)
        if not l:
            return True
        
        while i<l:
            c = s[i]
            if c == '(':
                stack.append(c)
                
            elif c == ')':
                if stack and stack[-1] == '(':
                    stack.pop()
                else:
                    return False
                
            else:
                sub = s[i+1:]
                return (self.valid('('+sub, stack[:])
                       or self.valid(')'+sub, stack[:])
                       or self.valid(sub, stack[:]))
            
            i += 1
            
        return True if len(stack)==0 else False
    
    
    def checkValidString(self, s: str) -> bool:
        return self.valid(s)",Medium,29,808,0.0,1,4.0,6.0,27.86206896551724,42.0,2.992413793103448
399.0,valid palindrome ii,"class Solution:
    def validPalindrome(self, s: str) -> bool:
        n=len(s)
        left,right=0,n-1
        cnt=0
        while left<=right:
            if s[left]==s[right]:
                left+=1
                right-=1
            else:
                if cnt==1:
                    return False
                else:
                    if self.check(s,left+1,right):
                        left+=1
                    elif self.check(s,left,right-1):
                        right-=1
                    else:
                        return False
                    cnt+=1
        return True
    def check(self,s,left,right):
        if s[left:right+1]==s[left:right+1][::-1]:
            return True
        return False",Easy,24,737,0.0,2,4.0,6.0,30.70833333333333,47.0,2.17625
400.0,baseball game,"class Solution:
    def calPoints(self, ops: List[str]) -> int:
        res = []
        for i in ops:
            if i == 'C':
                res.pop()
            elif i == 'D':
                x = res[len(res)-1]
                res.append(2*x)
            elif i == '+':
                x = res[len(res) - 1]
                y = res[len(res) - 2]
                res.append(x+y)
            else:
                res.append(int(i))
            
            
        return sum(res)",Easy,17,486,0.0,4,4.0,4.0,28.58823529411765,23.0,4.647058823529411
401.0,redundant connection,"class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        dict={}
        n=len(edges)
        for i in range(1,n+1):
            dict[i]=i
            
        def find_parent(u):
            if dict[u]==u:
                
                return u
            else:
                a=find_parent(dict[u])
                
                dict[u]=a
                return a
            
        for i,j in edges:
            u=find_parent(i)
            v=find_parent(j)
            
            if u==v:
                return [i,j]
            else:
                dict[v]=u",Medium,24,620,0.0,2,4.0,4.0,25.83333333333333,29.0,4.415
403.0,longest univalue path,"class Solution:
    def longestUnivaluePathUtil(self, root: TreeNode, maxCounter) -> int:
        counter = 0
        counterChoose = [0]
        if root!=None:
            if root.left!=None:
                temp = self.longestUnivaluePathUtil(root.left, maxCounter) + 1
                if root.val==root.left.val:
                    counterChoose.append(temp)
                    counter+= temp
            if root.right!=None:
                temp = self.longestUnivaluePathUtil(root.right, maxCounter) + 1
                if root.val==root.right.val:
                    counter+= temp
                    counterChoose.append(temp)
        maxCounter[0] = max(maxCounter[0], counter)
        return max(counterChoose)
    def longestUnivaluePath(self, root: TreeNode) -> int:
        maxCounter = [0]
        self.longestUnivaluePathUtil(root, maxCounter)
        return maxCounter[0]",Medium,20,890,0.0,4,3.0,5.0,44.5,36.0,1.975
404.0,knight probability in chessboard,"class Solution:
    def __init__(self):
        self.possibleMoves = [(-2,1),(-1,2),(1,2),(2,1),(2,-1),(1,-2),(-1,-2),(-2,-1)]
        self.mem = dict()
        
    def isInside(self, r, c, N):
        if r < 0 or c < 0 or r >= N or c >= N:
            return False
        return True
    
    def Util(self, N, K, r, c):
        if K == 0:
            return 1
        if (K, r, c) in self.mem:
            return self.mem[(K, r, c)]
        total = 0
        for i, j in self.possibleMoves:
            if self.isInside(r + i, c + j, N):
                corMoves = self.Util(N, K - 1, r + i, c + j)
                total += corMoves
        self.mem[(K, r, c)] = total
        return total
    
    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:
        totalPossible = self.Util(N, K, r, c)
        return totalPossible / 8 ** K",Medium,25,856,0.0,0,3.0,5.0,34.24,72.0,-0.4616000000000007
405.0,maximum sum of 3 non overlapping subarrays,"class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        curr = sum(nums[:k])
        # groups of sum-k 
        g = [0]*n
        for i in range(n-k+1):
            g[i] = curr
            if i+k < n:
                curr += nums[i+k] - nums[i]
        # pre[i]: the previous group index with maximum sum when i is the center group
        pre = [0]*n
        for i in range(k+1, n-2*k+1):
            pre[i] = pre[i-1] if g[pre[i-1]] >= g[i-k] else i-k
        # after[i]: the next group index with maximum sum when i is the center group
        after = [n-k]*n
        for i in range(n-2*k, k-1, -1):
            after[i] = after[i+1] if g[after[i+1]] > g[i+k] else i+k
        
        # Final iteration: find the maximum total sum with their group index 
        ans = []
        S = 0
        for i in range(k, n-2*k+1):
            curr = g[pre[i]] + g[i] + g[after[i]]
            if curr > S:
                S = curr
                ans = [pre[i], i, after[i]]
        return ans",Hard,27,1054,4.0,6,3.0,8.0,39.03703703703704,42.0,1.906666666666668
406.0,employee importance,"class Solution(object):
    def getImportance(self, employees, id):
        """"""
        :type employees: Employee
        :type id: int
        :rtype: int
        """"""
        d = dict()
        for node in employees:
            d[node.id] = node
            
        def Importance(node):
            if len(node.subordinates)==0:
                return node.importance
            else:
                S = node.importance
                for _id in node.subordinates:
                    S += Importance(d[_id])
                return S
                
        return Importance(d[id])",Medium,20,590,0.0,1,3.0,3.0,29.5,22.0,4.905
407.0,stickers to spell word,"class Solution:
    def minStickers(self, stickers: List[str], target: str) -> int:

        stickers = [Counter(s) for s in stickers if set(s)&amp;set(target)]
        dp = {}
        def generate(target):
            if not target: return 0
            if target in dp: return dp[target]
            
            target_counter = Counter(target)
            res = float(""inf"")
            for sticker in stickers:
                if sticker[target[0]] == 0: continue
                tmp = 1 + generate("""".join([letter*count for letter,count in (target_counter-sticker).items()]))

                res = min(res,tmp)
            dp[target] = res
            return res

        res = generate(target)
        return -1 if res == float(""inf"") else res",Hard,20,751,0.0,0,3.0,8.0,37.55,28.0,3.6405
408.0,top k frequent words,"class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        """"""
        Firstly, we use a Counter to count the frequency of each word within
        words, assigning the outcome as count. Then, for each key, value pair
        in count, a tuple of (value, key) is created, which is subsequently 
        sorted using a lambda of -x[0] (the frequency, sorted high to low), and 
        the lexographical order within the frequency. Finally, the k largest
        values of words are returned.
        
        :param words: the words to be considered. (List[str])
        :param k: the number of words to be considered. (int)
        :return outcome_list: the list containing the outcome. (List[str])
        """"""
        words = ((value, key) for key, value in Counter(words).items())
        words = sorted(words, key=lambda x: (-x[0], x[1]))
        return [value for key, value in words[:k]]",Medium,16,924,0.0,0,2.0,3.0,57.75,33.0,1.3825000000000005
409.0,binary number with alternating bits,"class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while True:
            previous_bit = n &amp; 1
            n >>= 1
            if not n:
                return True
            
            current_bit = n &amp; 1
            if previous_bit == current_bit:
                return False
            previous_bit = current_bit",Easy,11,353,0.0,2,3.0,3.0,32.09090909090909,17.0,5.111818181818182
410.0,max area of island,"class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        def dfs(i,j):
            if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]==0:
                return 0
            grid[i][j]=0
            down = dfs(i+1,j)
            up = dfs(i-1,j)
            right = dfs(i,j+1)
            left = dfs(i,j-1)
            a = 1+(up+down+right+left)
            return a
        ans = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                ans = max(ans,dfs(row,col))
        return ans",Medium,16,566,0.0,1,3.0,3.0,35.375,33.0,3.27625
411.0,count binary substrings,"class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        group_lens = [len(list(g)) for _, g in groupby(s)]
        return sum(min(a, b) for a, b in zip(group_lens, group_lens[1:]))",Easy,3,200,0.0,1,2.0,2.0,66.66666666666667,11.0,2.7200000000000006
412.0,degree of an array,"class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        d = {}
        m, j, count = 1, [nums[0]], []
        for i in nums:
            if i not in d:
                d[i] = 1
            else:
                d[i] += 1
                if d[i] > m:
                    m = d[i]
                    j = [i]
                elif d[i] == m:
                    j.append(i)
        for i in j:
            count.append(len(nums) - nums[::-1].index(i) - nums.index(i))
        return min(count)",Easy,16,518,0.0,5,4.0,5.0,32.375,27.0,3.84625
413.0,partition to k equal sum subsets,"class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        total = sum(nums)
        if total % k: return False 
        
        avg = total // k
        
        @cache
        def fn(x, mask):
            """"""Return True if available elements can be parititioned.""""""
            if x > avg: return False 
            if x == avg: return fn(0, mask)
            if not mask: return True 
            for i in range(len(nums)): 
                if mask &amp; 1<<i and fn(x + nums[i], mask ^ 1<<i): return True 
            return False 
        
        nums.sort(reverse=True)
        return fn(0, (1 << len(nums))-1)",Medium,18,652,0.0,-1,3.0,7.0,36.22222222222222,31.0,3.5200000000000005
414.0,falling squares,"class Solution:
    def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        ans = []
        for i, (x, l) in enumerate(positions): 
            val = 0
            for ii in range(i): 
                xx, ll = positions[ii]
                if xx < x+l and x < xx+ll: val = max(val, ans[ii])
            ans.append(val + l)
        for i in range(1, len(ans)): ans[i] = max(ans[i-1], ans[i])
        return ans",Hard,10,429,0.0,4,3.0,4.0,42.9,22.0,3.519
415.0,search in a binary search tree,"class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if root.val == val:
            return root
        
        return self.searchBST(root.left, val) or self.searchBST(root.right, val)",Easy,8,294,0.0,0,3.0,2.0,36.75,14.0,5.112500000000001
416.0,insert into a binary search tree,"class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        s = 'right' if val > root.val else 'left'
        if getattr(root, s) is None:
            setattr(root, s, TreeNode(val))
        else:
            self.insertIntoBST(getattr(root, s), val)
        return root",Medium,7,301,0.0,1,3.0,2.0,43.0,16.0,4.290000000000001
417.0,binary search,"class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low = 0
        high = len(nums)-1
        loc = -1
        while (low <= high):
            mid = (high+low)//2
            if nums[mid] == target:
                return mid
            if nums[mid] > target:
                high = mid-1
            elif nums[mid] < target:
                low = mid+1
        return loc",Easy,13,406,0.0,3,3.0,4.0,31.23076923076923,24.0,4.42923076923077
418.0,design hashset,"# Array List Solution

class MyHashSet:

    def __init__(self):
        self.buckets = []

    def add(self, key: int) -> None:
        count = 0
        for x in self.buckets:
            if key in x:
                x += [key]
                count += 1
        if count == 0:
            self.buckets += [[key]]

    def remove(self, key: int) -> None:
        for x in self.buckets:
            while key in x:
                x.remove(key)

    def contains(self, key: int) -> bool:
        for x in self.buckets:
            if key in x:
                return True
        return False",Easy,25,593,1.0,6,2.0,7.0,23.72,29.0,4.525199999999999
419.0,to lower case,"class Solution:
    def toLowerCase(self, s: str) -> str:
        output = ''
        for char in s:
            ascii_index = ord(char)
            if 65 <= ascii_index <= 90:
                output += chr(ascii_index+32)
            else:
                output += char
        return output",Easy,9,293,0.0,2,3.0,2.0,32.55555555555556,16.0,5.17
420.0,random pick with blacklist,"class Solution:

    def __init__(self, n: int, blacklist: List[int]):
        # The size of whitelist
        self.white_len = n - len(blacklist)
        # Last index of the array
        self.last_idx = n - 1
        # Mapping dictionary
        self.mapping = {}
        # Set the index of blacklist element all to -1
        for i in blacklist:
            self.mapping[i] = -1
        
        for i in blacklist:
            # skip blacklist
            if i >= self.white_len:
                continue
            while self.last_idx in blacklist:
                self.last_idx -= 1
            self.mapping[i] = self.last_idx
            self.last_idx -= 1

    def pick(self) -> int:
        idx = randint(0,self.white_len-1)
        if idx in self.mapping:
            return self.mapping[idx]
        return idx",Hard,26,822,5.0,3,3.0,5.0,31.615384615384617,24.0,4.594615384615385
421.0,minimum ascii delete sum for two strings,"class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        @lru_cache(None)
        def getASCII(char):
            return ord(char)
        
        if len(s1) < len(s2):
            s1, s2 = s2, s1
            
        m, n = len(s1), len(s2)
        
        dp = [0]*(n+1)
        
        for i in range(1, n+1):
            dp[i] += dp[i-1] + getASCII(s2[i-1])
            
        for i in range(1, m+1):
            new_dp = [0]*(n+1) 
            new_dp[0] = dp[0] + getASCII(s1[i-1])
            
            for j in range(1, n+1):
                if s1[i-1] == s2[j-1]:
                    new_dp[j] = dp[j-1]
                else:
                    new_dp[j] = min(getASCII(s1[i-1])+dp[j], getASCII(s2[j-1])+new_dp[j-1])
            
            dp = new_dp
        
        return dp[-1]",Medium,28,825,0.0,4,3.0,5.0,29.464285714285715,35.0,3.4282142857142857
422.0,subarray product less than k,"class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
       
        # Init
        n = len(nums)
        m = 0 # no. of subarrays
       
        # Base Case
        if k == 0:
            return 0
        
        # Base Case
        if sum(nums) == n:
            return (n)*(n+1)//2 if k > 1 else 0 
        
        # For each element
        for i,num_i in enumerate(nums):
            
            # Calc curr product
            curr_prod = num_i
            
            # Check if is less then k, else continue
            if curr_prod < k:
                m += 1
            else:
                continue
            
            # For each j from i+1 to n-1
            for num_j in nums[i+1:]:
                
                # calc current product
                curr_prod = curr_prod * num_j
                
                # Check if is less then k, else break
                if curr_prod < k:
                    m += 1
                else:
                    break
                    
        return m",Medium,39,1065,10.0,0,3.0,11.0,27.307692307692307,34.0,4.362307692307693
423.0,best time to buy and sell stock with transaction fee,"class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        self.dp=[[-1 for i in range(2)] for i in range(50001)]
        return self.dfs(0,0,prices,fee)
    def dfs(self,day,own,prices,fee):
        if day==len(prices):
            return 0
        if self.dp[day][own]!=-1:
            return self.dp[day][own]
        if own:
            p1=prices[day]-fee+self.dfs(day+1,not own,prices,fee)
            p2=self.dfs(day+1,own,prices,fee)
            self.dp[day][own]=max(p1,p2)
        else:
            p1=-(prices[day])+self.dfs(day+1,not own,prices,fee) #here we are sending(not own) bcoz own is 0
            p2=self.dfs(day+1,own,prices,fee)# here we are sending(own) bcoz own is 0
            self.dp[day][own]=max(p1,p2)
        return self.dp[day][own]",Medium,17,790,2.0,0,3.0,5.0,46.47058823529412,44.0,1.31764705882353
424.0,1 bit and 2 bit characters,"class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i = 0
        while i in range(len(bits)):
            if i == len(bits)-1:
                return True
            if bits[i] == 0:
                i += 1
            else:
                i += 2
        return False",Easy,10,299,0.0,2,3.0,3.0,29.9,18.0,5.2090000000000005
425.0,maximum length of repeated subarray,"class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        def helper(l):
            base = 1 << 7
            M = 10 **9 + 7
            a = pow(base, l, M)
            t1, t2 = 0, 0
            hashes = set()
            for i in range(len(nums1)):
                t1 = (base * t1 + nums1[i]) % M
                if i >= l:
                    t1 -= a * nums1[i - l]
                    t1 %= M
                if i >= l - 1:
                    hashes.add(t1)
                    
            for j in range(len(nums2)):
                t2 = (base * t2 + nums2[j]) % M
                if j >= l:
                    t2 -= a * nums2[j - l]
                    t2 %= M
                if j >= l - 1:
                    if t2 in hashes: return True
            return False
        
        a, b = 0, min(len(nums1), len(nums2))
        while a < b:
            m = (a + b + 1) // 2
            if helper(m):
                a = m
            else:
                b = m - 1
        return a",Medium,32,1027,0.0,7,4.0,9.0,32.09375,51.0,1.3515625
426.0,find k th smallest pair distance,"class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        nums.sort()
        N = len(nums)

        def less(v):
            """"""number of distances < v""""""
            cnt, left = 0, 0
            for right in range(1, N):
                while left < right and nums[right] - nums[left] >= v:
                    left += 1
                cnt += right - left
            return cnt

        lo, hi = 0, max(nums) - min(nums)
        while lo <= hi:
            v = (lo+hi) // 2
            cnt = less(v)
            if cnt < k:
                lo = v + 1
            else:
                hi = v - 1
        return hi",Hard,22,651,0.0,3,3.0,4.0,29.59090909090909,34.0,3.576818181818182
427.0,longest word in dictionary,"class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort(reverse=True)
        words.sort(key=lambda x : len(x))
        i = len(words)-1
        while i > -1:
            flag = True
            for j in range(1,len(words[i])):
                if words[i][:j] not in words:
                    flag = False
            if flag:
                return words[i]
            i -= 1
        return ''",Medium,13,427,0.0,3,3.0,4.0,32.84615384615385,19.0,4.783846153846154
428.0,accounts merge,"class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        email_to_ids = collections.defaultdict(list)
        visited_accounts = [False]*len(accounts)
        for i, acct in enumerate(accounts):
            for email in acct[1:]:            
                email_to_ids[email].append(i)
        
        res = []
        for id, acct in enumerate(accounts):
            if visited_accounts[id]: 
                continue
            visited_accounts[id] = True
            merged_emails = set()
            stack = acct[1:]
            while stack:
                email = stack.pop()
                merged_emails.add(email)
                for id in email_to_ids[email]:
                    if not visited_accounts[id]: 
                        stack.extend([new_email for new_email in accounts[id][1:] if new_email != email])            
                        visited_accounts[id] = True
            res.append([acct[0]] + sorted(merged_emails))
        return res",Medium,23,1012,0.0,7,4.0,9.0,44.0,26.0,2.78
429.0,remove comments,"class Solution:

    pat1 = re.compile(r""//[^~]*~"")
    pat2 = re.compile(r""/\*.*?\*/"")

    def removeComments(self, source: List[str]) -> List[str]:
        one_line = ""~"".join(source) + ""~""
        idx_pat1 = one_line.find(""//"")
        idx_pat2 = one_line.find(""/*"")

        while -1 < idx_pat1 or -1 < idx_pat2:
            if -1 < idx_pat1 and -1 < idx_pat2:
                if idx_pat1 < idx_pat2:
                    one_line = Solution.pat1.sub(""~"", one_line, 1)
                else:
                    one_line = Solution.pat2.sub("""", one_line, 1)
            elif -1 < idx_pat1:
                one_line = Solution.pat1.sub(""~"", one_line, 1)
            else:
                one_line = Solution.pat2.sub("""", one_line, 1)
            idx_pat1 = one_line.find(""//"")
            idx_pat2 = one_line.find(""/*"")

        return [line for line in one_line.split(""~"") if line]",Medium,23,884,0.0,4,3.0,6.0,38.43478260869565,36.0,2.520869565217392
430.0,find pivot index,"class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        if(len(nums) <= 1):
            return 0
        s = sum(nums)
        c = 0
        for i in range(len(nums)):
            if (s - nums[i]) / 2 == c:
                return i
            c += nums[i]
        return -1",Easy,10,292,0.0,0,3.0,3.0,29.2,16.0,5.5920000000000005
431.0,split linked list in parts,"class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        n = 0
        current = head
        while (current):
            n += 1
            current = current.next
        
        parts = []
        for k in range(k, 0, -1):
            partSize = ceil(n / k)
            nextNode = head
            for _ in range(partSize - 1):
                if (not nextNode): break
                nextNode = nextNode.next
            parts.append(head)
            if (nextNode):
                head = nextNode.next
                nextNode.next = None
            n -= partSize
                
        return parts",Medium,21,670,0.0,4,3.0,5.0,31.904761904761905,25.0,4.208571428571428
432.0,number of atoms,"class Solution:
    def countOfAtoms(self, formula: str) -> str:
        mp = {}
        stack = []
        for i, x in enumerate(formula): 
            if x == ""("": stack.append(i)
            elif x == "")"": mp[stack.pop()] = i
        
        def fn(lo, hi): 
            """"""Return count of atom in a freq table.""""""
            k = lo 
            ans = defaultdict(int)
            while k < hi: 
                cnt = 0 
                if formula[k] == ""("": 
                    freq = fn(k+1, mp[k])
                    k = mp[k] + 1
                    while k < hi and formula[k].isdigit(): 
                        cnt = 10*cnt + int(formula[k])
                        k += 1
                    for key, val in freq.items(): ans[key] += val * max(1, cnt)
                else: 
                    atom = formula[k]
                    k += 1
                    while k < hi and formula[k] != ""("" and not formula[k].isupper(): 
                        if formula[k].isalpha(): atom += formula[k]
                        else: cnt = 10*cnt + int(formula[k])
                        k += 1
                    ans[atom] += max(1, cnt)
            return ans 
        
        
        ans = []
        for k, v in sorted(fn(0, len(formula)).items()): 
            ans.append(k)
            if v > 1: ans.append(str(v))
        return """".join(ans)",Hard,36,1357,0.0,9,4.0,23.0,37.69444444444444,59.0,-0.0725000000000015
433.0,self dividing numbers,"class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
    	L = []
    	for i in range(left,right+1):
    		d = list(str(i))
    		m = len(d)
    		if '0' in d:
    			continue
    		j = 0
    		while j < m and i%int(d[j]) == 0:
    			j += 1
    		if j == m:
    			L.append(i)
    	return(L)
		
	- Python 3
	- Junaid Mansuri",Easy,16,358,0.0,3,1.0,4.0,22.375,24.0,5.34625
434.0,my calendar i,"# Binary Search Tree Solution -> If exact matching of intervals found then return False
#                                Else you can add this interval to that particular node's left or right
class Node:
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None
class MyCalendar:
    def __init__(self):
        self.head = None
        
    def insert(self, s, e, node):
        if s >= node.e:
            if node.right: return self.insert(s, e, node.right)
            else: 
                nn = Node(s, e)
                node.right = nn
                return True
        elif e <= node.s:
            if node.left: return self.insert(s, e, node.left)
            else:
                nn = Node(s, e)
                node.left = nn
                return True
        else: return False
        
    def book(self, s: int, e: int) -> bool:
        if self.head == None:
            nn = Node(s, e)
            self.head = nn
            return True
        return self.insert(s, e, self.head)",Medium,32,1061,2.0,-2,3.0,6.0,33.15625,52.0,1.8359375
435.0,count different palindromic subsequences,"class Solution:
    def countPalindromicSubsequences(self, s: str) -> int:
        n = len(s)
        t = [[0 for _ in range(n)] for _ in range(n)]
        
        for g in range(n):
            i = 0
            for j in range(g, n):
                if g == 0:
                    t[i][j] = 1
                elif g == 1:
                    t[i][j] = 2
                else:
                    if s[i] != s[j]:
                        t[i][j] = t[i][j-1] + t[i+1][j] - t[i+1][j-1]
                    else:
                        if s[i:j+1].count(s[i]) == 2:
                            t[i][j] = 2*t[i+1][j-1] + 2
                        elif s[i:j+1].count(s[i]) == 3:
                            t[i][j] = 2*t[i+1][j-1] + 1
                        else:
                            temp = s[i+1:j]
                            x = i + temp.index(s[i]) + 2
                            y = j - temp[::-1].index(s[i]) - 2
                            t[i][j] = 2*t[i+1][j-1] - t[x][y]
                i = i+1
        
        return t[0][n-1]% (10**9 + 7)",Hard,27,1059,0.0,7,5.0,9.0,39.22222222222222,47.0,1.049999999999999
436.0,flood fill,"class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        
        rows = len(image)
        cols = len(image[0])
        color_to_change = image[sr][sc]
        
        def dfs(r,c):
            if(r<0 or c<0 or r>rows-1 or c>cols-1 or image[r][c] == newColor or image[r][c]!=color_to_change):
                return
            image[r][c] = newColor
            
            #iterate through all four directions
            dfs(r+1,c)
            dfs(r-1,c)
            dfs(r,c+1)
            dfs(r,c-1)
        
        dfs(sr,sc)
        return image",Easy,19,623,1.0,-1,3.0,1.0,32.78947368421053,31.0,3.868947368421052
437.0,asteroid collision,"class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        ans = []
        for a in asteroids:
            if a > 0:
                ans.append(a)
            else:
                appendFlag = True
                while ans:
                    if ans[-1] < 0:
                        break
                    else:
                        if ans[-1] + a < 0:
                            ans.pop(-1)
                        elif ans[-1] + a == 0:
                            ans.pop(-1)
                            appendFlag = False
                            break
                        else:
                            appendFlag = False
                            break
                if appendFlag:
                    ans.append(a)                    
        return ans",Medium,23,818,0.0,4,5.0,7.0,35.56521739130435,25.0,3.759130434782608
438.0,parse lisp expression,"class Solution:
    def evaluate(self, expression: str) -> int:
        loc = {}
        stack = []
        for i, x in enumerate(expression): 
            if x == ""("": stack.append(i)
            elif x == "")"": loc[stack.pop()] = i
        
        def fn(lo, hi, mp): 
            """"""Return value of given expression.""""""
            if expression[lo] == ""("": return fn(lo+1, hi-1, mp)
            i = lo
            vals = []
            while i < hi: 
                if expression[i:i+3] in (""let"", ""add""): 
                    op = expression[i:i+3]
                    i += 3
                elif expression[i:i+4] == ""mult"": 
                    op = ""mult""
                    i += 4
                elif expression[i].isalpha(): 
                    x = """"
                    while i < hi and expression[i].isalnum(): 
                        x += expression[i]
                        i += 1
                    if op in (""add"", ""mult""): vals.append(mp[x])
                elif expression[i].isdigit() or expression[i] == ""-"": 
                    v = """"
                    while i < hi and (expression[i].isdigit() or expression[i] == ""-""): 
                        v += expression[i]
                        i += 1
                    if op == ""let"": mp[x] = int(v)
                    else: vals.append(int(v))
                elif expression[i] == ""("": 
                    v = fn(i+1, loc[i], mp.copy())
                    i = loc[i] + 1
                    if op == ""let"": mp[x] = v
                    else: vals.append(v)
                else: i += 1
            if op == ""let"": return int(v)
            elif op == ""add"": return sum(vals)
            else: return reduce(mul, vals)
            
        return fn(0, len(expression), {})",Hard,43,1758,0.0,12,4.0,17.0,40.88372093023256,98.0,-4.439534883720931
439.0,monotone increasing digits,"class Solution:
def monotoneIncreasingDigits(self, n: int) -> int:
    s = str(n)
    for i in range(len(s)-1,0,-1):
        if s[i]<s[i-1]:
            n = n-(int(s[i:])+1)
            s = str(n)
    return n",Medium,7,209,0.0,2,2.0,2.0,29.857142857142858,14.0,5.672857142857143
440.0,daily temperatures,"class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        
        N = len(temperatures)
        stack, answer = [], [0 for _ in range(N)]
        for index, value in enumerate(temperatures):
            while stack and stack[-1][1] < value:
                i = stack.pop()[0]
                answer[i] = index-i
            stack.append((index, value))
        return answer",Medium,10,412,0.0,2,3.0,3.0,41.2,16.0,4.392
441.0,delete and earn,"class Solution:
    def deleteAndEarn(self, n: List[int]) -> int:
    	if not n: return 0
    	a, b, C = 0, n.count(1), collections.Counter(n)
    	for i in range(2,max(n)+1): b, a = max(C[i]*i + a, b), b
    	return b
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,8,264,0.0,1,1.0,2.0,33.0,17.0,5.210000000000001
442.0,cherry pickup,"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        
        rows = len(grid)
        cols = len(grid[0])
        
        #Go down or go right
        directions = [(1, 0), (0, 1)]
        
        #Enables cache for our dp
        @lru_cache(None)
        def dp(row_1, row_2, col_1, col_2):
            
            #if we hit a wall or we go out of the grid
            if col_1 >= cols or col_2 >= cols or row_1 >= rows or row_2 >= rows or grid[row_1][col_1] == -1 or grid[row_2][col_2] == -1:
                return -inf
            #Pick current cherries
            result = grid[row_1][col_1]
            
            #Do not double cherries if both paths are the same
            if col_1 != col_2 or row_1 != row_2:
                result += grid[row_2][col_2]
            
            # If we are at the end of the grid stop
            if not (row_1 == rows - 1 and col_1 == cols - 1):
                result += max(dp(new_row_1 + row_1, new_row_2 + row_2, new_col_1 + col_1, new_col_2 + col_2) 
                              for new_row_1, new_col_1 in directions
                              for new_row_2, new_col_2 in directions)
            
            return result
        
        ans = dp(0, 0, 0, 0)
        return 0 if ans == -inf else ans",Hard,32,1295,6.0,1,3.0,10.0,40.46875,55.0,0.8578124999999996
443.0,network delay time,"class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        d = {}
        graph = [[] for _ in range(n)]
        for i in times:
            d[(i[0]-1,i[1]-1)] = i[2]
            graph[i[0]-1].append(i[1]-1)        
        parent = [-1]*n
        cost = [10**9]*n
        visited = [False]*n
        cost[k-1] = 0
        x = 0
        while x <= n-1:
            m = (-1,10**9)
            for i in range(n):
                if not visited[i] and m[1] > cost[i]:
                    m = (i,cost[i])
            for i,j in enumerate(graph[m[0]]):
                if (m[0],j) in d and cost[j] > cost[m[0]] + d[(m[0],j)]:
                    cost[j] = cost[m[0]] + d[(m[0],j)]
                    parent[j] = m[0]
            visited[m[0]] = True
            x += 1
        return -1 if (max(cost)) == 10**9 else max(cost)",Medium,23,865,0.0,6,3.0,8.0,37.60869565217392,43.0,1.7752173913043483
444.0,find smallest letter greater than target,"class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
    	t, n = ord(target), list(map(ord,letters))
    	if t >= max(n): return chr(min(n))
    	d = {c : i for i,c in enumerate(n) if c > t}
    	return letters[d[min(d)]]
		
		
- Python 3
- Junaid Mansuri",Easy,9,292,0.0,0,1.0,3.0,32.44444444444444,18.0,5.220000000000001
445.0,min cost climbing stairs,"class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int: 
        # Handle empty cost case
        if not cost: return 0
        
        # min_cost is the minimum cost to get to some step i
        min_cost = [0] * len(cost)
        min_cost[0] = cost[0]
        
        # Loop through. At each i, the cost is:
        #   - The cost of that step plus the minimum cost of the two steps before it
        for i in range(1, len(cost)):
            min_cost[i] = cost[i] + min(min_cost[i-1], min_cost[i-2])

        # Return the smaller of the two last steps (since two steps could be taken from the second last step out)
        return min(min_cost[-1], min_cost[-2])",Easy,15,687,5.0,0,2.0,3.0,45.8,15.0,4.458
446.0,largest number at least twice of others,"class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
    	M = max(nums)
    	return nums.index(M) if len([0 for i in nums if 2*i <= M]) == len(nums)-1 else -1
		
		
- Python 3
- Junaid Mansuri",Easy,7,208,0.0,0,1.0,3.0,29.714285714285715,11.0,6.1657142857142855
447.0,shortest completing word,"class Solution:
    def shortestCompletingWord(self, l: str, w: List[str]) -> str:
        res={}
        lp=l.lower()
        d={}
        for i in lp:
            if i.isalpha():
                d[i]=lp.count(i)
        for i in w:
            j=i.lower()
            c=0
            for k in d.keys():
                if j.count(k)<d[k]:
                    c=1
                    break
            if c==0:
                m=res.get(len(j),[])
                res[len(j)]=m+[j]
        return res[(min(list(res.keys())))][0]",Easy,18,529,0.0,5,3.0,6.0,29.38888888888889,27.0,4.175
448.0,contain virus,"class Solution:
    def containVirus(self, isInfected: List[List[int]]) -> int:

        # return number of walls needed
        def dfs(r, c):

            # return
            if (r, c) in visited or r < 0 or c < 0 or r >= m or c >= n:
                return 0

            # contained cells
            if isInfected[r][c] == -1:
                return 0
            
            # uninfected cells
            if isInfected[r][c] == 0:
                risky.add((r, c))
                return 1
            
            # infected cells
            visited.add((r ,c))
            walls = 0
            if isInfected[r][c] == 1:
                walls += dfs(r+1, c)
                walls += dfs(r-1, c)
                walls += dfs(r, c+1)
                walls += dfs(r, c-1)

            return walls
        
        m, n = len(isInfected), len(isInfected[0])
        total_wall = 0

        while True:
            # store (len(risky), risky, wall, starting points)
            gettingInfected = []
            visited = set()
            for i in range(m):
                for j in range(n):
                    if isInfected[i][j] == 1 and isInfected[i][j] not in visited:
                        risky = set()
                        w = dfs(i, j)
                        gettingInfected.append((-len(risky), risky, w, i, j))

            
            # heapy the gettingInfectious array to get the max len of risky
            heapq.heapify(gettingInfected)

            if not gettingInfected or gettingInfected[0][2] == 0:
                return total_wall

            # mark the infected cells as contained starting from (i, j)
            lr, risky, w, i, j = heapq.heappop(gettingInfected)
            # maybe a dfs for marking the cells?
            queue = collections.deque([(i, j)])
            while queue:
                r, c = queue.pop()
                if r < 0 or c < 0 or r >= m or c >= n or isInfected[r][c] != 1:
                    continue

                isInfected[r][c] = -1

                queue.append((r+1, c))
                queue.append((r-1, c))
                queue.append((r, c+1))
                queue.append((r, c-1))

            # increment the total walls
            total_wall += w
            for area in gettingInfected:
                riskyCells = area[1]
                for cell in riskyCells:
                    r, c = cell
                    isInfected[r][c] = 1",Hard,73,2429,10.0,6,3.0,15.0,33.273972602739725,96.0,-2.7346575342465744
449.0,open the lock,"class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        mp, queue, vis, ans = Counter(deadends), deque(), Counter(), 0
        
        if mp['0000'] > 0:
            return -1
        queue.append(['0','0','0','0'])
        vis['0000'], len_q = 1, 1
        while len_q:
            ans += 1
            while len_q:
                var = queue.popleft()
                digit = ''.join(var)
                if digit == target:
                    return ans - 1
                for i in range(4):
                    ch = var[i]
                    forw, rev = int(ch) + 1 if int(ch) + 1 < 10 else 9 - int(ch), int(ch) - 1 if int(ch) - 1 >= 0 else 9 + int(ch)
                    for direction in [forw, rev]:
                        var[i] = str(direction)
                        digit = ''.join(var)
                        if mp[digit] == 0 and vis[digit] == 0:
                            queue.append([d for d in digit])
                            vis[digit] = 1
                    var[i] = ch
                len_q -= 1
            len_q = len(queue)
        return -1",Medium,27,1112,0.0,5,4.0,12.0,41.18518518518518,54.0,0.3533333333333317
450.0,cracking the safe,"class Solution:
    def crackSafe(self, n: int, k: int) -> str:

        total = k**n-1
        start = '0' * n
        visited = set()
        visited.add('0' * n)
        self.ans = '0' * n

        def dfs(total,start):
            if total == 0: 
                return True
            for i in range(k):
                last = start[1:n]
                #print(last+str(i))
                end = last+str(i)
                if end not in visited:
                    visited.add(end)
                    total = total-1
                    self.ans = self.ans+str(i)
                    if dfs(total, end):
                        return True
                    else:
                        visited.remove(end)
                        total = total+1
                        self.ans = self.ans[:-1]
                        #print(""l"")
            return False

        dfs(total,start)
        return self.ans",Hard,30,918,2.0,1,4.0,4.0,30.6,31.0,3.926
451.0,reach a number,"class Solution:
    def reachNumber(self, target: int) -> int:
        t = abs(target)
        n = int(((1+8*t)**.5-1)/2)
        LT = n*(n+1)//2
        if LT == t: return n
        if (LT + n + 1 - t) % 2 == 0: return n + 1
        return n + 3 - n % 2
			
			
	- Python 3
	- Junaid Mansuri",Medium,11,292,0.0,0,2.0,2.0,26.545454545454547,16.0,5.890909090909091
452.0,pyramid transition matrix,"class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mem = dict()
        mem2 = set()
        for a in allowed:
            if a[:2] not in mem:
                mem[a[:2]] = list()
            
            mem2.add(a[0])

            mem[a[:2]].append(a[-1])
        
        n = len(bottom)

        def helper(cur_sol, i, j):
            if i == n:
                return True
            
            l, r = cur_sol[i - 1][j], cur_sol[i - 1][j + 1]
            if l + r in mem:
                for candidate in mem[l + r]:
                    if j == 0 or (j > 0 and cur_sol[i][j - 1] + candidate in mem):
                        if j == n - i - 1 or (j < n - i - 1 and candidate in mem2):
                            cur_sol[i].append(candidate)
                            if j < n - i - 1:
                                next_i, next_j = i, j + 1
                            else:
                                next_i, next_j = i + 1, 0
                            if helper(cur_sol, next_i, next_j):
                                return True

                            cur_sol[i].pop()

            return False

        cur_sol = [list(bottom)] + [list() for _ in range(n - 1)]
        return helper(cur_sol, 1, 0)",Medium,36,1275,0.0,6,4.0,10.0,35.416666666666664,53.0,0.9124999999999996
453.0,set intersection size at least two,"class Solution:
    def intersectionSizeTwo(self, A: List[List[int]]) -> int:
        A.sort(key=lambda x:(x[1],-x[0]))
        ans = []
        ans.append(A[0][1]-1)
        ans.append(A[0][1])
        n = len(A)
        # print(A)
        for i in range(1,n):
            if A[i][0]>ans[-1]:
                ans.append(A[i][1]-1)
                ans.append(A[i][1])
            elif A[i][0]>ans[-2]:
                ans.append(A[i][1])
        # print(ans)
        return len(ans)",Hard,15,482,2.0,3,3.0,3.0,32.13333333333333,16.0,5.228000000000001
454.0,special binary string,"class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        
        def fn(lo, hi): 
            if lo == hi: return """"
            vals = []
            ii, prefix = lo, 0
            for i in range(lo, hi):
                prefix += 1 if s[i] == ""1"" else -1 
                if prefix == 0: 
                    vals.append(""1"" + fn(ii+1, i) + ""0"")
                    ii = i+1
            return """".join(sorted(vals, reverse=True))
        
        return fn(0, len(s))",Hard,14,486,0.0,1,3.0,4.0,34.714285714285715,30.0,3.635714285714287
455.0,prime number of set bits in binary representation,"class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        count=0
        s=[2,3,5,7,11,13,17,19,23,29,31]
        for i in range(left,right+1):
            if(bin(i).count('1') in s):
                count+=1
        return count",Easy,7,259,0.0,1,3.0,2.0,37.0,23.0,4.13
456.0,partition labels,"class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        
        # calculate last window index of each character in string
        # This will help to define the current window boundary
        last_idx = {c:i for i,c in enumerate(s)}    
                
        # Start with window size 1             
        res = [1]
        # define the boundary based on first character
        end = last_idx[s[0]]     
        
        # Following loop is similar to merge intervals
        # start the loop at index 1
        for i in range(1, len(s)):            
            if i <= end:
                # update current window boundary
                # and also the current window length
                end = max(end, last_idx[s[i]])
                res[-1] += 1
            else:
                # add the next window 
                res.append(1)
                end = last_idx[s[i]]
        
        return res",Medium,25,932,9.0,2,3.0,3.0,37.28,20.0,4.7048000000000005
457.0,largest plus sign,"class Solution:
    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:
        dp = [[n] * n for _ in range(n)]
        for i, j in mines:
            dp[i][j] = 0
        
        for i in range(n):
            left = up = right = down = 0
            for j in range(n):
                if dp[i][j] == 0:
                    left = 0
                else:
                    left += 1
                    dp[i][j] = min(dp[i][j], left)
                
                if dp[j][i] == 0:
                    up = 0
                else:
                    up += 1
                    dp[j][i] = min(dp[j][i], up)
                
                j = ~j
                if dp[i][j] == 0:
                    right = 0
                else:
                    right += 1
                    dp[i][j] = min(dp[i][j], right)
                
                if dp[j][i] == 0:
                    down = 0
                else:
                    down += 1
                    dp[j][i] = min(dp[j][i], down)
        
        return max(val for row in dp for val in row)",Medium,34,1090,0.0,7,4.0,10.0,32.05882352941177,54.0,1.0547058823529412
458.0,couples holding hands,"class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        d = {v: k for k, v in enumerate(row)} # get the number->position dictionary
        count = 0
        for i in range(0, len(row), 2):
            pair = row[i]^1 # use XOR to find pair number
            if row[i+1] == pair: continue
            pos = d[pair]
            row[i+1], row[pos] = row[pos], row[i+1] # find the pair of row[i]
            d[row[pos]] = pos # update row[pos] position in dictionary
            count += 1
        return count",Hard,11,530,4.0,1,3.0,3.0,48.18181818181818,24.0,3.1836363636363645
459.0,toeplitz matrix,"class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        for i in range(1 ,len(matrix)):
            for j in range(1, len(matrix[0])):
                if matrix[i - 1][j - 1] != matrix[i][j]:
                        return False
        return True",Easy,6,281,0.0,2,3.0,3.0,46.833333333333336,11.0,4.385000000000001
460.0,reorganize string,"class Solution:
    def reorganizeString(self, S: str) -> str:
        L, A, m, B = len(S), [0]*len(S), 1-len(S) % 2, []
        for k,v in collections.Counter(S).most_common(): B += k*v
        for i,c in enumerate(B):
            I = (2*i + (2*i >= L)*m) % L
            A[I] = c
            if I != 0 and A[I-1] == c: return ''
        return """".join(A)
		
		
- Junaid Mansuri",Medium,11,379,0.0,2,2.0,3.0,34.45454545454545,26.0,4.059090909090909
461.0,max chunks to make sorted ii,"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        n=len(arr)
        que=[]
        res=0
        for i in range(n-1,-1,-1):
            if not que or arr[i]<=que[0]:
                que.insert(0,arr[i])
                res+=1
            else:
                a=bisect_left(que,arr[i])
                if len(que)-1-a<0:
                    que=que[0:1]
                    res=1
                elif a-1!=0:
                    res=len(que)-a+1
                    que=que[0:1]+que[a:]
        return res",Hard,17,536,0.0,4,4.0,4.0,31.529411764705884,30.0,3.68235294117647
462.0,max chunks to make sorted,"class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        largest_chunk=0
        start=0
        for i in range(len(arr)):
            visited=[False]*len(arr)
            for j in range(start,i+1):
                visited[arr[j]]=True
            if all(visited[start:i+1]):
                largest_chunk+=1
                start=i+1
        return largest_chunk",Medium,11,386,0.0,3,3.0,3.0,35.09090909090909,16.0,4.881818181818183
463.0,jewels and stones,"class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        count = 0
        for s in jewels:
            count += stones.count(s)
        return count",Easy,5,182,0.0,1,2.0,1.0,36.4,10.0,5.5440000000000005
464.0,sliding puzzle,"class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        board = board[0] + board[1] # flatten into vector 
        
        ans = 0 
        seen = set([tuple(board)])
        queue = [board]
        while queue: 
            newq = []
            for x in queue: 
                if x == [1,2,3,4,5,0]: return ans 
                k = x.index(0)
                for kk in (k-1, k+1, k-3, k+3): 
                    if 0 <= kk < 6 and (k, kk) not in ((2, 3), (3, 2)):
                        xx = x.copy()
                        xx[k], xx[kk] = xx[kk], xx[k]
                        if tuple(xx) not in seen: 
                            seen.add(tuple(xx))
                            newq.append(xx)
            queue = newq 
            ans += 1
        return -1",Hard,21,795,1.0,5,4.0,6.0,37.85714285714285,41.0,1.992857142857142
465.0,global and local inversions,"class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        m=float('inf')
        for i in range(len(A)-1,1,-1):
            m=min(m,A[i])
            if A[i-2]>m:
                return False
        return True",Medium,7,233,0.0,1,3.0,2.0,33.285714285714285,13.0,5.464285714285715
466.0,swap adjacent in lr string,"class Solution:
    def canTransform(self, start: str, end: str) -> bool: 
        ret_0 = collections.defaultdict(int)
        ret_1 = collections.defaultdict(int)
        lst_0, lst_1 = [[]]*2
        r0, r1 = [""""]*2 
        i = 0
        while i < len(start):
            if start[i] in ""LR"":
                ret_0[start[i]] += 1
                r0 += start[i]
            if end[i] in ""LR"":
                ret_1[end[i]] += 1
                r1 += end[i]
            if ret_0[""R""] >= ret_1[""R""] and ret_0[""L""] <= ret_1[""L""]:
                pass
            else:
                return False
            i += 1
                 
        return True if r0 == r1 else False",Medium,20,677,0.0,3,3.0,6.0,33.85,32.0,3.3935000000000004
467.0,swim in rising water,"class Solution:
    def swimInWater(self, grid) -> int:
        rows = len(grid)
        cols = len(grid[0])
        T = [[float('-inf') for _ in range(cols)] for _ in range(rows)]
        stack = [(grid[0][0], 0,0)]

        visited = {}

        while stack:
            time,x,y = heapq.heappop(stack)
            nei = [(1,0), (-1,0), (0,1),(0,-1)]
            for dx,dy in nei:
                nx, ny = x+dx, y+dy
                if (nx,ny) not in visited and nx >= 0 and nx < rows and ny >= 0 and ny < cols:
                    T[nx][ny] = max(grid[nx][ny], time)
                    visited[(nx,ny)] = True
                    if nx == rows-1 and ny == cols-1:
                        return T[-1][-1]
                    heapq.heappush(stack, (max(grid[nx][ny], time), nx, ny))

        return T[-1][-1]",Hard,21,811,0.0,3,3.0,6.0,38.61904761904762,51.0,1.064285714285715
468.0,k th symbol in grammar,"class Solution:
    def kthGrammar(self, N: int, K: int) -> int:
        memo = {(1,1): 0}
        def helper(n,k):
            if (n,k) in memo: 
                return memo[(n,k)]
                
            if k==1: return 0
            
            t = helper(n-1, math.ceil(k/2))
            if t==0:
                if k%2==0: return 1
                else: return 0
                
            if t==1:
                if k%2==0: return 0
                else: return 1
                
        return helper(N,K)",Medium,18,522,0.0,0,4.0,6.0,29.0,40.0,3.1500000000000004
469.0,reaching points,"class Solution:
    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        # if both of sx, sy are even, only evens can be generated, but not all evens can be generated 
        # as such, if you have any odds only in the end target, return false 
        if (sx % 2 == sy % 2 == 0) and ((tx % 2 != 0) or (ty % 2 != 0)) : 
            return False 
        # or if you have matches that are exactly equal, return True 
        elif (sx == sy == tx == ty) or (sx == tx and sy == ty) : 
            return True
        else : 
            # otherwise, return the euclidean gcd procession 
            return self.euclidean_gcd(sx, sy, tx, ty)

    def euclidean_gcd(self, sx, sy, tx, ty) : 
        # loop while tx and ty are greater than or equaal to their target 
        # count = 0 
        # loop zero printing can be commented out 
        # self.print_euclidean_progression(sx, sy, tx, ty, count)
        while (tx >= sx) and (ty >= sy) :
            # if these are equal to each other, break 
            if tx == ty : 
                break
            # otherwise, depending on which is larger 
            elif tx > ty : 
                # if the other target is above their start still 
                if ty > sy : 
                    # modulo reduction to remainder 
                    tx %= ty 
                else : 
                    # if it is at the target, return the modulo result for gcd 
                    return (tx - sx) % ty == 0 
            else : 
                # see above section for logic breakdown 
                if tx > sx : 
                    ty %= tx 
                else : 
                    return (ty - sy) % tx == 0 
            # increment count 
            # count += 1 
            # loop repeats with new values 
            # self.print_euclidean_progression(sx, sy, tx, ty, count)
        # either you broke early due to tx == ty or you completed thee loop when they are less than the valuation 
        # could still be the case that sx == tx and sy == ty 
        # handled by above edge cases for non-loop progression variant 
        # return (sx == tx and sy == ty)
        return False 
    
    def print_euclidean_progression(self, sx, sy, tx, ty, count) : 
        print(""At count "", count, "" the values of sx, sy are "", (sx, sy), "" and the values of tx, ty are "", (tx, ty))",Hard,48,2367,22.0,-5,3.0,17.0,49.3125,121.0,-5.538124999999999
470.0,rabbits in forest,"class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        ans = 0
        cnt = defaultdict(int)
        for x in answers: 
            if not cnt[x] % (1 + x): ans += 1 + x # reached capacity &amp; update ans
            cnt[x] += 1
        return ans",Medium,7,271,1.0,2,3.0,2.0,38.71428571428572,11.0,5.155714285714286
471.0,transform to chessboard,"class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        n = len(board)
        
        def fn(vals): 
            """"""Return min moves to transform to chessboard.""""""
            total = odd = 0 
            for i, x in enumerate(vals): 
                if vals[0] == x: 
                    total += 1
                    if i&amp;1: odd += 1
                elif vals[0] ^ x != (1 << n) - 1: return inf
            ans = inf 
            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)
            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)
            return ans 
        
        rows, cols = [0]*n, [0]*n
        for i in range(n): 
            for j in range(n): 
                if board[i][j]: 
                    rows[i] ^= 1 << j 
                    cols[j] ^= 1 << i
        ans = fn(rows) + fn(cols)
        return ans if ans < inf else -1",Hard,24,921,0.0,6,4.0,11.0,38.375,51.0,0.8462499999999995
472.0,minimum distance between bst nodes,"class Solution:
    def minDiffInBST(self, root: TreeNode) -> int:
        low = []
        def inorder (root):
            if root is None:
                return 
            inorder(root.left)
            low.append(root.val)
            inorder(root.right)
        inorder(root)
        print(low)
        return min(low[i+1] - low[i]
                   for i in range(len(low) - 1))",Easy,12,387,0.0,0,3.0,3.0,32.25,8.0,6.1175
473.0,letter case permutation,"class Solution:
    def letterCasePermutation(self, S: str) -> List[str]:
        
        # ending condition
        if len(S)==1:
            if S.isdigit(): return [S]
            else: return [S.lower(), S.upper()]
        
        first_char, remain = S[0], S[1:]
        remain_permutation = self.letterCasePermutation(remain)
        # if digit
        if first_char.isdigit():
            return [str(first_char) + item for item in remain_permutation]
        # if letter
        else:
            return [first_char.lower() + item for item in remain_permutation] + [first_char.upper() + item for item in remain_permutation]",Medium,15,632,3.0,0,3.0,8.0,42.13333333333333,19.0,4.248
474.0,is graph bipartite,"class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:      
        colors = [0]*len(graph)                         # 0: no color, 1: red, -1: green

        def dfs(node: int, node_color: int) -> bool:    # node: current node, node_color: current node's color
            if colors[node] != 0:                       # if current node was already colored
                return colors[node] == node_color       # return True if current node was colored the same
            
            colors[node] = node_color                   # color current node
            for neighbor in graph[node]:                # iterate current node's neighbor nodes
                if not dfs(neighbor, -1*node_color):    # DFS neighbor nodes with different color
                    return False                        # return False if neighbors are non-bipartite (short-circuit)
            return True

        for node in range(len(graph)):
            if colors[node] == 0 and not dfs(node, 1):  # iterate for nodes that are not connected 
                return False                            # return False if a connected nodes are non-bipartite (short-circuit)
            
        return True",Medium,18,1207,10.0,-2,5.0,11.0,67.05555555555556,34.0,0.7849999999999984
475.0,k th smallest prime fraction,"class Solution:
    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        pq = [(arr[i]/arr[-1], i, -1) for i in range(len(arr)-1)]
        for _ in range(k): 
            _, i, j = heappop(pq)
            if i - j + 1 < len(arr): heappush(pq, (arr[i]/arr[j-1], i, j-1))
        return [arr[i], arr[j]]",Medium,6,329,0.0,2,3.0,3.0,54.833333333333336,20.0,2.765000000000001
476.0,cheapest flights within k stops,"class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        dist_price = [float('inf') for _ in range(n)]
        dist_price[src]=0
        
        for source,dest,cost in flights:
            if src==source:
                dist_price[dest] = cost
        
        for times in range(0,K):
            
            temp = [*dist_price]
            
            for srce,dest,cost in flights:
                temp[dest] = min(temp[dest] , cost + dist_price[srce])
            dist_price = temp
        
        if dist_price[dst] == float('inf'):
            return -1
        return dist_price[dst]",Medium,19,666,0.0,4,3.0,6.0,35.05263157894737,36.0,2.825263157894737
478.0,escape the ghosts,"class Solution:
    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
        l = [abs(ghost[0]-target[0])+abs(ghost[1]-target[1]) for ghost in ghosts]
        return min(l)>abs(target[0])+abs(target[1])",Medium,3,229,0.0,0,2.0,1.0,76.33333333333333,9.0,2.1100000000000003
479.0,domino and tromino tiling,"class Solution:
    def numTilings(self, N: int) -> int:
        f0, f1, f2 = 0, 1, 1
        for i in range(N-1): f0, f1, f2 = f1, f2, (2*f2 + f0) % 1_000_000_007
        return f2",Medium,4,181,0.0,1,2.0,1.0,45.25,16.0,4.147500000000001
480.0,custom sort string,"class Solution:
    def customSortString(self, S: str, T: str) -> str:
        letter_count = collections.Counter(T)
        other_letters = set(string.ascii_lowercase) - set(S)
        order = S + ''.join(other_letters)
        result = []
        for letter in order:
            result.extend([letter * letter_count[letter]])
        return ''.join(result)",Medium,8,359,0.0,1,2.0,1.0,44.875,12.0,4.58125
481.0,number of matching subsequences,"class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        def isSubSeq(s1, s2):
            iter = 0
            
            for index, val in enumerate(s1):
                if val == s2[iter]:
                    iter += 1
                    
                if iter == len(s2):
                    break
            
            return iter == len(s2)
        
        return sum([1 if isSubSeq(s, w) else 0 for w in words])",Medium,14,460,0.0,1,4.0,5.0,32.857142857142854,25.0,4.242857142857143
482.0,preimage size of factorial zeroes function,"class Solution:

    def preimageSizeFZF(self, k: int) -> int:
        if k < 5:
            return 5
        elif k == 5:
            return 0
        left, right = 4, 5 * k
        while left < right:
            middle = (left + right) // 2
            zeros = sum(middle // pow(5, p)
                        for p in range(1, int(log(middle, 5)) + 1))
            if zeros < k:
                left = middle + 1
            elif zeros > k:
                right = middle - 1
            else:
                return 5
        return 0",Hard,18,538,0.0,2,3.0,6.0,29.88888888888889,28.0,4.21
483.0,valid tic tac toe state,"class Solution:
    def validTicTacToe(self, b: List[str]) -> bool:
    	T, w = {'XXX':0, 'OOO':0}, """".join(b).count('X') - """".join(b).count('O')
    	for i in [0,1,2]: T[b[0][i]+b[1][i]+b[2][i]], T[b[i][0]+b[i][1]+b[i][2]], T[b[0][2*i//2]+b[1][1]+b[2][2*(1-i//2)]] = 1, 1, 1
    	return False if (w not in [0,1]) or (T['XXX'] == 1 and w != 1) or (T['OOO'] == 1 and w != 0) else True
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,8,432,0.0,1,1.0,2.0,54.0,28.0,2.2200000000000006
484.0,number of subarrays with bounded maximum,"class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        ans, prev = 0, 0
        i, j = 0, 0
        n = len(nums)
        
        for j in range(n):
            if left <= nums[j] <= right:
                prev = (j-i+1)
                ans += prev
            elif nums[j] < left:
                ans += prev
            else:
                i, prev = j+1, 0
        
        return ans",Medium,15,442,0.0,3,3.0,3.0,29.466666666666665,31.0,3.888000000000001
485.0,rotate string,"class Solution:
    def rotateString(self, s: str, goal: str) -> bool:
        if len(s) == len(goal):
            x = 2*s
            return goal in x
        return False",Easy,5,172,0.0,0,3.0,1.0,34.4,12.0,5.524000000000001
486.0,all paths from source to target,"class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        total = [[0]]
        ans = []
        target = len(graph) - 1
        while total: # start BFS
            itr = total.pop(0)
            last = itr[-1]
            possible = graph[last]
            if not possible: #not possible means no valid edge stars with the end of this path
                continue
            for i in possible:
                if i == target: #find valid path, concact the target, and append it to answer
                    ans.append(itr + [target])
                    continue
                total.append(itr + [i]) #add all pending path to the end of the queue
        return ans",Medium,16,717,4.0,2,3.0,4.0,44.8125,20.0,3.826875
487.0,smallest rotation with highest score,"class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        diff = [1] * len(nums)
        for i, x in enumerate(nums): 
            diff[(i-x+1) % len(nums)] -= 1
        prefix = list(accumulate(diff))
        return prefix.index(max(prefix))",Hard,6,260,0.0,1,2.0,4.0,43.333333333333336,10.0,4.92
488.0,champagne tower,"class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        
        
        dp =[ [0]*row for row in range(1,100+2) ]
        
        
        dp[0][0] = poured
        
        
        for i in range(query_row+1):
            
            for j in range(i+1):# calculating the amount of liquid which will left after completely filling this cup
                
                left = (dp[i][j] -1)/2
                
                if left >0:
                    dp[i+1][j]+=left
                    dp[i+1][j+1]+=left
                    
        return min(1, dp[query_row][query_glass])",Medium,20,646,1.0,3,3.0,4.0,32.3,20.0,4.773000000000001
489.0,minimum swaps to make sequences increasing,"class Solution:
    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:
        dp = [[-1]*2 for i in range(len(nums1))]
        
        def solve(prev1, prev2, i, swaped):
            if i >= len(nums1): return 0
            if dp[i][swaped] != -1: return dp[i][swaped]
                        
            ans = 2**31
            
            # No Swap
            if nums1[i] > prev1 and nums2[i] > prev2:
                ans = solve(nums1[i], nums2[i], i+1, 0) 
            
            # Swap
            if nums1[i] > prev2 and nums2[i] > prev1:
                ans = min(ans, 1 + solve(nums2[i], nums1[i], i+1, 1)) 
            
            dp[i][swaped] = ans
            return ans
        
        return solve(-1, -1, 0, 0)",Hard,21,745,2.0,1,3.0,5.0,35.476190476190474,37.0,2.9471428571428584
490.0,find eventual safe states,"class Solution:
    
    def is_cycle(self, graph: List[List[int]], node: int, is_visited: Set, is_safe: Set) -> bool:
        
        # IF node is already visited, return cycle detected true
        if node in is_visited:
            return True
        
        # IF node is already explored, and no cycle detected, return False
        if node in is_safe:
            return False
        
        # Add node to is_visited set
        is_visited.add(node)
        
        # Try to detect cycle in path of adjacent nodes
        for adj_node in graph[node]:
            if self.is_cycle(graph, adj_node, is_visited, is_safe):
                return True
        
        # Backtrack: Very important, as there can be many paths going through the same node.
        # And we might not have explored all of them. So remove the node from the visited set
        # and mark it as safe
        is_visited.remove(node)
        
        # Mark node as safe, as no cycle detected in its path
        is_safe.add(node)
        
        return False
    
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        
        # Init
        is_safe = set()
        is_visited = set()
        
        # Try to detect cycle for all the nodes
        for node in range(len(graph)):
            if node not in is_visited:
                self.is_cycle(graph, node, is_visited, is_safe)
                
        # Make sorted array of is_safe set
        is_safe = sorted(list(is_safe))
        
        return is_safe",Medium,44,1523,11.0,0,3.0,9.0,34.61363636363637,36.0,3.5447727272727283
491.0,unique morse code words,"class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        code=["".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",""...-"","".--"",""-..-"",""-.--"",""--..""]
        transformation=set()
        for word in words:
            s=''
            for letter in word:
                s=s+code[ord(letter)-97]
            transformation.add(s)
        return len(transformation)",Easy,9,472,0.0,2,3.0,5.0,52.44444444444444,36.0,1.3800000000000008
492.0,split array with same average,"class Solution:
    def splitArraySameAverage(self, A: List[int]) -> bool:
        A.sort()
        DP=[set() for _ in range(len(A)//2+1)]    #DP[i] stores the all available sum with i items in a bracket
        all_sum=sum(A)
        DP[0]=set([0])
        for item in A:                  #iterate over items in the list
            for count in range(len(DP)-2,-1,-1):          # iterate backwards w.r.t. the bracket size
                if len(DP[count])>0:                             # if DP[i] is not empty, then update DP[i+1] by adding the current item into all sums in DP[i]
                    for a in DP[count]:
                        DP[count+1].add(a+item)
        for size in range(1,len(DP)):
            if all_sum*size/len(A) in DP[size]:
                return True
        return False",Hard,14,806,4.0,5,4.0,8.0,57.57142857142857,19.0,2.5385714285714283
493.0,number of lines to write string,"class Solution:
    def numberOfLines(self, widths: List[int], s: str) -> List[int]:
        letter_w = {chr(97 + i): widths[i] for i in range(26)}
        n_lines = line_len = 0
        for c in s:
            line_len += letter_w[c]
            if line_len > 100:
                n_lines += 1
                line_len = letter_w[c]
        return [n_lines + (line_len > 0), line_len]",Easy,9,385,0.0,2,3.0,3.0,42.77777777777778,19.0,3.95
494.0,max increase to keep city skyline,"class Solution:
    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        # the vertical skyline is the max # of each column
        # the horizontal skyline is the max # of each row
        
        # a building's height should be min(max of that row, max of that column)
        
        size = len(grid)
        
        columns = rows_to_columns(grid)
        
        row_maxs = list(max(row) for row in grid) # horizontal skyline
        
        column_maxs = list(max(column) for column in columns) # vertical skyline
        
        total_increase = 0
        
        for row in range(size):
            row_max = row_maxs[row]
            for column in range(size):
                column_max = column_maxs[column]
                max_height = min(column_max, row_max)
                actual_height = grid[row][column]
                total_increase += max_height - actual_height
                
        return total_increase
                
def rows_to_columns(grid: List[List[int]]):
    columns = []
    for i in range(len(grid)):
        column = []
        for row in grid:
            column.append(row[i])
        columns.append(column)
    return columns",Medium,34,1197,5.0,3,3.0,6.0,35.205882352941174,25.0,4.171470588235295
495.0,soup servings,"class Solution:
    def soupServings(self, n: int) -> float:
        if n >= 4276: return 1.0

        @lru_cache(None)
        def f(a: int, b: int)->float:
            if a <= 0 and b <= 0: return 0.5
            if a <= 0: return 1
            if b <= 0: return 0
            return (f(a-100,b) + f(a-75,b-25) + f(a-50,b-50) + f(a-25,b-75))*.25
        
        return f(n,n)",Medium,11,378,0.0,-1,3.0,4.0,34.36363636363637,29.0,3.887272727272727
496.0,expressive words,"class Solution:
    def expressiveWords(self, S: str, W: List[str]) -> int:
        LW, C, n = len(W), [], 0
        for s in [S]+W:
            C.append([[],[]])
            for k,g in itertools.groupby(s): C[-1][0].append(k), C[-1][1].append(len(list(g)))
        LC = len(C[0][0])
        for i in range(1,LW+1):
            if C[0][0] != C[i][0]: continue
            for j in range(LC):
                if C[i][1][j] > C[0][1][j] or (C[i][1][j] < C[0][1][j] and C[0][1][j] == 2): break
            else: n += 1
        return n
                
				
- Junaid Mansuri",Medium,15,571,0.0,4,3.0,6.0,38.06666666666667,31.0,3.0540000000000003
497.0,chalkboard xor game,"class Solution:
    def xorGame(self, nums: List[int]) -> bool:
        return reduce(xor, nums) == 0 or not len(nums)&amp;1",Hard,2,124,0.0,0,2.0,0.0,62.0,9.0,3.3999999999999995
498.0,subdomain visit count,"class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d= {}
        for cpdomain in cpdomains:
            page = """"      
            count, full_page = cpdomain.split(' ')
            sub_doms = full_page.split('.')[::-1]
            curr_page =""""
            for dom in  sub_doms:
                curr_page = dom + curr_page
                if curr_page in d:
                    d[curr_page]  += int(count)
                else:
                    d[curr_page]  = int(count)
                curr_page = '.' + curr_page                
        return [  "" "".join([str(count), site]) for site,count in d.items()]",Medium,15,651,0.0,3,4.0,4.0,43.4,23.0,3.374000000000001
499.0,largest triangle area,"class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:
        def area(x1, y1, x2, y2, x3, y3):
            return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2
        
        n = len(points)
        res = 0
        for i in range(n - 2):
            x1, y1 = points[i]
            for j in range(i + 1, n - 1):
                x2, y2 = points[j]
                for k in range(j + 1, n):
                    x3, y3 = points[k]
                    res = max(res, area(x1, y1, x2, y2, x3, y3))
        
        return res",Easy,15,559,0.0,2,3.0,3.0,37.266666666666666,31.0,3.2460000000000004
500.0,largest sum of averages,"class Solution:
    def largestSumOfAverages(self, A: List[int], K: int) -> float:
        s=[0]
        for i in A:
            s.append(i+s[-1]);
        n=len(s);
        mini= -200000
        d={};
        def fun(old,new,k):
            temp=(old,new,k);
            if(temp in d.keys()): return d[temp]
            if(new>=n) or (old>=n):
                return mini;
            if(k==1):
                return (s[-1]-s[old])/(n-1-old);
            d[temp]= max(fun(old,new+1,k),fun(new,new+1,k-1)+((s[new]-s[old])/(new-old)) );
            return d[temp]
        return fun(0,1,K);
		```",Medium,18,596,0.0,-3,3.0,4.0,33.111111111111114,36.0,3.42
501.0,binary tree pruning,"class Solution:
    def pruneTree(self, root: TreeNode) -> TreeNode:
		# Base case - return None if node does not exist
        if root is None:
            return None
        else:
			# recursively traverse the left and right subtrees 
            root.left = self.pruneTree(root.left)
            root.right = self.pruneTree(root.right)
			
			# Condition to check if subtree doesn't have 1 as node value i.e root.val == 0
            if root.left is None and root.right is None and root.val == 0:
                return None
            else:
                return root",Medium,14,574,3.0,-1,2.0,4.0,41.0,17.0,4.669999999999999
502.0,bus routes,"class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        if source == target:
            return 0
        set_routes = [set(route) for route in routes]
        start_buses = [i for i, s in enumerate(set_routes) if source in s]
        state = set()
        for i in start_buses[::-1]:
            state.update(set_routes.pop(i))
        if target in state:
            return 1
        n_buses = 1
        while state:
            new_state = set()
            n_buses += 1
            new_busses = [i for i, s in enumerate(set_routes) if state &amp; s]
            for i in new_busses[::-1]:
                new_state.update(set_routes.pop(i))
            if target in new_state:
                return n_buses
            state = new_state
        return -1",Hard,21,822,0.0,3,3.0,11.0,39.142857142857146,32.0,2.9171428571428573
503.0,ambiguous coordinates,"class Solution:
    def ambiguousCoordinates(self, s: str) -> List[str]:
        s = s[1:-1]
        sp = [(s[:x], s[x:]) for x in range(1,len(s))]
        o = []
        for left, right in sp:
            la = []
            if left[0] == '0' and len(left) > 1 and set(left) != set([""0""]):
                if left[1:][-1] != '0':                
                    la.append((left[:1] + '.' + left[1:]))
            else:
                if (len(left) > 1 and set(left) != set([""0""])) or len(left) == 1:
                    la.append(left)
                    for y in range(1, len(left)):
                        if int(left[y:]) != 0 and left[y:][-1] != '0':
                            la.append((left[:y] + '.' + left[y:]))
                            
            ra = []
            if right[0] == '0' and len(right) > 1 and set(right) != set([""0""]):
                if right[1:][-1] != '0':
                    o += [""(%s, %s)""%(i, (right[:1] + '.' + right[1:])) for i in la]
            else:
                if (len(right) > 1 and set(right) != set([""0""])) or len(right) == 1:                 
                    o += [""(%s, %s)""%(i, right) for i in la]
                    for y in range(1, len(right)):
                        if int(right[y:]) != 0 and right[y:][-1] != '0':
                            rightside = right[:y] + '.' + right[y:]
                            o += [""(%s, %s)""%(i, rightside) for i in la]
                    
        return o",Medium,29,1468,0.0,11,5.0,15.0,50.62068965517241,81.0,-3.6158620689655177
505.0,race car,"class Solution:
    def racecar(self, target: int) -> int:
        dq=deque([(0,0,1)])
        while dq:
            move,pos,speed=dq.popleft()
            if pos==target:
                return move
            dq.append((move+1,pos+speed,speed*2))
            if (pos+speed>target and speed>0) or pos+speed<target and speed<0:
                speed=-1 if speed>0 else 1
                dq.append((move+1,pos,speed))
            else:
                continue",Hard,12,461,0.0,2,3.0,4.0,38.41666666666666,28.0,3.4425
506.0,most common word,"class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        result = ''
        word_count = {}
        
        # Replace all puctuations with white spaces
        paragraph = paragraph.lower()\
                             .replace('!', ' ')\
                             .replace('?', ' ')\
                             .replace('\'', ' ')\
                             .replace(',', ' ')\
                             .replace(';', ' ')\
                             .replace('.', ' ')
        
        # Split paragraph by white spaces (irrespective of the nubmer of white spaces)
        for w in paragraph.split():
            if w not in banned: # Optional: can use set() to drop duplicates in banned
                # Increase word count
                word_count[w] = word_count.get(w, 0) + 1
                
                # If new word has a count greater than previous word then replace resulting word
                if word_count[w] > word_count.get(result, 0): 
                    result = w
        
        return result",Easy,24,1078,5.0,3,4.0,4.0,44.91666666666666,26.0,3.1375
507.0,short encoding of words,"class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        words = sorted(words,key=len)
        #print(words)
        ret = ''
        for w in words[::-1]:
            if (w+'#') not in ret:
                ret = ret + w +'#'
        #print(ret)
        return len(ret)",Medium,9,298,4.0,2,3.0,2.0,33.111111111111114,14.0,5.48
508.0,shortest distance to a character,"class Solution:
    def shortestToChar(self, S: str, C: str) -> List[int]:
        l=[]
        x=[]
        for i in range(len(S)):
            if(S[i]==C):
                l.append(i)
        a=l[0]
        b=l[len(l)-1]
        k=0
        for i in range(len(S)):
            if(i<a):
                x.append(a-i)
            elif(i>b):
                x.append(i-b)
            else:
                if(i==l[k]):
                    x.append(0)
                    if(k<len(l)-1):
                        k+=1
                        continue
                else:
                    x.append(min(i-l[k-1],l[k]-i))
        return x",Easy,23,637,0.0,1,4.0,7.0,27.695652173913043,32.0,4.007391304347826
509.0,card flipping game,"class Solution:
    def flipgame(self, f: List[int], b: List[int]) -> int:
    	return min(set(f+b)-set(f[i] for i in range(len(f)) if f[i] == b[i]), default = 0)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,6,211,0.0,0,1.0,2.0,35.166666666666664,12.0,5.575
510.0,binary trees with factors,"class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        
        arr.sort()
        
        memo={}
        memo[arr[0]] = 1
        
        for i in range(1, len(arr)):
            count = 1
            for j in range(0, i):
                if arr[i]/arr[j] in memo:
                    count+=memo[arr[j]]*memo[arr[i]/arr[j]]
            memo[arr[i]] = count
        return sum(memo.values()) % (10**9+7)",Medium,14,437,0.0,3,3.0,3.0,31.214285714285715,15.0,5.330714285714286
511.0,goat latin,"class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        
        #vars
        output = ''
        goatword = ''
        vowles = list(['a', 'e', 'i', 'o', 'u'])

        #enumerate and iterate
        for idx, word in enumerate(sentence.split(' ')):
            goatword = ''
            if word[0:1].lower() in vowles:
                goatword = word+'ma'
            elif word[0:1].lower() not in vowles:
                goatword = word[1:len(word)]+word[0:1]+'ma'

            #add extra a based on word position
            goatword = goatword + 'a'*(idx+1) + ' '

            #update output word
            output = output + goatword

        return(output.rstrip())",Easy,22,690,4.0,3,3.0,3.0,31.363636363636363,25.0,4.477272727272728
512.0,friends of appropriate ages,"class Solution:
    def numFriendRequests(self, ages: List[int]) -> int:
        requests = 0
        ages_le = [0 for _ in range(121)]
        for age in ages:
            ages_le[age] += 1
        for index in range(1, 121):
            ages_le[index] += ages_le[index-1]
        for age in ages:
            age_lower_bound = int(age//2) + 8
            age_upper_bound = age
            too_young = 0
            if age_lower_bound > age_upper_bound:
                continue
            if age_lower_bound < 0:
                continue
            elif age_lower_bound > 0:
                too_young = ages_le[age_lower_bound-1]
            requests += ages_le[age_upper_bound] - 1 - too_young
        return requests",Medium,19,722,0.0,4,3.0,7.0,38.0,24.0,3.76
513.0,most profit assigning work,"class Solution:
    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        d = defaultdict(int)
        for k,v in zip(difficulty,profit):
            d[k] = max(d[k],v)
        bucket = [0 for _ in range(max(worker)+1)]
        val = 0
        for i in range(len(bucket)):
            if i in d:
                val = max(val,d[i])
            bucket[i] = val
        return sum([bucket[w] for w in worker])",Medium,11,460,0.0,3,3.0,7.0,41.81818181818182,22.0,3.6763636363636367
514.0,making a large island,"class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        mark = 2
        islands = []
        n = len(grid)
        
        def mark_it(x, y):  # marks island and returns square of that island
            grid[x][y] = mark
            s = 1
            for xn in (x - 1, x + 1):
                if 0 <= xn < n and grid[xn][y] == 1:
                    s += mark_it(xn, y)
            for yn in (y - 1, y + 1):
                if 0 <= yn < n and grid[x][yn] == 1:
                    s += mark_it(x, yn)
            return s
        
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    islands.append(mark_it(i, j))
                    mark += 1
        
        if not islands: return 1
        
        ret = max(islands)
        
        def check_it(x, y):  # returns sum of adjacent islands to zero cell
            adj = []
            for xn in (x - 1, x + 1):
                if 0 <= xn < n and grid[xn][y] != 0:
                    adj.append(grid[xn][y] - 2)
            for yn in (y - 1, y + 1):
                if 0 <= yn < n and grid[x][yn] != 0:
                    adj.append(grid[x][yn] - 2)
            if not adj: return 0
            return sum([islands[a] for a in set(adj)])
        
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 0:
                    ret = max(ret, 1 + check_it(i, j))
        return ret",Hard,42,1461,2.0,12,4.0,17.0,34.785714285714285,71.0,-1.1107142857142858
515.0,count unique characters of all substrings of a given string,"class Solution:
		def uniqueLetterString(self, s: str) -> int:
			res = 0
			n = len(s)
			# dp_keys stores all keys in a substring
			dp_keys = [[set() for _ in range(n)] for _ in range(n)]
			# dp_unqs stores all unique characters in a substring
			dp_unqs = [[set() for _ in range(n)] for _ in range(n)]
			# dp_count stores the number of unique characters in a substring
			dp_count = [[0 for _ in range(n)] for _ in range(n)]
			for i in range(n):
				dp_keys[i][i] = set(s[i])
				dp_unqs[i][i] = set(s[i])
				dp_count[i][i] = 1
				res += 1

			for end_i in range(n):
				for start_i in range(end_i - 1, -1, -1):
					if s[start_i] not in dp_keys[start_i + 1][end_i]:
						tmp = copy.deepcopy(dp_keys[start_i + 1][end_i])
						tmp.add(s[start_i])
						dp_keys[start_i][end_i] = tmp
                
						tmp = copy.deepcopy(dp_unqs[start_i + 1][end_i])
						tmp.add(s[start_i])
						dp_unqs[start_i][end_i] = tmp
                
						dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] + 1
						res += dp_count[start_i][end_i] 
					else:
						dp_keys[start_i][end_i] = dp_keys[start_i + 1][end_i]
						if s[start_i] in dp_unqs[start_i + 1][end_i]:
							tmp = copy.deepcopy(dp_unqs[start_i + 1][end_i])
							tmp.remove(s[start_i])   
							dp_unqs[start_i][end_i] = tmp
							dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] - 1
							res += dp_count[start_i][end_i] 
						else:
							dp_unqs[start_i][end_i] = dp_unqs[start_i + 1][end_i]
							dp_count[start_i][end_i] = dp_count[start_i + 1][end_i] 
							res += dp_count[start_i][end_i]
			return res",Hard,41,1594,3.0,5,1.0,11.0,38.8780487804878,37.0,2.560975609756098
516.0,consecutive numbers sum,"class Solution:
    def consecutiveNumbersSum(self, n: int) -> int:
        ans = 0
        for x in range(1, int(sqrt(2*n))+1): 
            if (n - x*(x+1)//2) % x == 0: ans += 1
        return ans",Hard,5,199,0.0,2,2.0,2.0,39.8,13.0,4.878
518.0,masking personal information,"class Solution:
    def maskPII(self, S: str) -> str:
        if ""@"" in S: # email address
            name, domain = S.lower().split(""@"")
            return f""{name[0]}*****{name[-1]}@{domain}""
        else: # phone number 
            d = """".join(c for c in S if c.isdigit())
            ans = f""***-***-{d[-4:]}""
            return ans if len(d) == 10 else f""+{'*'*(len(d)-10)}-"" + ans",Medium,8,388,2.0,0,3.0,4.0,48.5,15.0,4.035
520.0,find and replace in string,"class Solution:
    def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:
        for i, s, t in sorted(zip(indexes, sources, targets), reverse=True): 
            if S[i:i+len(s)] == s: S = S[:i] + t + S[i+len(s):]
        return S",Medium,4,282,0.0,2,2.0,2.0,70.5,26.0,0.8150000000000013
521.0,sum of distances in tree,"class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        count = [1]*n
        res = [0]*n
                
        g = defaultdict(list)
        
        for s,e in edges:
            g[s].append(e)
            g[e].append(s)
            
        visited = set()
        
        def dfs_count_up_to_0(node):
            visited.add(node)
            
            for c in g[node]:
                if c not in visited:
                    count[node] += dfs_count_up_to_0(c)
                    res[node] += res[c] + count[c]
            return count[node]
        
        
        def dfs_fill_up_rest(node):
            visited.add(node)
            for c in g[node]:
                if c not in visited:
                    res[c] =  res[node] - count[c] + n - count[c]
                    dfs_fill_up_rest(c)
            
        dfs_count_up_to_0(0)
        
        visited.clear()
        
        dfs_fill_up_rest(0)
        
        return res",Hard,36,1002,0.0,4,3.0,5.0,27.83333333333333,22.0,4.875
522.0,image overlap,"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        n = len(img1)
        reduce_list = lambda lst: sum([1 << i for i,a in enumerate(lst) if a == 1])
        img1, img2 = list(map(reduce_list, img1)), list(map(reduce_list, img2))
        count_bits = lambda num: sum((num>>i)&amp;1 for i in range(n))   
        overlap = lambda lst1, lst2, sx1, sx2, sy1, sy2: sum(count_bits((row1>>sx1) &amp; (row2>>sx2)) for row1,row2 in zip(lst1[sy1:], lst2[sy2:]))
        overlap_xy = lambda lst1, lst2, dx, dy: overlap(lst1, lst2, dx if dx > 0 else 0, 0 if dx > 0 else -dx, dy if dy > 0 else 0, 0 if dy > 0 else -dy )
        return max(overlap_xy(img1, img2, dx, dy) for dx in range(-n+1, n) for dy in range(-n+1, n))",Medium,8,763,0.0,1,2.0,10.0,95.375,59.0,-4.66375
523.0,rectangle overlap,"class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):
        if (rec1[0] == rec1[2] or rec1[1] == rec1[3] or rec2[0] == rec2[2] or rec2[1] == rec2[3]):
            return False

        return not (rec1[2] <= rec2[0] or rec1[3] <= rec2[1] or rec1[0] >= rec2[2] or rec1[1] >= rec2[3])",Easy,5,300,0.0,0,2.0,1.0,60.0,25.0,1.9800000000000004
524.0,new 21 game,"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = collections.deque([float(i <= n) for i in range(k, k + maxPts)])
        s = sum(dp)
        for i in range(k):
            dp.appendleft(s / maxPts)
            s += dp[0] - dp.pop()
        
        return dp[0]",Medium,8,305,0.0,1,3.0,2.0,38.125,16.0,4.728750000000001
525.0,push dominoes,"class Solution:
    def pushDominoes(self, dominoes: str) -> str:
        mp = [0]*len(dominoes)
        ii = len(dominoes)
        for i in reversed(range(len(dominoes))): 
            if dominoes[i] != ""."": ii = i 
            mp[i] = ii 
            
        ans = []
        ii = -1 
        for i, x in enumerate(dominoes): 
            if dominoes[i] in ""LR"": 
                ans.append(dominoes[i])
                ii = i 
            else: 
                ll = ""L"" if ii == -1 else dominoes[ii]
                rr = ""R"" if mp[i] == len(dominoes) else dominoes[mp[i]]
                if ll == rr: ans.append(ll)
                elif ll == ""L"": ans.append(""."")
                else: 
                    if i - ii < mp[i] - i: ans.append(""R"")
                    elif i - ii > mp[i] - i: ans.append(""L"")
                    else: ans.append(""."")
        return """".join(ans)",Medium,23,881,0.0,8,4.0,10.0,38.30434782608695,41.0,1.7326086956521731
526.0,similar string groups,"class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        def similar(word1, word2):
            diff = []
            for a,b in zip(word1, word2):
                if a != b:
                    diff.append((a,b))
                    if diff and len(diff) > 2:
                        return False
            if diff and sorted(diff[0]) != sorted(diff[1]):
                return False
            return True
        
        graph = {}
        for i in range(len(strs)):
            graph[strs[i]] = []
            for j in range(len(strs)):
                if i != j and similar(strs[i], strs[j]):
                    graph[strs[i]].append(strs[j])
        # print(graph)
        
        visited = set()
        q = deque()
        group_count = 0
        for i in range(len(strs)):
            if strs[i] not in visited:
                group = []
                q.append(strs[i])
                while q:
                    node = q.popleft()
                    visited.add(node)
                    group.append(node)
                    for sim in graph[node]:
                        if sim not in visited:
                            q.append(sim)
                # print(group, visited)
                group_count += 1
        return group_count",Hard,37,1284,2.0,9,4.0,19.0,34.7027027027027,37.0,2.4767567567567568
527.0,magic squares in grid,"class Solution:
    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension 
        
        def fn(i, j): 
            """"""Return True if grid[i-1:i+2][j-1:j+2] is a magic squre.""""""
            seen = set()
            row, col = [0]*3, [0]*3 # row sum &amp; column sum 
            diag = anti = 0
            for ii in range(i-1, i+2):
                for jj in range(j-1, j+2):
                    if not 0 <= grid[ii][jj] < 10 or grid[ii][jj] in seen: return False 
                    seen.add(grid[ii][jj])
                    row[ii-i+1] += grid[ii][jj]
                    col[jj-j+1] += grid[ii][jj]
                    if ii-jj == i-j: diag += grid[ii][jj]
                    if ii+jj == i+j: anti += grid[ii][jj]
            return len(set(row)) == 1 and len(set(col)) == 1 and row[0] == col[0] == diag == anti
        
        ans = 0
        for i in range(1, m-1):
            for j in range(1, n-1): 
                if grid[i][j] == 5 and fn(i, j): ans += 1
        return ans",Medium,23,1052,2.0,6,4.0,9.0,45.73913043478261,64.0,-1.0365217391304355
528.0,keys and rooms,"class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        A, B = [0], []
        visited_room_set = set()
        while A:
            B = set([k for r in A for k in rooms[r] if k not in visited_room_set])
            visited_room_set.update(A)
            A, B = B, []
            
        return len(visited_room_set) == len(rooms)",Medium,9,363,0.0,1,3.0,4.0,40.333333333333336,17.0,4.430000000000001
529.0,split array into fibonacci sequence,"class Solution:
    def splitIntoFibonacci(self, S: str) -> List[int]:
        L, T, t = len(S), """", []
        for i in range(1,L-2):
        	for j in range(1,L-i-1):
        		if (i > 1 and S[0] == '0') or (j > 1 and S[i] == '0'): continue
        		a, b = int(S[:i]), int(S[i:i+j])
        		T, t = S[:i+j], [a,b]
        		while len(T) < L:
        			c = a + b
        			T += str(c)
        			t += [c]
        			a, b = b, c
        		if len(T) == L and T == S and len(t) > 2 and t[-1] < 2**31 - 1: return t
        return []
		
		
- Junaid Mansuri
(Leet Code ID)@hotmail.com",Medium,18,583,0.0,3,2.0,5.0,32.388888888888886,50.0,1.785000000000002
530.0,guess the word,"class Solution:
    def findSecretWord(self, wordlist: List[str], master: 'Master') -> None:
        master.guess(master._Master__secret)",Hard,2,137,0.0,1,2.0,0.0,68.5,7.0,2.955
531.0,backspace string compare,"class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        stack1 = [] # taking empty stack
        stack2 = [] # taking another empty stack
        
        for i in range(len(s)): # traversing through string s.
            if s[i] is not ""#"": # if the elem is not #
                stack1.append(s[i]) # will push it to the stack1
            else: # if it is ""#"" and there is some elem in stack1 then we`ll pop it else we`ll pass.
                if len(stack1)>0: 
                    stack1.pop()
                else:
                    pass
                
        for i in range(len(t)): # traversing through string t.       
            if t[i] is not ""#"": # if the elem is not #
                stack2.append(t[i]) # will push it to the stack2
            else: # if it is ""#"" and there is some elem in stack2 then we`ll pop it else we`ll pass.
                if len(stack2)>0:
                    stack2.pop()
                else:
                    pass
                
        return stack1 == stack2 # returning if they are equal when both are typed into empty text editors",Easy,23,1114,11.0,6,4.0,11.0,48.43478260869565,24.0,3.080869565217391
532.0,longest mountain in array,"class Solution:
""""""
192ms 40.16% time
14.7MB 86.68% space
""""""
    def longestMountain(self, A: List[int]) -> int:
        if len(A)<3:return 0
        curr=-1
        itr=1
        while itr+1<len(A):
            if A[itr-1]<A[itr] and A[itr]>A[itr+1]:
                j,k=itr-1,itr+1
                temp=3
                while j-1>=0:
                    if A[j-1]<A[j]:
                        temp+=1
                        j-=1
                    else:break
                while k+1<len(A):
                    if A[k+1]<A[k]:
                        temp+=1
                        k+=1
                    else:break
                curr=max(curr,temp)
            itr+=1
        return curr if curr!=-1 else 0



Java Solution: 2ms beat 96.71%, 40.2MB beats 92.82%

class Solution {
    public int longestMountain(int[] A) {
        if(A.length<3){return 0;}
        int curr=-1;
        int itr=1;
        while(itr+1<A.length){
            if(A[itr]>A[itr+1]&amp;&amp;A[itr]>A[itr-1]){
                int j=itr-1;
                int k=itr+1;
                int temp=3;
                while(j-1>=0){
                    if(A[j-1]<A[j]){
                        temp+=1;
                        j-=1;
                    }
                    else{break;}
                }
                while(k+1<A.length){
                    if(A[k+1]<A[k]){
                        temp+=1;
                        k+=1;
                    }
                    else{break;}
                }
                curr=(curr<temp)?temp:curr;
            }
            itr+=1;
        }
        return (curr!=-1)?curr:0;
    }
}",Medium,61,1629,0.0,0,4.0,15.0,26.704918032786885,63.0,1.0565573770491792
533.0,hand of straights,"class Solution:
    def isNStraightHand(self, hand, W):
        """"""
        :type hand: List[int]
        :type W: int
        :rtype: bool
        """"""
        cnt=collections.Counter(hand)
        _h=[]
        for h in hand:
            heapq.heappush(_h,h)
        
        while _h:
            curEle=heapq.heappop(_h)
            if cnt[curEle]==0:
                continue            
            for i in range(W):
                if cnt[curEle+i]<=0:
                    return False   
                else:
                    cnt[curEle+i]-=1
        return True",Medium,21,574,0.0,3,3.0,5.0,27.33333333333333,26.0,4.58
534.0,shortest path visiting all nodes,"class Solution:
    def shortestPathLength(self, graph: List[List[int]]) -> int:
        q = []
        n = len(graph)
        for i in range(n):
            visit = set()
            visit.add(i)
            q.append([i, visit])
        
        steps = 0
        while q:
            num = len(q)
            for i in range(num):
                node, visit = q.pop(0)
                #print(node, visit)
                if len(visit) == n:
                    return steps
                for nei in graph[node]:
                    temp = visit.copy()
                    temp.add(nei)
                    q.append([nei, temp])
            if q:steps += 1",Hard,21,659,1.0,6,4.0,6.0,31.38095238095238,26.0,4.015714285714285
535.0,shifting letters,"class Solution:
    def shiftingLetters(self, S: str, shifts: List[int]) -> str:
        for i in range(len(shifts)-2, -1, -1):
            shifts[i] += shifts[i+1]
        return ''.join(chr((ord(c) - ord('a') + shift) % 26 + ord('a'))
                       for c, shift in zip(S, shifts))",Medium,5,291,0.0,1,3.0,10.0,58.2,13.0,3.2220000000000004
537.0,rectangle area ii,"class Solution:
    def rectangleArea(self, rectangles: List[List[int]]) -> int:
        line = []
        for x1, y1, x2, y2 in rectangles: 
            line.append((y1, x1, x2, 1))
            line.append((y2, x1, x2, 0))
        
        ans = yy = val = 0
        seg = []
        for y, x1, x2, tf in sorted(line): 
            ans += val * (y - yy)
            yy = y 
            if tf: insort(seg, (x1, x2))
            else: seg.remove((x1, x2))
            val = 0 
            prev = -inf 
            for x1, x2 in seg: 
                val += max(0, x2 - max(x1, prev))
                prev = max(prev, x2)
        return ans % 1_000_000_007",Hard,19,654,0.0,4,3.0,4.0,34.421052631578945,40.0,2.482105263157896
538.0,loud and rich,"class Solution:
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        #Let len(richer) = n and let len(quiet) = m!
        #Time: O(n + m + m + m*m + m +  m) -> O(m^2 + n)
        #Space: O(m*m + m + m + m*m + m) -> O(m^2)
        #step 1: build adjacency list representation and update indegrees of every node initially!
        adj = [[] for _ in range(len(quiet))]
        indegrees = [0] * len(quiet)
        #we want edges to go from richer to poorer so that ancestors of every node are all people
        #who have more money than the node person!
        for rel in richer:
            richer, poorer = rel[0], rel[1]
            adj[richer].append(poorer)
            indegrees[poorer] += 1
        
        queue = deque()
        ancestors = []
        for i in range(len(quiet)):
            new = set()
            new.add(i)
            ancestors.append(new)
        #step 2: fill in the queue all nodes that have indegrees of 0!

        #step 3: proceeding with Kahn's algorithm and recording list of all ancestors to every node!
        while queue:
            cur = queue.pop()
            for neighbor in adj[cur]:
                ancestors[neighbor].add(cur)
                ancestors[neighbor].update(ancestors[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] == 0):
                    queue.append(neighbor)
        
        ancestors = [list(s) for s in ancestors]
        output = []
        #step 4:for each person, find the least quiet person who also has more money than the current               #person we're iterating on!
        for a in range(len(ancestors)):
            cur_ancestors = ancestors[a]
            if(len(cur_ancestors) == 1):
                output.append(a)
                continue
            minimum = cur_ancestors[0]
            for ancestor in cur_ancestors:
                #check if current person with more money than person a has lower quiet level!
                if(quiet[ancestor] < quiet[minimum]):
                    minimum = ancestor
            output.append(minimum)
        return output",Medium,47,2132,10.0,5,3.0,13.0,45.361702127659576,50.0,0.8374468085106379
539.0,peak index in a mountain array,"class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        s,e=0,len(arr)-1
        while s<e:
            m=s+(e-s)//2
            if arr[m]<arr[m+1]:
                s=m+1
            else:
                e=m
        return s",Medium,9,256,0.0,2,3.0,2.0,28.444444444444443,16.0,5.54
540.0,car fleet,"class Solution:  # O(NlogN)
    
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        stack = [] # no. of fleet
        
        # pair of distance and speed to sort it
        pair = [(p,s) for p,s in zip(position,speed) ]
        
        # sort the pair based on positions and travesing from reverse order
        for p,s in sorted(pair)[::-1]:
            
            # find the time
            t = (target - p) /s
            
            stack.append(t)
            
            if len(stack) >= 2 and stack[-1] <= stack[-2]:  #  fleet
                stack.pop()
        
        return len(stack)
		```
		feel free to ask Q...
		#happytohelpu",Medium,22,690,7.0,2,3.0,3.0,31.363636363636363,24.0,4.757272727272728
541.0,k similar strings,"class Solution:
    def kSimilarity(self, A: str, B: str) -> int:
        la = []
        lb = []
        for a, b in zip(A, B):
            if a != b:
                la.append(a)
                lb.append(b)
        queue = {''.join(la): 0}
        while lb:
            q = {}
            for pre, swap in queue.items():
                if pre[-1] != lb[-1]:
                    eq = []
                    for i, ch in enumerate(pre[:-1]):
                        if ch == lb[-1] and lb[i] != ch:
                            eq.append(i)
                            if lb[i] == pre[-1]:
                                eq = [i]
                                break
                    for i in eq:
                        tmp = pre[:i] + pre[-1] + pre[i + 1:-1]
                        q[tmp] = min(swap + 1, q.get(tmp, float('inf')))
                else:
                    q[pre[:-1]] = min(swap, q.get(pre[:-1], float('inf')))
            lb.pop()
            queue = q
        return list(queue.values())[0]",Hard,27,1018,0.0,8,5.0,9.0,37.7037037037037,50.0,0.8266666666666662
542.0,score of parentheses,"class Solution:
    def scoreOfParentheses(self, S: str) -> int:
        left_parenthesis_count = 0
        score = 0
        score_flag = False
        for c in S:
            if c == '(':
                left_parenthesis_count += 1
                score_flag = True
            else:
                left_parenthesis_count -= 1
                if score_flag:
                    score += pow(2, left_parenthesis_count)
                    
                score_flag = False
        
        return score",Medium,16,506,0.0,3,4.0,3.0,31.625,21.0,4.63375
543.0,minimum cost to hire k workers,"class Solution:
    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:
        
        
        workers=[]
        for w,q in zip(wage, quality):
            workers.append([float(w) / q, q] )
        workers.sort()
        print(workers)                   
        res = float('inf')
        qsum = 0
        heap = []
        for r, q in workers:
            
            heapq.heappush(heap, -q)
            #print(heap)
            qsum += q
            if len(heap) > K:
                qsum += heapq.heappop(heap)
            if len(heap) == K:
                res = min(res, qsum * r)
        print(heap)
        return res",Hard,22,666,1.0,4,3.0,4.0,30.27272727272728,30.0,3.8954545454545455
544.0,mirror reflection,"class Solution:
    def mirrorReflection(self, p: int, q: int) -> int:
    	g = math.gcd(p,q)
    	return 2 if not p//g % 2 else q//g % 2
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,7,186,0.0,0,1.0,1.0,26.571428571428573,9.0,6.648571428571429
545.0,buddy strings,"class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        l = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                l.append(i)
        return (len(l) == 2 and s[l[0]] == goal[l[1]] and s[l[1]] == goal[l[0]]) or (len(l) == 0 and max(Counter(s).values()) > 1)",Easy,8,365,0.0,2,3.0,3.0,45.625,26.0,2.9937499999999995
546.0,lemonade change,"class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        # meet 20 , give 10 prior to 5.
        bill_5, bill_10, bill_20 = 0, 0, 0
        for bill in bills:
            if bill == 5:
                bill_5 += 1
            elif bill == 10:
                bill_10 += 1
                bill_5 -= 1
            elif bill == 20:
                if bill_10:
                    bill_10 -= 1
                    bill_5 -= 1
                else:
                    bill_5 -= 3
            if bill_5 < 0:
                return False
        return True",Easy,18,573,1.0,5,4.0,6.0,31.83333333333333,34.0,3.2349999999999994
547.0,score after flipping matrix,"class Solution:
    def matrixScore(self, G: List[List[int]]) -> int:
        G, M, N = list(zip(*[[b^g[0]^1 for b in g] for g in G])), len(G), len(G[0])
        return sum(max(sum(g),M-sum(g))*2**(N-i-1) for i,g in enumerate(G))

		
- Junaid Mansuri
- Chicago, IL",Medium,7,264,0.0,0,1.0,3.0,37.71428571428572,13.0,5.245714285714286
548.0,shortest subarray with sum at least k,"class Solution:
    def shortestSubarray(self, A: List[int], K: int) -> int:
    	C, m, a = [0]+list(itertools.accumulate(A)), float('inf'), collections.deque()
    	for i, c in enumerate(C):
    		while a and C[a[-1]] >= c: a.pop()
    		while a and c - C[a[0]] >= K: m = min(m, i - a.popleft())
    		a.append(i)
    	return -1 if m == float('inf') else m
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Hard,11,406,0.0,3,1.0,4.0,36.90909090909091,25.0,3.9381818181818193
549.0,all nodes distance k in binary tree,"class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        # dfs1: generate parent hashmap { node : prnt }
        # this lets us traverse up as well as down
        # then dfs2 starting from target
        # add seen nodes to set to avoid looping, otherwise take K steps away
        # O(N) time, O(N + H) space including recursive calls to tree height

        # helper function to get parents
        def get_prnts(node, parent):
            if not node: return
            d[node] = parent
            get_prnts(node.left, node)
            get_prnts(node.right, node)

        d = {}
        get_prnts(root, None)

        # helper function to step from target
        def rcrs(node, dist):
            if (not node) or (node in seen): return
            seen.add(node)

            if dist == K:
                res.append(node.val)
            else:
                rcrs(node.left, dist+1)
                rcrs(node.right, dist+1)
                rcrs(d[node], dist+1)

        res = []
        seen = set()
        rcrs(target, 0)
        return res

    def distanceK1(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        # recursive dfs only: find target, update distance, re-traverse branches
        # dist initially inf until target found
        # O(N) ish time, O(H) recursive call space

        def rcrs(node, dist):
            if node is target:
                dist = 0

            # check distance of kids to target
            lt, rt = float(""inf""), float(""inf"")
            if node.left:  lt = rcrs(node.left, dist+1)
            if node.right: rt = rcrs(node.right, dist+1)

            # update node distance from children if not yet updated
            if dist == float(""inf""): dist = min(lt, rt)

            # add node.val to result list if K steps from target
            if dist == K: self.res.append(node.val)

            # if target found, one branch hasn't seen it, redo said branch
            if dist < float(""inf""):
                if node.left and lt == float(""inf""):  rcrs(node.left, dist+1)
                if node.right and rt == float(""inf""): rcrs(node.right, dist+1)
            return dist+1

        # setup &amp; recursive call
        self.res = []
        rcrs(root, float(""inf""))
        return self.res",Medium,64,2315,15.0,7,3.0,14.0,36.171875,86.0,-1.85546875
550.0,shortest path to get all keys,"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:
        dir = [[1,0], [-1,0], [0,1], [0,-1]]
        m = len(grid)
        n = len(grid[0])
        
        q = []
        k = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '@': q.append([i, j, ''])
                elif grid[i][j].islower(): k += 1

        visited = set()
        moves = 0
        while q:
            new_q = []
            for row, col, keys in q:
                if len(keys) == k: return moves
                if ((row, col, keys) in visited): continue
                visited.add((row, col, keys))
                for r, c in dir:
                    nr, nc = row + r, col + c
                    if nr < 0 or nr == m or nc < 0 or nc == n: continue 
                    val = grid[nr][nc]
                    if val == '#': continue
                    if val == '.' or val == '@' or val in keys: new_q.append([nr, nc, keys])
                    elif val.islower(): new_q.append([nr, nc, keys + val])
                    elif val.lower() in keys: new_q.append([nr, nc, keys])
            moves += 1
            q = new_q
        return -1",Hard,31,1185,1.0,10,4.0,14.0,38.2258064516129,79.0,-2.1403225806451616
551.0,smallest subtree with all the deepest nodes,"class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        # recursive dfs approach
        # helper function: pass ""level"" when descending, return (node, max_depth)
        # if left depth == right_depth, return yourself
        # else return the side with greater depth
        # O(N) time, O(H) stack calls

        def rcrs(node, level):
            if not node: return (None, level-1)

            lt_node, lt_depth = rcrs(node.left, level+1)
            rt_node, rt_depth = rcrs(node.right, level+1)

            if not lt_node and not rt_node:
                return (node, level)

            if lt_depth == rt_depth:
                return (node, lt_depth)
            else:
                if lt_depth > rt_depth:
                    return (lt_node, lt_depth)
                else:
                    return (rt_node, rt_depth)

        # setup &amp; recursive call
        return rcrs(root, 0)[0]",Medium,26,939,6.0,-4,3.0,5.0,36.11538461538461,37.0,3.349615384615385
552.0,prime palindrome,"class Solution:
    def primePalindrome(self, k: int) -> int:
        def is_prime(num):
            if num % 2 is 0: return False
            return all(num%i for i in range(3, int(num**0.5)+1, 2))
        
        if k < 12:
            return next(x for x in [2,3,5,7,11] if x >= k)
        else:
            string_k = str(k)
            string_length = len(string_k)
            
            if string_length % 2:
                starting_root = int(string_k[:string_length-string_length//2])
                for root in range(starting_root, 10**6):
                    root = str(root)
                    palindrome_gen = int(root + root[-2::-1])
                    if is_prime(palindrome_gen) and palindrome_gen >= k:
                        return palindrome_gen
            else:
                starting_root = str(10**(string_length-string_length//2))
                starting_reverse = starting_root[-2::-1]
                for root in range(int(starting_root), 10**6):
                    palindrome_gen = int(str(root) + starting_reverse)
                    if is_prime(palindrome_gen) and palindrome_gen >= k:
                        return palindrome_gen",Medium,25,1173,0.0,3,4.0,10.0,46.92,43.0,1.0572
553.0,transpose matrix,"class Solution:
    def transpose(self, A: List[List[int]]) -> List[List[int]]:
        A = list(map(list, zip(*A)))
        return A",Easy,3,133,0.0,0,2.0,0.0,44.333333333333336,7.0,5.19
554.0,binary gap,"class Solution:
    def binaryGap(self, n: int) -> int:
        return max((lambda x: [x[i+1]-x[i] for i in range(len(x)-1)])([i for i,j in enumerate(bin(n)) if j == '1']), default = 0)
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Easy,6,234,0.0,0,1.0,3.0,39.0,12.0,5.23
555.0,reordered power of 2,"class Solution:
    def reorderedPowerOf2(self, N: int) -> bool:
        def str2dict(s):
            d = {}
            for i, e in enumerate(s):
                if e in d:
                    d[e] = d[e] + 1
                else:
                    d[e] = 1
            return d
        
        s = str(N)
        l = len(s)
        d = str2dict(s)
        
        i = 0
        result = False
        while not result:
            two_power = 2**i
            s_two_power = str(two_power)
            if len(s_two_power) == l:
                result = str2dict(s_two_power) == d
            elif len(s_two_power) > l:
                break
            i += 1
        return result",Medium,25,686,0.0,3,3.0,5.0,27.44,32.0,3.9704
556.0,advantage shuffle,"class Solution:
    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
        A.sort()
        mp = {}
        for x in sorted(B, reverse=True): 
            if x < A[-1]: mp.setdefault(x, []).append(A.pop())
        
        ans = []
        for x in B: 
            if x in mp and mp[x]: 
                ans.append(mp[x].pop())
            else: 
                ans.append(A.pop())
        return ans",Medium,13,421,0.0,4,3.0,4.0,32.38461538461539,18.0,4.865384615384615
557.0,minimum number of refueling stops,"class Solution:
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        ans = k = 0 
        total = startFuel 
        pq = [] 
        while total < target: 
            while k < len(stations) and stations[k][0] <= total: 
                heappush(pq, -stations[k][1]) 
                k += 1
            if not pq: return -1 
            total -= heappop(pq)
            ans += 1
        return ans",Hard,12,447,0.0,2,3.0,3.0,37.25,24.0,3.9475
558.0,leaf similar trees,"class Solution:
	def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
		return self.helper(root1)==self.helper(root2)       
	def helper(self,root):
		res=[]
		if not root:
			return []
		if not root.left and not root.right:
			res.append(root.val)
		res+=self.helper(root.left)
		res+=self.helper(root.right)
		return res",Easy,11,334,0.0,0,1.0,2.0,30.363636363636363,17.0,5.507272727272728
559.0,length of longest fibonacci subsequence,"class Solution:
    def lenLongestFibSubseq(self, A: List[int]) -> int:
    	L, M, AA = len(A), 0, {i for i in A}
    	for i in range(L-1):
    		for j in range(i+1,L):
    			a, b, s = A[i], A[j], 0
    			while a in AA: a, b, s = b, a + b, s + 1
    			if s > M: M = s
    			if a > A[-1]:
    				if j == i + 1:
    					return 0 if M == 2 else M
    				break
					
					
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,15,418,0.0,5,1.0,8.0,27.866666666666667,36.0,3.532
560.0,walking robot simulation,"class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        # 0) Keep obstacke in set for future reference
        obstacle_set = set()
        for o in obstacles:
            obstacle_set.add((o[0], o[1]))

        # 1) Define movement functions and way to turn direction
        up = lambda pos: (pos[0], pos[1]+1)
        down = lambda pos: (pos[0], pos[1]-1)
        left = lambda pos: (pos[0]-1, pos[1])
        right = lambda pos: ((pos[0]+1, pos[1]))
        moves = [up, right, down, left]
        cpos = (0, 0)
        mi = 0
        def turn(mi, v):
            return (mi + 1) % 4 if v == -1 else (mi - 1 + 4) % 4

        move = lambda pos: moves[mi](cpos)
        
        # 2) Execute the command(s)
        max_dist = 0
        for cmd in commands:
            if cmd < 0:
                mi = turn(mi, cmd)                
            else:
                for _ in range(cmd):
                    next_pos = move(cpos)
                    if next_pos in obstacle_set:
                        break

                    cpos = next_pos
        
            max_dist = max(max_dist, pow(cpos[0], 2) + pow(cpos[1], 2))
            
        # 3) Return the result
        return max_dist",Medium,36,1244,4.0,2,3.0,7.0,34.55555555555556,51.0,1.6500000000000004
561.0,koko eating bananas,"class Solution:
    def minEatingSpeed(self, piles: List[int], hour: int) -> int:
        l=1
        h=max(piles)
        def fun(speed):
            ans=0
            for i in piles:
                ans+=ceil(i/speed)
            #print(ans)
            if ans>hour:
                return False
            return True
        ans=h
        while(l<=h):
            
            mid=(l+h)//2
           
            if fun(mid):
                ans=min(ans,mid)
                h=mid-1
            else:
                l=mid+1
        return ans",Medium,22,549,1.0,1,3.0,4.0,24.954545454545453,26.0,4.95409090909091
562.0,middle of the linked list,"class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pos=0
        curr=head
        while(curr!=None):
            pos+=1
            curr=curr.next
        curr=head
        for i in range(pos//2):
            curr=curr.next
        return curr",Easy,10,291,0.0,1,3.0,2.0,29.1,14.0,5.7410000000000005
563.0,stone game,"class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        @functools.cache
        def doIWin(l,r):
            if l > r: return 0
            
            left = piles[l] - doIWin(l+1,r) # `-` because my opponent!
            
            right= piles[r] - doIWin(l,r-1)
            
            return max(left, right)
        
        return (doIWin(0,len(piles)-1) + sum(piles) )//2",Medium,12,403,1.0,-1,3.0,1.0,33.583333333333336,15.0,5.3975
564.0,nth magical number,"class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        def gcd(x,y):
            if(x==0):
                return y
            return gcd(y%x,x)
        lcm=(a*b)//gcd(a,b)
        s=set()
        x=a
        while(x<=lcm):
            s.add(x)
            x+=a
        x=b
        while(x<=lcm):
            s.add(x)
            x+=b
        
        le=0
        l=[]
   
        for i in s:
            l.append(i)
            le+=1
        l.sort()    #sort all multiples of a and b which are less than their lcm.
        
        #below approach is based on pattern observation. Try to take some example and observer the pattern(e.g n=4,8,9,16,18,41 #a=3, b=7)
        r=n%le
        q=n//(le+1)
      
        if(q==0):
            return l[n-1]
        else:
            q=n//le
            res=  ((q*l[-1])%1000000007)
            if(r>0):
                  res=(res+ l[r-1]) %1000000007
            return res",Hard,36,951,2.0,-2,3.0,6.0,26.416666666666668,54.0,2.2425000000000006
565.0,profitable schemes,"class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        MOD = 1_000_000_007
        
        @cache
        def fn(i, n, p): 
            """"""Return count at i with n people remaining and p profit to make.""""""
            if n < 0: return 0
            if i == len(group): return p <= 0 
            return (fn(i+1, n, p) + fn(i+1, n-group[i], p-profit[i])) % MOD

        return fn(0, n, minProfit)",Hard,11,466,0.0,-2,3.0,2.0,42.36363636363637,29.0,3.2272727272727275
566.0,decoded string at index,"class Solution:
    def decodeAtIndex(self, S: str, K: int) -> str:
		# e.g. S == 'ab2c3d'
		# ls_len: list of lengths of new patterns [2, 5] (ab, ababc)
		# ls_total_len: list of lengths of times * new pattern [4, 15] (abab, ababcababcababc)
		# ls_pattern: list of new additional pattern ['ab', 'c']
        ls_len = []
        ls_total_len = []
        ls_pattern = []
        tmp = ''
        length = 0
        # flag for string without integer
		prev_num = -1
		
        for i in range(len(S)): 
            value = S[i]
            if i == 0: 
				# first char is letter only
                tmp = value
                length = 1
                continue
            if 50 <= ord(value) <= 57: 
                if tmp: 
					# if not more than one integer appearing together
                    ls_pattern.append(tmp)
                    ls_len.append(length)
                    ls_total_len.append(length * int(value))
                else: 
					# e.g. S = 'a23', here ls_total_len will change from [2] (aa) to [6] (aaaaaa). 
					# The other two lists unchanged.
                    ls_total_len[-1] = length * int(value)
                length = length * int(value)
                tmp = ''
                prev_num = i
            else: 
                tmp += value
                length += 1       
        
		# residual is the last part left with no multiplier, e.g. S = 'ab2c3d', then the last 'd' is the residual
        residual = tmp
		if prev_num < 0: 
			# if no integer is in S, return the (K - 1)th element. 
            return S[K - 1]
       
        if K > ls_total_len[-1]: 
			# if K is within the first pattern
            return residual[K - ls_total_len[-1] - 1]
        if K <= ls_total_len[0]: 
			# if K is in the residual
            ptn = ls_pattern[0]
            len_ptn = ls_len[0]
            return ptn[(K - 1) % len_ptn]
        
        def bs(k, lb, ub, ls): 
			# binary search of K's location in the two lists: ls_len &amp; ls_total_len
            if k <= ls[lb]: 
                return lb - 1
            if k > ls[ub]: 
                return ub
            if ub == lb + 1: 
                return lb
            mid = (lb + ub) // 2
            if k == ls[mid]: 
                return mid - 1
            elif k < ls[mid]:
                return bs(k, lb, mid, ls)
            else: 
                return bs(k, mid + 1, ub, ls)
         
		# due to the nature of the two lists, idx1 >= idx2
        idx1 = bs(K, 0, len(ls_pattern) - 1, ls_len)
        idx2 = bs(K, 0, len(ls_pattern) - 1, ls_total_len)

        while idx1 != idx2 and idx2 != -1: 
			# if idx1 ==  idx2, (K - 1)th element is in the new additional pattern
			# if idx2 == -1, (K - 1)th element is in the first pattern
            K %= ls_len[idx1]
            if not K: 
                K = ls_len[idx1]
            idx1 = bs(K, 0, idx1, ls_len)
            idx2 = bs(K, 0, idx2, ls_total_len)
        if idx2 == -1: 
            return ls_pattern[0][K % ls_len[0] - 1]
        if idx1 == idx2: 
            return ls_pattern[idx1 + 1][K - ls_total_len[idx1] - 1]",Medium,84,3087,17.0,4,3.0,23.0,36.75,131.0,-6.147500000000001
567.0,boats to save people,"class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort() # ascending 
        
        ans, lo, hi = 0, 0, len(people)-1
        while lo <= hi: 
            ans += 1
            if lo < hi and people[lo] + people[hi] <= limit: lo += 1
            hi -= 1
        return ans",Medium,9,323,1.0,2,3.0,2.0,35.888888888888886,22.0,4.3100000000000005
568.0,reachable nodes in subdivided graph,"class Solution:
    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
        graph = defaultdict(dict)
        dp = defaultdict(dict)
        
        for v1, v2, wt in edges:
            graph[v1][v2] = wt + 1
            graph[v2][v1] = wt + 1
            dp[v1][v2] = 0
            dp[v2][v1] = 0
        
        #print(graph)
        
        def dijkstra(graph, dp):
            
            myheap = [(0, 0)]
            distances = [float(inf)] * n
            distances[0] = 0
            
            while myheap:
                cost, node = heappop(myheap)
                if cost > maxMoves or cost > distances[node]:
                    continue
                    
                for nxtNode, nxtCost in graph[node].items():
                    totalCost = nxtCost + cost
                    remainingMoves = maxMoves - cost
					# nxtCost is the distance bw node and nxtNode so there are nxtCost - 1 new nodes in bw them
					# If remainingMoves are greater than number of new nodes bw them -> it mean we can reach all nodes between the current pair of nodes
                    dp[node][nxtNode] = max(dp[node][nxtNode], min(remainingMoves, nxtCost - 1))
                    
                    if totalCost > distances[nxtNode] or totalCost > maxMoves:
                        continue
                    
                    distances[nxtNode] = totalCost
                    heappush(myheap, (totalCost, nxtNode))
                    #print(nxtNode, distances)
            
            return dp, distances
        
        dp, dist = dijkstra(graph, dp)
        #print(dist)
        #print(dp)
        ans = 0
        for key in dp:
            for node, num in dp[key].items():
                total = dp[node][key] + num
                ans += min(total, graph[key][node] - 1)
		# each pair is counted twice so we need to divide by 2
        ans = ans // 2
        
		# count how many old nodes are reachable
        for elem in dist:
            if elem != float(inf):
                ans += 1
        
        return ans",Hard,56,2081,8.0,6,3.0,10.0,37.160714285714285,61.0,0.3355357142857151
570.0,uncommon words from two sentences,"class Solution:
    def uncommonFromSentences(self, A: str, B: str) -> List[str]:
    	S = [collections.Counter(A.split()),collections.Counter(B.split())]
    	return [j for i in range(2) for j in S[i] if S[i][j] == 1 and j not in S[1-i]]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Easy,7,287,0.0,0,1.0,3.0,41.0,12.0,5.05
571.0,spiral matrix iii,"class Solution:
    def spiralMatrixIII(self, M: int, N: int, x: int, y: int) -> List[List[int]]:
        A, d = [[x,y]], 0
        while len(A) < M*N:
            for s in 1,-1:
                d += 1
                for y in range(y+s,y+s*(d+1),s):
                    if 0<=x<M and 0<=y<N: A.append([x,y])
                for x in range(x+s,x+s*(d+1),s):
                    if 0<=x<M and 0<=y<N: A.append([x,y])
        return A
        
		
- Junaid Mansuri
- Chicago, IL",Medium,14,475,0.0,6,3.0,6.0,33.92857142857143,43.0,2.106428571428572
572.0,possible bipartition,"class Solution:
    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:
        
        d = deque([])
        colors = {}
        
        graph = {i: [] for i in range(1, N+1)}
        
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
            
        for i in graph.keys():
            
            if i not in colors:
                colors[i] = 1
                d.append(i)
                
                while d:
                    
                    item = d.popleft()
                    for ch in graph[item]:
                        
                        if ch in colors:
                            if colors[ch] == colors[item]:
                                return False
                        else:
                            colors[ch] = 1 - colors[item]
                            d.append(ch)
        return True",Medium,29,912,0.0,6,4.0,8.0,31.448275862068964,27.0,3.869655172413792
573.0,super egg drop,"class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        return self.solve(k,n)
    
    def solve(self,e,f):
        if f == 0 or f == 1:
            return f
        if e == 1:
            return f
        
        ans = float('inf')
        
        for k in range(1,f):
            temp = 1 + max(self.solve(e-1,k-1), self.solve(e,f-k))
            ans = min(ans,temp)
            
        return ans",Hard,16,422,0.0,0,3.0,3.0,26.375,31.0,4.34625
574.0,fair candy swap,"class Solution:
    def fairCandySwap(self, A, B):
        Sa = sum(A)
        Sb = sum(B)
        setB = set(B)
        for x in A:
            if x + (Sb - Sa) / 2 in setB:
                return [x, x + (Sb - Sa) / 2]",Easy,7,220,0.0,2,3.0,2.0,31.428571428571427,10.0,5.871428571428572
575.0,construct binary tree from preorder and postorder traversal,"class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> TreeNode:
        pre_index, post_index  = 0, 0
        def dfs(prev_val):
            nonlocal pre_index
            nonlocal post_index

            if prev_val == postorder[post_index]:
                return None
            
            node = TreeNode(preorder[pre_index])
            pre_index += 1

            node.left = dfs(node.val)
            node.right = dfs(node.val)

            post_index += 1

            return node
        return dfs(-1)",Medium,19,557,0.0,-1,3.0,1.0,29.31578947368421,20.0,5.241578947368422
576.0,find and replace pattern,"class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        
        
        
        ans=[]
        
        for j in words:
            
            if len(j)==len(pattern):
                if len(set(j)) == len(set(pattern)):
                    
                    pe={}
                    we={}
                    
                    h=0
                    for i in range(1,len(pattern)):
                        
                        if pattern[i]==pattern[i-1]:
                            if j[i-1]!=j[i]:
                                h+=1
                                break
                        elif pattern[i]!=pattern[i-1]:
                            if j[i-1]==j[i]:
                                h+=1
                                break
                        
                        if pattern[i] not in pe:
                            pe[pattern[i]]=1
                            if j[i] in we:
                                h+=1
                                break
                            else:
                                we[j[i]]=1
                        
                        if pattern[i] in pe:
                            pe[pattern[i]]+=1
                            
                            if j[i] not in we:
                                h+=1
                                break
                            else:
                                we[j[i]]+=1
                                
                    
                        
                    if h==0 and sorted(list(we.values()))==sorted(list(pe.values())):
                        ans.append(j)
                        
        return ans",Medium,49,1724,0.0,9,6.0,13.0,35.18367346938776,55.0,0.4334693877551032
577.0,sum of subsequence widths,"class Solution:
    def sumSubseqWidths(self, nums: List[int]) -> int:
        MOD = 1_000_000_007
        ans = 0 
        for i, x in enumerate(sorted(nums)): 
            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))
        return ans % MOD",Hard,6,255,0.0,1,2.0,1.0,42.5,14.0,4.595000000000001
578.0,surface area of 3d shapes,"class Solution:
    def surfaceArea(self, G: List[List[int]]) -> int:
        N, C = len(G), [(1,0),(0,-1),(-1,0),(0,1)]
        G, S = [[0]*(N+2)] + [[0]+g+[0] for g in G] + [[0]*(N+2)], 2*N**2 - 2*sum(G,[]).count(0)
        for i,j in itertools.product(range(1,N+1),range(1,N+1)): S += sum(max(0,G[i][j]-G[i+x][j+y]) for x,y in C)
        return S
		
		
- Junaid Mansuri",Easy,8,372,0.0,1,2.0,3.0,46.5,27.0,2.9350000000000005
579.0,groups of special equivalent strings,"class Solution:        
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        return len(set(''.join(sorted(stri[i] for i in range(len(stri)) if i%2==0)) + ''.join(sorted(stri[i] for i in range(len(stri)) if i%2!=0)) for stri in A))",Medium,2,244,0.0,0,3.0,5.0,122.0,9.0,-2.0600000000000005
580.0,all possible full binary trees,"class Solution:
    def allPossibleFBT(self, N: int) -> List[TreeNode]:
        #impossible to satisfy the conditions
        if N % 2 == 0:
            return []
        
        full_list = {}
        
        #base cases
        full_list[1] = [TreeNode(0)]
        temp = TreeNode(0)
        temp.left = full_list[1][0]
        temp.right = full_list[1][0]
        full_list[3] = [temp]
        
        for x in range(5, N+1, 2):
            full_list[x] = []
            n_left = 1
            n_right = (x - 1) - n_left  # x-1 to exclude the root node
            
            #go through all combinations of children trees that add to x-1
            while n_right >= 1:
                for l_tree in full_list[n_left]:
                    for r_tree in full_list[n_right]:
                        temp = TreeNode(0)
                        temp.left = l_tree
                        temp.right = r_tree
                        #print(temp)
                        full_list[x].append(temp)
                
                n_left += 2
                n_right -= 2
        
        #print(len(full_list[N]))
        return full_list[N]",Medium,34,1143,6.0,4,4.0,5.0,33.61764705882353,31.0,3.634411764705882
581.0,monotonic array,"class Solution:
    
    def is_increasing(self, items):
        start_value = items[0]
        for value in items: 
            if value > start_value:
                return True
            if value < start_value:
                return False
            
    def get_comparison_function(self, is_increasing):
        def is_asscending(a, b):
            return a <= b
        
        def is_decending(a, b):
            return a >= b
        
        if is_increasing: 
            return is_asscending
        return is_decending
    
    def isMonotonic(self, A: List[int]) -> bool:
        is_increasing = self.is_increasing(A)
        is_monotonic = self.get_comparison_function(is_increasing)
        
        for index in range(1, len(A)):
            previous_item = A[index - 1]
            item = A[index]
            if not is_monotonic(previous_item, item):
                return False
            
        return True",Easy,31,935,0.0,-1,3.0,6.0,30.161290322580644,32.0,3.9654838709677422
582.0,increasing order search tree,"class Solution(object):
    def increasingBST(self, root):
        """"""
        :type root: TreeNode
        :rtype: TreeNode
        """"""
        self.all_nodes = []

        def find_all_nodes(root):
            if root:
                self.all_nodes.append(root.val)
                find_all_nodes(root.left)
                find_all_nodes(root.right)

        find_all_nodes(root)
        self.all_nodes.sort()

        tree = TreeNode(self.all_nodes.pop())
        while len(self.all_nodes) > 0:
            t = TreeNode(self.all_nodes.pop())
            t.left = None
            t.right = tree
            tree = t

        return tree",Easy,24,641,0.0,2,3.0,2.0,26.70833333333333,17.0,5.59625
583.0,bitwise ors of subarrays,"class Solution:
    def subarrayBitwiseORs(self, A: List[int]) -> int:
        ans, vals = set(), set()
        for x in A: 
            vals = {x | xx for xx in vals} | {x}
            ans |= vals
        return len(ans)",Medium,6,221,0.0,1,3.0,2.0,36.833333333333336,11.0,5.345000000000001
584.0,orderly queue,"class Solution:
    def calcS(self,s):
        res = 0
        for x in s:
            res *= 26
            res += (ord(x)-96)

        return res

    def orderlyQueue(self, s: str, k: int) -> str:

        if k == 1:
            least = inf
            indx = 0
            ss = s*2
            d = len(s)
            for l in range(d):
                if least>self.calcS(ss[l:l+d]):
                    least = self.calcS(ss[l:l+d])
                    indx = l
            return ss[indx:indx+d]
                 
        else:
            D = defaultdict(int)
        
            for x in s:
                D[x] += 1
            
            abc = ""abcdefghijklmnopqrstuvwxyz""
            res = """"

            for x in abc:
                res += x*D[x]

            return res",Hard,34,787,0.0,4,3.0,6.0,23.147058823529413,37.0,3.796764705882353
585.0,numbers at most n given digit set,"class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        limit = str(n)
        limit_len = len(limit)
        digits_len = len(digits)
        res = 0
        
        for idx in range(1, limit_len):
            res += pow(digits_len, idx)
        
        for idx in range(limit_len):
            is_start_eq_digit = False
            for digit in digits:
                if digit < limit[idx]:
                    res += pow(digits_len, limit_len - idx - 1)
                elif digit == limit[idx]:
                    is_start_eq_digit = True
            
            if not is_start_eq_digit:
                return res
        
        return res + 1",Hard,21,694,0.0,5,3.0,6.0,33.04761904761905,28.0,3.7457142857142856
586.0,valid permutations for di sequence,"class Solution:
    def numPermsDISequence(self, s: str) -> int:
        myStore = [1]
        
        for index, val in enumerate(s):
            if val == 0:
                continue
            temp = []
            for i in range(index + 2):
                if val == ""I"":
                    curr = sum(myStore[i:])
                else:
                    curr = sum(myStore[:i])
                temp.append(curr)
            myStore = temp
        return sum(myStore) % (10**9+7)",Hard,15,488,0.0,3,4.0,4.0,32.53333333333333,24.0,4.252
587.0,fruit into baskets,"class Solution:
    def totalFruit(self, tree: List[int]) -> int:
        ans = ii = 0
        freq = {}
        for i, x in enumerate(tree): 
            freq[x] = 1 + freq.get(x, 0)
            while len(freq) > 2: 
                freq[tree[ii]] -= 1
                if freq[tree[ii]] == 0: freq.pop(tree[ii])
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans",Medium,11,394,0.0,3,3.0,3.0,35.81818181818182,22.0,4.216363636363637
588.0,sort array by parity,"class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        even = 0                                                    # The index currently contain odd, waiting for accepting a even num
        
        for odd in range(len(nums)):
            if nums[odd] % 2 == 0:                                  # if index-odd encounter a even num, swap it with index-even.
                nums[even], nums[odd] = nums[odd], nums[even]       # Indices at and before index-even are even num now,
                even += 1                                           # so even-index should go 1 step further 
                                                                    # ready to accept next even num
        return nums",Easy,9,741,5.0,2,8.0,5.0,82.33333333333333,18.0,0.3900000000000005
589.0,super palindromes,"class Solution:
    def superpalindromesInRange(self, left: str, right: str) -> int:
        '''
        1. For each number in the range [floor(square root of integer value of left), floor(square root of integer value of right)], 
                - need to check if the number is palindrome and (number^2) is palindrome
        2. One possible way to do this quicker is 
                - to generate all the palindromes within the range [floor(square root of integer value of left), floor(square root of integer value of right)]
                - and check whether the square of this palindrome is also a palindrome
        3. If [floor(square root of integer value of left)] is of x digits and [floor(square root of integer value of right)] is of y digits, then
                - if x>1: start generating palindrome from the lowest number of x digits that is divisible by 10, else: start generating palindrome from 1
                - generate palindrome upto the highest number of y digits that is 999...9 (y 9's) 
        4. To generate palindromes of x and y digits, we need to check only the first ceil(x/2) digits and ceil(y/2) digits 
                of [floor(square root of integer value of left)] and [floor(square root of integer value of right)] respectively
        '''
        
        cnt = 0
        lft = str(int(int(left)**0.5))
        rght = str(int(int(right)**0.5))
        
        lft_1 = lft
        rght_1 = rght
        
        if len(lft)%2:
            lft = ""1""+""0""*((len(lft)//2))
        else:
            lft = ""1""+""0""*((len(lft)//2)-1)                                                 #getting the value from where palindromes are started to be generated
            
        if len(rght)%2:
            rght = ""9""*((len(rght)//2)+1)
        else:
            rght = ""9""*(len(rght)//2)                                                       #getting the value upto which palindromes are generated
        
        for num in range(int(lft),int(rght)+1):
            num=str(num)
            len_string=len(num)
            
            if (len_string*2)-1 >= len(lft_1):                                              #length of palindrome must be greater than or equal the given 'left' string parameter
                str_N_1 = num[0:len_string-1]+num[len_string-1]+num[0:len_string-1][::-1]   #generate an odd length palindrome by appending the num string in two opposite orders, and keep the middle character fixed 
                sq_1 = str(int(str_N_1)**2)                                                 #generate the string representation of the square of the palindrome integer
                if int(left) <= int(sq_1) <= int(right) and sq_1==sq_1[::-1]:               #square is palindrome and within the given left and right parameters
                    cnt+=1                                                                  #increment the result by 1
            
            if len_string*2 <= len(rght_1):                                                 #length of palindrome must be less than or equal the given 'right' string parameter 
                str_N_2 = num+num[::-1]                                                     #generate an even length palindrome by appending the num string in two opposite orders
                sq_2 = str(int(str_N_2)**2)
                if int(left) <= int(sq_2) <= int(right) and sq_2==sq_2[::-1]:
                    cnt+=1
                
        return cnt",Hard,48,3453,10.0,8,5.0,11.0,71.9375,72.0,-4.054375
590.0,sum of subarray minimums,"class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:

        # get the index of the first previous value that is less than the current one. 
        # if there is no value less than the current one in the previous array
        # set the index as -1 which means all previous values are larger than 
        # the current one so we can include all the previous array in the subarray
        # with current index as the minimun.
        prev_less_index = [-1] * len(arr)
        stack = []
        for i, val in enumerate(arr):
            while stack and arr[stack[-1]] > val:
                stack.pop()
            prev_less_index[i] = stack[-1] if stack else - 1
            stack.append(i)

        # with similar logtic, get the first index of following values that is less than
        # the current one.
        next_less_index = [len(arr)] * len(arr)
        stack = []
        for i, val in enumerate(arr):
            while stack and arr[stack[-1]] > val:
                next_less_index[stack.pop()] = i
            stack.append(i)
        res = 0
        for i, val in enumerate(arr):
            res = (res + val * (i - prev_less_index[i]) * (next_less_index[i] - i)) % 1_000_000_007

        return res",Medium,28,1233,7.0,5,3.0,7.0,44.035714285714285,24.0,3.4367857142857154
591.0,smallest range i,"class Solution:
    def smallestRangeI(self, A: List[int], K: int) -> int:
        return max(0,max(A)-min(A)-2*K)",Easy,2,114,0.0,0,2.0,0.0,57.0,8.0,3.95
592.0,snakes and ladders,"class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        n = len(board)
        ans = 0
        queue = [1]
        seen = {1}
        while queue: 
            newq = []
            for x in queue: 
                if x == n*n: return ans 
                for xx in range(x+1, x+7): 
                    if xx <= n*n:
                        i, j = divmod(xx-1, n)
                        if board[~i][~j if i&amp;1 else j] != -1: xx = board[~i][~j if i&amp;1 else j]
                        if xx not in seen: 
                            newq.append(xx)
                            seen.add(xx)
            ans += 1
            queue = newq 
        return -1",Medium,19,692,0.0,6,4.0,9.0,36.42105263157895,30.0,3.122105263157894
593.0,smallest range ii,"class Solution:
    def smallestRangeII(self, nums: List[int], k: int) -> int:
        
        # Remove duplicates and sort
        arr = sorted(list(set(nums)))
        
        res = arr[-1] - arr[0]
        for i in range(len(arr) - 1):
            res = min(res, max(arr[i] + k, arr[-1] - k) - min(arr[0] + k, arr[i + 1] - k))
        
        return res",Medium,10,359,1.0,1,2.0,1.0,35.9,14.0,5.229
594.0,sort an array,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:

	
        return sorted(nums)   #1
		```
		```
		#2
import heapq
class Solution:
def sortArray(self, nums: List[int]) -> List[int]:
        heapq.heapify(nums)
        l=[]
        while(nums):
            l.append(heapq.heappop(nums))
        return l
 
		```",Medium,17,332,3.0,-1,1.0,2.0,19.529411764705884,12.0,7.16235294117647
595.0,cat and mouse,"class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        n = len(graph)
        
        @cache
        def fn(i, m, c): 
            """"""Return """"""
            if i == 2*n: return 0 # tie 
            if m == 0: return 1 # mouse wins
            if m == c: return 2 # cat wins 
            if i&amp;1: # cat's turn 
                tie = 0 
                for cc in graph[c]: 
                    if cc != 0: 
                        x = fn(i+1, m, cc)
                        if x == 2: return 2 
                        if x == 0: tie = 1
                if tie: return 0 
                return 1
            else: # mouse's turn 
                tie = 0 
                for mm in graph[m]: 
                    x = fn(i+1, mm, c)
                    if x == 1: return 1 
                    if x == 0: tie = 1
                if tie: return 0
                return 2 
        
        return fn(0, 1, 2)",Hard,28,936,5.0,3,4.0,13.0,33.42857142857143,57.0,1.0714285714285712
596.0,x of a kind in a deck of cards,"class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        C=Counter(deck).values()
        for i in range(2,len(deck)+1):
            if all([c%i==0 for c in C]): return True
        return False",Easy,5,216,0.0,1,2.0,3.0,43.2,12.0,4.732
597.0,partition array into disjoint intervals,"class Solution:
    def partitionDisjoint(self, A: List[int]) -> int:
        n = len(A)
        large, small = [0] * n, [0] * n
        l, s = -sys.maxsize, sys.maxsize
        for i in range(n):
            large[i], small[n-1-i] = (l:=max(l, A[i])), (s:=min(s, A[n-1-i]))
        for i in range(n):   
            if large[i] <= small[i+1]: return i+1
        return -1",Medium,9,372,0.0,2,3.0,3.0,41.333333333333336,26.0,3.38
598.0,word subsets,"class Solution:
    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:
   
        ans=[]
        maind={}
        
        for i in B:
            d={}
            for j in i:
                if j in d:
                    d[j]+=1
                else:
                    d[j]=1
            for j in i:
                if j not in maind:
                    maind[j]=d[j]
                if j not in d:
                    d[j]=0
                maind[j]=max(maind[j],d[j])
        # print(maind)
        
        for i in A:
            d1={}
            f=True
            for j in i:
                if j in d1:
                    d1[j]+=1
                else:
                    d1[j]=1
            # print(d1)
            for j in maind:
                
                if j not in d1:
                    d1[j]=-1
                # print( maind[j],d1[j])
                if maind[j]>d1[j]:
                    f=False
                    break
            if  f:
                ans.append(i)
                
        return ans",Medium,41,1053,3.0,12,4.0,13.0,25.682926829268293,39.0,2.9485365853658534
600.0,maximum sum circular subarray,"class Solution:
    def kadane_max(self, nums):
        for i in range(1, len(nums)):
            if nums[i-1] > 0:
                nums[i] += nums[i-1]
        return max(nums)
    
    def kadane_min(self, nums):
        for i in range(1, len(nums)):
            if nums[i-1] < 0:
                nums[i] += nums[i-1]
        return min(nums)
    
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        x = self.kadane_max(nums[::])
        y = sum(nums) - self.kadane_min(nums[::])
        if y == 0:
            y = max(nums)
        return max(x, y)",Medium,18,569,0.0,3,3.0,5.0,31.61111111111111,31.0,3.695
601.0,number of music playlists,"class Solution:
    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:
        
        @cache
        def fn(i, x): 
            """"""Return number starting from ith position with x songs already appeared.""""""
            if i == goal: return x == n 
            ans = 0 
            if x < n: ans += (n-x) * fn(i+1, x+1) # a new song
            if k < x: ans += (x-k) * fn(i+1, x) # an old song
            return ans % 1_000_000_007
        
        return fn(0, 0)",Hard,12,478,2.0,0,3.0,3.0,39.833333333333336,28.0,3.515000000000001
602.0,minimum add to make parentheses valid,"class Solution:
    def minAddToMakeValid(self, S: str) -> int:
        op = cl = 0 # open and closed parenthesis needed 
        for c in S: 
            cl += 1 if c == ""("" else -1 # need ) to balance extra (
            if cl < 0: 
                cl = 0
                op += 1 # need ( to balance extra )
        return op + cl",Medium,8,332,3.0,2,3.0,3.0,41.5,16.0,4.485
603.0,sort array by parity ii,"class Solution:
    def sortArrayByParityII(self, A: List[int]) -> List[int]:
        ev, od = 0, 1
        sol = [0] * len(A)
        for el in A:
            if el % 2 == 0: 
                sol[ev] = el
                ev += 2
            else:
                sol[od] = el
                od += 2
        return sol",Easy,11,319,0.0,2,3.0,2.0,29.0,19.0,5.19
604.0,3sum with multiplicity,"class Solution:
    def threeSumMulti(self, arr: List[int], target: int) -> int:
        freq = {}
        for x in arr: 
            freq[x] = 1 + freq.get(x, 0)
        
        ans = 0
        vals = list(freq)
        
        for i in range(len(vals)):
            for ii in range(i+1): 
                x = target - vals[i] - vals[ii]
                if x in freq: 
                    if vals[i] == vals[ii] == x: 
                        ans += comb(freq[x], 3)
                    elif vals[i] == vals[ii] != x: 
                        ans += comb(freq[vals[i]], 2) * freq[x]
                    elif vals[i] < x and vals[ii] < x: 
                        ans += freq[vals[i]] * freq[vals[ii]] * freq[x]
        return ans % 1_000_000_007",Medium,19,748,0.0,7,4.0,7.0,39.36842105263158,37.0,2.096842105263157
605.0,minimize malware spread,"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            nodes.add(i)
            for j, conn in enumerate(graph[i]):
                if conn and j not in nodes:
                    dfs(j)
        
        maxRemoval, minNode = -1, float('inf')
        for node in initial:
            nodes = set()
            dfs(node)
            
            if nodes &amp; initial == {node}:
                l = len(nodes)
                if l > maxRemoval or (l == maxRemoval and node < minNode):
                    minNode = node
                    maxRemoval = l
                    
        return minNode if maxRemoval > -1 else min(initial)",Hard,21,751,0.0,5,4.0,6.0,35.76190476190476,31.0,3.1414285714285715
606.0,long pressed name,"class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
    	name, typed, c, N = name+'0', typed+'0', 1, []
    	for s in [name,typed]:
    		for i in range(len(s)-1):
    			if s[i] == s[i+1]:
    				c += 1
    			else:
    				N.append([s[i],c])
    				c = 1
    	return all([N[i][0] == N[i+len(N)//2][0] and N[i][1] <= N[i+len(N)//2][1] for i in range(len(N)//2)])

		
		
- Python 3
- Junaid Mansuri",Easy,15,428,0.0,3,1.0,4.0,28.53333333333333,30.0,4.192000000000001
607.0,flip string to monotone increasing,"class Solution:
    def minFlipsMonoIncr(self, S: str) -> int:
    	return min(2*j-i for i,j in enumerate([0]+list(itertools.accumulate([int(i) for i in S]))))+len(S)-S.count('1')
		
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,7,231,0.0,0,1.0,2.0,33.0,6.0,6.37
608.0,three equal parts,"class Solution:
    def threeEqualParts(self, arr: List[int]) -> List[int]:
        ones = [i for i, x in enumerate(arr) if x]
        n, r = divmod(len(ones), 3)
        if r: return -1, -1
        if not n: return 0, 2
        a, b, c = ones[0], ones[n], ones[2*n]
        r = len(arr) - c
        if r > max(b-a, c-b) or not arr[a+1:a+r] == arr[b+1:b+r] == arr[c+1:]:
            return -1, -1
        return a + r - 1, b + r",Hard,10,428,0.0,0,2.0,5.0,42.8,34.0,2.628
609.0,minimize malware spread ii,"class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        
        def dfs(i):
            for j, conn in enumerate(graph[i]):
                if conn and j not in initial and j not in nodes:
                    nodes.add(j)
                    dfs(j)
        
        sourceDict = defaultdict(list)
        for node in initial:
            nodes = set()
            dfs(node)
            
            for i in nodes:
                sourceDict[i].append(node)
        
        counter = defaultdict(int)
        maxVal, minNode = -1, float('inf')
        for infected, sources in sourceDict.items():
            if len(sources) == 1:
                src = sources[0]
                counter[src] += 1
                if counter[src] > maxVal or (counter[src] == maxVal and src < minNode):
                    minNode = src
                    maxVal = counter[src]
                    
        return minNode if maxVal > -1 else min(initial)",Hard,28,1022,0.0,7,4.0,8.0,36.5,37.0,2.3550000000000004
610.0,unique email addresses,"class Solution(object):
    def numUniqueEmails(self, emails):
        """"""
        :type emails: List[str]
        :rtype: int
        """"""

        results = set()
        for email in emails:
            local, domain = email.split(""@"")
            local = local[:local.index(""+"")].replace(""."", """") if ""+"" in local else local.replace(""."", """")
            results.add(local + ""@"" + domain)

        return len(results)",Easy,13,418,0.0,1,2.0,2.0,32.15384615384615,15.0,5.426153846153847
611.0,binary subarrays with sum,"class Solution:
    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        zgaps,gap = [],0
        for v in A:
            if v:
                zgaps+=[gap]
                gap=0
            else:
                gap+=1
        zgaps+=[gap]
        if S==0:
            return sum([(g*(g+1))//2 for g in zgaps])
        return sum([(zgaps[i]+1)*(zgaps[i+S]+1) for i in range(len(zgaps)-S)])",Medium,12,405,0.0,2,3.0,5.0,33.75,21.0,4.5625
612.0,minimum falling path sum,"class Solution:
    def minFallingPathSum(self, A: List[List[int]]) -> int:
    	L, A, m = len(A), [[math.inf] + i + [math.inf] for i in A], math.inf
    	for i,j in itertools.product(range(1,L),range(1,L+1)): A[i][j] += min(A[i-1][j-1],A[i-1][j],A[i-1][j+1])
    	return min(A[-1])
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,8,331,0.0,1,1.0,2.0,41.375,18.0,4.356250000000001
613.0,beautiful array,"class Solution:
    def beautifulArray(self, n: int) -> List[int]:
        return (
            [1, 2][:n]
            if n < 3
            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]
            + [x * 2 for x in self.beautifulArray(n // 2)]
        )",Medium,7,268,0.0,0,3.0,6.0,38.285714285714285,8.0,5.574285714285715
614.0,shortest bridge,"class Solution:
	def shortestBridge(self, grid: List[List[int]]) -> int:       
		rows, cols = len(grid), len(grid[0])

  # Mark the first island with '#'s
    def dfs(row, col):
        if row not in range(rows) or col not in range(cols) or grid[row][col] != 1:
            return False
        
        grid[row][col] = '#'
        dfs(row+1, col)
        dfs(row-1, col)
        dfs(row, col+1)
        dfs(row, col-1)
             

# If the inner loop does not break, the outer loop will not either. 
# The for-else clause only happens if the inner loop does not break. Then continue avoids the outer break too. 
    for row in range(rows):
        for col in range(cols):
            if grid[row][col] == 1:
                dfs(row,col)
                break
        else:
            continue # only executed if the inner loop did NOT break
        break  # only executed if the inner loop DID break
    
	
	# Now let's expand from the first island we just marked and return the second we see the second island
    shortest_bridge_distance = 0
    q = deque([(r,c,shortest_bridge_distance) for r in range(rows) for c in range(cols) if grid[r][c] == '#'])     

    visited = set()
    while q:
        row, col, shortest_bridge_distance  = q.popleft()
        directions = ((row+1,col),(row-1,col),(row,col+1),(row,col-1))
		
        for new_row, new_col in directions:
            if new_row in range(rows) and new_col in range(cols) and (new_row,new_col) not in visited:
                if grid[new_row][new_col] == 1:
                    return shortest_bridge_distance
					
                q.append((new_row, new_col, shortest_bridge_distance+1))
                visited.add((new_row,new_col))",Medium,43,1705,8.0,-3,2.0,16.0,39.65116279069768,57.0,1.1113953488372097
615.0,knight dialer,"class Solution:
    NEIGHBORS_MAP = {
            1: (6, 8),
            2: (7, 9),
            3: (4, 8),
            4: (3, 9, 0),
            5: tuple(),
            6: (1, 7, 0),
            7: (2, 6),
            8: (1, 3),
            9: (2, 4),
            0: (4, 6),
        }
        
    def getNeighbors(self, position):
        return self.NEIGHBORS_MAP[position]

    def knightDialer(self, N: int, memo={}) -> int:
        return sum(self.helper(neigh, N-1, memo) for neigh in self.NEIGHBORS_MAP.keys()) % (10**9 + 7)
    
    def helper(self, current, hops, memo):
        if (current, hops) in memo:
            return memo[(current, hops)]
        if hops == 0:
            return 1
        res = sum(self.helper(neigh, hops - 1, memo) for neigh in self.getNeighbors(current))
        memo[(current, hops)] = res
        return res",Medium,27,848,0.0,-2,3.0,4.0,31.40740740740741,59.0,1.213333333333333
616.0,stamping the sequence,"class Solution:
    # O(n(n-m) * m) time,
    # O(n-m) space,
    # Approach: sliding window, 
    def movesToStamp(self, stamp: str, target: str) -> List[int]:
        n = len(target)
        m = len(stamp)
        target = list(target)
        ans = []
        vstd_indexes = set()
        
        
        def isStamped(subarray):
            for index,ch in enumerate(subarray):
                if not (ch == '?' or ch == stamp[index]):
                    return False
                
            return True
        
        
        def replaceToPlaceholder(start):
            non_questionmark = 0
            for i in range(m):
                if target[start+i] != '?':
                    non_questionmark += 1
                    target[start+i] = '?'
                
            return non_questionmark
        
        
        reversed = 0     # number of reversed characters back to '?' 
        l, r = 0, m
        stampExists = False     # if stamp exists in one traversal of target
        
        while reversed != n:
            while r <= n:
                if l not in vstd_indexes and isStamped(target[l:r]):
                    stampExists = True
                    ans.append(l)
                    vstd_indexes.add(l)
                    break
                l +=1
                r +=1
            if stampExists:
                reversed +=replaceToPlaceholder(ans[-1])
                stampExists = False
                l, r = 0, m
            else:
                return []
            
        ans.reverse()
        return ans",Hard,51,1566,5.0,3,3.0,9.0,30.705882352941178,55.0,1.5764705882352938
617.0,reorder data in log files,"class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        res=[]
        digi=[]
        letter=[]
        for i in logs:
            k=i.split()
            if k[1].isdigit():
                digi.append(i)
            else:
                letter.append(i)
        d={}
        for i in letter:
            k=i.split()
            m=d.get(tuple(k[1:]),[])
            m.append(k[0])
            d[tuple(k[1:])]=m
        for i in sorted(list(d.keys())):
            x=[x for x in i]
            s=''
            for j in x:
                s+=j+' '
            s=s.strip()
            for j in sorted(d[i]):
                res.append(j+' '+s)
        return(res+digi)",Medium,25,697,0.0,6,3.0,7.0,27.88,27.0,4.2508
618.0,range sum of bst,"class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        cursum = 0
        if root.val != None:
            cursum = root.val if low <= root.val <= high else 0
        if root.left and root.val >= low:
            cursum += self.rangeSumBST(root.left, low, high)
        if root.right and root.val <= high:
            cursum += self.rangeSumBST(root.right, low, high)

        return cursum",Easy,10,430,0.0,3,2.0,4.0,43.0,29.0,2.9300000000000006
619.0,minimum area rectangle,"class Solution:
    def minAreaRect(self, points: List[List[int]]) -> int:
        ans = inf
        seen = {(x, y) for x, y in points}
        for x, y in points: 
            for xx, yy in points: 
                if x != xx and y != yy and (x, yy) in seen and (xx, y) in seen: 
                    ans = min(ans, abs((xx-x)*(yy-y)))
        return ans if ans < inf else 0",Medium,8,374,0.0,3,3.0,5.0,46.75,21.0,3.3325000000000014
620.0,distinct subsequences ii,"class Solution:
    def distinctSubseqII(self, s: str) -> int:
        freq = [0]*26 
        for i in reversed(range(len(s))): freq[ord(s[i])-97] = (1 + sum(freq)) % 1_000_000_007
        return sum(freq) % 1_000_000_007",Hard,4,221,0.0,1,2.0,1.0,55.25,8.0,4.0475
621.0,valid mountain array,"class Solution:
    def validMountainArray(self, arr: List[int]) -> bool:
        increased = decreased = False
        
        for i in range(1, len(arr)):
            if arr[i] > arr[i-1]:
                if decreased:
                    return False
                increased = True
            elif arr[i] < arr[i-1]:
                if not increased:
                    return False
                decreased = True
            else:
                return False
            
        return decreased",Easy,16,508,0.0,2,4.0,5.0,31.75,18.0,4.9825
622.0,di string match,"class Solution:
    def diStringMatch(self, s: str) -> List[int]:
        
        a=0
        b=len(s)
        
        ans=[]
        for j in s:
            
            if j=='I':
                ans.append(a)
                a+=1
            else:
                ans.append(b)
                b-=1
                
        ans.append(a)
        return ans",Easy,17,361,0.0,2,3.0,2.0,21.23529411764705,16.0,6.188823529411764
623.0,find the shortest superstring,"class Solution:
    def shortestSuperstring(self, words: List[str]) -> str:
        n = len(words)
        graph = [[0]*n for _ in range(n)] # graph as adjacency matrix 
        
        for i in range(n):
            for j in range(n): 
                if i != j: 
                    for k in range(len(words[j])): 
                        if words[i].endswith(words[j][:k]): 
                            graph[i][j] = len(words[j]) - k 
                            
        @cache
        def fn(prev, mask): 
            """"""Return length of shortest superstring &amp; current choice of word.""""""
            if mask == 0: return 0, None
            vv, kk = inf, None
            for k in range(n): 
                if mask &amp; 1<<k: 
                    v, _ = fn(k, mask ^ 1<<k)
                    offset = len(words[k]) if prev == -1 else graph[prev][k]
                    if v + offset < vv: vv, kk = v + offset, k
            return vv, kk
        
        ans = []
        prev = -1 
        mask = (1<<n) - 1
        while mask: 
            _, k = fn(prev, mask)
            if ans: ans.append(words[k][-graph[prev][k]:])
            else: ans.append(words[k])
            prev = k
            mask ^= 1<<k 
        return """".join(ans)",Hard,33,1250,1.0,8,4.0,13.0,37.87878787878788,60.0,-0.0890909090909097
624.0,delete columns to make sorted,"class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        
        deletionIndices=[]
        x=[]
        
        length=len(A[0])
        counter=-1
        for i in range(length):
            check=[]
            acheck=[]
            for j in range(len(A)):
                check.append(A[j][i])
                acheck=sorted(check)
                if check!=acheck:
                    deletionIndices.append(i)
                    break
              
        return len(deletionIndices)",Easy,18,512,0.0,2,3.0,3.0,28.444444444444443,16.0,5.54
625.0,minimum increment to make array unique,"class Solution:
    def minIncrementForUnique(self, A: List[int]) -> int:
        m, c, _ = -math.inf, 0, A.sort()
        for a in A: (c, m) = (c + (1 + m - a), m + 1) if a <= m else (c, a)
        return c
		
		
- Junaid Mansuri",Medium,7,230,0.0,1,1.0,3.0,32.857142857142854,17.0,5.222857142857144
626.0,validate stack sequences,"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        i = 0
        stack = []
        for x in pushed: 
            stack.append(x)
            while stack and stack[-1] == popped[i]: 
                stack.pop()
                i += 1
        return not stack",Medium,9,315,0.0,2,3.0,2.0,35.0,15.0,5.05
627.0,most stones removed with same row or column,"class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        root = set()
        parent = {}
        rank = {}
        for x, y in stones:
            self.set_param(x, parent, rank)
            self.set_param(~y, parent, rank)
            self.union(x, ~y, parent, rank)
        # get parent for all nodes
        for p in parent:
            root.add(self.find(parent[p], parent))
        # Answer is: no. of stones - no. of components
        # Since we can't remove all stones from a components, there we be number of components number of stones left
        return len(stones) - len(root)
        
    def set_param(self, x, parent, rank):
        if(x not in parent):
            parent[x] = x
            rank[x] = 0

    def find(self, x, parent):
        if(x != parent[x]):
            parent[x] = self.find(parent[x], parent)
        return parent[x]
    
    def union(self, x, y, parent, rank):
        parent_x = self.find(x, parent)
        parent_y = self.find(y, parent)
        
        if(parent_x == parent_y):
            return
        rank_x = rank[parent_x]
        rank_y = rank[parent_y]
        
        if(rank_x > rank_y):
            parent[parent_y] = parent_x
        elif(rank_x < rank_y):
            parent[parent_x] = parent_y
        else:
            parent[parent_y] = parent_x
            rank[parent_x] += 1",Medium,41,1372,3.0,0,3.0,8.0,33.46341463414634,59.0,1.0282926829268284
628.0,bag of tokens,"class Solution:
    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:
        tokens.sort()
        score = 0
        while len(tokens) > 0:
            if P >= tokens[0]:
                P -= tokens[0]
                score += 1
                tokens.pop(0)
            elif len(tokens) > 2 and score > 0:
                score -= 1
                P += tokens[-1]
                tokens.pop()
            else:
                break
        return score",Medium,15,468,0.0,2,4.0,3.0,31.2,21.0,4.732
629.0,largest time for given digits,"class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        
            return ''.join(result[-1]) if (result := sorted([[*p[:2]]+[':']+[*p[2:]] for p in itertools.permutations([str(n) for n in A]) if int(''.join(p[:2])) < 24 and int(''.join(p[2:])) < 60], key=lambda p: int(''.join(p[:2]))*100 + int(''.join(p[3:])))) else """"",Medium,3,349,0.0,1,2.0,4.0,116.33333333333331,19.0,-2.549999999999999
630.0,reveal cards in increasing order,"class Solution:
    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
        ans = [0]*len(deck)
        idx = deque(range(len(deck)))
        for x in sorted(deck): 
            ans[idx.popleft()] = x
            if idx: idx.append(idx.popleft())
        return ans",Medium,7,281,0.0,2,3.0,2.0,40.142857142857146,10.0,5.087142857142857
631.0,flip equivalent binary trees,"class Solution:
    def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:
        
        def fn(n1, n2):
            """"""Return True if n1 is a flip of n2.""""""
            if not n1 or not n2: return n1 is n2
            return n1.val == n2.val and (fn(n1.left, n2.right) and fn(n1.right, n2.left) or fn(n1.left, n2.left) and fn(n1.right, n2.right))
        
        return fn(root1, root2)",Medium,8,399,0.0,-2,3.0,2.0,49.875,18.0,3.651250000000001
632.0,largest component size by common factor,"class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        
        def find(node):
            if parent[node] == -1: return node
            else:
                parent[node] = find(parent[node])
                return parent[node]
        
        def union(idx1,idx2):
            par1,par2 = find(idx1),find(idx2)
            if par1!=par2:
                if rank[par1] > rank[par2]:
                    parent[par2] = par1
                elif rank[par2] > rank[par1]:
                    parent[par1] = par2
                else:
                    parent[par2] = par1
                    rank[par1] += 1
        
        n = len(nums)
        parent = defaultdict(lambda:-1)
        rank = defaultdict(lambda:0)
        for i in range(n):
            limit = int(nums[i]**0.5)
            for j in range(2,limit+1):
                if nums[i] % j == 0:
                    union(nums[i],j)
                    union(nums[i],nums[i]//j)
        count = defaultdict(lambda:0)
        best = -1
        for num in nums:
            par = find(num)
            tmp = count[par] + 1
            if tmp > best: best = tmp
            count[par] = tmp
        return best",Hard,36,1200,0.0,7,4.0,9.0,33.333333333333336,53.0,1.0399999999999991
633.0,verifying an alien dictionary,"class Solution:
    
    def compare(self, cache, word1, word2):
        i, j = 0,0
        while i < len(word1) and j < len(word2):
            if cache[word1[i]] < cache[word2[j]]:
                return True
            elif cache[word1[i]] > cache[word2[j]]:
                return False
            else: #letters equal case
                i += 1
                j += 1

        if i < len(word1):
            return False
        """"""
            why false?
            In some cases word1 can be aaa, word2 can be aa
            here we must return false becoz they are not in lexicographic order
            becoz word2 appears first than word1
        """"""
        
        return True #same words case and shorter words case like aa, aaa i will definitely reach end 
    
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        """"""
            Main Idea behind this is,
            How we see our Oxford or Some english Dictionary (So called lexicographic order)
            
            Eg:
            Case 1:
                Assume we have words like ad, af, ag, ba, bba, bbaaaag in our oxford Dictionary
                at diff page numbers Now compare the page numbers of these words once it is for sure
                pageNumber(ad) < pageNumber(af) < pageNumber(ag) < ... pageNumber(bbaaag)
            Case 2:
                if we go in depth
                if two 2 words are in same page, say x, xy
                it is for sure LineNumber(x) < lineNumber(xy) (Note < operator is Strictly lesser)
            Case 3:
                Words like a, aa, aaa, aaaa are in our dictionary
                definitly appearance(a) < appearance(aa) < appearance(aaa) < appearance(aaaa)
                appearance may be a line number or page number
        """"""
        
        """"""
            In our Question there are asking for a different alphabetical order and asking us to check 
            whether appearance(word1) < appearance(word2) < appearance(word3) < ... < appearance(wordn) or not
            Just compare 
                word1 with word2 
                word2 with word3
                word3 with word4
                ....
                wordn-1 with wordn
            Reason: if word1 < word2 it is for sure lesser than word3 and so on
        """"""
        cache = {}
        for i in range(len(order)):
            cache[order[i]] = i
        
        for i in range(1, len(words)):
            if not self.compare(cache, words[i-1], words[i]):
                return False
        return True",Easy,62,2549,2.0,1,3.0,18.0,41.11290322580645,65.0,-0.3601612903225799
634.0,array of doubled pairs,"class Solution:
    def canReorderDoubled(self, A: List[int]) -> bool:
        A = sorted([-i if i < 0 else i for i in A], reverse=True)
        n, c, cnt = len(A), collections.Counter(A), 0
        for i in range(n):
            if c[2*A[i]] > 0:
                c[2*A[i]] -= 1
                c[A[i]] -= 1
                cnt += 1
        return cnt >= n // 2",Medium,9,361,0.0,2,3.0,4.0,40.11111111111112,22.0,3.89
635.0,delete columns to make sorted ii,"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions 
        ans, grp = 0, [0]*m
        for j in range(n): 
            for i in range(1, m): 
                if grp[i-1] == grp[i] and strs[i-1][j] > strs[i][j]: 
                    ans += 1
                    break
            else: 
                for i in range(1, m): 
                    grp[i] = max(grp[i-1], grp[i])
                    if grp[i-1] == grp[i] and strs[i-1][j] < strs[i][j]: grp[i] = i
        return ans",Medium,13,551,1.0,4,4.0,5.0,42.38461538461539,31.0,2.6453846153846152
636.0,tallest billboard,"class Solution:
    def tallestBillboard(self, rods: List[int]) -> int:
        
        def fn(arr): 
            """"""Possible a mapping from diff to length""""""
            mp = defaultdict(int)
            for t in range(1, len(arr)+1): 
                for total in combinations(arr, t): 
                    tt = sum(total)
                    for p in range(0, t+1): 
                        for part in combinations(total, p): 
                            pp = sum(part)
                            mp[pp*2 - tt] = max(mp[pp*2 - tt], pp)
            return mp 
        
        left = rods[:len(rods)//2]
        right = rods[len(rods)//2:]
        
        mp = fn(left)
        keys = sorted(mp.keys())
        
        ans = 0 
        for diff, v in fn(right).items(): 
            k = bisect_left(keys, -diff)
            if k < len(keys) and keys[k] == -diff: 
                ans = max(ans, mp[-diff] + v)
        return ans",Hard,26,935,0.0,5,4.0,11.0,35.96153846153846,37.0,2.523461538461538
637.0,prison cells after n days,"class Solution:
    def prisonAfterNDays(self, cells: List[int], n: int) -> List[int]:
        counter = 0
        bitmap = 0
		# cells to bitmap
        for b in cells:
            bitmap = (bitmap<<1)|b
		# memory table
        idToCount = {bitmap:counter}
        countToCells = {counter:bitmap}
        for j in range(n):
			# bin(126) = 1111110
            bitmap = ~((bitmap<<1)^(bitmap>>1))&amp;126
            counter += 1
            if bitmap in idToCount:
                dis = idToCount[bitmap]
				# mod
                bitmap = countToCells[(n-dis)%(counter-dis)+dis]
                break
            else:
                idToCount[bitmap] = counter
                countToCells[counter] = bitmap
		# bitmap to cells
        for i in range(8):
            cells[7-i] = (bitmap>>i)&amp;1
        return cells",Medium,25,823,5.0,3,3.0,4.0,32.92,35.0,3.377200000000001
638.0,check completeness of a binary tree,"class Solution:
    def isCompleteTree(self, root: TreeNode) -> bool:
        queue = [root]
        while queue[0]:
            node = queue[0]
            queue = queue[1:]
            queue.append(node.left)
            queue.append(node.right)
        return not any(queue)",Medium,8,277,0.0,1,3.0,1.0,34.625,10.0,5.643750000000001
639.0,regions cut by slashes,"class Solution:
    def regionsBySlashes(self, grid: List[str]) -> int:
	'''
	--------
	| \ 0 / |
	| 3\ /  |
	|  /\ 1 |
	|/  2 \ |
	|-------|

	'''
        self.N = len(grid)
        # m_ = [i for i in range(self.N * self.N * 4)]
        m_ = list(range(self.N * self.N * 4))
        self.count = self.N * self.N * 4
        for r in range(self.N):
            line = grid[r]
            for c in range(self.N):
                w = line[c]
                if r > 0:  # no horizontal line '-'
                    self.u(m_, self.g(r - 1, c, 2), self.g(r, c, 0))
                if c > 0:  # no vertical line '|'
                    self.u(m_, self.g(r, c - 1, 1), self.g(r, c, 3))
                if w != '/':  # if not '/', then region 0 and 1 will be in the same region(set)
                    self.u(m_, self.g(r, c, 0), self.g(r, c, 1))
                    self.u(m_, self.g(r, c, 3), self.g(r, c, 2))
                if w != '\\': # if not '\\', then region 1 and 2 will be in the same region(set)
                    self.u(m_, self.g(r, c, 0), self.g(r, c, 3))
                    self.u(m_, self.g(r, c, 1), self.g(r, c, 2))
        return self.count

    def f(self, m_, a):  # find set
        if m_[a] == a:   # if parent found, return, else continue finding
            return a
        return self.f(m_, m_[a])
    
    def u(self, m_, a, b):  # union sets
        pa = self.f(m_, a)
        pb = self.f(m_, b)
        if (pa == pb):
            return
        m_[pa] = pb
        self.count -= 1
    
    def g(self, r, c, i):  # find exact region(set) for every element in grid
        return (r * self.N + c) * 4 + i",Medium,45,1632,10.0,2,3.0,13.0,36.266666666666666,87.0,-1.863999999999999
640.0,delete columns to make sorted iii,"class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions
        
        @cache 
        def fn(k, prev):
            """"""Return min deleted columns to make sorted.""""""
            if k == n: return 0 
            ans = 1 + fn(k+1, prev) # delete kth column
            if prev == -1 or all(strs[i][prev] <= strs[i][k] for i in range(m)): 
                ans = min(ans, fn(k+1, k)) # retain kth column
            return ans 
        
        return fn(0, -1)",Hard,13,525,3.0,-1,3.0,3.0,40.38461538461539,26.0,3.7653846153846153
641.0,n repeated element in size 2n array,"class Solution:
    def repeatedNTimes(self, A: List[int]) -> int:
        length = len(A)
        for i in A:
            if A.count(i)>1:
                return i",Easy,5,164,0.0,2,3.0,2.0,32.8,9.0,5.848000000000001
642.0,maximum width ramp,"class Solution:
    def maxWidthRamp(self, nums: List[int]) -> int:
        if not nums: return 0
        
        max_vals = self.create_max_vals(nums)
        max_width = 0
        i = 0
        
        while i + max_width < len(nums):
            j = i + max_width
            
            while j < len(nums) and nums[i] <= max_vals[j]:
                j += 1
            
            max_width = max(max_width, j - i - 1)
            i += 1
        
        return max_width
        
    def create_max_vals(self, nums: List[int]) -> List[int]:
        max_val = 0
        max_vals = [0] * len(nums)
        
        for i in range(len(nums)-1, -1, -1):
            max_val = max(max_val, nums[i])
            max_vals[i] = max_val
        
        return max_vals",Medium,27,770,0.0,2,3.0,4.0,28.51851851851852,32.0,3.9333333333333336
643.0,minimum area rectangle ii,"class Solution:
    def minAreaFreeRect(self, points: List[List[int]]) -> float:
        N = len(points)
        
        seen = set()
        for point in points:
            seen.add(tuple(point))

        # length^2
        def length2(a, b):
            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])
        
        best = 1e30
        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                
                lij = length2(points[i], points[j])
                for k in range(N):
                    if i == k or j == k:
                        continue
                    
                    # given i->j line, add to k to find l
                    dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]
                    
                    pl = (points[k][0] + dx, points[k][1] + dy)
                    if pl not in seen:
                        continue
                    
                    lik = length2(points[i], points[k])
                    ljk = length2(points[j], points[k])

                    lil = length2(points[i], pl)
                    ljl = length2(points[j], pl)
                    lkl = length2(points[k], pl)
                    
                    if lij == lkl and lik == ljl and lil == ljk:
                        best = min(best, sqrt(lij * lik * lil) / sqrt(max(lij, lik, lil)))
                    
        if best >= 1e29:
            return 0
        return best",Medium,42,1514,2.0,4,4.0,9.0,36.04761904761905,62.0,0.1557142857142839
644.0,least operators to express number,"class Solution:
    def solve(self,x,target):
        if target in self.dp : return self.dp[target]
        
        # when target == 1 we can solve just by doing x/x  
        if target == 1: return 1
        
         # current value = x and operations performed  = 0
        cur = x
        op = 0
       
        # if cur < target : the best decision is to multiply
        while cur < target:    
            cur *= x
            op += 1
        
        # if cur == target : we reached using minimum possible operations 
        if cur == target :
            return op
        
        if op == 0:
            # cur is already larger than target
            # x/x + make(target-1) : make 2 operations + solve(target-1)
            ans = 2 + self.solve(x,target - 1)
        else:
            # we try to reach nearest val via multiply less than target
            # and find ans for remaining i.e. target - cur/x 
            # here op becomes op - 1 so op - 1 + 1 becomes op
            ans = op + self.solve(x,target-(cur//x))
            
        if cur - target < target :
            # diff between cur and target is less than target
            # i.e. we can make cur and remove cur - target
            tmp = op + 1 + self.solve(x,cur - target)
            if tmp < ans : ans = tmp
        
        # finally use dp for memoization
        self.dp[target] = ans
        return ans",Hard,38,1394,12.0,6,3.0,13.0,36.68421052631579,48.0,1.83842105263158
645.0,univalued binary tree,"class Solution:
    def isUnivalTree(self, root: TreeNode) -> bool:
        if root is None:
            return True
        self.cons=root.val
        def dfs(node):
            if node:
                if node.val!=self.cons:
                    return False
                dfs(node.left)
                dfs(node.right)
        
        dfs(root)
        return True",Easy,13,370,0.0,1,3.0,3.0,28.46153846153846,11.0,6.098461538461539
646.0,vowel spellchecker,"class Solution:
    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
        original_hash, lowercase_hash, ignore_vowel_hash = {}, {}, {}
        for index, word in enumerate(wordlist):
            original_hash[word] = index
            lowercase_word = word.lower()
            if lowercase_word not in lowercase_hash:
                lowercase_hash[lowercase_word] = index
            trans_vowel_word = self.trans_vowel(lowercase_word)
            if trans_vowel_word not in ignore_vowel_hash:
                ignore_vowel_hash[trans_vowel_word] = index
        check_result = []
        for query in queries:
            if query in original_hash:
                check_result.append(query)
            elif query.lower() in lowercase_hash:
                check_result.append(wordlist[lowercase_hash[query.lower()]])
            else:
                trans = self.trans_vowel(query.lower())
                if trans in ignore_vowel_hash:
                    check_result.append(wordlist[ignore_vowel_hash[trans]])
                else:
                    check_result.append("""")
        return check_result

    @classmethod
    def trans_vowel(cls, word):
        list_word = list(word)
        for i, c in enumerate(word):
            if c in ('a', 'e', 'i', 'o', 'u'):
                list_word[i] = 0
        return str(list_word)",Medium,31,1371,0.0,8,3.0,9.0,44.2258064516129,40.0,1.3596774193548384
647.0,numbers with same consecutive differences,"class Solution:
    def numsSameConsecDiff(self, n: int, k: int) -> List[int]:
        
        def fn(i, x):
            """"""Return numbers with same consecutive differences.""""""
            if i == n-1: return [str(x)]
            ans = []
            if x+k < 10: ans += [str(x) + xx for xx in fn(i+1, x+k)]
            if k and 0 <= x-k: ans += [str(x) + xx for xx in fn(i+1, x-k)] 
            return ans 
        
        return sum((fn(0, x) for x in range(1, 10)), [])",Medium,11,474,0.0,0,3.0,8.0,43.09090909090909,26.0,3.341818181818182
648.0,binary tree cameras,"class Solution:
    def minCameraCover(self, root: TreeNode) -> int:
        # Post order traversal to make sure we transit left, right and root so that camera's can be assigned in the right order.
        def postorder(root, parent):
            if not root:
                return 0
            
            L = postorder(root.left, root)
            R = postorder(root.right, root)
            
            # check if something is a tail node. 
            tail_node = (not root.left and not root.right)
            
            # Camera coverage is there if either a camera exists or if a camera cover node
            # however, if we discovered coverage to children or camera with children, 
            # we dont want to assign camera too root but to its parent. 
            # Only case need covering in the root node. 
            left_camera = (not root.left) or (root.left and root.left.val >= 1)
            right_camera = (not root.right) or (root.right and root.right.val >= 1)
            iscovered = left_camera and right_camera 

            # check if either children is not having coverage == 0 
            # usecase : root has left chld covered by its children but on right side its not covered the the root needs to have a camera. 
            either_zero = False
            
            if root.left and root.left.val == 0:
                either_zero = True
            if root.right and root.right.val == 0:
                either_zero = True
                
            if not parent and (root.val == 2 or root.val == 0):
                return L + R + (1 if (either_zero or not root.val) else 0)
            elif not tail_node and not iscovered:
                root.val = 1
                # if root needs camera, then propagate coverate to its parent and children.
                if parent:
                    parent.val = 2 if parent.val == 0 else parent.val
                
                if root.left:
                    root.left.val = 2 if root.left.val == 0 else root.left.val
                    
                if root.right:
                    root.right.val = 2 if root.right.val == 0 else root.right.val
                
                L += 1                
                            
            return L + R 
                        
        mc = postorder(root, None)

        return mc",Hard,50,2342,9.0,5,4.0,18.0,46.84,66.0,-0.9956000000000014
649.0,pancake sorting,"class Solution:
    def pancakeSort(self, A: List[int]) -> List[int]:
        sort_k_list = []
        ''' sorting k used for pancake flip '''
        for i in range(len(A), 0, -1):
            v = A[i-1]
            if v != i:
                # Start pancake sorting
                # 0) Look for value as `v`
                vi = A.index(i)

                # 1) Performing pancake flip twice to move value `v` into
                #    destined position `i`
                if vi >= 1:
                    sort_k_list.append(vi+1)    # 1.1 Move value `v` to first position
                    A[:vi+1] = A[:vi+1][::-1]
                    sort_k_list.append(i)       # 1.2 Move value `v` from first position to target position `i`
                    A[:i] = A[:i][::-1]                    
                else:
                    # value `v` is already at first position
                    # so swap it to the destined position
                    sort_k_list.append(i)
                    A[:i] = A[:i][::-1]                    
            
        return sort_k_list",Medium,24,1076,9.0,3,5.0,6.0,44.833333333333336,32.0,2.6450000000000005
650.0,powerful integers,"class Solution:
    def powerfulIntegers(self, x, y, bound):
        answer = []
        cnt1 = 0
        cnt2 = 0
        while x**(cnt1+1) <= bound:
            if x == 1:
                break
            cnt1 += 1
        while y**(cnt2+1) <= bound:
            if y == 1:
                break
            cnt2 += 1
        for i in range(cnt1+1):
            for j in range(cnt2+1):
                if x**(i) +y**(j) <= bound:
                    answer.append((x**(i) +y**(j)))
        answer = set(answer)
        answer = list(answer)
        return (answer)



x = 1
y = 2
bound = 100
Solution().powerfulIntegers(x,y, bound)",Medium,26,634,0.0,5,2.0,7.0,24.384615384615383,36.0,3.785384615384616
651.0,flip binary tree to match preorder traversal,"class Solution:
    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
        ans = []
        stack = [root]
        i = 0 
        while stack: 
            node = stack.pop()
            if node: 
                if node.val != voyage[i]: return [-1]
                i += 1
                if node.left and node.right and voyage[i] == node.right.val: 
                    ans.append(node.val)
                    node.left, node.right = node.right, node.left 
                stack.extend([node.right, node.left])
        return ans",Medium,14,560,0.0,3,4.0,4.0,40.0,24.0,3.58
652.0,equal rational numbers,"class Solution:

    def to_float(self, n: str) -> float:
        if ""."" not in n:
            return float(n)
        whole, dec = n.split(""."")
        if dec:
            if ""("" in dec:
                idx_bracket = dec.index(""("")
                return float(f""{whole}.{dec[:idx_bracket]}{dec[idx_bracket + 1: -1] * 17}"")
            return float(f""{whole}.{dec}"")
        return float(f""{whole}."")

    def isRationalEqual(self, s: str, t: str) -> bool:
        return abs(self.to_float(s) - self.to_float(t)) < 1e-16",Hard,14,521,0.0,-1,3.0,3.0,37.21428571428572,20.0,4.530714285714286
653.0,k closest points to origin,"class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return sorted(points, key = lambda x: x[0] ** 2 + x[1] ** 2)[:k]",Medium,2,164,0.0,0,2.0,0.0,82.0,11.0,1.4000000000000004
654.0,subarray sums divisible by k,"class Solution:
    def subarraysDivByK(self, A: List[int], K: int) -> int:
    	D, s = {0:1}, 0
    	for a in A:
    		s = (s + a) % K
    		if s in D: D[s] += 1
    		else: D[s] = 1
    	return sum(i*(i-1)//2 for i in D.values())
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,11,280,0.0,2,1.0,3.0,25.454545454545453,17.0,5.829090909090909
655.0,odd even jump,"class Solution:
    def oddEvenJumps(self, arr: List[int]) -> int:
        large = [-1] * len(arr)
        small = [-1] * len(arr)
        
        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (x[1], x[0])): 
            while stack and stack[-1] < i: large[stack.pop()] = i 
            stack.append(i)
        
        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (-x[1], x[0])): 
            while stack and stack[-1] < i: small[stack.pop()] = i
            stack.append(i)
        
        odd = [0] * len(arr)
        even = [0] * len(arr)
        odd[-1] = even[-1] = 1
        for i in reversed(range(len(arr))): 
            if 0 <= large[i]: odd[i] = even[large[i]]
            if 0 <= small[i]: even[i] = odd[small[i]]
        return sum(odd)",Hard,21,798,0.0,7,3.0,7.0,38.0,40.0,1.9800000000000004
656.0,largest perimeter triangle,"class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        # Condition of a triangle a<(b+c) and a>=b>=c
        nums=sorted(nums,reverse=True)
        for i in range(len(nums)-2):
            if nums[i]<nums[i+1]+nums[i+2]:
                return nums[i] + nums[i+1] + nums[i+2]
        return 0",Easy,7,317,1.0,1,3.0,2.0,45.285714285714285,16.0,4.124285714285715
657.0,squares of a sorted array,"class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            nums[i] = nums[i]**2
        nums.sort()
        return nums",Easy,5,182,0.0,1,2.0,1.0,36.4,7.0,5.844
658.0,longest turbulent subarray,"class Solution:
    def maxTurbulenceSize(self, A: List[int]) -> int:
        index = 0
        A_len = len(A)
        A_len_ = A_len - 1
        current_length = 1
        max_length = 1
        
        
        while (A_len - index > max_length):
            while (index < A_len_ and A[index + 1] == A[index]):
                index += 1
             
            
            if (A_len - index > max_length):    
                faktor = 1 if A[index] > A[index + 1] else -1
                index += 1
                current_length = 2


                while (index < A_len_ and faktor * A[index] < faktor * A[index + 1]):
                    faktor = -faktor
                    current_length += 1
                    index += 1


                if (current_length > max_length):
                    max_length = current_length
                    
        return max_length",Medium,29,884,0.0,5,3.0,6.0,30.48275862068965,33.0,3.476551724137932
659.0,distribute coins in binary tree,"class Solution:
    def distributeCoins(self, root: TreeNode) -> int:
        
        def fn(node):
            """"""Return flux (surplus/deficit) of node.""""""
            nonlocal ans 
            if not node: return 0
            left, right = fn(node.left), fn(node.right)
            ans += abs(left) + abs(right)
            return node.val - 1 + left + right # surplus/deficit 
        
        ans = 0
        fn(root)
        return ans",Medium,13,442,1.0,-2,3.0,1.0,34.0,12.0,5.720000000000001
660.0,unique paths iii,"class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        moves = ((1, 0), (-1, 0), (0, 1), (0, -1))
        ans = 0

        # ----------------------------------------------
        def dfs(grid, r, c, vertexSet):
            nonlocal ans, moves

            vertexSet.remove((r, c))
            if grid[r][c] == 2:
                if len(vertexSet) == 0:
                    ans += 1
                return

            for x, y in moves:
                x, y = r + x, c + y
                if (x, y) in vertexSet:
                    dfs(grid, x, y, vertexSet.copy())
        # -----------------------------------------------
        
        vertexSet = set()
        r1, r2 = 0, 0
        for r in range(len(grid)):                  # Add (row, col) in set if it is not onstacle
            for c in range(len(grid[0])):
                if grid[r][c] != -1:
                    if grid[r][c] == 1:
                        r1, c1 = r, c
                    vertexSet.add((r, c))
                    
        dfs(grid, r1, c1, vertexSet)                # Start DFS from start - (row, col) 
        return ans",Hard,31,1137,4.0,7,4.0,9.0,36.67741935483871,60.0,0.1990322580645163
661.0,triples with bitwise and equal to zero,"class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        ans = 0
        mem = [0] * (1 << 16)
        size = len(nums)

        for i in range(size):
            for j in range(i, size):
                mem[nums[i]&amp;nums[j]] += 2 if i != j else 1
        
        for ij in range(1 << 16):
            if mem[ij] > 0:
                for k in nums:
                    if k &amp; ij == 0:
                        ans += mem[ij]
        return ans",Hard,15,470,0.0,6,3.0,7.0,31.33333333333333,26.0,4.04
662.0,minimum cost for tickets,"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        dp = [0]*(days[-1]+1)
        for i in range(len(dp)):
            if i in days:
                dp[i] = min(dp[max(0, i-1)]+costs[0],
                            dp[max(0, i-7)]+costs[1], dp[max(0, i-30)]+costs[2])
            else:
                dp[i] = dp[i-1]
        return dp[-1]",Medium,9,383,0.0,2,4.0,2.0,42.55555555555556,18.0,4.01
663.0,string without aaa or bbb,"class Solution:
    def strWithout3a3b(self, a: int, b: int) -> str:
		# n = current # of consecutive chracters in res that are the same
		# positive if it's consecutive as, negative if it's bs
        n = 0
        res = ''
        while a and b:
            if n == -2 or (n != 2 and a >= b):
                res += 'a'
                a -= 1
                n = max(1, n + 1)
            else:
                res += 'b'
                b -= 1
                n = min(-1, n - 1)
        return res + (a * 'a') + (b * 'b')",Medium,15,524,2.0,2,3.0,4.0,34.93333333333333,28.0,3.836
664.0,sum of even numbers after queries,"class Solution:
    def sumEvenAfterQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:
        s=0
        a=[0]*len(queries)
        for i in A:
            if i%2==0:
                s+=i
                
        for i in range(len(queries)):
            indx=queries[i][1]
            val=queries[i][0]
            
            if val%2==0:
                if A[indx]%2==0:
                    s+=val


            else:
                if A[indx]%2==0:
                    s-=A[indx]
                   

                else:
                    s+=A[indx]+val
                
            A[indx]+=val
            a[i]=s
                
            
        return a",Medium,29,690,0.0,6,3.0,6.0,23.79310344827586,37.0,3.618620689655173
665.0,interval list intersections,"class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        LA, LB, I, i, j = len(A), len(B), [], 0, 0
        while i < LA and j < LB:
            a, b, i = A[i], B[j], i + 1
            if a[1] > b[1]: a, b, i, j = b, a, i - 1, j + 1
            if b[0] <= a[1]: I.append([max(a[0],b[0]),a[1]])
        return I
		
		
- Junaid Mansuri
- Chicago, IL",Medium,11,409,0.0,3,2.0,3.0,37.18181818181818,39.0,2.453636363636364
666.0,vertical order traversal of a binary tree,"class Solution:
    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
        cols_hash_map = collections.defaultdict(lambda : collections.defaultdict(list))
        min_col = math.inf
        max_col = -math.inf
        max_row = -math.inf
        def traverse(root, row, col):
            nonlocal min_col, max_col, max_row
            if not root:
                return
            min_col = min(min_col, col)
            max_col = max(max_col, col)
            max_row = max(max_row, row)
            bisect.insort(cols_hash_map[col][row], root.val)
            
            traverse(root.left, row + 1, col - 1)
            traverse(root.right, row + 1, col + 1)
            
        traverse(root, 0, 0)
        res = []
        for i in range(min_col, max_col + 1):
            tmp = []
            for j in range(max_row + 1):
                tmp.extend(cols_hash_map[i][j])
            res.append(tmp)
        return res",Hard,25,954,0.0,2,3.0,3.0,38.16,34.0,2.8656
667.0,smallest string starting from leaf,"class Solution:
    stack = []
    best = None
    
    def lexorder(s1,s2):
        if s1 == None:
            return s2
        for i in range(min(len(s1),len(s2))):
            if s1[i] < s2[i]:
                return s1
            elif s1[i] > s2[i]:
                return s2
        if len(s1) < len(s2):
            return s1
        return s2
    
    def dfs(self, root):
        Solution.stack.append(root.val)
        if root.left:
            self.dfs(root.left)
        if root.right:
            self.dfs(root.right)
        if root.left == None and root.right == None:
            Solution.best = Solution.lexorder(Solution.best, Solution.stack[::-1])
        Solution.stack.pop()
        
    def smallestFromLeaf(self, root: TreeNode) -> str:
        self.dfs(root)
        return """".join([chr(x+97) for x in Solution.best])",Medium,28,842,0.0,3,3.0,9.0,30.071428571428573,36.0,3.333571428571429
668.0,add to array form of integer,"class Solution(object):
    def addToArrayForm(self, A, K):
        """"""
        :type A: List[int]
        :type K: int
        :rtype: List[int]
        """"""
        A = int(''.join(map(str, A)))
        B = A + K
        C = list(map(int, str(B)))
        return C",Easy,10,265,0.0,0,2.0,1.0,26.5,15.0,5.995
669.0,satisfiability of equality equations,"class Solution:
    def __init__(self):
        self.id_ = [i for i in range(26)]
    
    def find(self,x):
        while x != self.id_[x]:
            self.id_[x] = self.id_[self.id_[x]]
            x = self.id_[x]
        return x
    
    def union(self,x,y):
        x = self.find(x)
        y = self.find(y)
        self.id_[x] = self.id_[y]
    
    def equationsPossible(self, equations: List[str]) -> bool:
        for a,sign,_,b in equations:
            if sign == '=':
                self.union(ord(a)-97,ord(b)-97)
        for a,sign,_,b in equations:
            if sign == '!':
                if self.find(ord(a)-97) == self.find(ord(b)-97):
                    return False
        return True",Medium,23,711,0.0,4,3.0,7.0,30.91304347826087,41.0,2.697826086956521
670.0,broken calculator,"class Solution:
    def brokenCalc(self, X: int, Y: int) -> int:
        c = 0
        while Y>X:
            if Y%2: Y += 1
            else: Y //= 2     
            c += 1
        return c + (X - Y)",Medium,7,201,0.0,2,3.0,2.0,28.714285714285715,15.0,5.615714285714286
671.0,subarrays with k different integers,"class Solution:
    def atMostK(self, nums, k):
        good_count = 0
        counter = collections.Counter()
        
        begin = 0
        for end in range(len(nums)):
            if counter[nums[end]] == 0:
                k -= 1
            counter[nums[end]] += 1
            
            while k < 0:
                counter[nums[begin]] -= 1
                if counter[nums[begin]] == 0:
                    k += 1
                
                begin += 1
            
            good_count += end - begin + 1
        
        return good_count
            
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        return self.atMostK(nums, k) - self.atMostK(nums, k - 1)",Hard,23,708,0.0,3,3.0,4.0,30.782608695652176,32.0,3.669565217391305
672.0,cousins in binary tree,"class Solution(object):
    def isCousins(self, root, x, y):
        """"""
        :type root: TreeNode
        :type x: int
        :type y: int
        :rtype: bool
        """"""
        def f(root, v, p):
            if root.val == v:
                _d = 1
                _p = p
                return _d, _p
            
            if root.left!=None:
                l_d, l_p = f(root.left, v, root.val)
                if l_d!=None:
                    return l_d+1, l_p
                
            if root.right!=None:
                r_d, r_p = f(root.right, v, root.val)
                if r_d!=None:
                    return r_d+1, r_p             
            return None, p
			
        _x = f(root, x, None)
        _y = f(root, y, None)
        return (_x[0] == _y[0]) and (_x[1] != _y[1])",Easy,27,804,0.0,1,3.0,5.0,29.77777777777778,52.0,1.879999999999999
673.0,rotting oranges,"class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        # 0  =  means empty
        # 1  =  fresh orange
        # 2  =  rotten orange
        # every minute any every rotten orange infects its adjacent fresh orange
        # min no of minutes to make all rotten else -1
            
        fresh_oranges = 0
        rotten_oranges = []
        rows = len(grid)
        cols = len(grid[0])
        steps = 0
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 1:
                    fresh_oranges += 1
                elif grid[r][c] == 2:
                    rotten_oranges.append((r,c))
        if fresh_oranges == 0: return 0            
        while rotten_oranges:
            tmp = []
            while rotten_oranges:
                r,c = rotten_oranges.pop(0)
                paths = ((r+1,c),(r-1,c),(r,c+1),(r,c-1))
                for x,y in paths:
                    if 0<=x<rows and 0<=y<cols and grid[x][y] == 1:
                        grid[x][y] = 2
                        fresh_oranges -=1
                        if fresh_oranges == 0: return steps + 1
                        tmp.append((x,y))
            steps += 1
            rotten_oranges = tmp
        
        return -1",Medium,34,1273,5.0,8,4.0,10.0,37.44117647058823,63.0,-0.1897058823529427
674.0,minimum number of k consecutive bit flips,"class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        ans = flip = 0 
        queue = deque()
        for i, x in enumerate(nums):
            if queue and i == queue[0]: 
                flip ^= 1
                queue.popleft()
            if x == flip: 
                if len(nums) - i < k: return -1
                ans += 1
                flip ^= 1
                queue.append(i+k)
        return ans",Hard,13,438,0.0,3,3.0,4.0,33.69230769230769,25.0,4.107692307692308
675.0,number of squareful arrays,"class Solution:
def numSquarefulPerms(self, A: List[int]) -> int:
     
    res = []
    visited = [0] * len(A)
    A.sort()
    def helper(nums,out, res):
        if len(out) == len(nums):
            res.append(out[:])
            return
        else:
             
            for i in range(len(A)):
                if visited[i]:
                    continue
                if i > 0 and A[i] == A[i-1] and visited[i -1]:
                    continue
                if len(out) >= 2 and (out[-1] +out[-2])**0.5 != int((out[-1] +out[-2])**0.5):
                    continue
                if len(out) >= 1 and (out[-1] +A[i])**0.5 != int((out[-1] +A[i])**0.5):
                    continue
                visited[i] = 1
                out.append(A[i])
                helper(nums,out, res)
                out.pop()
                visited[i] = 0
    helper(A,[], res)
    #print(res)
    return len(res)",Hard,28,912,1.0,1,3.0,6.0,32.57142857142857,37.0,3.168571428571429
676.0,find the town judge,"class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        if n == 1:
            return 1
        
        d = {}
        trusted = set()
        
        for t in trust:
            if t[1] not in d:
                d[t[1]] = []
            d[t[1]].append(t[0])
            trusted.add(t[0])
        
        for key in d:
            if len(d[key]) == n - 1 and key not in trusted:
                return key
        
        return -1

class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        count = [0] * (n + 1)
        
        for t in trust:
            count[t[0]] -= 1
            count[t[1]] += 1
        
        for i in range(1, n + 1):
            if count[i] == n - 1:
                return i
        
        return -1",Easy,32,798,0.0,4,3.0,8.0,24.9375,38.0,3.535625
677.0,maximum binary tree ii,"class Solution:
    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
        prev, node = None, root
        while node and val < node.val: prev, node = node, node.right
        
        temp = TreeNode(val, left=node)
        if prev: prev.right = temp 
        else: root = temp 
        return root",Medium,8,319,0.0,2,2.0,2.0,39.875,22.0,3.97125
678.0,available captures for rook,"class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        # At first find position of rook and save in 'iR' and 'jR' variables
        for i in range(len(board)):
            for j in range(len(board[i])):
                if board[i][j] == 'R':
                    iR = i
                    jR = j
        # find all first figures on line and row
        res = []
        for j in range(jR + 1, len(board)):
            if board[iR][j] != '.':
                res.append(board[iR][j])
                break
        for j in range(jR - 1, -1, -1):
            if board[iR][j] != '.':
                res.append(board[iR][j])
                break
        for i in range(iR + 1, len(board)):
            if board[i][jR] != '.':
                res.append(board[i][jR])
                break
        for i in range(iR - 1, -1, -1):
            if board[i][jR] != '.':
                res.append(board[i][jR])
                break
        # calculate how many pawns
        resCount = 0
        for i in range(len(res)):
            if res[i] == 'p':
                resCount += 1
        return resCount",Easy,31,1130,3.0,9,3.0,13.0,36.45161290322581,39.0,2.219354838709677
679.0,minimum cost to merge stones,"class Solution:
    @cache
    def dp(self, l, r, piles) -> int:
        if r - l < piles:
            return inf
        if r - l == piles:
            return 0
        if piles == 1:
            return self.dp(l, r, self.k) + self.prefix_sum[r] - self.prefix_sum[l]
        return min(self.dp(l, m, i) + self.dp(m, r, piles - i) for i in range(1, piles) for m in range(l+i, r-i+1))
            
    def mergeStones(self, stones: List[int], k: int) -> int:
        if (len(stones) - k) % (k - 1) != 0:
            return -1
        self.k = k
        self.prefix_sum = [0]
        for i in range(0, len(stones)):
            self.prefix_sum.append(self.prefix_sum[-1] + stones[i])
        return self.dp(0, len(stones), 1)",Hard,18,723,0.0,0,3.0,7.0,40.16666666666666,38.0,2.405
680.0,grid illumination,"class Solution:
def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
    
    row,col,dig1,dig2 = defaultdict(int),defaultdict(int),defaultdict(int),defaultdict(int)
    
    def switch(i,j,isOn):
        val = 1 if isOn else -1
        row[i] += val
        col[j] += val
        dig1[i+j]+=val
        dig2[i-j]+=val
    
    def check(x,y):
        return 1 if row[x] or col[y] or dig1[x+y] or dig2[x-y] else 0
    
    seen = set()
    for x,y in set([tuple(lamp) for lamp in lamps]):
        seen.add((x,y))
        switch(x,y,1)
    
    res = []
    for x,y in queries:
        res.append(check(x,y))
        for dx,dy in [(0,0),(0,1),(0,-1),(1,0),(-1,0),(1,1),(-1,-1),(1,-1),(-1,1)]:
            if (x+dx,y+dy) in seen:
                seen.remove((x+dx,y+dy))
                switch(x+dx,y+dy,0)
    return res",Hard,27,865,0.0,3,2.0,7.0,32.03703703703704,60.0,0.8166666666666682
681.0,find common characters,"class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        n = len(A)
        if n == 0:
            return []
        master = None
        
        for word in A:
            freq = get_freq(word)
            if master is None:
                master = freq
            else:
                master = get_new_master(master, freq)
        output = []
        for char in master:
            output = output + [char]*master[char]
        return output
                
def get_new_master(m, s):
    dict = {}
    for char in m:
        if char in s:
            if s[char] >= m[char]:
                dict[char] = m[char]
            else:
                dict[char] = s[char]
    return dict
        
def get_freq(word):
    dict = {}
    for char in word:
        if char in dict:
            dict[char]+=1
        else:
            dict[char] = 1
    return dict",Easy,35,884,0.0,6,3.0,9.0,25.257142857142856,39.0,3.2868571428571425
682.0,check if word is valid after substitutions,"class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s: 
            if c == ""c"" and stack[-2:] == [""a"", ""b""]:
                stack.pop()
                stack.pop()
            else: stack.append(c)
        return not stack",Medium,8,263,0.0,2,3.0,2.0,32.875,17.0,5.041250000000001
683.0,max consecutive ones iii,"class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        ans = ii = cnt = 0
        for i, x in enumerate(A):
            if not x: cnt += 1
            while ii <= i and cnt > K: 
                if not A[ii]: cnt -= 1
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans",Medium,9,324,0.0,4,3.0,4.0,36.0,23.0,4.04
684.0,maximize sum of array after k negations,"class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        heapq.heapify(A)
        for i in range(K):
            heapq.heappush(A,-1 * heapq.heappop(A))
        return sum(A)",Easy,5,211,0.0,1,2.0,2.0,42.2,9.0,5.122
685.0,clumsy factorial,"class Solution:
    def clumsy(self, n: int) -> int:
        if n == 1 or n == 2:
            return n
        if n >= 3:
            fact = n * (n - 1) // (n - 2)
            n -= 3
        while n - 4 >= 0:
            fact = fact + n - (n - 1) * (n - 2) // (n - 3)
            n -= 4
        if n > 0:
            fact += n
            n = n - 1
            if n > 0:
                fact -= n
                n = n- 1
        return fact",Medium,16,441,0.0,4,3.0,5.0,27.5625,30.0,4.099375
686.0,minimum domino rotations for equal row,"class Solution(object):
    def minDominoRotations(self, A, B):
        """"""
        :type A: List[int]
        :type B: List[int]
        :rtype: int
        """"""
        for x in range(1, 7):
            ca = cb = 0
            for i in range(len(A)):
                if A[i] != x and B[i] != x:
                    break
            else:
                for i in range(len(A)):
                    if A[i] != x:
                        ca += 1
                    if B[i] != x:
                        cb += 1
                return min(ca, cb)
        return -1",Medium,19,564,0.0,4,4.0,6.0,29.68421052631579,27.0,4.148421052631578
687.0,construct binary search tree from preorder traversal,"class Solution:
    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        root = None
        for i in range(len(preorder)):
            node = preorder[i]
            root = self.handle(root, node)
        return root
        
    def handle(self, root, x):
        if not root:
            return TreeNode(x)
        if x < root.val:
            root.left = self.handle(root.left, x)
        else:
            root.right = self.handle(root.right, x)
        return root",Medium,17,534,0.0,1,3.0,4.0,31.41176470588235,22.0,4.732941176470589
688.0,complement of base 10 integer,"class Solution:
    def bitwiseComplement(self, N: int) -> int:
        position_value = 1
        ret = 0
        
        
        if (N == 0):
            return 1
        
        
        while (N > 0):
            if (not N &amp; 1):
                ret += position_value
            
            N //= 2
            position_value *= 2
                     
        return ret",Easy,17,383,0.0,2,3.0,3.0,22.529411764705884,17.0,5.97235294117647
689.0,pairs of songs with total durations divisible by 60,"class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        count=0
        d={}
        for i in time:
            k=i%60
            if k in d:
                d[k]+=[i]
            else:
                d[k]=[i]
        for i in d:
            if i==30 or i==0 :count+=int(((len(d[i])**2)-len(d[i]))//2)
            elif 60-i in d:
                count+=len(d[i])*len(d[60-i])
                d[i]=[]
                d[60-i]=[]
        return count",Medium,16,477,0.0,5,3.0,5.0,29.8125,26.0,4.236875
690.0,capacity to ship packages within d days,"class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        
        def canShip(capacity: int) -> bool:
            nonlocal D
            count = 1
            loaded = 0 
            for w in weights:
                if loaded + w <= capacity:
                    loaded += w
                else:
                    count += 1
                    loaded = w
            return count <= D
            
        
        maxWeight = max(weights)
        lo = sum(weights) // D
        hi = maxWeight * len(weights) // D + 1
        while lo < hi:
            mid = (lo + hi) // 2
            if mid < maxWeight or not canShip(mid):
                lo = mid + 1
            else:
                hi = mid
        return lo",Medium,25,752,0.0,3,3.0,4.0,30.08,33.0,3.632800000000001
691.0,numbers with repeated digits,"class Solution:
    def numDupDigitsAtMostN(self, N: int) -> int:
    	T = [9,261,4725,67509,831429,9287109,97654149,994388229]
    	t = [99,999,9999,99999,999999,9999999,99999999,999999999]
    	if N < 10:
    		return 0
    	L = len(str(N))
    	m, n = [1], []
    	g = 11-L
    	for i in range(L):
    		n.append(int(str(N)[i]))
    		m.append(g)
    		g = g*(12-L+i)
    	S = 0
    	for i in range(L):
    		if len(set(n[:L-i-1])) != len(n)-i-1:
    			continue
    		k = 0
    		for j in range(10):
    			if j not in n[:L-i-1] and j > n[L-i-1]:
    				k += 1
    		S += k*m[i]
    	return(T[L-2]-(t[L-2]-N-S))
	
- Python 3
- Junaid Mansuri",Hard,25,646,0.0,4,1.0,6.0,25.84,42.0,3.1743999999999994
692.0,partition array into three parts with equal sum,"class Solution:
    def canThreePartsEqualSum(self, A):
        A += [0]
        sa = sum(A)
        saby3 = sa // 3
        sdum = 0
        count = 0
        x = 0
        for x in range(len(A)):
            sdum += A[x]
            if sdum == saby3:
                count += 1
                sdum = 0
            if count == 3:
                break
        if count == 3 and sum(A[x:1]) == 0:
            return True
        else:
            return False",Easy,18,460,0.0,2,3.0,4.0,25.55555555555556,30.0,4.4
693.0,best sightseeing pair,"class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        prev, res = values[0], 0
        
        for i in range(1, len(values)):
            res = max(res, prev + values[i] - i)
            prev = max(prev, values[i] + i)
        
        return res",Medium,8,283,0.0,1,3.0,1.0,35.375,14.0,5.1762500000000005
694.0,smallest integer divisible by k,"class Solution:
    def smallestRepunitDivByK(self, K: int) -> int:
    	if K % 2 == 0 or K % 5 == 0: return -1
    	i = n = 1
    	while n % K != 0: n, i = (10*n + 1) % K, i + 1
    	return i
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,9,241,0.0,1,1.0,2.0,26.77777777777778,19.0,5.57
695.0,binary string with substrings representing 1 to n,"class Solution:
    def queryString(self, S: str, N: int) -> bool:
        
        for i in range(1,N+1):
            x=str(bin(i).replace(""0b"", """"))
            
            if S.find(x)==-1:
                return False
            
        return True",Medium,9,255,0.0,1,3.0,2.0,28.33333333333333,15.0,5.710000000000001
696.0,convert to base 2,"class Solution:
    def baseNeg2(self, N: int) -> str:
        ans = []
        while N: 
            ans.append(N &amp; 1)
            N = -(N >> 1)
        return """".join(map(str, ans[::-1] or [0]))",Medium,6,200,0.0,1,3.0,1.0,33.333333333333336,13.0,5.460000000000001
697.0,binary prefix divisible by 5,"class Solution:
    def prefixesDivBy5(self, A: List[int]) -> List[bool]:
        
        state = 0
        answer = []
        for a in A:
            if a == 0:
                state = ( 2*state ) % 5
            else:
                state = ( 2*state+1 ) % 5
            answer.append(state==0)
        return answer",Easy,11,321,0.0,2,3.0,2.0,29.181818181818183,18.0,5.273636363636364
698.0,next greater node in linked list,"class Solution:
    def nextLargerNodes(self, head: ListNode) -> List[int]:
        prev, node = None, head
        while node: node.next, node, prev = prev, node.next, node
        
        node = prev 
        ans, stack = [], []
        while node: 
            while stack and stack[-1] <= node.val: stack.pop()
            ans.append(stack[-1] if stack else 0)
            stack.append(node.val)
            node = node.next 
        return ans[::-1]",Medium,12,455,0.0,3,3.0,4.0,37.91666666666666,25.0,3.727500000000001
699.0,number of enclaves,"class Solution:
    
    # Generates all coordinates on boundaries
    def boundary_coordinates(self, grid):
        rows = len(grid)
        cols = len(grid[0])
        for row_index in range(rows):
            yield (row_index, 0) 
            yield (row_index, cols - 1)
        for col_index in range(1, cols - 1):
            yield (0, col_index)
            yield (rows - 1, col_index)
    
    # Returns a set of all 1's on boundaries.
    def ones_on_boundaries(self, grid):
        coordinates = self.boundary_coordinates(grid)
        return {(row, col) for row, col in coordinates if grid[row][col] == 1} 
    
    # Generates the neighbours of a given cell
    def get_neighbours(self, row, col, grid):
        if row > 0:
            yield (row - 1, col)
        if col > 0:
            yield (row, col - 1)
        if row < len(grid) - 1:
            yield (row + 1, col)
        if col < len(grid[0]) - 1:
            yield (row, col + 1)
    
    # Counts the number of enclaves.
    def numEnclaves(self, A: List[List[int]]) -> int:
        total_ones = sum([sum(row) for row in A])
        reachable_ones = 0
        visited = self.ones_on_boundaries(A)
        ones_reachable_on_boundary = list(visited)
        while ones_reachable_on_boundary:
            row, col = ones_reachable_on_boundary.pop()
            reachable_ones += 1
            for adj_row, adj_col in self.get_neighbours(row, col, A):
                if (adj_row, adj_col) not in visited and A[adj_row][adj_col] == 1:
                    visited.add((adj_row, adj_col))
                    ones_reachable_on_boundary.append((adj_row, adj_col))
        return total_ones - reachable_ones",Medium,42,1674,4.0,8,3.0,12.0,39.85714285714285,59.0,0.0128571428571433
700.0,remove outermost parentheses,"class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        if not S:
            return ''
        # find the outmost Paretheses index
        opened = 0
        result = []
        left = 0
        for index,item in enumerate(S):
            opened += 1 if item == '(' else -1
            if opened == 0:
                result.append(S[left+1:index])
                left = index +1
                
        return """".join(result)",Easy,14,450,1.0,2,3.0,4.0,32.142857142857146,21.0,4.747142857142856
701.0,sum of root to leaf binary numbers,"class Solution:
    def sumRootToLeaf(self, root: TreeNode) -> int:
        binaryNumbers = self.pathFinder(root)
        s = 0
        for num in binaryNumbers:
            s += int(num, 2)
        return s
    
    def pathFinder(self, root):
        if root is None:
            return []
        if root.left is None and root.right is None:
            return [str(root.val)]
        lp = self.pathFinder(root.left)
        rp = self.pathFinder(root.right)
        left = [str(root.val) + str(p) for p in lp]
        right = [str(root.val) + str(p) for p in rp]
        return left + right",Easy,17,593,0.0,0,2.0,5.0,34.88235294117647,18.0,4.9405882352941175
702.0,camelcase matching,"class Solution:
    def camelMatch(self, queries, pattern):
        return [Solution.match(q, pattern) for q in queries]

    @staticmethod
    def match(query, pattern):
        hit = []
        idx_start = 0

        for p in pattern:
            idx_find = query.find(p, idx_start)
            if idx_find == -1: return False

            for letter in query[idx_start:idx_find]:
                if letter.isupper(): return False

            hit.append(idx_find)
            idx_start = idx_find + 1

        for letter in query[idx_start:]:
            if letter.isupper(): return False

        return True",Medium,22,612,0.0,2,2.0,7.0,27.818181818181817,23.0,4.956363636363636
703.0,video stitching,"class Solution:
    def videoStitching(self, clips: List[List[int]], T: int) -> int:
        if not T: return 0 # edge case 
        
        ans = yy = mx = 0
        for x, y in sorted(clips):
            if mx < x: return -1 # gap 
            if yy < x <= mx: ans, yy = ans+1, mx
            mx = max(mx, y)
            if T <= mx: return ans + 1
        return -1 # not reaching T",Medium,10,385,3.0,2,3.0,5.0,38.5,27.0,3.655
704.0,divisor game,"class Solution:
    winnums = []
    losenums = [1]
    
    def divisorGame(self, N: int) -> bool:
        if self.calcGame(N) >=0 :
            return True
        else:
            return False

    def calcGame(self, N):
        divisors = []
        
        if N in self.winnums:
            return 1
        if N in self.losenums:
            return -1

        for num in range(1,N):
            if N % num == 0:
                divisors.append(num)
        if len(divisors)==0:
            self.losenums.append(N)
            return -1

        
        for divisor in divisors:
            newNum = N-divisor
            profit = - self.calcGame(newNum)
            
            if profit == 0:
                continue
            if profit >= 0:
                self.winnums.append(N)
                return 1
       
        self.losenums.append(N)
        return -1",Easy,37,879,0.0,2,3.0,9.0,23.75675675675676,36.0,3.961891891891893
705.0,maximum difference between node and ancestor,"class Solution:
    def maxAncestorDiff(self, root: TreeNode) -> int:
        return self._max_ancestor_diff(root, root.val, root.val)

    def _max_ancestor_diff(self, root: TreeNode, max_ancestor_val: int, min_ancestor_val: int) -> int:
        if root is None:
            return 0
        return max(
            abs(max_ancestor_val - root.val),
            abs(min_ancestor_val - root.val),
            self._max_ancestor_diff(
                root.left, max(max_ancestor_val, root.val), min(min_ancestor_val, root.val)),
            self._max_ancestor_diff(
                root.right, max(max_ancestor_val, root.val), min(min_ancestor_val, root.val))
        )",Medium,14,668,0.0,-1,3.0,6.0,47.71428571428572,27.0,2.885714285714285
706.0,longest arithmetic subsequence,"class Solution(object):
  def longestArithSeqLength(self, A):
    idx = collections.defaultdict(list)
    for i, v in enumerate(A):
      idx[v].append(i)
    c = {}
    ans = 0
    for k in range(len(A)):   # last
      for j in range(k):      # middle
        v = 2 * A[j] - A[k]   
        if v in idx:
          for i in idx[v]:    # list of first
            if i >= j: 
              break
            r = 1
            if (i, j) in c:
              r = max(r, c[i, j] + 1)
            ans = max(ans, r)
            c[j, k] = r
    return ans + 2",Medium,19,552,3.0,6,2.0,7.0,29.05263157894737,26.0,4.425263157894737
707.0,recover a tree from preorder traversal,"class Solution:
    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:
        i = 0
        stack = []
        
        fake = TreeNode(0)
        stack.append(fake)
        
        while i < len(traversal):
            lvl = 0
            while i < len(traversal) and traversal[i] == '-':
                lvl += 1
                i += 1
            
            beg = i
            while i < len(traversal) and traversal[i] != '-':
                i += 1
            
            val = int(traversal[beg:i])
            
            while len(stack)  - 1 > lvl:
                stack.pop()
                
            children = TreeNode(val)
            node = stack[-1]
            
            if node.left == None:
                node.left = children
            else:
                node.right = children
            
            stack.append(children)
        
        return stack[0].left",Hard,33,919,0.0,5,3.0,5.0,27.848484848484848,36.0,3.413636363636364
708.0,two city scheduling,"class Solution:
	def twoCitySchedCost(self, costs: List[List[int]]) -> int:
		res=0
		size=len(costs)/2
		CityA=0
		CityB=0
		costs=sorted(costs, key=lambda x:abs(x[0]-x[1]),reverse=True)
		for i in costs:
			if CityB<size and i[0]>=i[1]:
				res+=i[1]
				CityB+=1
			elif CityA<size and i[1]>=i[0]:
				res+=i[0]
				CityA+=1
			elif CityA==size:
				res+=i[1]
			elif CityB==size:
				res+=i[0]       
		return res",Medium,18,417,0.0,5,1.0,5.0,23.166666666666668,38.0,3.755000000000001
709.0,matrix cells in distance order,"class Solution:
    def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
        res = []
        for r in range(0, R):
            for c in range(0, C):
                res.append([r,c])
        return sorted(res, key=lambda x: abs(x[0] - r0) + abs(x[1] - c0))",Easy,6,290,0.0,2,3.0,2.0,48.333333333333336,20.0,3.3500000000000005
710.0,maximum sum of two non overlapping subarrays,"class Solution:
    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        if L<M:
            L,M=M,L
        res=-float('inf')
        for i in range(len(A)-L+1):
            temp1=sum(A[i:i+L])
            #if left
            if i>=M:
                for j in range(i-M+1):
                    t2=sum(A[j:j+M])
                    res=max(res,temp1+t2)
            #if right
            if len(A)-i-L>=M:
                for j in range(i+L,len(A)):
                    t2=sum(A[j:j+M])
                    res=max(res,temp1+t2)
        return res",Medium,17,570,2.0,6,4.0,8.0,33.529411764705884,35.0,2.96235294117647
711.0,moving stones until consecutive,"class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        a,b,c = sorted([a,b,c])
        d1 = abs(b-a)-1 
        d2 = abs(c-b)-1
        mi = 2
        if d1 == 0 and d2 == 0: mi = 0
        elif d1 <= 1 or d2 <= 1: mi =1    
        ma = c - a - 2
        return [mi,ma]",Medium,9,306,0.0,2,2.0,2.0,34.0,33.0,3.3999999999999995
712.0,coloring a border,"class Solution:
    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        orig = grid[r0][c0]
        seen = {(r0, c0)}
        stack = [(r0, c0)]
        while stack: 
            i, j = stack.pop()
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                if (ii, jj) not in seen:
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == orig: 
                        stack.append((ii, jj))
                        seen.add((ii, jj))
                    else: grid[i][j] = color 
        return grid",Medium,14,629,0.0,4,4.0,4.0,44.92857142857143,47.0,0.7764285714285712
713.0,uncrossed lines,"class Solution:
    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:
        ans = [0]*(1 + len(B))
        for i in reversed(range(len(A))): 
            tmp = ans.copy()
            for j in reversed(range(len(B))): 
                if A[i] == B[j]: ans[j] = 1 + tmp[j+1]
                else: ans[j] = max(tmp[j], ans[j+1])
        return ans[0]",Medium,8,363,0.0,3,3.0,3.0,45.375,19.0,3.65625
714.0,escape a large maze,"class Solution:
    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        blocked = set(map(tuple, blocked))
        
        def dfs(sx, sy, tx, ty): 
            """"""Return True if (x, y) is not looped from (tx, ty).""""""
            seen = {(sx, sy)}
            stack = [(sx, sy)]
            while stack: 
                x, y = stack.pop()
                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True 
                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): 
                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: 
                        seen.add((xx, yy))
                        stack.append((xx, yy))
            return False 
        
        return dfs(*source, *target) and dfs(*target, *source)",Hard,17,852,0.0,1,4.0,5.0,50.11764705882353,53.0,-0.1105882352941201
715.0,valid boomerang,"class Solution:
    def isBoomerang(self, p: List[List[int]]) -> bool:
        return (p[2][1]-p[1][1])*(p[1][0]-p[0][0]) != (p[2][0]-p[1][0])*(p[1][1]-p[0][1])
		
		
- Junaid Mansuri",Easy,5,183,0.0,0,1.0,0.0,36.6,6.0,6.045999999999999
716.0,binary search tree to greater sum tree,"class Solution:
    def bstToGst(self, root: TreeNode) -> TreeNode:
        
        def fn(node, val):
            """"""Return updated node's value.""""""
            if node.right: val = fn(node.right, val)
            node.val = val = node.val + val
            if node.left: val = fn(node.left, val)
            return val 
            
        fn(root, 0)
        return root",Medium,11,375,0.0,0,3.0,2.0,34.09090909090909,16.0,5.151818181818182
717.0,minimum score triangulation of polygon,"class Solution:
    def recursion(self,start,end):
        if start >= end :
            return 0
        
        if self.dp[start][end] != -1 : return self.dp[start][end]

        best = float('inf')
        
        for mid in range(start,end):
            tmp = self.recursion(start,mid) + self.recursion(mid+1,end) + \
            self.values[start-1]*self.values[mid]*self.values[end]
            if tmp < best: best = tmp
        
        self.dp[start][end] = best
        return best
    
    def minScoreTriangulation(self, values: List[int]) -> int:
        n = len(values)
        self.dp = [[-1 for i in range(n)] for j in range(n)]
        self.values = values
        return self.recursion(1,n-1)",Medium,21,711,0.0,1,2.0,6.0,33.857142857142854,27.0,4.072857142857144
718.0,moving stones until consecutive ii,"class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        high = max(stones[-1] - stones[1], stones[-2] - stones[0]) - (len(stones) - 2)
        
        ii, low = 0, inf
        for i in range(len(stones)): 
            while stones[i] - stones[ii] >= len(stones): ii += 1
            if i - ii + 1 == stones[i] - stones[ii] + 1 == len(stones) - 1: low = min(low, 2)
            else: low = min(low, len(stones) - (i - ii + 1))
        return [low, high]",Medium,10,507,0.0,3,3.0,3.0,50.7,28.0,2.277000000000001
719.0,robot bounded in circle,"class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
       
        # Dictionary, which outputs change in direction
        # given the current direction and instruction
        directions = {0: {""G"": 0, ""L"": 3, ""R"": 1}, # North
                      1: {""G"": 1, ""L"": 0, ""R"": 2}, # East
                      2: {""G"": 2, ""L"": 1, ""R"": 3}, # South
                      3: {""G"": 3, ""L"": 2, ""R"": 0}} # West
        
        # Start position
        start = (0,0) # (x,y)
        
        # Function which will run robot once
        def moveRobot(curr, direction):
            
            # Loop for each instruction
            for instruction in instructions:
                
                # Set position
                if instruction == ""G"":
                    if direction == 0: # North
                        curr = (curr[0],curr[1]+1)
                    elif direction == 1: # East
                        curr = (curr[0]+1,curr[1])
                    elif direction == 2: # South
                        curr = (curr[0],curr[1]-1)
                    elif direction == 3: # West
                        curr = (curr[0]-1,curr[1])
                    else:
                        pass

                # Set direction
                direction = directions[direction][instruction]
                
            return (curr, direction)
        
		# Move robot from start position and pointing to North
        curr, direction = moveRobot(start,0)
        
        # Case 1:
        # If robot return to start then it won't leave a cetrain area
        if (curr == start):
            return True
        
        # Case 2:
        # If robot is not pointing towards north, it means it has changed
        # direction, so in next iteration it will change direction again,
        # and in next iteration again, and so on, so it will remain it
        # a certain bounded area no matter what.
        if (direction != 0):
            return True
        
        return False",Medium,53,2006,24.0,4,4.0,11.0,37.84905660377358,87.0,-1.6264150943396256
720.0,flower planting with no adjacent,"class Solution:
    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:
        # n gardens 1 to n
        # paths [x,y] bidirectional path between garden x and y
        # in each garden plant one of 4 types of flowers
        # at most 3 paths coming into or leaving it
        # choose flower type -> any two gardens connected by path have different flowers
        # return any choice of answers : answer[i] = flower in (i+1)th garden
        
        nodes = [x for x in range(n)]
        colour = [None]*n
        edges = {x:{} for x in range(n)}
        for x,y in paths:
            edges[x-1][y-1] = True
            edges[y-1][x-1] = True
        for node in range(n):
            adj = edges[node]
            blocked = [False]*n
            size = 4
            for x in adj:
                if colour[x] != None:blocked[colour[x]-1] = True
            if blocked[0] == False:
                colour[node] = 1
            elif blocked[1] == False:
                colour[node] = 2
            elif blocked[2] == False:
                colour[node] = 3
            elif blocked[3] == False:
                 colour[node] = 4
        return colour",Medium,29,1173,6.0,7,3.0,11.0,40.44827586206897,47.0,1.299655172413793
721.0,partition array for maximum sum,"class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        
        @lru_cache(None)
        def fn(i):
            """"""Return maximum sum of arr[:i].""""""
            if i == 0: return 0 # boundary condition 
            ans = 0
            for kk in range(1, min(i, k)+1): 
                ans = max(ans, fn(i-kk) + max(arr[ii] for ii in range(i-kk, i)) * kk)
            return ans 
        
        return fn(len(arr))",Medium,12,454,1.0,-1,3.0,3.0,37.833333333333336,20.0,4.515
722.0,longest duplicate substring,"class Solution:
    def longestDupSubstring(self, s: str) -> str:
        results = set()
        window = len(s)//2
        largest = """"
        while window > len(largest):
            for right in range(window, len(s)+1):
                substr = s[right-window:right]
                if substr in results:
                    if len(substr) > len(largest):
                        largest = substr
                        window += (len(s)-window)//2+1
                        results.clear()
                        continue
                else:
                    results.add(substr)
            else:
                if window == len(largest) + 1:
                    break
                window = max(window//2, len(largest)+1)
        return largest",Hard,20,761,0.0,3,4.0,5.0,38.05,27.0,3.4555000000000007
723.0,last stone weight,"class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        for i, stone in enumerate(stones):
            stones[i] = -stone
        heapq.heapify(stones)

        while len(stones) > 1:
            y, x = heapq.heappop(stones), heapq.heappop(stones)
            if x != y:
                heapq.heappush(stones, y - x)
        
        return -stones[0] if stones else 0",Easy,11,393,0.0,3,3.0,5.0,35.72727272727273,16.0,4.824545454545455
724.0,remove all adjacent duplicates in string,"class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []
        for char in s:
            if stack:
                # check if last element in stack
                # equals current char
                if char == stack[-1]:
                    stack.pop()
                    continue
                else:
                    stack.append(char)
            else:
                stack.append(char)

        return """".join(stack)",Easy,15,457,2.0,2,4.0,4.0,30.466666666666665,14.0,5.578
725.0,longest string chain,"class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        words.sort(key = lambda x : len(x))
        dis_map = collections.defaultdict(int)
        for w in words:
            maybe = [w[:i] + w[i + 1:] for i in range(len(w))]
            for m in maybe:
                dis_map[w] = max(dis_map[m] + 1, dis_map[w])
        return max(dis_map.values())",Medium,8,375,0.0,2,3.0,3.0,46.875,15.0,3.98125
726.0,last stone weight ii,"class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        if len(stones) == 1:
            return stones[0]
        
        S = sum(stones)
        half = sum(stones) // 2
        
        mat = [False for _ in range(half+1)]
        
        for i in stones:
            arr = []
            for j in range(len(mat)):
                if j == i:
                    arr.append(i)
                elif i < j and not mat[j] and mat[j-i]:
                    arr.append(j)
            for x in arr: # simultaneous update
                mat[x] = True
        
        s2 = max([i for i in range(len(mat)) if mat[i]])
        return abs(S-2*s2)",Medium,21,666,1.0,5,3.0,9.0,31.714285714285715,24.0,4.305714285714286
727.0,height checker,"class Solution(object):
    def heightChecker(self, heights):
        """"""
        :type heights: List[int]
        :rtype: int
        """"""
        count =0
        k =heights[:]
        heights.sort()
        for i in range(len(heights)):
            if heights[i] != k[i]:
                count +=1
        return count",Easy,12,320,0.0,2,3.0,2.0,26.666666666666668,14.0,5.9
728.0,grumpy bookstore owner,"class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
        accC = [0]
        n = len(customers)
        for x in customers:
            accC.append(x + accC[-1])
        for i, x in enumerate(grumpy):
            if x == 1: customers[i] = 0
        accCG = [0]   
        for x in customers:
            accCG.append(x + accCG[-1])
        return max(accC[min(i+X-1, n)]-accC[i-1] + accCG[-1] - (accCG[min(i+X-1, n)]-accCG[i-1]) for i in range(1, n+1))",Medium,11,502,0.0,4,3.0,5.0,45.63636363636363,24.0,3.072727272727273
729.0,previous permutation with one swap,"class Solution:
    def prevPermOpt1(self, arr: List[int]) -> List[int]:
        for i in reversed(range(len(arr)-1)):
            if arr[i] > arr[i+1]: break 
        else: return arr 
        
        ii, val = i, 0
        for k in range(i+1, len(arr)): 
            if val < arr[k] < arr[i]: ii, val = k, arr[k]
        
        arr[i], arr[ii] = arr[ii], arr[i]
        return arr",Medium,11,385,0.0,2,3.0,4.0,35.0,23.0,4.25
730.0,distant barcodes,"class Solution:
    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:
        # Get the counts of all of our barcode elements.
        cnts = collections.Counter(barcodes)
		# Put the -'ve counts along with themselves into a min heap.
		# For those new to this we use -'ve because this is a min heap, so largest cnt pop'd first.
        heap = [(-v, k) for k,v in cnts.items()]
        heapq.heapify(heap)
        res = []
        # While we have elements on our heap.
        while heap:
		    # pop the top element.
            cnt1, num1 = heapq.heappop(heap)
			# If the top element was the last we used, we need something different.
            if res and res[-1] == num1:
			    # pop the next highest cnt element. 
                cnt, num = heapq.heappop(heap)
                res.append(num)
                cnt += 1
				# If there's still elements left we put them back on the heap.
                if cnt != 0:
                    heapq.heappush(heap, (cnt, num))
				# We can also add the first that we popped, and push it back on the heap as well.
                res.append(num1)
                cnt1 += 1
                if cnt1 != 0:
                    heapq.heappush(heap, (cnt1, num1))
			# else we just add the highest cnt element and put the remaining back on.
            else:
                res.append(num1)
                cnt1 += 1
                if cnt1 != 0:
                    heapq.heappush(heap, (cnt1, num1))
            
        return res",Medium,34,1488,10.0,5,3.0,12.0,43.76470588235294,38.0,2.181176470588236
731.0,greatest common divisor of strings,"class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        strings = [str1, str2] if len(str1) > len(str2) else [str2, str1]
        
        
        for length in range(len(strings[1]), 0, -1):
            if (not len(strings[0]) % length and not len(strings[1]) % length):
                substring = strings[1][:length]
                number_substrings_1 = len(strings[0]) // length
                number_substrings_2 = len(strings[1]) // length
                
                
                if (number_substrings_1 == strings[0].count(substring) and
                   number_substrings_2 == strings[1].count(substring)):
                    return substring
                
        return """"",Easy,16,726,0.0,1,4.0,4.0,45.375,26.0,3.0162500000000003
732.0,flip columns for maximum number of equal rows,"class Solution:
    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        d = collections.defaultdict(int)                # hashmap for counting
        m, n = len(matrix), len(matrix[0])
        for i in range(m):
            reverse = not matrix[i][0]                  # decide whether need to reverse bit
            cur = ''                                    # expanded version of above 1 liner
            for j in range(n):
                if reverse:
                    cur += '0' if matrix[i][j] else '1'
                else:    
                    cur += '1' if matrix[i][j] else '0'
            d[cur] += 1                                 # count frequency
        return max(d.values())",Medium,13,721,4.0,3,5.0,6.0,55.46153846153846,18.0,2.88846153846154
733.0,adding two negabinary numbers,"class Solution:
    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:
        x = reduce(lambda x, y: x*(-2) + y, arr1)
        x += reduce(lambda x, y: x*(-2) + y, arr2)
        ans = []
        while x: 
            ans.append(x &amp; 1)
            x = -(x >> 1)
        return ans[::-1] or [0]",Medium,8,319,0.0,1,3.0,1.0,39.875,22.0,3.97125
734.0,number of submatrices that sum to target,"class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        if not matrix:
            return 0
        
        def num_for_one_row(nums):
            prev = {}
            prev[0] = 1
            cur_sum = 0
            ans = 0
            for num in nums:
                cur_sum += num
                if cur_sum - target in prev:
                    ans += prev[cur_sum - target]
                if cur_sum not in prev:
                    prev[cur_sum] = 1
                else:
                    prev[cur_sum] += 1
            return ans 
        
        res = 0
        m = len(matrix)
        n = len(matrix[0])
        
        for i in range(m):
            nums = [0]*n
            for j in range(i,m):
                for k in range(n):
                    nums[k]+=matrix[j][k]
                res += num_for_one_row(nums)
                
        return res",Hard,31,921,0.0,5,4.0,9.0,29.70967741935484,31.0,3.686129032258065
736.0,letter tile possibilities,"class Solution:
    def numTilePossibilities(self, tiles: str) -> int:
        res=[]
        def rec(t,now,k):
            nonlocal res
            if k==1:
                for i in t:
                    res.append(now+i)
                return
            for i in range(len(t)):
                rec(t[:i]+t[i+1:],now+t[i],k-1)
        for i in range(1,len(tiles)+1):
            rec(tiles,'',i)
        return(len(set(res)))",Medium,13,428,0.0,3,3.0,4.0,32.92307692307692,23.0,4.376923076923077
737.0,insufficient nodes in root to leaf paths,"class Solution:
    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:
        cands = set()
        def dfs(node, s):
            if node.left is None and node.right is None:
                if (s + node.val) < limit:
                    return True
                else:
                    return False
            else:
                if node.left:
                    left = dfs(node.left, s + node.val)
                    if left:
                        node.left = None
                else:
                    left = True
                if node.right:
                    right = dfs(node.right, s + node.val)
                    if right:
                        node.right = None
                else:
                    right = True
                return left and right
        if dfs(root, 0):
            return None
        return root",Medium,25,873,0.0,3,4.0,7.0,34.92,31.0,3.3372
738.0,smallest subsequence of distinct characters,"class Solution:
    def smallestSubsequence(self, s: str) -> str:
        stack = []
        for i, c in enumerate(s):
            if c in stack:
                continue
            while stack and stack[-1] in s[i:] and c < stack[-1]:
                stack.pop()
            if c not in stack:
                stack.append(c)
        return ''.join(stack)",Medium,10,357,0.0,3,3.0,4.0,35.7,13.0,5.127000000000001
739.0,duplicate zeros,"class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        temp = []
        for i in arr:
            if i == 0:
                temp.append(0)
                temp.append(0)
            else:
                temp.append(i)
        for i in range(len(arr)):
            arr[i] = temp[i]",Easy,13,391,0.0,3,3.0,4.0,30.07692307692308,15.0,5.433076923076923
741.0,shortest path in binary matrix,"class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        N, M = len(grid), len(grid[0])
        directions = ((1,1),(1,0),(0,1),(1,-1),(-1,1),(0,-1),(-1,0),(-1,-1))
        
        Coordinate = namedtuple('Coordinate', ['x', 'y'])
        start = Coordinate(0,0)
        goal = Coordinate(N-1, M-1)
        
        if grid[start.x][start.y] != 0:
            return -1
        
        def withinBounds(curr):
            return 0 <= curr.x < N and 0 <= curr.y < M
        
        queue = deque([(start)])
        grid[start.x][start.y] = 1
        pathLength = 1
        
        while queue:
            for _ in range(len(queue)):
                curr = queue.popleft()

                if curr == goal:
                    return pathLength

                for r, c in directions:
                    neigh = Coordinate(curr.x + r, curr.y + c)
                    if withinBounds(neigh) and grid[neigh.x][neigh.y] == 0:
                        grid[neigh.x][neigh.y] = 1
                        queue.append(neigh)
            
            pathLength += 1

        return -1",Medium,34,1119,0.0,3,3.0,6.0,32.911764705882355,60.0,0.6779411764705898
742.0,shortest common supersequence,"class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        
        @lru_cache(None)
        def fn(i, j): 
            """"""Return min length of common supersequence of str1[i:] and str2[j:].""""""
            if i == len(str1): return len(str2)-j
            if j == len(str2): return len(str1)-i
            if str1[i] == str2[j]: return 1 + fn(i+1, j+1)
            return 1 + min(fn(i+1, j), fn(i, j+1))
        
        ans = []
        i = j = 0 
        while i < len(str1) and j < len(str2): 
            if str1[i] == str2[j]: 
                ans.append(str1[i])
                i += 1
                j += 1
            elif fn(i+1, j) < fn(i, j+1): 
                ans.append(str1[i])
                i += 1
            else: 
                ans.append(str2[j])
                j += 1
        return """".join(ans) + str1[i:] + str2[j:]",Hard,24,881,0.0,1,3.0,6.0,36.708333333333336,48.0,1.6562499999999982
743.0,statistics from a large sample,"class Solution:
    def sampleStats(self, count: List[int]) -> List[float]:
        total = sum(count)
        mn = med0 = med1 = -1 
        psm = cnt = mode = 0
        for i, x in enumerate(count): 
            if x: 
                if mn < 0: mn = i
                mx = i
                psm += i * x
                cnt += x
                if cnt >= (total+1)//2 and med0 < 0: med0 = i
                if cnt >= (total+2)//2 and med1 < 0: med1 = i
                if x > count[mode]: mode = i
        return [mn, mx, psm/total, (med0+med1)/2, mode]",Medium,14,556,0.0,6,3.0,6.0,39.71428571428572,38.0,2.0857142857142854
744.0,car pooling,"class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        trips = sorted(trips, key = lambda a: a[1])
        # print(trips)
        i = 0
        j = trips[0][1]
        se = collections.defaultdict(int)
        while i< len(trips):
            capacity+=se[j]
            del se[j]
            if j == trips[i][1]:
                se[trips[i][2]] += trips[i][0]
                capacity-= trips[i][0]
                i+=1
                if capacity<0:
                    return False
            
            else:
                j+=1
        return True",Medium,19,598,1.0,2,3.0,3.0,31.473684210526315,28.0,4.107368421052632
745.0,find in mountain array,"class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        low = 0
        high = mountain_arr.length()
        peak = -1
        
        while (low < high - 1):
            mid = (low + high) // 2
            midVal = mountain_arr.get(mid)
            leftMid = mountain_arr.get(mid - 1)
            rightMid = mountain_arr.get(mid + 1)

            if (midVal > leftMid and midVal > rightMid):
                peak = mid
                break
            elif (midVal > leftMid and midVal < rightMid):
                low = mid 
            else:
                high = mid
        
        low = 0
        high = peak
        while (low <= high):
            mid = (low + high) // 2
            midVal = mountain_arr.get(mid)
            
            if midVal == target:
                return mid
            elif midVal < target:
                low = mid + 1
            else:
                high = mid - 1
                
        low = peak
        high = mountain_arr.length() - 1
        while (low <= high):
            mid = (low + high) // 2
            print(low, mid, high)
            midVal = mountain_arr.get(mid)
            
            if midVal == target:
                return mid
            elif midVal < target:
                high = mid - 1
            else:
                low = mid + 1
        
        return -1",Hard,47,1398,0.0,6,3.0,9.0,29.74468085106383,60.0,0.7829787234042556
746.0,brace expansion ii,"class Solution:
    def braceExpansionII(self, s: str) -> List[str]:
        def getWord():
            nonlocal i
            word = """"
            while i < len(s) and s[i].isalpha():
                word += s[i]
                i += 1
            return word
        
        
        def dfs():
            nonlocal i
            res = set()
            if s[i] == '{':
                i += 1
                res.update(dfs())
                while i < len(s) and s[i] == ',':
                    i += 1
                    res.update(dfs())
                i += 1
            elif s[i].isalpha():
                res.add(getWord())

            while i < len(s) and (s[i] == '{' or s[i].isalpha()): 
                res = {w + a for a in dfs() for w in res}
            return res

        i = 0
        return sorted(dfs())",Hard,29,829,0.0,3,3.0,7.0,28.58620689655172,34.0,3.6672413793103456
747.0,distribute candies to people,"class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        cycle_offset = num_people * (num_people + 1) // 2
        cycles = 0
        n_2 = num_people ** 2
        required_candies = cycle_offset
        ret = []
        
        
        while (candies >= required_candies):
            cycles += 1
            candies -= required_candies
            required_candies = cycles * n_2 + cycle_offset

        
        if (cycles > 0):
            fixed_candy_size = cycles * (cycles - 1) // 2 * num_people


            for person in range(1, num_people + 1):
                ret.append(fixed_candy_size + cycles * person)
                
            fixed_candy_size = cycles * num_people


            for person in range(num_people):
                person_candies = fixed_candy_size + person + 1


                if (person_candies > candies):
                    ret[person] += candies
                    return ret
                else:
                    ret[person] += person_candies
                    candies -= person_candies
        else:
            skip = False
            
            
            for person in range(1, num_people + 1):
                if (skip):
                    ret.append(0)
                elif (candies < person):
                    ret.append(candies)
                    skip = True
                else:
                    ret.append(person)
                    candies -= person
                    
            return ret",Easy,49,1518,0.0,7,3.0,8.0,30.97959183673469,42.0,2.4118367346938783
749.0,filling bookcase shelves,"class Solution:
    def minHeightShelves(self, books: List[List[int]], shelf_width: int) -> int:
        if not books:
            return 0
        
        # dynamic programming
        # key = (extra_width at the last level, last layer height)
        # value = min_height
        best = dict()
        best[(shelf_width, 0)] = 0
        for width, height in books:
            new_best = dict()
            for (width_left, level_height), total_height in best.items():
                # start new level
                key = (shelf_width - width, height)
                val = total_height + height
                if key in new_best:
                    new_best[key] = min(new_best[key], val)
                else:
                    new_best[key] = val
                # use current level
                if width <= width_left:
                    key = (width_left - width, max(height, level_height))
                    val = total_height + max(height, level_height) - level_height
                    if key in new_best:
                        new_best[key] = min(new_best[key], val)
                    else:
                        new_best[key] = val
            best = new_best
        return min(best.values())",Medium,29,1227,5.0,5,4.0,6.0,42.310344827586206,42.0,1.6520689655172394
750.0,parsing a boolean expression,"class Solution:
    def parseBoolExpr(self, expression: str) -> bool:     
        # 0b0000 - ' '
        # 0b0100 - '!'
        # 0b1000 - '&amp;'
        # 0b1100 - '|'
        # 0b0010 (2) - if t in expression
        # 0b0001 (1) - if f in expression
        
        d = { 0b0110:1, 0b0101:2,
               0b1010:2, 0b1001:1, 0b1011:1,
               0b1110:2, 0b1101:1, 0b1111:2,
               0b0010:True, 0b0001:False }        

            
        levels = [0]
        for x in expression:                             
            if x == ',' or x == ""("":
                continue
            elif x == 't':
                levels[-1] |= 2
            elif x == 'f':
                levels[-1] |= 1
            elif x == ')':     
                level = levels.pop()
                levels[-1] |= d[level]
            elif x =='!':
                levels.append(0b0100)
            elif x =='&amp;':
                levels.append(0b1000)
            elif x =='|':
                levels.append(0b1100)                            
                
        return d[levels[0]]",Hard,33,1088,6.0,7,4.0,10.0,32.96969696969697,63.0,0.3127272727272725
751.0,defanging an ip address,"class Solution:
    def defangIPaddr(self, address: str) -> str:
        return (""[.]"".join(address.split(""."")))",Easy,2,112,0.0,0,2.0,0.0,56.0,5.0,4.34
752.0,corporate flight bookings,"class Solution:
    def corpFlightBookings(self, b: List[List[int]], n: int) -> List[int]:
        res=[0]*n
        for i,j,k in b:
            for m in range(i-1,j):
                res[m]+=k
        return res",Medium,6,212,0.0,2,3.0,2.0,35.333333333333336,14.0,5.12
753.0,delete nodes and return forest,"class Solution:
    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:
        trees = []
        targets = set(to_delete)
        def dfs(root):
            if (not root): return root
            root.left = dfs(root.left)
            root.right = dfs(root.right)
            if (root.val not in targets): return root
            if (root.left): trees.append(root.left)
            if (root.right): trees.append(root.right)
            return None
        dummy = TreeNode(to_delete[0], left=root)
        dfs(dummy)
        return trees",Medium,14,563,0.0,1,3.0,4.0,40.21428571428572,19.0,4.240714285714287
754.0,maximum nesting depth of two valid parentheses strings,"class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        depths = [0, 0] #depths[0]: A, depths[1]: B
        answer = []
        
        
        for char in seq:
            if (char == '('):
                if (depths[0] < depths[1]):
                    answer.append(0)
                    depths[0] += 1
                else:
                    answer.append(1)
                    depths[1] += 1
            else:
                if (depths[0] > depths[1]):
                    depths[0] -= 1 
                    answer.append(0)
                else:
                    depths[1] -= 1
                    answer.append(1)
            
        return answer",Medium,22,691,1.0,4,4.0,4.0,31.40909090909091,27.0,4.033181818181817
755.0,relative sort array,"class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        return sorted(arr1, key=lambda x: (arr2.index(x) if x in arr2 else math.inf, x))",Easy,2,184,0.0,0,2.0,1.0,92.0,11.0,0.5000000000000018
756.0,lowest common ancestor of deepest leaves,"class Solution:
    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        
        @lru_cache(None)
        def fn(node):
            """"""Return height of tree rooted at node.""""""
            if not node: return 0 
            return 1 + max(fn(node.left), fn(node.right))
        
        node = root
        while node: 
            left, right = fn(node.left), fn(node.right)
            if left == right: return node
            elif left > right: node = node.left
            else: node = node.right",Medium,14,512,0.0,1,3.0,4.0,36.57142857142857,22.0,4.26857142857143
757.0,longest well performing interval,"class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        prefixSum=0
        hmap=defaultdict(int)
        ans=0
        for length,hour in enumerate(hours):
            prefixSum+=1 if hour>8 else -1
            if prefixSum>0:ans=max(ans,length+1)
            if prefixSum not in hmap:
                hmap[prefixSum]=length
            if prefixSum-1 in hmap:
                ans=max(ans,length-hmap[prefixSum-1])
        return ans",Medium,12,453,0.0,4,3.0,5.0,37.75,21.0,4.0825
758.0,smallest sufficient team,"class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        
        n_skills = len(req_skills)
        n_people = len(people)
        
        # index skills
        skill_map = {x: i for i, x in enumerate(req_skills)}
        
        # descending sort by length of skills per person
        people = sorted([(i, x) for i, x in enumerate(people)], key=lambda x: -len(x[1]))
        
        # bit people skill
        people_bit = {}
        for i, p in people:
            tmp = 0
            for s in p:
                tmp |= 1 << skill_map[s]
            # if a person skill cannot be covered from pervious people then added
            if all(x | tmp != x for x in people_bit): people_bit[tmp] = i 
        
        # reverse skill set and id
        people_bit = {v: k for k, v in people_bit.items()}
        cands = [*people_bit.keys()]

        # final answer and size for recording minimum team size
        self.ans = None
        self.size = float('inf')

        @lru_cache(None)
        def dp(i, mask, team):
            if mask == (1 << n_skills) - 1 and self.size > len(team):
                self.size = len(team)
                self.ans = team
                return
            if i == len(cands):
                return
            # if current person has skill not covered by previous included skills
            if mask | people_bit[cands[i]] != mask:
                dp(i + 1, mask | people_bit[cands[i]], tuple(set(team)|{cands[i]}))
            dp(i + 1, mask, team)


        dp(0, 0, tuple())
        return self.ans",Hard,44,1609,7.0,5,3.0,13.0,36.56818181818182,59.0,0.608863636363635
759.0,number of equivalent domino pairs,"class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
    	s, D = 0, {}
    	for d in dominoes:
    		x = tuple(sorted(d))
    		if x in D:
    			D[x] += 1
    		else:
    			D[x] = 0
    	return sum([i*(i+1)//2 for i in list(D.values())])
		
		
- Python 3
- Junaid Mansuri",Easy,13,305,0.0,2,1.0,3.0,23.46153846153846,14.0,6.308461538461538
761.0,minimum cost tree from leaf values,"class Solution:
    
    def __init__(self):
        self.m={}
    
    def mctFromLeafValues(self, arr: List[int]) -> int:
        
        def find_max(st,end,arr):
            if arr[st:end+1]==[]:
                return 0
            return max(arr[st:end+1])
        
        def helper(st,en,arr):
            
            if st==en:
                self.m[str(st)+"" ""+str(en)]=0
                return 0
            
            if (en-st)==1:
                self.m[str(st)+"" ""+str(en)]=arr[st]*arr[en]
                return arr[st]*arr[en]
            
            if str(st)+"" ""+str(en) in self.m:
                return self.m[str(st)+"" ""+str(en)] 
            
            ans=float(""inf"")
            
            for i in range(st,en):
                
                a=find_max(st,i,arr)
                b=find_max(i+1,en,arr)
                temp=helper(st,i,arr)+helper(i+1,en,arr)
                
                ans=min(ans,temp+(a*b))
                
            self.m[str(st)+"" ""+str(en)]=ans
            return ans
                
            
        
        
        return helper(0,len(arr)-1,arr)",Medium,41,1129,0.0,-1,3.0,5.0,27.536585365853657,49.0,2.50170731707317
762.0,maximum of absolute value expression,"class Solution:
    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
    	M = 0
    	for c in [[1,1],[1,-1],[-1,1],[-1,-1]]:
    		m = float('inf')
    		for i in [arr1[i]*c[0]+arr2[i]*c[1]+i for i in range(len(arr1))]:
    			if i < m: m = i
    			if i - m > M: M = i - m
    	return M
		
		
- Python 3
- Junaid Mansuri",Medium,12,338,0.0,4,1.0,5.0,28.166666666666668,24.0,4.765
763.0,n th tribonacci number,"class Solution:
    def tribonacci(self, n: int) -> int:
        
        if n < 3:
            if n == 0:
                return 0
            if n == 1 or n == 2:
                return 1
        
        t0, t1, t2 = 0, 1, 1

        for i in range(3, n + 1):
            t = t0 + t1 + t2
            t0 = t1
            t1 = t2
            t2 = t

        return t",Easy,17,368,0.0,2,3.0,4.0,21.647058823529413,29.0,4.851764705882353
764.0,alphabet board path,"class Solution:
    def alphabetBoardPath(self, target):
        hashTable = [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [5, 0]]
        OFFSET, current = 97, 0
        res = """"
        
        for t in target:
            v_move = hashTable[current][0] - hashTable[ord(t)-OFFSET][0]
            h_move = hashTable[current][1] - hashTable[ord(t)-OFFSET][1]
            
            while v_move != 0 or h_move != 0:
                #Go vertical direction
                while v_move != 0:
                    if v_move < 0 and current < 21:
                        res += 'D'
                        v_move += 1
                        current += 5
                    elif v_move > 0:
                        res += 'U'
                        v_move -= 1
                        current -= 5
                    else:
                        break
                
                #Go horizontal direction     
                current -= h_move
                while h_move != 0:
                    if h_move < 0:
                        res += 'R'
                        h_move += 1
                    else:
                        res += 'L'
                        h_move -= 1
            res += '!'
        return res",Medium,34,1385,2.0,6,5.0,7.0,40.73529411764706,90.0,-3.246176470588235
765.0,largest 1 bordered square,"class Solution:
    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions 
        
        hori = deepcopy(grid)
        vert = deepcopy(grid)
        for i in range(m):
            for j in range(n): 
                if grid[i][j]: 
                    if j: hori[i][j] += hori[i][j-1] # horizontal precipitation
                    if i: vert[i][j] += vert[i-1][j] # vertical precipitation 
        
        ans = 0
        for i in reversed(range(m)):
            for j in reversed(range(n)): 
                val = min(hori[i][j], vert[i][j])
                while val > ans: 
                    if vert[i][j-val+1] >= val and hori[i-val+1][j] >= val: 
                        ans = val 
                    val -= 1
        return ans*ans",Medium,20,807,3.0,9,4.0,9.0,40.35,31.0,2.6085
766.0,stone game ii,"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        @functools.cache
        def dp(l, m, i_am_alice): # lets return alice count
            if l == len(piles): return 0
            
            left = []
            taking_now = 0

            for x in range(2*m):
                if l+x == len(piles): break
                
                if i_am_alice:
                    taking_now += piles[l+x]
                taking_later = dp(l+x+1, max(m,x+1), not i_am_alice)
                
                left.append(taking_now + taking_later)
        
            if i_am_alice: # i want to maximize alice
                return max(left)
            
            else: # i am bob, want to minimize alice
                return min(left)
        
        return dp(0,1,True)",Medium,24,799,3.0,0,3.0,5.0,33.291666666666664,30.0,3.943750000000001
767.0,longest common subsequence,"class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text1)+1) for _ in range(len(text2)+1)]
        for i in range(1, len(text2)+1):
            for j in range(1, len(text1)+1):
                if text1[j-1] == text2[i-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[len(text2)][len(text1)]",Medium,9,453,0.0,3,4.0,4.0,50.333333333333336,20.0,3.05
768.0,decrease elements to make array zigzag,"class Solution:
    def movesToMakeZigzag(self, nums: List[int]) -> int:
    	L, m, M = len(nums), 0, 0
    	for i in range(1,L-1,2):
    		t = min(nums[i-1],nums[i+1])
    		if nums[i] >= t: m += nums[i] - t + 1
    	if i == L - 3 and nums[-1] >= nums[-2]: m += nums[-1] - nums[-2] + 1
    	for i in range(2,L-1,2):
    		t = min(nums[i-1],nums[i+1])
    		if nums[i] >= t: M += nums[i] - t + 1
    	if nums[0] >= nums[1]: M += nums[0] - nums[1] + 1
    	if (i == L - 3 or i == 1) and nums[-1] >= nums[-2]: M += nums[-1] - nums[-2] + 1
    	return min(m,M)
		
		
- Junaid Mansuri",Medium,15,580,0.0,7,1.0,7.0,38.66666666666666,50.0,1.0399999999999991
769.0,binary tree coloring game,"class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:
        # solution below doesn't use all the info provided
        # namely, total number of nodes
        # do a simple dfs to capture left, right nodes from target x
        # this gives you p1, p2 and p3
        # O(N) time and O(H) tree height call space

        def rcrs(node) -> int:
            if not node: return 0
            lt = rcrs(node.left)
            rt = rcrs(node.right)
            if node.val == x: self.cnts.extend([lt,rt])
            return lt + rt + 1

        self.cnts = []
        rcrs(root)
        self.cnts.append( n - 1 - sum(self.cnts) )
        return (2*max(self.cnts) - sum(self.cnts)) > 1

    def btreeGameWinningMove1(self, root: TreeNode, n: int, x: int) -> bool:
        # draw tree diagrams to find the pattern
        # for any given node, there are three potential paths away
        # Pa, Pb, Pc == (up, left, right)
        # start from chosen X node, find length of path in directions A,B,C
        # if there exists a value P1 > (P2 + P3 + 1), then guaranteed win
        # or P1 - P2 - P3 > 1
        #    max(all) - (sum(all) - max(all)) > 1
        #    2*max(all) - sum(all) > 1

        # traverse tree from root, create parent dict to allow upward travel
        # then start from chosen X and find P_up, P_left, P_right
        # take the max value from paths, if > other two + 1, return true else false
        # recursive dfs helper function
        # repeat three times with each of x.left, x.right, x.prnt
        # O(N) time and space

        d, self.start = {}, None
        def rcrs_dn(node, prnt) -> None:
            if not node: return
            if node.val == x:
                self.start = node
            d[node] = prnt
            rcrs_dn(node.left, node)
            rcrs_dn(node.right, node)
        rcrs_dn(root, None)

        def dfs_away(node, last) -> int:
            if not node: return 0
            cnt = 1
            if node.left and (node.left is not last):
                cnt += dfs_away(node.left, node)
            if node.right and (node.right is not last):
                cnt += dfs_away(node.right, node)
            if d[node] and (d[node] is not last):
                cnt += dfs_away(d[node], node)
            return cnt

        p1 = dfs_away(self.start.left, self.start)
        p2 = dfs_away(self.start.right, self.start)
        p3 = dfs_away(d[self.start], self.start)

        return ( 2*max(p1, p2, p3) - (p1 + p2 + p3) ) > 1",Medium,62,2526,19.0,1,3.0,11.0,40.74193548387097,95.0,-2.646774193548387
770.0,longest chunked palindrome decomposition,"class Solution:
    def longestDecomposition(self, text: str) -> int:
        import re
        groups = 0
        while True:
            match = re.fullmatch(r'(\w+?).*\1', text)
            if match:
                groups += 2
                subend = match.end(1)
                text = text[subend:-subend]
            else:
                return groups + 1 if text else groups",Hard,11,384,0.0,2,3.0,3.0,34.90909090909091,15.0,5.058181818181819
771.0,day of the year,"class Solution:
    
    di = {1:0, 2:31, 3:59, 4:90, 5:120, 6:151, 7:181, 8:212, 9:243, 10:273, 11:304, 12:334}
    
    def dayOfYear(self, date: str) -> int:
        y, m, d = [int(i) for i in date.split(""-"")]
        a = self.di[m] + int(d) 
        if (m > 2) and ((not y % 4) and (y % 100 or not y % 400)): a += 1
        return a",Easy,8,336,0.0,1,2.0,2.0,42.0,36.0,2.4400000000000004
772.0,number of dice rolls with target sum,"class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        if n == 1:
            if target > k: return 0
            else: return 1
        memo = [0 for t in range(target+1)]
        # Note that we do not use memo[0]
        for i in range(1, target+1):
            if i <= k:
                memo[i] = 1
            else:
                break
                
        for _ in range(1, n):
            tmp = [i for i in memo]
            for t in range(1, target+1):
                memo[t] = 0
                for dice in range(1, k+1):
                    if t - dice > 0:
                        memo[t] += tmp[t-dice]
                memo[t] = int(memo[t] % (1e9+7))
        return int(memo[-1] % (1e9+7))",Medium,21,746,1.0,5,4.0,10.0,35.523809523809526,36.0,2.702857142857143
773.0,swap for longest repeated character substring,"class Solution:
    def maxRepOpt1(self, text: str) -> int:
        inuse = collections.defaultdict(int)  # chars used in the repeated substring
        left = collections.defaultdict(int)  # not used chars
        MOVE_TO_THE_NEXT_CHAR = 1
        REPLACE = 0
        LEAVE_AS_IT_IS = -1
        res, i, n = 1, 0, 0

        # initially no chars are used yet
        for ch in text:
            left[ch] += 1
        
        for j, ch in enumerate(text):
            inuse[ch] += 1  # since we use this char
            left[ch] -= 1  # subtract its count from left dict
            n = max(inuse[ch], n)
        
            # this defines action we are going to take
            action = j - i - n
        
            char_exists = False
            if action >= MOVE_TO_THE_NEXT_CHAR:
                inuse[text[i]] -= 1
                left[text[i]] += 1  # add it to the left dict back, since it is no longer in use
                i += 1

            # we can replace only if we have unused char in the left dict    
            elif action == REPLACE:
                char_exists = left[ch] > 0 
                
            elif action == LEAVE_AS_IT_IS:
                char_exists = True
        
            if char_exists and j - i >= res:
                res = j - i + 1
        
        return res",Medium,37,1314,8.0,6,3.0,7.0,35.51351351351352,47.0,1.883783783783784
774.0,find words that can be formed by characters,"class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        
        #vars to hold values
        wordlen = 0
        runningsum = 0
        charedits = chars

        #evaluate words individually
        for word in words:
            wordlen = 0
            charedits = chars

            #Evaluate letters in words
            for letter in word:

                #check the letter in the updating list
                if letter in charedits:
                    wordlen +=1
                    charedits = charedits.replace(letter,' ',1)

            #check word char match
            if len(word) == wordlen:
                runningsum += len(word)

        return(runningsum)",Easy,25,714,5.0,4,3.0,4.0,28.56,24.0,4.8096000000000005
775.0,maximum level sum of a binary tree,"class Solution:
    def maxLevelSum(self, root: TreeNode) -> int:
        from collections import deque
        if not root: return []
        queue, res = deque([root]), []
        
        while queue:
            cur_level, size = [], len(queue)
            for i in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                cur_level.append(node.val)
            res.append(cur_level)
        res = [sum(i) for i in res]
        return res.index(max(res))+1",Medium,17,621,0.0,4,3.0,6.0,36.52941176470589,18.0,4.49235294117647
776.0,as far from land as possible,"class Solution:
    def maxDistance(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        
        q = collections.deque()
        zeros = 0
        # Get our number of zeros and our 1 starting locations.
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 0:
                    zeros += 1
                if grid[row][col] == 1:
                    q.append((row, col, 0))
        # Two edge cases where we will want to return -1.
        if not q or not zeros:
            return -1
        # Our manhattan distance based movements (d, u, r, l)
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
		# Keep record of the largest encountered distance.
        dist = 0
		# while there are 0's left to move to.
        while zeros and q:
            r, c, d = q.popleft()
			# Try to move in all of our possible directions.
            for y, x in directions:
                nr = y + r
                nc = x + c
				# Make sure the new location is in the grid and is a 0.
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
				    # record the new disr, mark the location as visited and put back into the queue.
                    dist = max(d + 1, dist)
                    zeros -= 1
                    grid[nr][nc] = '#'
                    q.append((nr, nc, d + 1))
                    
        return dist",Medium,36,1440,9.0,6,3.0,9.0,40.0,60.0,0.2200000000000006
777.0,last substring in lexicographical order,"class Solution:
    def lastSubstring(self, s: str) -> str:
        max_substring = """"
        max_char = """"
        for i in range(len(s)):
            if s[i] >= max_char:
                max_char = s[i]
                max_substring = max(max_substring, s[i : ])
        return max_substring",Hard,8,294,0.0,2,3.0,2.0,36.75,15.0,4.892500000000001
778.0,invalid transactions,"class Solution:
    def invalidTransactions(self, ts: List[str]) -> List[str]:
        nts = [t.split(',') for t in ts]
        nts = sorted([[a, int(b), int(c), d] for a, b, c, d in nts])
        res = set()
        for a in nts:
            if a[2] > 1000: res.add(','.join(map(str,a)))
        for i in range(len(nts)):
            for j in range(i + 1, len(nts)):
                a, b = nts[i], nts[j]
                if a[0] != b[0] or abs(a[1] - b[1]) > 60: break
                if a[3] != b[3]: 
                    res.add(','.join(map(str,a)))
                    res.add(','.join(map(str,b)))
        return list(res)",Medium,14,628,0.0,5,3.0,8.0,44.85714285714285,35.0,1.982857142857144
779.0,compare strings by frequency of the smallest character,"class Solution:
    def numreturn(self , inputlist):
        a = sorted(inputlist)
        res = sum([1 for i in a if i==a[0]])
        return res
    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
        q = [self.numreturn(iq) for iq in queries]
        w = [self.numreturn(iw) for iw in words]
        res = []
        for i in range(len(q)):
            temp = sum([1 for one in w if one>q[i]])
            res.append(temp)
        return res",Medium,12,484,0.0,-3,2.0,7.0,40.333333333333336,20.0,4.43
780.0,remove zero sum consecutive nodes from linked list,"class Solution:
    def removeZeroSumSublists(self, H: ListNode) -> ListNode:
        A, b = ListNode(0), 1; A.next = H
        while b:
            s, b, D, C = 0, 0, {0:A}, A.next
            while C != None:
                s += C.val
                if s in D:
                    D[s].next, b = C.next, 1
                    break
                else: D[s], C = C, C.next
        return A.next
		
		
- Junaid Mansuri
- Chicago, IL",Medium,15,436,0.0,2,3.0,3.0,29.066666666666663,30.0,4.0840000000000005
781.0,prime arrangements,"class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        
        def simplesieve(n):
            prime=[]
            mark=[True]*(n+1)
            p=2
            while (p**2 <=n):
                if mark[p]:
                    for i in range(p*p,n+1,p):
                        mark[i]=False
                p+=1
            for i in range(2,n+1):
                if mark[i]:
                    prime.append(i)
            return prime
        
        def segementedsieve(n):
            result=[]
            limit=math.floor(math.sqrt(n))+1
            primes=simplesieve(limit)
            result.extend(primes)
            low=limit
            high=low+limit
            while low<=n:
                if high>=n:
                    high=n
                mark=[True]*(limit+1)
                
                for i in primes:
                    lowlimit=int(math.floor(low/i)*i)
                    if lowlimit<low:
                        lowlimit+=i
                    for j in range(lowlimit,high+1,i):
                        mark[j-low]=False
                for i in range(low,high):
                    if mark[i-low]:
                        result.append(i)
                
                low+=limit
                high+=limit
                
            return result
        
        #print(segementedsieve(n+1))
        number_of_primes_less_than_n=len(segementedsieve(n+1))
        non_prime_number_count=n-number_of_primes_less_than_n
        prime_permutations=math.factorial(number_of_primes_less_than_n)
        non_prime_permutations=math.factorial(non_prime_number_count)
        return (prime_permutations*non_prime_permutations)%(10**9+7)",Easy,49,1696,1.0,10,4.0,12.0,34.61224489795919,53.0,0.784897959183672
782.0,can make palindrome from substring,"class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        runningCount = [[0]*26]
        countSnapshot = [0]*26
        a = ord(""a"")
        for c in s:
            countSnapshot[ord(c)-a] += 1
            runningCount.append([*countSnapshot]) # the * is necessary to deep copy the list
        
        for left,right,k in queries:
            if k>=13:
                yield True
                continue
            odds = 0
            for i in range(26):
                odds += (runningCount[right+1][i] - runningCount[left][i])%2
            yield k>=odds//2",Medium,16,614,1.0,4,3.0,4.0,38.375,23.0,3.86625
783.0,number of valid words for each puzzle,"class Solution:
    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
        freq = defaultdict(int)
        for word in words: 
            mask = 0
            for c in word: mask |= 1 << (ord(c) - 97)
            freq[mask] += 1
            
        ans = []
        for puzzle in puzzles: 
            mask = val = 0 
            for c in puzzle: mask |= 1 << (ord(c) - 97)
            mask0 = mask # loop through sub-masks
            while mask: 
                if mask &amp; (1 << ord(puzzle[0])-97): val += freq[mask]
                mask = mask0 &amp; (mask - 1)
            ans.append(val)
        return ans",Hard,17,652,1.0,6,3.0,6.0,38.35294117647059,30.0,3.048235294117648
784.0,distance between bus stops,"class Solution:
    def distanceBetweenBusStops(self, D: List[int], s: int, d: int) -> int:
    	return min(sum(D[min(s,d):max(s,d)]), sum(D)-sum(D[min(s,d):max(s,d)]))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Easy,6,217,0.0,0,1.0,0.0,36.16666666666666,16.0,5.085000000000001
785.0,day of the week,"class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        # The first day of 1971 was Thursday
        week_day = [ ""Thursday"", ""Friday"", ""Saturday"",""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday""]
        no_of_days = 0
        for i in range(1971, year):
            if (i % 400 == 0) or (i % 4 == 0 and i % 100 != 0):
                no_of_days += 366
            else:
                no_of_days += 365

        # If current year is leap year and month is more than February then extra 1 day needs to be added
        if ((year % 400 == 0) or (year % 4 == 0 and year % 100 != 0)):
            if (month > 2):
                no_of_days += 1

        for i in range(1, month):
            no_of_days += months[i]

        no_of_days += day

        return (week_day[(no_of_days % 7)])",Easy,22,885,2.0,5,3.0,6.0,40.22727272727273,58.0,0.1795454545454529
786.0,maximum subarray sum with one deletion,"class Solution:
    def maximumSum(self, arr: List[int]) -> int:
	    # noDeletions, oneDeletion, max
        nodel = onedel = mx = arr[0]
        
        for i in range(1, len(arr)):
            nodel2 = nodel
            nodel = max(arr[i], arr[i] + nodel)
            onedel = max(arr[i], arr[i] + onedel, max(0, arr[i]) + nodel2)
            mx = max(mx, nodel, onedel)
            
        return mx",Medium,11,405,1.0,1,3.0,1.0,36.81818181818182,22.0,4.286363636363637
787.0,make array strictly increasing,"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        n1 , n2, dp = len(arr1) , len(arr2) , {}
        arr2.sort()
        
        def solve(i , j , prev):
            
            if i == n1:return 0
            
            if (i,j,prev) in dp: return dp[(i,j,prev)]
            
            k = bisect.bisect_right(arr2[j:],prev) + j
        
            ans = float('inf') if k == n2 else solve(i+1,k+1,arr2[k]) + 1
            
            if arr1[i] > prev:ans = min(ans,solve(i+1 , j ,arr1[i]))
            
            dp[(i,j,prev)] = ans
            
            return ans
        
        
        ans = solve(0,0,-float('inf'))
        
        return ans if ans != float('inf') else -1",Hard,24,746,0.0,0,3.0,5.0,31.08333333333333,46.0,2.4224999999999994
788.0,maximum number of balloons,"class Solution:
    def maxNumberOfBalloons(self, t: str) -> int:
        	return (lambda x: min(x[i]//(1 + (i in 'lo')) for i in 'balon'))(collections.Counter(t))
			
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Easy,5,210,0.0,0,1.0,1.0,42.0,6.0,5.5600000000000005
789.0,reverse substrings between each pair of parentheses,"class Solution:
    def reverseParentheses(self, s: str) -> str:
        stack = []
        i = 0
        while i < len(s):
            while i < len(s) and s[i] != "")"":
                stack.append(s[i])
                i += 1
            temp = """"
            if i < len(s) and s[i] == "")"":
                while stack[-1] != ""("":
                    temp += stack.pop()
                i += 1
                stack.pop()
            if temp != """":
                for letter in temp:
                    stack.append(letter)
        return """".join(stack)",Medium,17,557,0.0,6,4.0,6.0,32.76470588235294,26.0,3.8511764705882334
790.0,k concatenation maximum sum,"class Solution:
    def kConcatenationMaxSum(self, a: List[int], k: int) -> int:
    	L, M, j, m = len(a), 10**9 + 7, 0, 0
    	if min(a) >= 0: return sum(a)*k % M
    	if max(a) <= 0: return 0
    	while j < 2*L:
    		n, i = 0, j
    		for j in range(i,2*L):
    			n, j = n + a[j%L], j + 1
    			if n < 0: break
    			if n > m: m = n
    	return max(m,sum(a)*(k-2)+m) % M
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,15,425,0.0,3,1.0,6.0,28.33333333333333,36.0,3.61
791.0,critical connections in a network,"class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        graph = [[] for _ in range(n)]
        group = [None] * n

        for n1, n2 in connections:
            graph[n1].append(n2)
            graph[n2].append(n1)

        def dfs(node, parent):
            group[node] = node
            for neighbor in graph[node]:
                if neighbor == parent:
                    continue
                elif group[neighbor] is None:
                    dfs(neighbor, node)
                    if group[neighbor] != neighbor:
                        group[node] = group[neighbor]
                else:
                    if group[neighbor] < group[node]:
                        group[group[node]] = group[neighbor]
                    else:
                        group[group[neighbor]] = group[node]

        def get_root_parent(node):
            if group[node] == node:
                return node
            group[node] = get_root_parent(group[node])
            return group[node]

        dfs(0, 0)

        for i in range(n):
            group[i] = get_root_parent(i)

        return [conn for conn in connections if group[conn[0]] != group[conn[1]]]",Hard,35,1221,0.0,5,3.0,11.0,34.885714285714286,40.0,2.380285714285715
792.0,minimum absolute difference,"class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        
        arr.sort()
        temp = arr[1] - arr[0]
        for i in range(len(arr) - 1):
            temp = min(temp ,arr[i+1] - arr[i] )
        
        res = [[arr[i] , arr[i+1]] for i in range(len(arr)-1) if arr[i+1] - arr[i] == temp]

        return res",Easy,10,353,0.0,1,2.0,4.0,35.3,14.0,5.243
793.0,ugly number iii,"class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        [a,b,c] = sorted([a,b,c])
        if a == 1: return n
        def lcm(x,y): return x*y//math.gcd(x,y)
        AB, BC, AC, ABC, r, s = lcm(a,b), lcm(b,c), lcm(a,c), lcm(lcm(a,b),c), n*a//3, n*a+1
        def unc(x): return x//a + x//b + x//c - x//AB - x//BC - x//AC + x//ABC
        while unc(s-1) - n > 0:
            m = (r+s)//2
            if unc(m) - n > 0: s = m
            else: r = m
        return max(i*((s-1)//i) for i in [a,b,c])
				
				
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,15,586,0.0,0,2.0,4.0,39.06666666666667,50.0,1.3640000000000008
794.0,smallest string with swaps,"class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        class UF:
            def __init__(self, n): self.p = list(range(n))
            def union(self, x, y): self.p[self.find(x)] = self.find(y)
            def find(self, x):
                if x != self.p[x]: self.p[x] = self.find(self.p[x])
                return self.p[x]
        uf, res, m = UF(len(s)), [], defaultdict(list)
        for x,y in pairs: 
            uf.union(x,y)
        for i in range(len(s)): 
            m[uf.find(i)].append(s[i])
        for comp_id in m.keys(): 
            m[comp_id].sort(reverse=True)
        for i in range(len(s)): 
            res.append(m[uf.find(i)].pop())
        return ''.join(res)",Medium,17,734,0.0,4,3.0,5.0,43.1764705882353,32.0,2.494117647058824
795.0,sort items by groups respecting dependencies,"class Solution:
    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:
        for i in range(n): 
            if group[i] == -1: group[i] = i + m # re-group 
        
        graph0 = {} # digraph of groups 
        indeg0 = [0]*(m+n) # indegree of groups 
        
        graph1 = {} # digrpah of items 
        indeg1 = [0]*n # indegree of items
        
        for i, x in enumerate(beforeItems): 
            for xx in x: 
                if group[xx] != group[i]: 
                    graph0.setdefault(group[xx], []).append(group[i])
                    indeg0[group[i]] += 1
                graph1.setdefault(xx, []).append(i)
                indeg1[i] += 1
        
        def fn(graph, indeg): 
            """"""Return topological sort of graph using Kahn's algo.""""""
            ans = []
            stack = [k for k in range(len(indeg)) if indeg[k] == 0]
            while stack: 
                n = stack.pop()
                ans.append(n)
                for nn in graph.get(n, []):
                    indeg[nn] -= 1
                    if indeg[nn] == 0: stack.append(nn)
            return ans 
        
        tp0 = fn(graph0, indeg0) 
        if len(tp0) != len(indeg0): return [] 
        
        tp1 = fn(graph1, indeg1)
        if len(tp1) != len(indeg1): return []
        
        mp0 = {x: i for i, x in enumerate(tp0)}
        mp1 = {x: i for i, x in enumerate(tp1)}
        
        return sorted(range(n), key=lambda x: (mp0[group[x]], mp1[x]))",Hard,40,1523,5.0,6,3.0,16.0,38.075,64.0,-0.1667500000000004
796.0,unique number of occurrences,"class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        freq = {}
        for x in arr: 
            freq[x] = 1 + freq.get(x, 0)
        return len(freq) == len(set(freq.values()))",Easy,5,206,0.0,1,2.0,1.0,41.2,12.0,4.912
797.0,get equal substrings within budget,"class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        
        window = collections.deque([])
        best = 0
        i = 0
        
        while i < len(s):
            
            cost = abs(ord(s[i]) - ord(t[i]))
            
            if maxCost - cost >= 0:
                window.append(cost)
                maxCost -= cost
                best = max(best, len(window))
                i += 1
                continue
            
            if len(window) > 0:
                maxCost += window.popleft()
                continue
                
            i += 1
                
        return best",Medium,24,653,0.0,1,3.0,3.0,27.20833333333333,26.0,4.711250000000001
798.0,remove all adjacent duplicates in string ii,"class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        stack = []
        for c in s: 
            if stack and stack[-1][0] == c: 
                stack[-1][1] += 1
            else: stack.append([c, 1])
            if stack[-1][1] == k: stack.pop()
        return """".join(x*c for x, c in stack)",Medium,8,320,0.0,3,3.0,4.0,40.0,21.0,3.940000000000001
799.0,minimum moves to reach target with rotations,"class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        
        def findNeighbors(head, state):
            actual = []
            x, y = head
            if state == 'H':
                # go right when horizontal
                if y + 1 <= n - 1 and grid[x][y + 1] == 0:
                    actual.append((x, y + 1, 'H'))
                    
                # go down when horizontal
                if x + 1 <= n - 1 and grid[x + 1][y] == 0 and grid[x + 1][y - 1] == 0:
                    actual.append((x + 1, y, 'H'))
                    
                    # can rotate clkwise here
                    actual.append((x + 1, y - 1, 'V'))
                    
            else:
                # go down when vertical
                if x + 1 <= n - 1 and grid[x + 1][y] == 0:
                    actual.append((x + 1, y, 'V'))
                    
                # go right when vertical
                if y + 1 <= n - 1 and grid[x][y + 1] == 0 and grid[x - 1][y + 1] == 0:
                    actual.append((x, y + 1, 'V'))
                    
                    # can rotate anti clkwise here
                    actual.append((x - 1, y + 1, 'H'))
                    
            return actual
        
        visited = set()
        q = deque()
        q.append((0, 1, 'H', 0))
        
        while q:
            x, y, state, dist = q.popleft()
            if (x, y, state) == (n - 1, n - 1, 'H'):
                return dist
            
            if (x, y, state) in visited:
                continue
                
            visited.add((x, y, state))
            
            for nx, ny, ndir in findNeighbors((x, y), state):
                q.append((nx, ny, ndir, dist + 1))
                
        return -1",Hard,50,1793,6.0,6,4.0,9.0,35.86,89.0,-2.487399999999999
800.0,minimum cost to move chips to the same position,"class Solution:
    def minCostToMoveChips(self, C: List[int]) -> int:
        return min(sum(c % 2 for c in C), len(C) - sum(c % 2 for c in C))
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Easy,6,193,0.0,0,1.0,2.0,32.166666666666664,6.0,6.445
801.0,longest arithmetic subsequence of given difference,"class Solution:
    def longestSubsequence(self, A: List[int], k: int) -> int:
        D, C = {}, {}
        for a in A:
            if a not in D: D[a], C[a+k] = 1, a
            if a in C: C[a+k], D[C.pop(a)] = C[a], D[C[a]] + 1
        return max(D.values())
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,10,310,0.0,3,2.0,3.0,31.0,19.0,5.01
802.0,path with maximum gold,"class Solution:
    def getMaximumGold(self, G: List[List[int]]) -> int:
        M, N, V, m = len(G), len(G[0]), set(), [0]
        def dfs(i, j, t):
            V.add((i,j))
            for k,l in (i-1,j),(i,j+1),(i+1,j),(i,j-1):
                if 0 <= k < M and 0 <= l < N and G[k][l] and (k,l) not in V: dfs(k, l, t + G[k][l])
            m[0], _ = max(m[0], t), V.remove((i,j))
        for i,j in itertools.product(range(M),range(N)):
            if G[i][j]: dfs(i, j, G[i][j])
        return m[0]
		
		
- Junaid Mansuri
(LeetCode ID)@hotmail.com",Medium,14,551,0.0,4,2.0,4.0,39.35714285714285,46.0,1.4978571428571428
803.0,count vowels permutation,"class Solution:
    def countVowelPermutation(self, n: int) -> int:
        a, e, i, o, u, MOD = 1, 1, 1, 1, 1, 10**9+7
        for _ in range(n-1):
            a, e, i, o, u = e, (a+i)%MOD, (a+e+o+u)%MOD, (i+u)%MOD, a
        return sum([a, e, i, o, u])%MOD",Hard,5,258,0.0,1,2.0,1.0,51.6,30.0,2.176
804.0,split a string in balanced strings,"class Solution:
    def balancedStringSplit(self, s: str) -> int:
        stk = []
        ret = 0

        for ch in s:
            if not stk:             # begin
                ret += 1            # in balance
                stk.append(ch)
            elif ch == stk[-1]:     # continue
                stk.append(ch)
            else:                   # change direction
                stk.pop()
        return ret",Easy,13,422,4.0,2,4.0,3.0,32.46153846153846,15.0,5.378461538461539
806.0,dice roll simulation,"class Solution:
    def dieSimulator(self, n: int, R: List[int]) -> int:
        D, R, S, m = [[0]*7 for _ in range(n)], [0]+R, set(range(1,7)), 10**9 + 7
        def dfs(L, d):
            if L >= n: return 1 if L == n else 0
            c = 0
            if D[L][d]: return D[L][d]
            for i in S-{d}:
                for j in range(1,R[i]+1): c += dfs(L+j,i)
            D[L][d] = c
            return c
        return dfs(0,0) % m
		
		
- Junaid Mansuri",Hard,14,465,0.0,1,3.0,6.0,33.214285714285715,32.0,3.5707142857142857
807.0,maximum equal frequency,"class Solution:
    def maxEqualFreq(self, N: List[int]) -> int:
        L, C = len(N), collections.Counter(N)
        for i in range(L-1,-1,-1):
            S = set(C.values())
            if len(C.values()) == 1 or S == {1}: return i + 1
            elif len(S) == 2:
                if 1 in S and list(C.values()).count(1) == 1: return i + 1
                if list(C.values()).count(max(S)) == 1 and max(S) - min(S) == 1: return i + 1
            if C[N[i]] == 1: del C[N[i]]
            else: C[N[i]] -= 1
        return 0
		
		
- Junaid Mansuri",Hard,14,550,0.0,3,3.0,6.0,39.285714285714285,40.0,2.104285714285715
808.0,airplane seat assignment probability,"class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else 1/2",Medium,2,104,0.0,0,2.0,1.0,52.0,8.0,4.4
809.0,check if it is a straight line,"class Solution:
    def checkStraightLine(self, C: List[List[int]]) -> bool:
        if len(set(i[0] for i in C)) == 1: return True
        if len(set(i[0] for i in C)) < len(C): return False
        m, [x1, y1] = (C[1][1]-C[0][1])//(C[1][0]-C[0][0]), C.pop(0)
        for x,y in C:
            if (y-y1)/(x-x1) != m: return False
        return True
		
		
- Junaid Mansuri",Easy,10,373,0.0,1,2.0,6.0,37.3,19.0,4.563000000000001
810.0,remove sub folders from the filesystem,"class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        folder.sort(key=len, reverse=False)         # shorter ones in the front
        result = []
        
        while folder != []:
            curr = folder.pop(0)
            result.append(curr)
            tmp = copy.deepcopy(folder)
            for i in tmp:
                if (curr+""/"") in i:
                    folder.remove(i)
            # print(result)
        
        return result",Medium,14,479,2.0,3,3.0,3.0,34.214285714285715,15.0,5.140714285714287
811.0,replace the substring for balanced string,"class Solution:
    def balancedString(self, S: str) -> int:
        L, m, D, c, i, j = len(S), len(S), {k:v-len(S)//4 for k,v in collections.Counter(S).items() if v>len(S)//4}, {k:0 for k in 'QWER'}, -1, 0
        if not D: return 0
        for j, s in enumerate(S):
            while i < L - 1 and any(c[k] < D[k] for k in D): i += 1; c[S[i]] += 1
            if i == L - 1 and any(c[k] < D[k] for k in D): break
            m = min(m, i - j + 1); c[s] -= 1
        return m
		
		
- Junaid Mansuri",Medium,11,499,0.0,3,2.0,9.0,45.36363636363637,36.0,2.0172727272727267
812.0,maximum profit in job scheduling,"class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        start = min(startTime)
        end = max(endTime)
        n = len(startTime)
        newList = [[startTime[i]-start+1, endTime[i]-start+1, profit[i]] for i in range(n)]
        newList.sort(key = lambda x : x[1])
        n = len(newList)
        dp = [0]*(n + 1)
        for i in range(n):
            [starti, endi, costi] = newList[i]
            j = i-1
            while j >= 0 and newList[j][1] > starti:
                j-=1
            dp[i+1] = max(dp[j+1]+costi,dp[i+1], dp[i])

        return dp[-1]",Hard,16,630,0.0,2,3.0,3.0,39.375,32.0,2.95625
813.0,find positive integer solution for a given equation,"class Solution:
    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
        result =[]
        for x in range(1,z+1):
            l,h=1,z
            while(l<=h):
                m=(l+h)//2
                if (customfunction.f(x,m)==z):
                    result.append([x,m])
                    break;
                elif (customfunction.f(x,m)<z):
                    l=m+1
                elif (customfunction.f(x,m)>z):
                    h=m-1
        return result",Medium,14,511,0.0,3,4.0,5.0,36.5,31.0,3.1950000000000003
814.0,circular permutation in binary representation,"class Solution:
    def circularPermutation(self, n: int, start: int) -> List[int]:
        # gray code generation! for every new ""bit"":
        # 1) preface reversed list with 1 == same as adding 2^(N-1)
        # 2) squish onto existing list

        # (N)  1   2    3   gray
        #      0  00  000   0
        #      1  01  001   1
        #         11  011   2
        #         10  010   3
        #             110   4
        #             111   5
        #             101   6
        #             100   7

        # then find start position (ambiguously NOT gray representation)
        # slice and dice the created list with ""start"" at index 0

        # O(2^N) time, O(2^N) space

        gc, bit = [0, 1], 1
        while bit < n:
            bit += 1

            next_vals = []
            for val in reversed(gc):
                next_vals.append( val + 2**(bit-1) )
            gc.extend(next_vals)

        ind = gc.index(start)
        return gc[ind:] + gc[:ind]",Medium,31,984,15.0,3,3.0,3.0,31.741935483870968,24.0,4.983225806451613
815.0,maximum length of a concatenated string with unique characters,"class Solution:
    def maxLength(self, arr: List[str]) -> int:
        ans = 0
        freq = [0]*26 
        
        def fn(i): 
            """"""Return max length of arr[i:] given freq.""""""
            if i == len(arr): return 0 
            ans = fn(i+1) # skipping arr[i]
            if len(set(arr[i])) == len(arr[i]): 
                if all(freq[ord(c)-97] == 0 for c in arr[i]): 
                    for c in arr[i]: freq[ord(c)-97] += 1
                    ans = max(ans, len(arr[i]) + fn(i+1))
                    for c in arr[i]: freq[ord(c)-97] -= 1 # backtracking 
            return ans 
        
        return fn(0)",Medium,16,630,2.0,2,3.0,6.0,39.375,28.0,3.43625
816.0,tiling a rectangle with the fewest squares,"class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        # edge case 1 allowing early quit processing. 
        if n == m : 
            return 1 
        # edge case 2, occurs according to tiling problem. Only one for which implementation breaks. 
        elif (n==11 and m == 13) or (n==13 and m==11) : 
            return 6 
        else : 
            # memo usage of results. Build from result 1 go to end result. Bottom up progression. 
            memo = [[0 for _ in range(m+1)] for _ in range(n+1)]
            # loop from 1 to n inclusive 
            for n_measure in range(1, n+1) : 
                # loop 1 to m inclusive 
                for m_measure in range(1, m+1) : 
                    # if we are at equal measures, this is a square 
                    if (n_measure == m_measure) : 
                        # mark it as 1 as these are our measures so this can be covered by equal square 
                        memo[n_measure][m_measure] = 1
                        continue
                    # only do half the array 
                    else : 
                        if m_measure < n and n_measure < m and memo[m_measure][n_measure] != 0 : 
                            memo[n_measure][m_measure] = memo[m_measure][n_measure]
                            continue
                    # otherwise, set sub rectangles 1 and 2 and minimal rectangle to infinity to start 
                    sub_rectangle1, sub_rectangle2, min_rectangle = inf, inf, inf
                    offset = 1 
                    # starting with offset of 1 go to min of n and m 
                    while offset <= min(n_measure, m_measure) : 
                        # if we have run off the smaller, break at this point 
                        if (m_measure - offset < 0) or (n_measure - offset < 0) : 
                            break
                        # get sub rectangles 1 and 2 based off of which slicing you're doing 
                        sub_rectangle1 = memo[n_measure][m_measure-offset] + memo[n_measure-offset][offset]
                        sub_rectangle2 = memo[n_measure-offset][m_measure] + memo[offset][m_measure-offset]
                        # set min to minimum of the results now built 
                        min_rectangle = min(min_rectangle, sub_rectangle1, sub_rectangle2)
                        # increment offset as if you are doing two different measures simultaneously 
                        offset += 1 
                    # memoize current result minmal plus 1 more for work done for this square itself. 
                    memo[n_measure][m_measure] = min_rectangle + 1
            return memo[n][m]",Hard,42,2673,15.0,2,5.0,17.0,63.642857142857146,65.0,-2.0478571428571435
817.0,minimum swaps to make strings equal,"class Solution:
    def minimumSwap(self, S: str, T: str) -> int:
        L, D = len(S), {'x': 1, 'y': 1}
        for i in range(L): D[S[i]] += S[i] != T[i]
        return -1 if (D['x']+D['y']) % 2 else D['x']//2 + D['y']//2
		
		
- Junaid Mansuri",Medium,7,247,0.0,1,1.0,2.0,35.285714285714285,16.0,5.104285714285715
818.0,count number of nice subarrays,"class Solution:
def numberOfSubarrays(self, nums: List[int], k: int) -> int:
    
    res,left,end=0,0,0
    n=len(nums)
    dic = defaultdict(int)
    while (end<n):
        dic[nums[end]%2]+=1
        if dic[1]==k:
            re = 0              # count of even numbers right side of limit (k no. of odds)
            while end+1<n and nums[end+1]%2==0:
                re+=1
                end+=1
                dic[0]+=1
            
            le = 0
            while dic[1]==k:
                le+=1
                dic[nums[left]%2]-=1
                left+=1
            
            if re:
                res += le*(re+1)
            else:
                res += le
                
        end+=1
        
    return res",Medium,28,736,1.0,5,3.0,5.0,26.285714285714285,43.0,2.894285714285715
819.0,minimum remove to make valid parentheses,"class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        s,temp = list(s), []
        for i in range(len(s)):
            if s[i] in [""("","")""]:
                if not temp: temp.append((i,s[i]))
                elif temp[-1][-1]==""("" and s[i] == "")"": temp.pop()
                else: temp.append((i,s[i]))
        for item in temp: s[item[0]] = None
        res = """"
        for char in s:
            if char is not None: res += char
        return res",Medium,12,471,0.0,7,3.0,7.0,39.25,28.0,3.067500000000001
820.0,check if it is a good array,"class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        
        from functools import reduce
        def gcd (a,b):
            while b:
                a, b = b, a%b
            return a
        
        from math import gcd
        
        if reduce(gcd, nums) == 1:
            return True
        else:
            return False",Hard,14,353,0.0,0,3.0,2.0,25.214285714285715,17.0,5.850714285714286
821.0,cells with odd values in a matrix,"class Solution:
    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:
        row = set()
        col = set()
        ans = 0
        for i, j in indices:
            diff = m - 2 * len(col)
            ans += diff * (-1) ** (i in row) 
            row ^= {i}
            diff = n - 2 * len(row)
            ans += diff * (-1) ** (j in col) 
            col ^= {j}
        return ans",Easy,12,402,0.0,1,3.0,5.0,33.5,20.0,4.745000000000001
822.0,reconstruct a 2 row binary matrix,"class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
        cnt = sum(x==2 for x in colsum)
        if upper + lower != sum(colsum) or cnt > upper or cnt > lower : return [] #sanity check 
        
        ans = [[0]*len(colsum) for _ in range(2)]
        for i, c in enumerate(colsum): 
            if c == 2: ans[0][i] = ans[1][i] = 1
            elif c == 1:
                if cnt < upper: #there is capacity in upper
                    ans[0][i] = 1 
                    cnt += 1
                else: ans[1][i] = 1
        return ans",Medium,13,599,2.0,4,3.0,7.0,46.07692307692308,36.0,1.913076923076924
823.0,number of closed islands,"class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        m=len(grid)
        n=len(grid[0])
        ans=0
		#replacing all 0's to -1
        for i in range(m):
            for j in range(n):
                if grid[i][j]==0:
                    grid[i][j]=-1
		#reconverting -1's at boundaries and -1's connected with -1's at boundary to 0
        for i in range(m):
            for j in range(n):
                if (i==0 or i==m-1 or j==0 or j==n-1) and grid[i][j]==-1:
                    self.dfs(i,j,grid,m,n)
		#checking for number of closed island.
        for i in range(m):
            for j in range(n):
                if grid[i][j]==-1:
                    ans+=1
                    self.dfs(i,j,grid,m,n)
        return ans
    def dfs(self,row,col,grid,m,n):
        grid[row][col]=0
        if row-1>=0 and grid[row-1][col]==-1:
            self.dfs(row-1,col,grid,m,n)
        if row+1<m and grid[row+1][col]==-1:
            self.dfs(row+1,col,grid,m,n)
        if col-1>=0 and grid[row][col-1]==-1:
            self.dfs(row,col-1,grid,m,n)
        if col+1<n and grid[row][col+1]==-1:
            self.dfs(row,col+1,grid,m,n)
        return",Medium,32,1184,3.0,12,3.0,14.0,37.0,93.0,-3.410000000000002
824.0,maximum score words formed by letters,"class Solution:
    def maxScoreWords(self, W: List[str], T: List[str], S: List[int]) -> int:
        L, CT, D, SL, X, M = len(W), collections.Counter(T), {a:S[i] for i,a in enumerate(string.ascii_lowercase)}, set(''.join(W)), set(), 0
        for n in range(1,L+1):
            for wc in itertools.combinations(range(L),n):
                if any(wc[:i] in X for i in range(1,len(wc)+1)): continue
                CC = collections.Counter(''.join([W[i] for i in wc]))
                if any(CT[c] < CC[c] for c in SL): X.add(wc)
                else: M = max(M,sum(D[i]*CC[i] for i in CC))
        return M
		
		
- Junaid Mansuri
- Chicago, IL",Hard,13,644,0.0,3,2.0,9.0,49.53846153846154,36.0,1.6415384615384632
826.0,greatest sum divisible by three,"class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        dp = []
        for i in range(3):
            z = []
            for j in range(len(nums)):
                z.append(0)
            dp.append(z)
        dp[nums[0]%3][0] = nums[0]
        for i in range(1,len(nums)):
            for j in range(3):
                x = dp[j][i-1] + nums[i]
                dp[x%3][i] = max([dp[x%3][i], x, dp[x%3][i-1]])
                dp[j][i] = max(dp[j][i-1],dp[j][i])
        return dp[0][-1]",Medium,14,508,0.0,4,3.0,4.0,36.285714285714285,19.0,4.414285714285715
827.0,minimum moves to move a box to their target location,"class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        # dfs to move person
        # bfs to move box
        m = len(grid)
        n = len(grid[0])
        dirc = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        si, sj, bi, bj, tari, tarj = -1, -1, -1, -1, -1, -1
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == ""S"":
                    si, sj = i, j
                if grid[i][j] == ""B"":
                    bi, bj = i, j
                if grid[i][j] == ""T"":
                    tari, tarj = i, j
        
        def ok(i, j, bi=-1, bj=-1):
            if i < 0 or j < 0 or i >= m or j >= n:
                return False
            if grid[i][j] == ""#"" or (i == bi and j == bj):
                return False
            return True
        
        def p_reachable(si, sj, ti, tj, bi, bj):
            if not ok(ti, tj, bi, bj):
                return False
            vis = set()
            def dfs(i, j):
                vis.add((i, j))
                if i == ti and j == tj:
                    return True
                flag = False
                for d in dirc:
                    newi, newj = i + d[0], j + d[1]
                    if ok(newi, newj, bi, bj) and (newi, newj) not in vis:
                        flag = flag or dfs(newi, newj)
                return flag
            return dfs(si, sj)
        
        queue = deque()
        queue.append(((bi, bj), (si, sj)))
        bvis = set()
        cnt = 0
        while queue:
            l = len(queue)
            for i in range(l):
                cur = queue.popleft()
                if cur[0][0] == tari and cur[0][1] == tarj:
                    return cnt
                for d in dirc:
                    newbi = cur[0][0] + d[0]
                    newsi = cur[0][0] - d[0]
                    newbj = cur[0][1] + d[1]
                    newsj = cur[0][1] - d[1]
                    if ok(newbi, newbj) and ((newbi, newbj), (cur[0][0], cur[0][1])) not in bvis and p_reachable(cur[1][0], cur[1][1], newsi, newsj, cur[0][0], cur[0][1]):
                        queue.append(((newbi, newbj), (cur[0][0], cur[0][1])))
                        bvis.add(((newbi, newbj), (cur[0][0], cur[0][1])))
            cnt += 1
        return -1",Hard,60,2305,3.0,8,4.0,16.0,38.41666666666666,145.0,-8.557499999999997
828.0,minimum time visiting all points,"class Solution:
    def minTimeToVisitAllPoints(self, P: List[List[int]]) -> int:
        L, t = len(P), 0
        for i in range(L-1):
            (a,b), (c,d) = P[i], P[i+1]
            t += max(abs(a-c),abs(b-d))
        return t
		
		
- Junaid Mansuri",Easy,9,255,0.0,1,2.0,1.0,28.33333333333333,16.0,5.67
829.0,count servers that communicate,"class Solution:
    def countServers(self, grid: List[List[int]]) -> int:
        R = len(grid)
        C = len(grid[0])        
        visited = set()
        
        def neighbours(r, c, grid):
            nei = set()
            for i in range(C):
                nei.add((r,i))
            for j in range(R):
                nei.add((j,c))
            nei.discard((r,c))
            return nei
                    
        def dfs(grid,i,j, visited):
            for nei in neighbours(i,j, grid):
                x, y = nei
                if nei not in visited and grid[x][y] == 1:
                    visited.add(nei)
        
        for i, row in enumerate(grid):
            for j, val in enumerate(row):
                if val == 1:
                    dfs(grid, i, j, visited)
        
        return len(visited)",Medium,26,826,0.0,6,4.0,7.0,31.76923076923077,41.0,2.44076923076923
830.0,search suggestions system,"class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        ans = []
        n = len(products)
        now = products
        
        #iterate through length of searchWord
        for i in range(len(searchWord)):
            temp = []
            
            #iterate through length of current list
            for j in range(len(now)):
                
                #check if there are enough characters 
                if len(now[j])>= i and searchWord[:i+1] == now[j][:i+1]:
                    temp.append(now[j])
            
            #top 3 words hence sort
            temp.sort()
            
            if len(temp)>3:
                ans.append(temp[:3])
            else:
                ans.append(temp)
            now = temp
            
        return ans",Medium,26,834,4.0,4,3.0,5.0,32.07692307692308,26.0,4.253076923076923
831.0,number of ways to stay in the same place after some steps,"class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        n = min(arrLen, steps//2+1) #reachable right end
        ways = [1] + [0]*(n-1)
        for step in range(steps): 
            ways = [sum(ways[max(0,i-1):i+2]) % (10**9+7) for i in range(min(step+2,steps-step,n))]
        return ways[0]",Hard,6,316,1.0,1,2.0,2.0,52.66666666666666,16.0,3.5200000000000005
832.0,find winner on a tic tac toe game,"class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        class Score:
            def __init__(self):
                self.rows = [0 for i in range(3)]
                self.cols = [0 for i in range(3)]
                self.diag = 0
                self.adiag = 0
        A = Score()
        B = Score()
        for i, (x,y) in enumerate(moves):
            player = B if (i % 2) else A
            player.rows[x] += 1
            player.cols[y] += 1
            if (x == y):
                player.diag += 1
            if (x + y == 2):
                player.adiag += 1
                
            if 3 in A.rows or 3 in A.cols or A.diag == 3 or A.adiag == 3:
                return ""A""
            if 3 in B.rows or 3 in B.cols or B.diag == 3 or B.adiag == 3:
                return ""B""
            
        if len(moves) == 9:
            return ""Draw""
        else:
            return ""Pending""",Easy,27,922,0.0,3,4.0,9.0,34.148148148148145,48.0,1.706666666666667
833.0,number of burgers with no waste of ingredients,"class Solution:
    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:
        if tomatoSlices &amp; 1 or not (2*cheeseSlices <= tomatoSlices <= 4*cheeseSlices): return []
        return [(tomatoSlices - 2*cheeseSlices)//2, (4*cheeseSlices - tomatoSlices)//2]",Medium,3,283,0.0,0,2.0,1.0,94.33333333333331,13.0,0.0900000000000016
834.0,count square submatrices with all ones,"class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        total = 0
        dp = [[0] * len(row) for row in matrix]
        for i, row in enumerate(matrix):
            for j, num in enumerate(row):
                if not num:
                    continue
                upper = 0
                if i-1 >= 0:
                    upper = dp[i-1][j]
                left = 0
                if j-1 >= 0:
                    left = dp[i][j-1]
                diag = 0
                if i-1 >= 0 and j-1 >= 0:  # Can this be made less redundant?
                    diag = dp[i-1][j-1]
                dp[i][j] = min(upper, left, diag) + 1
                total += dp[i][j]
        return total",Medium,19,719,1.0,5,4.0,7.0,37.8421052631579,33.0,2.794210526315789
835.0,palindrome partitioning iii,"class Solution:
    def palindromePartition(self, s: str, k: int) -> int:
        
        n = len(s)
        
        def getChanges(i, j):
            ret = 0
            while i < j:
                if s[i] != s[j]:
                    ret += 1
                i += 1
                j -= 1
            return ret
        
        cost = [[getChanges(i, j) for j in range(n)] for i in range(n)]

        @cache
        def res(l = 0, r = 0, k = k):
            if l == len(s) and r == len(s) and k == 0:
                return 0
            elif r == len(s) or k <= 0:
                return math.inf
            else:
                return min(cost[l][r] + res(r + 1, r + 1, k - 1), res(l, r +1, k))
        
        return res()",Hard,25,734,0.0,0,3.0,6.0,29.36,48.0,2.3776
836.0,subtract the product and sum of digits of an integer,"class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        digit_prod = 1
        digit_sum = 0
        for i in range(len(str(n))):
            digit_prod *= int(str(n)[i]) 
            digit_sum += int(str(n)[i])
        return digit_prod - digit_sum",Easy,7,269,0.0,1,3.0,1.0,38.42857142857143,10.0,5.3014285714285725
837.0,group the people given the group size they belong to,"class Solution:
    def groupThePeople(self, G: List[int]) -> List[List[int]]:
        S, D = set(G), collections.defaultdict(list)
        for i, g in enumerate(G): D[g].append(i)
        return [D[i][i*j:i*(j+1)] for i in S for j in range(G.count(i)//i)]
		
		
- Junaid Mansuri
- Chicago, IL",Medium,8,293,0.0,1,1.0,3.0,36.625,12.0,5.383750000000001
838.0,find the smallest divisor given a threshold,"class Solution:
    def smallestDivisor(self, N: List[int], t: int) -> int:
        N.sort(); a, b, ceil = 1, N[-1], math.ceil
        while a < b:
            m = (a+b)//2
            if sum(ceil(n/m) for n in N) > t: a = m + 1
            else: b = m
        return a",Medium,7,269,0.0,2,3.0,3.0,38.42857142857143,20.0,4.241428571428572
839.0,minimum number of flips to convert binary matrix to zero matrix,"class Solution:
    def minFlips(self, G: List[List[int]]) -> int:
        M, N = len(G), len(G[0])
        P = [(i,j) for i,j in itertools.product(range(M),range(N))]
        for n in range(M*N+1):
            for p in itertools.permutations(P,n):
                H = list(map(list,G))
                for (x,y) in p:
                    for (i,j) in (x,y-1),(x,y),(x,y+1),(x-1,y),(x+1,y):
                        if 0 <= i < M and 0 <= j < N: H[i][j] = 1 - H[i][j]
                if max(max(H)) == 0: return n
        return -1
		
		
- Junaid Mansuri
- Chicago, IL",Hard,15,567,0.0,5,3.0,7.0,37.8,43.0,1.818
840.0,element appearing more than 25 percent in sorted array,"class Solution:
    def findSpecialInteger(self, arr: List[int]) -> int:
        larr = len(arr)
        
        if larr == 0:
            return None
        
        v = len(arr)*.25
        
        prev = None
        ct = 0
        for e in arr:
            if e == prev:
                ct += 1
            else:
                ct = 1
            prev = e
            if ct > v:
                return e
        return None",Easy,19,431,0.0,2,3.0,4.0,22.68421052631579,24.0,5.258421052631578
841.0,remove covered intervals,"class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        ans, prev = 0, -inf
        for _, y in sorted(intervals, key=lambda x: (x[0], -x[1])): 
            if y > prev: ans, prev = ans+1, y
        return ans",Medium,5,250,0.0,2,2.0,2.0,50.0,19.0,3.3599999999999994
842.0,minimum falling path sum ii,"class Solution:
    def minFallingPathSum(self, arr: List[List[int]]) -> int:
        if not arr or not arr[0]:
            return 0
        m, n = len(arr), len(arr[0])
        if n == 1:
            return arr[0][0] if m == 1 else 0
        dp = [[-1, 0], [-1, 0]]
        for i in range(m):
            min1, min2 = [[-1, float(""inf"")], [-1, float(""inf"")]]
            for j in range(n):
                min_idx = 0 if dp[0][0] != j else 1
                cur_val = dp[min_idx][1] + arr[i][j]
                if cur_val < min1[1]:
                    min1, min2 = [j, cur_val], min1
                elif cur_val < min2[1]:
                    min2 = [j, cur_val]
            dp = [min1, min2]
        return dp[0][1]",Hard,18,719,0.0,4,3.0,8.0,39.94444444444444,42.0,1.785
843.0,convert binary number in a linked list to integer,"class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        decn = 0
        while head:
            decn = decn*2 + head.val
            head = head.next
        
        return decn",Easy,7,201,0.0,1,3.0,1.0,28.714285714285715,9.0,6.275714285714286
844.0,sequential digits,"class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        def recur(number, ans):
            intNum = int(number)
            if intNum >= low and intNum <= high:  ans.append(intNum)
            if number[-1] != '9':                 recur( number + str( int(number[-1])+1 ), ans)
        ans =  []
        for i in range(1, 9): recur(str(i), ans)
        ans.sort()
        return ans",Medium,9,417,0.0,3,3.0,3.0,46.333333333333336,22.0,3.2700000000000005
845.0,maximum side length of a square with sum less than or equal to threshold,"class Solution:
    def maxSideLength(self, G: List[List[int]], t: int) -> int:
        M, N, m = len(G), len(G[0]), 0; S = [[0]*(N+1) for _ in range(M+1)]
        S[1] = list(itertools.accumulate([0]+G[0]))
        for i in range(1,M):
            s = list(itertools.accumulate(G[i]))
            for j in range(N): S[i+1][j+1] = s[j] + S[i][j+1]
        for i,j in itertools.product(range(M),range(N)):
            for L in range(m+1, min(M-i+1,N-j+1)):
                if S[i+L][j+L]-S[i][j+L]-S[i+L][j]+S[i][j] <= t: m = max(m,L)
                else: break
        return m
		
		
- Junaid Mansuri
- Chicago, IL",Medium,15,615,0.0,4,2.0,6.0,41.0,32.0,2.749999999999999
846.0,shortest path in a grid with obstacles elimination,"class Solution:
    def shortestPath(self, G: List[List[int]], k: int) -> int:
        M, N, P, Q, D, L = len(G)-1, len(G[0])-1, [(0,0,0)], [], {}, 0
        if k >= M+N: return M+N
        while P:
            for (x,y,s) in P:
                if (x,y) == (M,N): return L
                for i,j in (x-1,y),(x,y+1),(x+1,y),(x,y-1):
                    if 0<=i<=M and 0<=j<=N:
                        t = s + G[i][j]
                        if t <= k and D.get((i,j),math.inf) > t: D[(i,j)], _ = t, Q.append((i,j,t))
            P, Q, L = Q, [], L + 1
        return -1
		
		
- Junaid Mansuri
- Chicago, IL",Hard,16,606,0.0,5,3.0,7.0,37.875,70.0,-0.8887499999999999
847.0,find numbers with even number of digits,"class Solution(object):
    def findNumbers(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        #iniializing the counter
        counter = 0
        for i in nums:
            #counting the digits in the number
            count = 0
            while (i > 0):
                i = i//10
                count = count + 1
            #checking wether the count is even or odd
            if count % 2 == 0:
                counter +=1
        return counter",Easy,17,498,3.0,3,3.0,3.0,29.294117647058822,19.0,5.223529411764707
848.0,divide array in sets of k consecutive numbers,"class Solution:
    def isPossibleDivide(self, N: List[int], k: int) -> bool:
        L, C = len(N), collections.Counter(N)
        for i in range(L//k):
            m = min(C.keys())
            for j in range(m,m+k):
                if C[j] > 1: C[j] -= 1
                else: del C[j]
        return not (C or L % k)
		
		
- Junaid Mansuri
- Chicago, IL",Medium,12,357,0.0,3,2.0,3.0,29.75,19.0,5.1225000000000005
849.0,maximum number of occurrences of a substring,"class Solution:
    def maxFreq(self, s: str, M: int, m: int, _: int) -> int:
        L, D = len(s), collections.defaultdict(int)
        for j in range(L+1-m): D[s[j:j+m]] += (len(set(s[j:j+m])) <= M)
        return max(D.values())
		
		
- Junaid Mansuri
- Chicago, IL",Medium,8,269,0.0,1,1.0,1.0,33.625,21.0,4.75375
850.0,maximum candies you can get from boxes,"class Solution:
    def maxCandies(self, S: List[int], C: List[int], K: List[List[int]], CB: List[List[int]], I: List[int]) -> int:
        t, I, S, B = 0, set(I), set([i for i,v in enumerate(S) if v]), 1
        while B:
            B = 0
            for b in I &amp; S: t, I, S, B = t + C[b], I.union(set(CB[b]))-{b}, S.union(set(K[b])), 1
        return t
            
            
            
- Junaid Mansuri
- Chicago, IL",Hard,11,428,0.0,2,2.0,4.0,38.90909090909091,32.0,3.0581818181818186
851.0,replace elements with greatest element on right side,"class Solution:
    def replaceElements(self, arr: List[int]) -> List[int]:
        res = [-1]
        for i in range(len(arr)-1, 0, -1):
            res.append(max(res[-1], arr[i]))
        return res[::-1]",Easy,5,207,0.0,1,2.0,1.0,41.4,12.0,4.894
852.0,sum of mutated array closest to target,"class Solution:
    def solve(self,arr,k):    # returns the sum of arr , when replaced with k by fallowing 
                                # the given conditions  
        i=0
        while i<len(arr):
            if arr[i]>k:
                break
            i=i+1
            
        d=len(arr)-i
        d=d*k
        d=d+sum(arr[:i])
        return d
    
    def findBestValue(self, arr: List[int], target: int) -> int:
        end=max(arr)
        start=1
        x=0
        res=0
        rx=0
        arr.sort()
        while start<=end:
            mid=start+(end-start)//2
            a=list(arr)
            x=self.solve(a,mid) 
            
            if x<target:
                start=mid+1
            else:
                end=mid-1
                
            if abs(rx-target)>abs(target-x):
                rx=x                             
                res=mid
            elif abs(rx-target)==abs(target-x):
                res=min(res,mid)
                rx=min(rx,x)
                
        return res
    
    #rx is the sum of previous minimum number replaced in the array
    # mid is the number we are storing in the res  which is the number we are replacing in the array
    # every time we store sum of arr and mid  (mid is the number we are replacing in the arr  to get that sum)  considering the minimum",Medium,42,1344,5.0,4,3.0,6.0,32.0,50.0,1.9000000000000004
853.0,number of paths with max score,"class Solution:
    def pathsWithMaxScore(self, B: List[str]) -> List[int]:
        L, D, B[-1], m = len(B), {(0,0):(0,1)}, B[-1][:-1]+'0', 10**9 + 7
        def dfs(i,j):
            if (i,j) in D: return D[(i,j)]
            if i < 0 or j < 0 or B[i][j] == ""X"": return (0,0)
            SP = [dfs(x,y) for x,y in [(i-1,j),(i,j-1),(i-1,j-1)]]
            S = max(SP[i][0] for i in range(3))
            D[(i,j)] = (int(B[i][j]) + S, sum(y for x,y in SP if x == S))
            return D[(i,j)]
        (MS,MP) = dfs(L-1,L-1)
        return [[MS,0][MP == 0], MP % m]
		
		
- Junaid Mansuri
- Chicago, IL",Hard,15,602,0.0,-1,2.0,6.0,40.13333333333333,54.0,0.9280000000000008
854.0,deepest leaves sum,"class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        
        queue = deque()
        queue.append(root)
        
        res = []
        while queue:
            temp = []
            for _ in range(len(queue)):
                node = queue.popleft()
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(temp)
    
        return sum(res[-1])",Medium,20,584,0.0,4,3.0,5.0,29.2,14.0,5.5520000000000005
855.0,find n unique integers sum up to zero,"class Solution:
    def sumZero(self, n: int) -> List[int]:
        l = []
        if n % 2 == 0:
            for i in range(1, n//2 + 1):
                l.append(i * 2)
                l.append(-i * 2)
        else:
            for i in range(-n//2 + 1, n//2 + 1):
                l.append(i)
        return l",Easy,10,311,0.0,3,3.0,3.0,31.1,15.0,5.341000000000001
856.0,all elements in two binary search trees,"class Solution:
    
    def __init__(self):
        self.l1 = []
        self.l2 = []
    
    def inOrder(self,root, s):
        if root == None:
            return
        self.inOrder(root.left, s)
        s.append(root.val)
        self.inOrder(root.right, s)
    
    
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        self.inOrder(root1, self.l1)
        self.inOrder(root2, self.l2)
        l = self.l1 + self.l2 
        l.sort()
        return l",Medium,19,490,0.0,0,2.0,1.0,25.789473684210527,22.0,5.3589473684210525
857.0,jump game iii,"class Solution:
    def canReach(self, A: List[int], S: int) -> bool:
        L, V, C = len(A), set(), collections.deque([S])
        while C:
            _, i = V.update(C), C.popleft()
            if A[i] == 0: return True
            if i-A[i] >=0 and i-A[i] not in V: C.append(i-A[i])
            if i+A[i] < L and i+A[i] not in V: C.append(i+A[i])
        return False
        

- Junaid MAnsuri
- Chicago, IL",Medium,12,414,0.0,3,2.0,4.0,34.5,26.0,3.995
858.0,verbal arithmetic puzzle,"class Solution:
    def isSolvable(self, W: List[str], R: str) -> bool:
        LW, LR, F, ML, AW, V, LMap = len(W), len(R), set([w[0] for w in W+[R]]), max(map(len, W+[R])), W+[R], set(), {}
        if LR < ML: return False
        def dfs(d,i,c):
            if d == ML: return c == 0
            if i == len(W) + 1:
                s = sum(LMap[w[-d-1]] if d < len(w) else 0 for w in W) + c
                return dfs(d+1,0,s//10) if s % 10 == LMap[R[-d-1]] else False
            if i < LW and d >= len(W[i]): return dfs(d,i+1,c)
            ch = AW[i][-d-1]
            if ch in LMap: return dfs(d,i+1,c)
            for x in range((ch in F), 10):
                if x not in V:
                    LMap[ch], _ = x, V.add(x)
                    if dfs(d,i+1,c): return True
                    V.remove(LMap.pop(ch))
        return dfs(0,0,0)
		
		
- Junaid Mansuri
- Chicago, IL",Hard,21,884,0.0,2,3.0,12.0,42.095238095238095,66.0,-0.6885714285714268
859.0,decrypt string from alphabet to integer mapping,"class Solution:
    def freqAlphabets(self, s: str) -> str:
        x = ''
        i = len(s)-1
        while i > -1:
            if s[i] == '#':
                if int(s[i-2:i])%26 == 0:
                    x = chr(96+26) + x
                else:
                    x = chr(96 + int(s[i-2:i])%26) + x
                i -= 3
            else:
                x = chr(96 + int(s[i])%26) + x
                i -= 1
        return x",Easy,14,431,1.0,3,4.0,3.0,30.785714285714285,26.0,4.2492857142857146
861.0,get watched videos by your friends,"class Solution:
    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
        graph = collections.defaultdict(list)
        for u, v in enumerate(friends):
            for i in v:
                graph[u].append(i)
        queue = collections.deque()
        queue.append((id, 0))
        visited = set()
        visited.add(id)
        res = collections.defaultdict(int)
        while queue:
            id, l = queue.popleft()
            if l == level:
                for j in watchedVideos[id]:
                    res[j] += 1
            for v in graph[id]:
                if l+1 <= level and v not in visited:
                    visited.add(v)
                    queue.append((v, l+1))
        from functools import cmp_to_key
        def func(x, y):
            if res[x] > res[y]:
                return -1
            elif res[y] > res[x]:
                return 1
            else:
                if x > y:
                    return -1
                elif y > x:
                    return 1
                else:
                    return 0
        return (sorted(res.keys(), key=cmp_to_key(func)))[::-1]",Medium,33,1199,0.0,6,4.0,11.0,36.333333333333336,49.0,1.2300000000000004
862.0,minimum insertion steps to make a string palindrome,"class Solution:
    def minInsertions(self, s: str) -> int:
        n = len(s)
        dp = [[0 for i in range(n)] for j in range(n)]
        
        r=0
        c=1
        
        while c<n:
            ci = c
            r = 0
            
            while ci<n and r<n:
                if s[ci] == s[r]:
                    dp[r][ci] = dp[r+1][ci-1]
                else:
                    dp[r][ci] = 1+min(dp[r+1][ci],dp[r][ci-1])
                ci+=1
                r+=1
            c+=1
        return dp[0][n-1]",Hard,20,527,0.0,3,3.0,5.0,26.35,27.0,4.5685
863.0,decompress run length encoded list,"class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        k = 0
        arr = []
        while k < len(nums):
            freq = nums[k]
            val = nums[k+1]
            for i in range(freq):
                arr.append(val)
            k += 2
            
        return arr",Easy,11,310,0.0,2,3.0,2.0,28.181818181818183,13.0,5.863636363636363
865.0,sum of nodes with even valued grandparent,"class Solution:
    def sumEvenGrandparent(self, root: TreeNode) -> int:
        if not root: return 0 #edge case 
        ans = 0
        #preorder dfs
        stack = [(root, None, None)] #node-parent-grandparent
        while stack: 
            node, parent, grand = stack.pop()
            if grand and grand &amp; 1 == 0: ans += node.val #even-valued grandparent 
            if node.left: stack.append((node.left, node.val, parent))
            if node.right: stack.append((node.right, node.val, parent))
        return ans",Medium,11,530,4.0,4,3.0,5.0,48.18181818181818,25.0,2.903636363636364
866.0,distinct echo substrings,"class Solution:
    def distinctEchoSubstrings(self, text: str) -> int:
        ans = set()
        
        for i in range(len(text)-1): 
            for j in range(i+1, (i+len(text))//2+1): 
                if text[i:j] == text[j:2*j-i]: ans.add(text[i:j])
        
        return len(ans)",Hard,8,291,0.0,3,3.0,3.0,36.375,16.0,4.766250000000001
867.0,convert integer to the sum of two no zero integers,"class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        if n<10:
            return [1,n-1]
        a = int(str(n)[1:])+1
        a = int(''.join(['1' if i == '0' else i for i in str(a)]))
        return [a,n-a]",Easy,6,233,0.0,0,2.0,3.0,38.833333333333336,15.0,4.885
868.0,minimum flips to make a or b equal to c,"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        a = bin(a)[2:]
        b = bin(b)[2:]
        c = bin(c)[2:]
        x = max([len(a),len(b),len(c)])
        a = a.zfill(x)
        b = b.zfill(x)
        c = c.zfill(x)
        count = 0
        for i in range(x-1,-1,-1):
            if int(c[i]) != (int(a[i]) or int(b[i])):
                if c[i] == '0':
                    if a[i] == '1':
                        count += 1
                    if b[i] == '1':
                        count += 1
                else:
                    count += 1
        return count",Medium,19,603,0.0,5,4.0,5.0,31.73684210526316,43.0,2.303684210526316
870.0,minimum distance to type a word using two fingers,"class Solution:
    def minimumDistance(self, word: str) -> int:
        word = [ord(x)-65 for x in word]
        dist = lambda x, y: 0 if -1 in (x, y) else abs(x//6 - y//6) + abs(x%6 - y%6) # l1 distance
        
        @cache
        def fn(i, f1=-1, f2=-1):
            """"""Return minimum distance of typing word[i:] with 2 fingers.""""""
            if i == len(word): return 0 
            return min(dist(word[i], f1) + fn(i+1, word[i], f2), dist(word[i], f2) + fn(i+1, f1, word[i]))
        
        return fn(0)",Hard,11,516,1.0,-2,3.0,3.0,46.90909090909091,27.0,3.0581818181818186
871.0,maximum 69 number,"class Solution:
    def maximum69Number (self, num: int) -> int:

        lst_num = list(str(num))

        for i in range(len(lst_num)):
            if lst_num[i] == '6':
                lst_num[i] = '9'
                break
        return int(''.join(lst_num))",Easy,9,263,0.0,1,2.0,2.0,29.22222222222222,12.0,5.99
872.0,print words vertically,"class Solution:
    def printVertically(self, s: str) -> List[str]:
        M = max(map(len,s.split()))
        return [''.join(v).rstrip() for v in map(''.join,zip(*[s+' '*(M-len(s)) for s in s.split()]))]
		
		
- Junaid Mansuri
- Chicago, IL",Medium,7,243,0.0,0,1.0,2.0,34.714285714285715,9.0,5.915714285714286
873.0,delete leaves with a given value,"class Solution:
    def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:
    
        def helper(node):
            if node:    
                node.left = helper(node.left)
                node.right = helper(node.right)

                if not node.left and not node.right and node.val == target:
                    return None
                else:
                    return node
        
        return helper(root)",Medium,13,437,0.0,0,3.0,2.0,33.61538461538461,16.0,5.1946153846153855
874.0,minimum number of taps to open to water a garden,"class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        intervals = [(0, ranges[0])]
        for i in range(1, n + 1):
            l, r = max(i - ranges[i], 0), i + ranges[i]
            if intervals[-1][1] < r:
                while intervals and intervals[-1][0] >= l:
                    intervals.pop()
                if not intervals:
                    intervals.append((l, r))
                elif intervals[-1][1] < n and l <= intervals[-1][1]:
                    intervals.append((intervals[-1][1], r))
		return len(intervals) if intervals[-1][1] >= n else -1",Hard,12,596,0.0,5,4.0,6.0,49.66666666666666,29.0,2.09
875.0,break a palindrome,"class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        n = len(palindrome)
        # there is no way to replace a single character to make ""a"" not a palindrome
        # because no matter what we change, it is still a palindrome
        if n == 1:
            return ''
        # let's think about n = 2 case, e.g. ""bb""
        # in this case, to acheive the lexicographically smallest one
        # we should replace from the left and the best character to use is ""a""
        # for ""bb"", we replace the first ""b"" to ""a"" to become ""ab""
        
        # let's think about another n = 2 case, e.g. ""aa""
        # in this case, to acheive the lexicographically smallest one
        # we should replace from the left and the best character to use is ""a""
        # however, for ""aa"", we cannot use ""a"" here and the best character to use is ""b"" now
        # for ""aa"", we replace the second ""a"" to ""b"" to become ""ab""
        # why not replace the first ""a""? because ""ba"" is not smallest.
        for i in range(n // 2):
            #  here we know that as long as palindrome[i] is not ""a"", we skip it
            if palindrome[i] != 'a':
                # otherwise, we replace the first character that is not ""a""
                return palindrome[:i] + 'a' + palindrome[i + 1:]
        # by the time it reaches here, the only possible case is all the characters in palindrome is ""a""
        # e.g. ""aaaaaa"" so that we haven't changed anything in above logic
        # in this case, as mentioned above, the best character to use is ""b""
        # and we should replace the last character to achieve the smallest one possible
        return palindrome[:-1] + 'b'",Medium,27,1680,18.0,1,3.0,6.0,62.22222222222222,32.0,1.6799999999999995
876.0,sort the matrix diagonally,"class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        
        diag = {}
        m = len(mat)
        n = len(mat[0])
        
        for row in range(m):
            for col in range(n):
                diag.setdefault(col-row, [])
                diag[col-row].append(mat[row][col])
        
        for key, val in diag.items():
            diag[key] = sorted(val)
        
        for row in range(m):
            for col in range(n):
                mat[row][col] = diag[col-row].pop(0)
        
        return mat",Medium,19,559,0.0,5,3.0,5.0,29.42105263157895,17.0,5.172105263157895
877.0,reverse subarray to maximize array value,"class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        maxi, mini = -math.inf, math.inf
        
        for a, b in zip(nums, nums[1:]):
            maxi = max(min(a, b), maxi)
            mini = min(max(a, b), mini)
        change = max(0, (maxi - mini) * 2)
        
        # solving the boundary situation
        for a, b in zip(nums, nums[1:]):
            tmp1 = - abs(a - b) + abs(nums[0] - b)
            tmp2 = - abs(a - b) + abs(nums[-1] - a)
            change = max([tmp1, tmp2, change])
			
        original_value = sum(abs(a - b) for a, b in zip(nums, nums[1:]))
        return  original_value + change",Hard,16,647,1.0,3,3.0,3.0,40.4375,33.0,2.7406250000000005
878.0,rank transform of an array,"class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        rank = {x:len(arr)-i for i, x in enumerate(sorted(arr, reverse=True))}
        return map(rank.get, arr)",Easy,3,191,0.0,0,2.0,2.0,63.66666666666666,11.0,3.05
879.0,remove palindromic subsequences,"class Solution:
    def removePalindromeSub(self, s: str) -> int:
        
        n=len(s)
        if not n:
            return 0
        if s[::-1]==s:
            return 1
        else:
            return 2",Easy,9,209,0.0,0,3.0,2.0,23.22222222222222,14.0,6.33
880.0,"filter restaurants by vegan friendly, price and distance","class Solution:
    def filterRestaurants(self, R: List[List[int]], V: int, P: int, D: int) -> List[int]:
        R = [[r[1],r[0]] for r in R if r[2] >= V and r[3] <= P and r[4] <= D]
        return list(zip(*sorted(R, reverse = True)))[1] if R else []
		
		
- Junaid Mansuri
- Chicago, IL",Medium,7,289,0.0,0,1.0,3.0,41.285714285714285,22.0,4.024285714285715
881.0,find the city with the smallest number of neighbors at a threshold distance,"class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        
        dis=[]
        for i in range(n):
            x=[]
            for j in range(n):
                x.append(float(""inf""))
            dis.append(x)
            
        
        for i in range(len(edges)):
            x=edges[i]
            dis[x[0]][x[1]]=x[2]
            dis[x[1]][x[0]]=x[2]
            
        
        for k in range(n):
            for j in range(n):
                for i in range(n):
                    if dis[i][j]>dis[i][k]+dis[k][j]:
                        dis[i][j]=dis[i][k]+dis[k][j]
        
        d={}
        print(dis)
        for i in range(n):
            d[i]=0
        for i in range(n):
            for j in range(n):
                if dis[i][j]<=distanceThreshold:
                    if i==j:
                        continue
                    d[i]+=1
                    
        l=list(d.keys())
        min=float(""inf"")
        
        for i in range(len(l)):
            if d[l[i]]<min:
                min=d[l[i]]
                
        ans=[]
        for i in range(len(l)):
            if d[l[i]]==min:
                ans.append(l[i])
                
        
        
        return max(ans)",Medium,48,1276,0.0,15,3.0,16.0,26.58333333333333,48.0,1.7274999999999991
882.0,minimum difficulty of a job schedule,"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
        n = len(jobDifficulty)
        if d > n:
            return -1

        # Memoize maximum for every cut
        max_dp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(i, n):
                if i == j:
                    max_dp[i][j] = jobDifficulty[i]
                else:
                    max_dp[i][j] = max(max_dp[i][j - 1], jobDifficulty[j])
        
        # Calculate minimum difficulty
        dp = [[0 for _ in range(n)] for _ in range(d)]
        for i in range(d):
            for j in range(i, min(n, n - d + i + 1)):
                if i == 0:
                    dp[i][j] = max_dp[i][j]
                else:
                    dp[i][j] = min(
                        dp[i - 1][k - 1] + max_dp[k][j]
                        for k in range(i, j + 1)
                    )
        return dp[d - 1][n - 1]",Hard,26,965,2.0,6,4.0,19.0,37.11538461538461,35.0,2.639615384615385
883.0,the k weakest rows in a matrix,"class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:

        row = []
        for i in range(len(mat)):
            row.append((sum(mat[i]), i))
        heapq.heapify(row)

        ans = []
        while k>0:
            (val, idx) = heapq.heappop(row)
            ans.append(idx)
            k -= 1

        return ans",Easy,14,354,0.0,2,2.0,3.0,25.285714285714285,16.0,5.884285714285714
884.0,reduce array size to the half,"class Solution:
    def minSetSize(self, arr: List[int]) -> int:
        h = [-c for c in Counter(arr).values()]
        heapq.heapify(h)
        
        size = len(arr)
        half = (size + 1) // 2        
        result = 0
        while size > half:
            size += heapq.heappop(h)
            result += 1
            
        return result",Medium,12,351,0.0,1,3.0,3.0,29.25,13.0,5.827500000000001
885.0,maximum product of splitted binary tree,"class Solution:
    def maxProduct(self, root: TreeNode) -> int:
        subtreeSums = set()
        
        def getSum(node):
            if not node:
                return 0
            elif not node.left and not node.right:
                subtreeSums.add(node.val)
                return node.val
            else:
                result = getSum(node.left) + getSum(node.right) + node.val
                subtreeSums.add(result)
                return result
            
        rootSum = getSum(root)
        idealSplit = rootSum/2
        closestToIdeal = 0
        
        for possibleSum in subtreeSums:
            if math.fabs(possibleSum - idealSplit) < math.fabs(closestToIdeal - idealSplit):
                closestToIdeal = possibleSum        
        
        return (((rootSum - closestToIdeal) % (10**9 + 7)) * (closestToIdeal % (10**9 + 7)))  % (10**9 + 7)",Medium,23,879,0.0,1,3.0,4.0,38.21739130434783,18.0,4.520434782608696
886.0,jump game v,"class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        n=len(arr)
        ans=-float('inf')
        dp=[-1 for i in range(n)]
        def dfs(ind):
            if dp[ind]!=-1:
                return dp[ind]
            v1,v2=0,0
            for left in range(ind-1,max(-1,ind-d-1),-1):
                if arr[left]<arr[ind]:
                    lv=1+dfs(left)
                else:
                    break
                v1=max(v1,lv)
            for right in range(ind+1,min(n,ind+d+1),1):
                if arr[right]<arr[ind]:
                    rv=1+dfs(right)
                else:
                    break
                v2=max(v2,rv)
            dp[ind]=max(v1,v2,1)
            return dp[ind]
        for i in range(n):
            ans=max(ans,dfs(i))
        return ans",Hard,25,809,0.0,2,4.0,7.0,32.36,42.0,2.5276
887.0,number of steps to reduce a number to zero,"class Solution:
    def numberOfSteps(self, num: int) -> int:
        count = 0 # taking a couter to count  number of steps to reduce it to zero

        while num>0: # nums should not be less then 0
            if num % 2 == 0: # if num is completely divide by zero 
                num = num//2 # to have the quotient
                count+=1 # as number got reduced we will increase the counter
            else:
                num-=1 # and if num is not even then we subtract one out of it.
                count+=1 # as number got reduced we will increase the counter
        return count # returning the step occurred o reduce the number.",Easy,11,645,8.0,2,3.0,4.0,58.63636363636363,17.0,3.042727272727274
888.0,number of sub arrays of size k and average greater than or equal to threshold,"class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        window_start, total, res = 0, 0, 0
        
        for i in range(k - 1):
            total += arr[i]
            
        for window_end in range(k - 1, len(arr)):
            total += arr[window_end]
            if window_end - window_start + 1 > k:
                total -= arr[window_start]
                window_start += 1
                
            if total / k >= threshold:
                res += 1
            
        return res",Medium,16,543,0.0,4,3.0,4.0,33.9375,27.0,3.825625000000001
889.0,angle between hands of a clock,"class Solution:
    def angleClock(self, H: int, M: int) -> float:
        return min(abs(30*H-11*M/2),360-abs(30*H-11*M/2))
		
		
- Junaid Mansuri
- Chicago, IL",Medium,6,161,0.0,0,1.0,0.0,26.83333333333333,9.0,6.625
890.0,jump game iv,"class Solution:
    def minJumps(self, arr: List[int]) -> int:
        N, grps = len(arr), defaultdict(list)

        for i, el in enumerate(arr): 
            grps[el].append(i)

        vis, vis_grps = set(), set()
        
        def bfs(lvl, dist):
            nextLvl = set()
            
            for i in lvl:
                if i in vis: continue
                if i == N-1: return dist
                
                vis.add(i)
                
                if i: nextLvl.add(i-1)
                if i+1 < N: nextLvl.add(i+1)
                
                if not arr[i] in vis_grps:
                    vis_grps.add(arr[i])
                    nextLvl.update(grps[arr[i]])
            
            return bfs(nextLvl, dist + 1)
            
        return bfs(set([0]), 0)",Hard,27,794,0.0,4,3.0,7.0,29.40740740740741,28.0,4.133333333333333
891.0,check if n and its double exist,"class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        s = set([x*1.0 for x in arr])

        from collections import Counter
        if Counter(arr)[0] >= 2:
            return True
        
        for i in arr:
            t = i/2
            
            if t in s and t != 0:
                return True
        
        return False",Easy,14,359,0.0,1,3.0,5.0,25.642857142857142,13.0,6.152142857142857
892.0,minimum number of steps to make two strings anagram,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        x=list((Counter(s) &amp; Counter(t)).elements())
        return len(s)-len(x)",Medium,3,148,0.0,0,2.0,0.0,49.333333333333336,8.0,4.64
893.0,maximum students taking exam,"class Solution:
    def maxStudents(self, seats: List[List[str]]) -> int:
        m, n = len(seats), len(seats[0]) # dimensions 
        
        valid = []
        for i in range(m): 
            val = 0
            for j in range(n): 
                if seats[i][j] == ""."": val |= 1 << j 
            valid.append(val)
        
        @cache
        def fn(i, mask): 
            """"""Return max students taking seats[i:] given previous row as mask.""""""
            if i == len(seats): return 0 
            ans = fn(i+1, 0)
            for x in range(1 << n): 
                if x &amp; valid[i] == x and (x >> 1) &amp; x == 0 and (mask >> 1) &amp; x == 0 and (mask << 1) &amp; x == 0: 
                    ans = max(ans, bin(x).count(""1"") + fn(i+1, x))
            return ans 
        
        return fn(0, 0)",Hard,21,812,1.0,3,3.0,6.0,38.66666666666666,54.0,0.8000000000000007
894.0,count negative numbers in a sorted matrix,"class Solution:
    
    def negativeCounter(self, lst: List[int]) -> int:
        l = 0
        r = len(lst) - 1
        count = 0
        
        while l <= r:
            mid = l + (r - l)//2
            if lst[mid] >= 0:
                l = mid + 1
            else:
                count += r - mid + 1
                r = mid - 1
        return count
    
    def countNegatives(self, grid: List[List[int]]) -> int:
        
        count = 0       
        for item in grid:
            count += self.negativeCounter(item)
        return count",Easy,21,551,0.0,2,3.0,3.0,26.23809523809524,26.0,4.738571428571428
895.0,maximum number of events that can be attended,"class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        events.sort(key=lambda x: (x[1], x[0]))
        attend = set()
        
        for start, end in events:
            for day in range(start, end+1):
                if day not in attend: 
                    attend.add(day)
                    break
                    
        return len(attend)",Medium,11,379,0.0,2,3.0,3.0,34.45454545454545,14.0,5.199090909090909
896.0,construct target array with multiple sums,"class Solution:
    def isPossible(self, target: List[int]) -> bool:
        n = len(target)
        sumk = 0
        for x in sorted(target):
            if x == 1:
                continue
            if (x-1) % (n-1) != 0:
                return False
            k = (x-1)//(n-1)
            if not k > sumk:
                return False
            sumk += k
        return True",Hard,13,383,0.0,1,3.0,4.0,29.46153846153846,18.0,5.30846153846154
897.0,sort integers by the number of 1 bits,"class Solution:
    def count1s(self, num):
        count = 0
        while num >= 1:
            if num%2: count += 1
            num = num//2
        return count
    def cmp(self, vals):
        l,r = vals
        return r * 10000 + l
        
    def sortByBits(self, arr: List[int]) -> List[int]:
        new_arr = [[arr[i], self.count1s(arr[i])] for i,_ in enumerate(arr)]
        sorted_new_arr = sorted(new_arr, key = self.cmp)
        result = [sorted_new_arr[i][0] for i,_ in enumerate(sorted_new_arr)]
        return result",Easy,15,534,0.0,0,2.0,4.0,35.6,26.0,4.076
898.0,number of substrings containing all three characters,"class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        return reduce(lambda y,x:[y[0]+1+min(y[1].values()), dict(y[1],**{x[1]:x[0]})],
		              enumerate(s+'a'),[0,defaultdict(lambda:-1)])[0]",Medium,3,216,0.0,0,2.0,0.0,72.0,14.0,2.0
899.0,count all valid pickup and delivery options,"class Solution:
    def countOrders(self, n: int) -> int:
        ans = 1
        for x in range(2, n+1): 
            ans = (ans*x*(2*x-1)) % 1_000_000_007
        return ans",Hard,5,175,0.0,1,2.0,1.0,35.0,9.0,5.7700000000000005
900.0,number of days between two dates,"class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        if date1 > date2: date1, date2 = date2, date1
        y1, m1, d1 = [int(x) for x in date1.split(""-"")]
        y2, m2, d2 = [int(x) for x in date2.split(""-"")]
        
        leap = lambda y: (y%4 == 0 and y%100 != 0) or (y%400 == 0)
        dates = 365*(y2-y1) + sum(leap(y) for y in range(y1, y2))
        
        days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        dates -= days[m1-1] + (m1 > 2 and leap(y1)) + d1
        dates += days[m2-1] + (m2 > 2 and leap(y2)) + d2
        
        return dates",Easy,13,610,0.0,1,2.0,4.0,46.92307692307692,45.0,1.096923076923078
901.0,validate binary tree nodes,"class Solution:
    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:
        children = 0
        for i in range(n):
            if i > leftChild[i] > -1 or i > rightChild[i] > -1: return False
            children += (leftChild[i] > -1) + (rightChild[i] > -1)
        return children == n - 1",Medium,6,340,0.0,1,3.0,2.0,56.66666666666666,22.0,2.460000000000001
904.0,how many numbers are smaller than the current number,"class Solution:
    def smallerNumbersThanCurrent(self, nums):
        count = [0 for i in range(102)]
        for num in nums: count[num+1] += 1
        for i in range(1, len(count)): count[i] += count[i-1]
        return [count[num] for num in nums]",Easy,5,251,0.0,2,2.0,4.0,50.2,9.0,4.342
905.0,rank teams by votes,"class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        d = {}
        for z in range(len(votes[0])):
            for i in votes:
                d[i[z]] = d.get(i[z],'') + chr(97 + z)
        d = dict((i,j) for i,j in sorted(d.items(),key=lambda x:x[0]))
        return ''.join([i for i,j in sorted(d.items(),key=lambda x:x[1])])",Medium,7,348,0.0,4,3.0,4.0,49.71428571428572,20.0,3.105714285714286
906.0,linked list in binary tree,"class Solution:
    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        if root is None:
            return False
        if self.helper(head, root):
            return True
        if self.isSubPath(head, root.left):
            return True
        return self.isSubPath(head, root.right)

    def helper(self, list_node: ListNode, tree_node: TreeNode) -> bool:
        if list_node is None:
            return True
        if tree_node is None:
            return False
        if tree_node.val != list_node.val:
            return False
        else:
            return self.helper(list_node.next, tree_node.left) or self.helper(list_node.next, tree_node.right)",Medium,18,681,0.0,-1,3.0,6.0,37.833333333333336,26.0,3.874999999999999
907.0,minimum cost to make at least one valid path in a grid,"class Solution:
    def dfs(self, grid: List[List[int]]) -> int:
        # timeout
        
        size_y = len(grid)
        size_x = len(grid[0])
        src = (0, 0)
        des = (size_y - 1, size_x - 1)
        stack = [(src, 0)]
        costs = {
            src: 0
        }
        
        while stack:
            cur, cost = stack.pop()
            sign = grid[cur[0]][cur[1]]
            
            # print(cur, cost, sign)
            
            for neighbor, neighbor_sign in self.iter_neighbors(cur, size_y, size_x):
                neighbor_cost = cost
                if sign != neighbor_sign:
                    neighbor_cost += 1
                known_neighbor_cost = costs.get(neighbor)
                
                if known_neighbor_cost is None or known_neighbor_cost > neighbor_cost:
                    costs[neighbor] = neighbor_cost

                    stack.append((neighbor, neighbor_cost))
    
        return costs[des]
    
    def bfs(self, grid: List[List[int]]) -> int:
        # 7500 ms, 14.2 MB
        size_y = len(grid)
        size_x = len(grid[0])
        src = (0, 0)
        des = (size_y - 1, size_x - 1)
        queue = [(src, 0)]
        costs = {
            src: 0
        }
        
        while queue:
            cur, cost = queue.pop(0)
            sign = grid[cur[0]][cur[1]]
            
            for neighbor, neighbor_sign in self.iter_neighbors(cur, size_y, size_x):
                neighbor_cost = cost
                if sign != neighbor_sign:
                    neighbor_cost += 1
                known_neighbor_cost = costs.get(neighbor)
                
                if known_neighbor_cost is None or known_neighbor_cost > neighbor_cost:
                    costs[neighbor] = neighbor_cost

                    queue.append((neighbor, neighbor_cost))
    
        return costs[des]
    
    def dijkstra(self, grid: List[List[int]]) -> int:
        # 1000 ms, 16.7 MB
        import heapq

        class Node:
            def __init__(self, y, x, sign, distance=0, via=None):
                self.coord = (y, x)
                self.distance = distance
                self.via = via
                self.sign = sign

            def __lt__(self, other):
                return self.distance < other.distance
        
        size_y = len(grid)
        size_x = len(grid[0])
        start = Node(0, 0, grid[0][0])
        
        node_map = {
            (0, 0): start
        }
        visited_coords = {(0,0)}
        heap = [start]
        
        des_coord = (size_y - 1, size_x - 1)
        
        while heap:
            cur = heapq.heappop(heap)
            visited_coords.add(cur.coord)
            y, x = cur.coord
            
            for neighbor_coord, neighbor_sign in self.iter_neighbors(cur.coord, size_y, size_x):
                if neighbor_coord != cur.coord and neighbor_coord not in visited_coords:

                    if cur.sign == neighbor_sign:
                        # no penalty when it's the node the arrow is pointing at
                        nd = cur.distance
                    else:
                        nd = cur.distance + 1

                    node = node_map.get(neighbor_coord)
                    if node:
                        if node.distance > nd:
                            node.distance = nd
                            node.via = cur
                            heapq.heapify(heap)
                    else:
                        node = Node(*neighbor_coord, grid[neighbor_coord[0]][neighbor_coord[1]], distance=nd, via=cur)
                        node_map[neighbor_coord] = node
                    
                        heapq.heappush(heap, node)

        des_node = node_map[des_coord]

        return des_node.distance
    
    def iter_neighbors(self, coord: tuple, size_y: int, size_x: int):
        y, x = coord
        for sign in range(1, 5):
            if sign == 1:  # right
                if x < size_x - 1:
                    yield (y, x + 1), sign
            elif sign == 2: # left
                if x > 0:
                    yield (y, x - 1), sign
            elif sign == 3: # down
                if y < size_y - 1:
                    yield (y + 1, x), sign
            else:           # up
                if y > 0:
                    yield (y - 1, x), sign

    def minCost(self, grid: List[List[int]]) -> int:
        return self.dijkstra(grid)",Hard,133,4420,9.0,18,3.0,23.0,33.233082706766915,178.0,-11.690977443609022
908.0,increasing decreasing string,"class Solution:
    def sortString(self, s: str) -> str:
        
        count, res, flag = collections.Counter(sorted(s)), [], True

        while count:
            temp = list(count)
            res += temp if flag else reversed(temp)
            count -= collections.Counter(temp)
            flag ^= True        
        
        return """".join(res)",Easy,11,355,0.0,1,3.0,2.0,32.27272727272727,15.0,5.355454545454546
909.0,find the longest substring containing vowels in even counts,"class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        # one (int) variable to store vowel-related information
        # e.g., 00000 (0)
        # if a occurs, 00000 ^ 00001 = 00001 (1)
        # if i occurs, 00001 ^ 00100 = 00101 (5)
        # if a occurs, 00101 ^ 00001 = 00100 (4)
        # ---------------------------------------------------------
        # if at index 1, we have state 00101 (5)
        # and at index 11, we have state 00101 (5) again, 
        # then we can claim this sub-array (from index 1 to 11) has even vowels 
        # with the evidence that 00101 ^ 00101 = 00000 
        # ---------------------------------------------------------
        # Rationale
        # 1. We one-pass the array &amp; record the state at each element 
        # 2. If the current state has been recorded before, we compare to the leftmost index
        #    with the same state 
        
        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}
        d = {0: -1} # d: dictoray to record the leftmost indices of states 
        state, ans = 0, 0 
        for i, c in enumerate(s): # c: char 
            if c in vowels:
                state ^= vowels[c]
            
            # record the leftmost index with state v 
            if not (state in d): 
                d[state] = i 
                
            ans = max(ans, i-d[state])
        
        return ans",Medium,31,1403,18.0,3,3.0,10.0,45.25806451612903,42.0,2.0867741935483872
910.0,longest zigzag path in a binary tree,"class Solution:
    def longestZigZag(self, root: TreeNode) -> int:
        
        def fn(node): 
            """"""Return #nodes on longest ZigZag path starting at given node""""""
            nonlocal ans 
            if node is None: return (0, 0)
            (_, r1), (l2, _) = fn(node.left), fn(node.right)
            ans = max(ans, r1+1, l2+1)
            return (r1+1, l2+1)
        
        ans = 0
        fn(root)
        return ans-1",Medium,13,441,1.0,-2,3.0,1.0,33.92307692307692,18.0,5.126923076923077
911.0,maximum sum bst in binary tree,"class Solution:
    def maxSumBST(self, root: TreeNode):
        self.max = 0
		
        def dfs(root):
            if not root :  return (""N"" , 0)
            
            l_v , l_acc  =  dfs(root.left)            
            r_v , r_acc = dfs(root.right)
            
            if (l_v == ""N"" and r_v == ""N"") or (l_v == ""N"" and isinstance(r_v, int) and  r_v > root.val ) or (isinstance(l_v, int) and  l_v < root.val and r_v == ""N"" )  or isinstance(l_v, int) and isinstance(r_v, int) and l_v < root.val < r_v:
                now_acc = l_acc + r_acc + root.val
                self.max = max(self.max , now_acc)
                return (root.val ,now_acc )
            else: 
                return (root.val , -sys.maxsize )
            
        dfs(root)
        return self.max",Hard,18,783,0.0,-1,3.0,2.0,43.5,39.0,2.0649999999999995
912.0,generate a string with characters that have odd counts,"class Solution:
    def generateTheString(self, n: int) -> str:
        return ""a""*n if n &amp; 1 else ""a""*(n-1) + ""b""",Easy,2,118,0.0,0,2.0,1.0,59.0,5.0,4.07
913.0,number of times binary string is prefix aligned,"class Solution:
    def numTimesAllBlue(self, flips: List[int]) -> int:
        ans = 0
        largest = 0
        for i,n in enumerate(flips):
            largest = max(largest, n)
            if largest == i+1:
                ans+=1
        return ans",Medium,8,255,0.0,2,3.0,2.0,31.875,16.0,5.23125
914.0,time needed to inform all employees,"class Solution:
    def __init__(self):
        self.result = [0]
    def dfs(self,count,head,informTime,time): 
        self.result[0] = max(self.result[0],time)
        for emp in count[head]:
            self.dfs(count,emp,informTime,time+informTime[head])
            
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        count = collections.defaultdict(list)
        for i in range(len(manager)):
            count[manager[i]].append(i)
        
        self.dfs(count,headID,informTime,0)
        return self.result[0]",Medium,14,578,0.0,2,2.0,7.0,41.285714285714285,29.0,3.144285714285714
915.0,frog position after t seconds,"class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        if target==1:
            return 1.0 if len(edges)==0 else 0.0
        # note it's a undirected graph
        graph=[{} for _ in range(n+1)]
        for src,dst in edges:
            graph[src][dst]=1
            graph[dst][src]=1
        # do a bfs
        queue=[(1,1.0)]
        next=[]
        for time in range(t):
            for node,p in queue:
                for child in graph[node]:
                    del graph[child][node]
                    if child==target:
                        if time==t-1 or len(graph[child])<1:
                            return p/len(graph[node])
                        else:
                            return 0.0
                    next.append((child,p/len(graph[node])))
            queue=next
            next=[]
        return 0.0",Hard,24,895,2.0,4,4.0,9.0,37.29166666666666,43.0,1.94375
916.0,find a corresponding node of a binary tree in a clone of that tree,"class Solution:  
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:  
          
        queue = [([], original)]  
        while queue:  
            actions, node = queue.pop(0)  
            if id(node) == id(target):  
                cloned_target = cloned  
                for a in actions:  
                    if a == 1:  
                        cloned_target = cloned_target.right  
                    else:  
                        cloned_target = cloned_target.left  
                  
                return cloned_target  
                  
            if node.left:  
                actions_copy = []  
                actions_copy.extend(actions)  
                actions_copy.append(0) # Move left  
                queue.append((actions_copy, node.left))  
                  
            if node.right:  
                actions_copy = []  
                actions_copy.extend(actions)  
                actions_copy.append(1) # Move right  
                queue.append((actions_copy, node.right))  
                  
        return None",Easy,28,1112,2.0,5,4.0,6.0,39.71428571428572,33.0,2.665714285714285
917.0,lucky numbers in a matrix,"class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        row_count = len(matrix)
        column_count = len(matrix[0])
        
        result = []
        for row in matrix:
            # Identify min value in row and get it's column index
            min_value = min(row)
            min_index = row.index(min_value)
            column_index = 0
            column_max = 0
            # Using the column check for max of that column
            while column_index < row_count:
                if matrix[column_index][min_index] > column_max:
                    column_max = matrix[column_index][min_index]
                column_index += 1
            # If row min equals column max then add it to our results list   
            if column_max == min_value:
                result.append(min_value)
                
        return result",Easy,21,874,3.0,4,3.0,7.0,41.61904761904762,23.0,3.654285714285714
918.0,balance a binary search tree,"class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        
        def inorder_gen(n: TreeNode):
            if not n:
                return
            yield from inorder_gen(n.left)
            yield n
            yield from inorder_gen(n.right)
            n.left, n.right = None, None
            
        seq = tuple(inorder_gen(root))
        
        def restore(r, l) -> TreeNode:
            if r > l:
                return
            mid = l + (r - l) // 2
            n = seq[mid]
            n.left, n.right = restore(r, mid - 1), restore(mid + 1, l)
            return n
        
        return restore(0, len(seq)-1)",Medium,21,653,0.0,-1,3.0,2.0,31.09523809523809,25.0,4.581428571428572
919.0,maximum performance of a team,"class Solution:
def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
    MOD = 10**9+7
	
	#  Converting both list into one list
    candidates = zip(efficiency,speed)
	
	#  sort the candidates in terms of decreasing speed
    candidates = sorted(candidates,key=lambda x:x[0],reverse=True)
    speed_sum=res=0
	
	# defining heap to store ""K"" efficient candidates
    heap=[]
	
	# Checking with every candidates
    for ce,cs in candidates:
        if len(heap)>=k:
            speed_sum-=heap[0]
            heapq.heappop(heap)
        
        heapq.heappush(heap,cs)
        speed_sum+=cs
        res=max(res,speed_sum*ce)
    
	return res%MOD",Hard,24,681,4.0,2,1.0,3.0,28.375,33.0,4.126250000000001
920.0,find the distance value between two arrays,"class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        count, total = 0, len(arr1)
        
        for out in arr1:
            for inner in arr2:
                if abs(out - inner) <= d:
                    count += 1
                    brea
        return total - count",Easy,9,328,0.0,3,3.0,3.0,36.44444444444444,18.0,4.5600000000000005
921.0,cinema seat allocation,"class Solution:
    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
        count, reservedSeats, available_rows = 0, sorted(reservedSeats), n

        row = reservedSeats[0][0]
        available_rows -= 1
        row_result =  [0] * 10
        
        for seats in reservedSeats:
            sit = seats[1]
            if row == seats[0]:
                row_result[sit-1] = 1
            else:
                # Calculate
                spaces = 0
                for idx, chair in enumerate(row_result):
                    if chair == 0:
                        spaces += 1
                    else:
                        spaces = 0
                    
                    if spaces >= 4 and idx in (4,6,8):
                        count += 1
                        spaces = 0
                    
                row = seats[0] 
                row_result =  [0] * 10
                row_result[sit-1] = 1
                available_rows -= 1
                
        spaces = 0
        for idx, chair in enumerate(row_result):
            if chair == 0:
                spaces += 1
            else:
                spaces = 0
            if spaces >= 4  and idx in (4,6,8):
                count += 1
                spaces = 0
        
        count = count + (available_rows * 2)
                        
        return count",Medium,42,1369,1.0,8,4.0,8.0,32.595238095238095,62.0,0.1864285714285696
922.0,sort integers by the power value,"class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        
		# to store the power value of n, and avoid repeated computation
        loop_up_table = {}
        
        def power_val( n ):
            
            step, origin_input = 0, n
            while n != 1:

                
                if n in loop_up_table:
                    # speed up by look-up table
                    loop_up_table[origin_input] = loop_up_table[n] + step
                    return loop_up_table[n]+step
                
                
                if n &amp; 1 == 1:
                    n = 3*n + 1
                else:
                    n = n // 2
            
                step += 1
            
            loop_up_table[origin_input] = step
            return step
        
        # ------------------------------------------
        
        ranked_value = sorted( range(lo, hi+1), key = lambda n:  (power_val(n), n) )

        return ranked_value[k-1]",Medium,32,981,3.0,1,3.0,3.0,30.65625,34.0,3.7209375000000007
923.0,pizza with 3n slices,"class Solution:
    def maxSizeSlices(self, slices: List[int]) -> int:
        
        def solve(index,end,slices,n,dic):
            key=(index,n)
            if key in dic:
                return dic[key]
            else:
                if n==0 or index>end:
                    return 0
                include=slices[index]+solve(index+2,end,slices,n-1,dic)
                exclude=solve(index+1,end,slices,n,dic)
                dic[key]=max(include,exclude)
                return dic[key]
        l=len(slices)
        dic1={}
        dic2={}
        c1=solve(0,l-2,slices,l//3,dic1)
        c2=solve(1,l-1,slices,l//3,dic2)
        return max(c1,c2)",Hard,19,660,0.0,-1,3.0,2.0,34.73684210526316,45.0,2.253684210526316
924.0,create target array in the given order,"class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        result = []
        for i in range(0, len(index)):
            # insertion is guaranteed to be valid
            result.insert(index[i], nums[i]) # shift then insert value
        return result",Easy,6,298,2.0,1,3.0,2.0,49.66666666666666,11.0,4.2700000000000005
925.0,four divisors,"class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        
        def fn(x):
            c = s = 0
            for i in range(1, int(x**0.5)+1):
                if x % i == 0: 
                    c += 1 + (0 if x//i == i else 1)
                    s += i + (0 if x//i == i else x//i)
            return s if c == 4 else 0
        
        return sum(fn(x) for x in nums)",Medium,11,394,0.0,1,3.0,6.0,35.81818181818182,25.0,4.036363636363637
926.0,check if there is a valid path in a grid,"class Solution:
    def hasValidPath(self, grid: List[List[int]]) -> bool:
        if not grid or not grid[0]:
            return False
        
        M, N = len(grid), len(grid[0])
        left, right, up, down = (0,-1), (0,1), (-1,0), (1,0)
        direction = { 1: (left, right), 2: (up, down), 3: (left, down), 4: (right, down), 5: (left, up), 6: (right, up) }
        compatibles = { right: {1, 3, 5}, left: {1, 4, 6}, up: {2, 3, 4}, down: {2, 5, 6} }
        
        q = collections.deque([(0, 0)])
        seen = {(0, 0)}
        while q:
            r, c = q.popleft()
            if (r, c) == (M-1, N-1):
                return True
            di_x, di_y = direction[grid[r][c]]
            accepted_paths = compatibles[di_x] | compatibles[di_y]
            for dr, dc in [di_x, di_y]:
                cr, cc = r+dr, c+dc
                if (cr, cc) not in seen and 0 <= cr < M and 0 <= cc < N and grid[cr][cc] in accepted_paths:
                    seen.add((cr, cc))
                    q.append((cr, cc))
        return False",Medium,23,1041,0.0,3,3.0,5.0,45.26086956521739,86.0,-3.0334782608695647
927.0,longest happy prefix,"class Solution:
    def longestPrefix(self, s: str) -> str:
        lps = [0]*len(s)
        curr = 1
        pre = 0
        while curr < len(s):
            if s[curr] == s[pre]:
                lps[curr] = pre + 1
                curr +=1
                pre+=1
            else:
                if pre == 0:
                    lps[curr] = 0
                    curr += 1
                else:
                    pre = lps[pre-1]
        a = ''
        for i in range(lps[-1]):
            a += s[i]
        return a",Hard,19,521,0.0,4,4.0,4.0,27.42105263157895,29.0,4.152105263157894
928.0,find lucky integer in an array,"class Solution:
    def findLucky(self, arr: List[int]) -> int:
        ans = [0] * 501
        res = -1
        for i in range(len(arr)):
            ans[arr[i]] += 1
        for i in range(1, 501):
            if ans[i] == i:
                res = max(res, i)
        return res",Easy,9,280,0.0,3,3.0,3.0,31.11111111111111,17.0,5.140000000000001
929.0,count number of teams,"class Solution:
    def numTeams(self, rating: List[int]) -> int:
        teams = [0]
        
        def up(n1, n2):
            return n2 > n1
        
        def down(n1, n2):
            return n2 < n1
        
        def search_team(team, np=0, op=up):
            for i in range(np, len(rating)):
                nv = rating[i]
                if not team or op(team[-1], nv):
                    team_copy = []
                    team_copy.extend(team)
                    team_copy.append(nv)
                    if len(team_copy) < 3:
                        search_team(team_copy, np=i, op=op)
                    else:
                        teams[0] += 1
        
        # Search team in up rating
        search_team([])
        # Search team in down rating        
        search_team([], op=down)
        
        return teams[0]",Medium,27,850,2.0,1,4.0,3.0,31.48148148148148,33.0,3.6466666666666674
930.0,find all good strings,"class Solution:
    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
        p=10**9+7
        ord_a=ord('a')
        l=len(evil)
        dup=[]
        for i in range(1, l):
            if evil[i:]==evil[:l-i]:
                dup.append(i)
        lend=len(dup)
        def count(s):
            tmp_ct=0
            bd=1
            ind=n
            without_s=[]
            for i in range(n):
                tmp_ct*=26
                if bd:
                    tmp_ct+=ord(s[i])-ord_a
                if i>=l-1 and ind>i-l and evil<s[i-l+1:i+1]:
                    tmp_ct-=1
                if i>=l:
                    tmp_ct-=without_s[i-l]
                if i>=l-1:
                    if s[i-l+1:i+1]==evil:
                        bd=0
                        ind=i
                tmp_ct%=p
                tmp_with_s=0
                for j in range(lend):
                    d=dup[j]
                    if i>=d:
                        tmp_with_s+=without_s[i-d]
                    if i>=d-1 and ind>i-d and evil[:d]<s[i-d+1:i+1]:
                        tmp_with_s+=1
                without_s.append(tmp_ct-tmp_with_s)
            return tmp_ct, bd
        str_ct1, bd1=count(s1)
        str_ct2, bd2=count(s2)
        return (str_ct2-str_ct1+bd2)%p",Hard,39,1293,0.0,10,4.0,11.0,33.15384615384615,75.0,-1.3238461538461532
931.0,count largest group,"class Solution:
    def countLargestGroup(self, n: int) -> int:
        freq = {}
        for x in range(1, n+1): 
            key = sum(int(d) for d in str(x))
            freq[key] = 1 + freq.get(key, 0)
        vals = list(freq.values())
        return vals.count(max(vals))",Easy,7,277,0.0,1,3.0,2.0,39.57142857142857,12.0,4.99857142857143
932.0,construct k palindrome strings,"class Solution:
    def canConstruct(self, s: str, k: int) -> bool:
        if len(s) < k:
            return False
        
        counter = collections.Counter(s)
        
        odd_count = 0
        for key in counter:
            if counter[key] % 2 != 0:
                odd_count += 1
        
        return odd_count <= k",Medium,12,332,0.0,2,3.0,3.0,27.666666666666668,17.0,5.51
933.0,circle and rectangle overlapping,"class Solution:
    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        
        if xc >= x1 and xc <= x2 and yc >= y1 and yc <= y2:
            return True
        
        elif xc > x2:
            if yc > y2:
                return r**2 >= (xc-x2)**2 + (yc-y2)**2
            elif yc >= y1 and yc < y2:
                return r >= xc-x2
            else: # yc < y1
                return r**2 >= (xc-x2)**2 + (yc-y1)**2
        elif xc <= x1:
            if yc > y2:
                return r**2 >= (xc-x1)**2 + (yc-y2)**2
            elif yc >= y1 and yc < y2:
                return r >= x1-xc
            else: # yc < y1
                return r**2 >= (xc-x1)**2 + (yc-y1)**2
        elif xc > x1 and xc < x2 and yc > y2:
            
            return r >= yc -y2
        else: 
            return r >= y1-yc",Medium,24,865,2.0,0,3.0,8.0,36.04166666666666,68.0,-0.1437499999999989
934.0,reducing dishes,"class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort()
        result , current_sum = 0 , 0
        while satisfaction and satisfaction[-1] + current_sum > 0:
            current_sum += satisfaction.pop()
            result += current_sum
        return result",Hard,7,312,0.0,1,3.0,1.0,44.57142857142857,12.0,4.54857142857143
935.0,minimum subsequence in non increasing order,"class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        
        # make nums sorted in descending order
        nums.sort( reverse = True )
        
        summation = sum( nums )
        
        sequence, partial_sum = [], 0
        
        # keep picking number from largest one, until partial sum is larger than (summation / 2)
        for number in nums:
            
            partial_sum += number
            sequence.append( number )
            
            if partial_sum > summation / 2:
                break
                
        return sequence",Easy,19,594,2.0,1,3.0,2.0,31.26315789473684,15.0,5.526315789473685
937.0,longest happy string,"class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        nums = [a, b, c]
        chars = ['a', 'b', 'c']
        indices = [0, 1, 2]
        def keyFunc(i):
            return nums[i]
        indices = sorted(indices, key=keyFunc)
        if nums[indices[2]] > (nums[indices[1]] + nums[indices[0]] + 1) * 2:
            nums[indices[2]] = (nums[indices[1]] + nums[indices[0]] + 1) * 2
        if nums[indices[2]] > nums[indices[1]] + nums[indices[0]] + 1:
            s = """"
            gaps = nums[indices[1]] + nums[indices[0]] + 1
            doubles = nums[indices[2]] % gaps
            if doubles == 0:
                doubles = gaps
            singles = nums[indices[2]] - doubles
            for k in [0, 1]:
                for i in range(nums[indices[k]]):
                    if doubles > 0:
                        s += chars[indices[2]]
                        doubles -= 1
                    s += chars[indices[2]]
                    s += chars[indices[k]]
            if doubles > 0:
                s += chars[indices[2]]
            s += chars[indices[2]]
            return s
        else:
            s = """"
            singles = nums[indices[2]]
            gaps = nums[indices[1]] + nums[indices[0]] + 1
            zeros = gaps - singles
            skip = True
            for k in [0, 1]:
                for i in range(nums[indices[k]]):
                    if zeros > 0 and skip:
                        zeros -= 1
                    else:
                        s += chars[indices[2]]
                    s += chars[indices[k]]    
                    skip = not skip
            if not(zeros > 0 and skip):
                s += chars[indices[2]]
            return s",Medium,44,1734,0.0,9,4.0,11.0,39.40909090909091,68.0,-1.1268181818181835
938.0,stone game iii,"class Solution:
    def stoneGameIII(self, s: List[int]) -> str:
        n = len(s)
        dpi = 0
        dp1 = 0
        dp2 = 0
        i = n-1
        while i >= 0:
            ans = -1<<32
            ans = max(ans,s[i]-dpi)
            if i+1 < n:
                ans = max(ans,(s[i]+s[i+1])-dp1)
            if i+2 < n:
                ans = max(ans,(s[i]+s[i+1]+s[i+2])-dp2)
            dp2 = dp1
            dp1 = dpi
            dpi = ans
            i -= 1
        if dpi > 0:
            return ""Alice""
        if dpi == 0:
            return ""Tie""
        return ""Bob""",Hard,22,582,0.0,3,3.0,5.0,26.454545454545453,36.0,3.65909090909091
939.0,string matching in an array,"class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        words_set = words.sort(key=len)
        ans = []
        for i in range(len(words)):
            for j in range(i+1, len(words)):
                if words[i] in words[j]:
                    ans.append(words[i])
        return set(ans)",Easy,8,320,0.0,3,3.0,3.0,40.0,12.0,4.840000000000001
940.0,queries on a permutation with key,"class Solution:
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        
        p=[]
        for i in range(1,m+1):
            p.append(i)
        
        result=[]
        for i in range(len(queries)):
            x=queries[i]
            idx=p.index(x)
            p.pop(idx)
            p.insert(0,x)
            result.append(idx)
        
        return result
        print(result)",Medium,16,413,0.0,2,3.0,2.0,25.8125,15.0,5.876875
941.0,html entity parser,"class Solution:
    def entityParser(self, text: str) -> str:
        mapping = {""&amp;quot;"" : '""', 
                   ""&amp;apos;"" : ""'"", 
                   ""&amp;gt;""   : "">"", 
                   ""&amp;lt;""   : ""<"", 
                   ""&amp;frasl;"": ""/"", 
                   ""&amp;amp;""  : ""&amp;""}
        for key, val in mapping.items():
            text = text.replace(key, val)
        return text",Medium,10,407,0.0,1,3.0,1.0,40.7,23.0,3.797
942.0,number of ways to paint n × 3 grid,"class Solution:
    def numOfWays(self, n: int) -> int:
        if n == 0:
            return 0
        atlevel = 12
        five = 6
        four = 6
        depth = 1
        while depth < n:
            depth+=1
            a1four = five*2
            a1five = five*3
            b1five = four*2
            b1four = four*2
            atlevel = a1four+a1five+b1four+b1five
            five = a1five+b1five
            four = a1four+b1four
        return atlevel%(10**9+7)",Hard,17,475,0.0,1,3.0,2.0,27.94117647058824,23.0,4.94529411764706
943.0,minimum value to get positive step by step sum,"class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        
        prefix_sum = 0
        negative_most_offset = float('inf')
        
        # linear scan, and update nagative most offset by prefix sum
        for i in range(0, len(nums)):
            
            prefix_sum += nums[i]
            negative_most_offset = min( prefix_sum, negative_most_offset)
        
        # compute the minimum value to get positive
        threshold = min( negative_most_offset,  0 )
        
        # abs to flip the sign, +1 to make it larger than zero
        return abs(threshold)+1",Easy,16,598,3.0,1,3.0,1.0,37.375,16.0,4.916250000000001
944.0,find the minimum number of fibonacci numbers whose sum is k,"class Solution:
    
   
    
    def findMinFibonacciNumbers(self, k: int) -> int:
        m= [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733 
]
        m.sort()
        m=m[::-1]
        x=0
        count=0
        print(m)
        i=0
        y=k

        
        
        for i in range(len(m)):
            if m[i]>k:
                continue
            count+=1
            x+=m[i]
            if x>k:
                x-=m[i]
                count-=1
            if x==k:
                break
        return count",Medium,27,776,0.0,2,3.0,4.0,28.74074074074074,69.0,0.2133333333333347
945.0,the k th lexicographical string of all happy strings of length n,"class Solution:
    def getHappyString(self, n: int, k: int) -> str:
        def get_hs(n):
            ''' get happy string for length=`n`'''
            def _gen_of_hs(hs, n=n):
                ''' generator of happy string'''
                if len(hs) == n:
                    yield hs
                else:
                    for c in ['a', 'b', 'c']:
                        if hs and hs[-1] == c:
                            continue
                            
                        yield from _gen_of_hs(hs+c)
                        
            return _gen_of_hs('', n)
        
        num_of_hs = 0
        ''' number of happy string generated'''
        
        # Algorithm: Keep generating happy string util the kth one generated.
        for hs in get_hs(n):
            num_of_hs += 1
            if num_of_hs == k:
                return hs
            
        # Unable to retrieve the kth happy string
        return """"
            `",Medium,28,959,5.0,2,4.0,6.0,34.25,33.0,3.4575
946.0,restore the array,"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        dp = [0]*(len(s)+1)
        dp[-1] = sm = 1 
        
        ii = len(s)
        for i in reversed(range(len(s))): 
            if s[i] != ""0"": 
                while ii - i - 1 > log10(k) or int(s[i:ii]) > k: 
                    sm = (sm - dp[ii]) % 1_000_000_007
                    ii -= 1
                dp[i] = sm
                sm = (sm + dp[i]) % 1_000_000_007
        return dp[0]",Hard,13,469,0.0,3,3.0,3.0,36.07692307692308,22.0,4.193076923076923
947.0,reformat the string,"class Solution:
    def reformat(self, s: str) -> str:
        nextDigit, nextStr, res = 0, 0, """"
		
        def helper(curr,fn):
            #return first occurance str with function passed (digit, alpha)
            while curr<len(s):
                if fn(s[curr]):
                    break;
                curr+=1
            return curr
			
        #append to res digit and str in that order
        while nextDigit<len(s) and nextStr<len(s):
            nextDigit = helper(nextDigit, str.isdigit)
            nextStr = helper(nextStr, str.isalpha)
            if nextDigit >= len(s):
                break
            res += s[nextDigit] 
            if nextStr >= len(s):
                break
            res += s[nextStr] 
            nextDigit += 1
            nextStr += 1
            
        #if there are digits remaining 
        if helper(nextDigit + 1, str.isdigit) < len(s):
            return """"
        # if the current string is not accounted for, prepend it to the result
        if nextStr < len(s) and s[nextStr].isalpha():
            res = s[nextStr] + res
        # if we can find more strings
        if helper(nextStr + 1, str.isalpha) < len(s):
            return """"
        return res",Easy,34,1217,5.0,1,3.0,13.0,35.794117647058826,44.0,2.338529411764706
948.0,display table of food orders in a restaurant,"class Solution:
    def displayTable(self, orders) :
        #definitely needs improvement.
        tables = {}
        food = {}
        for order in orders: #go thru orders to list all table and food items.
            tables[order[1]] = None
            food[order[2]] = None
        food_kinds = len(food)
        tables_num = len(tables)
        display_table = [[""0"" for i in range(food_kinds+1)] for j in range(tables_num+1)]
        display_table[0][0] = ""Table""
        row_table = 1
        tables = dict(sorted(tables.items(),key = lambda x:int(x[0]))) #sort table in numeric order
        for table in tables:
            display_table[row_table][0]= table
            tables[table] = row_table #record which row is for this table.
            row_table+=1
        column_table = 1
        food = dict(sorted(food.items(),key = lambda x:x[0])) #sort food item in alphabetical order
        for food_item in food:
            display_table[0][column_table]= food_item
            food[food_item]= column_table #record which column is for this food item
            column_table +=1
            
        for order in orders:
            if display_table[tables[order[1]]][food[order[2]]] == ""0"":
                display_table[tables[order[1]]][food[order[2]]]=""1""
            else: 
                display_table[tables[order[1]]][food[order[2]]]=str(int(display_table[tables[order[1]]][food[order[2]]])+1)
        return display_table",Medium,30,1445,6.0,5,3.0,9.0,48.16666666666666,38.0,1.625
949.0,minimum number of frogs croaking,"class Solution:
    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        vals = {'c': 0, 'r': 1, 'o': 2, 'a': 3, 'k': 4}
        croaks = [0] * 4
        frogs = 0

        for c in croakOfFrogs:
            val = vals[c]
            if val:
                if not croaks[val - 1]:
                    return -1
                croaks[val - 1] -= 1
                
            if val != 4:
                croaks[val] += 1
            
            frogs = max(frogs, sum(croaks))
        
        return frogs if not sum(croaks) else -1",Medium,18,546,0.0,3,3.0,5.0,30.33333333333333,27.0,4.210000000000001
950.0,build array where you can find the maximum exactly k comparisons,"class Solution:
    def numOfArrays(self, n: int, m: int, k: int) -> int:
        
        @cache
        def fn(i, x, k): 
            """"""Return number of ways to build arr[i:] with current max at x and remaining cost at k.""""""
            if n - i < k: return 0 # impossible 
            if m - x < k: return 0 # impossible 
            if k == 0: return x**(n-i)
            return x*fn(i+1, x, k) + fn(i+1, x+1, k-1) + fn(i, x+1, k) - (x+1)*fn(i+1, x+1, k)
        
        return fn(0, 0, k) % 1_000_000_007",Hard,11,511,2.0,-2,3.0,3.0,46.45454545454545,31.0,2.739090909090909
951.0,maximum score after splitting a string,"class Solution:
    def maxScore(self, s: str) -> int:
        s_len = len(s)  
        ''' Length of `s`'''  
        max_score = -1  
        ''' Keep max score during searching'''  
        for i in range(s_len-2, -1, -1):  
            if s[i] != '0':  
                # Skip split on 1  
                continue  
  
            split_left = s[:i+1]  
            ''' Left part after split'''  
            if split_left.count('0') >= split_left.count('1'):  
                # print(""{}: {} {}"".format(s, split_left, s[i+1:]))  
                cur_score =  split_left.count('0') + s[i+1:].count('1')  
                if cur_score > max_score:  
                    max_score = cur_score  
  
        # If mas_score = -1, it means no split at all  
        # So we have to split at least once by minimum cost:  
        # s[:1] + s[1:]  
        # which will lose one '1' and obtain score = s.count('1') - 1   
        return max_score if max_score > 0 else s.count('1') - 1  


sol = Solution()
for s, ans in [
                (""01101"", 4),
                (""110000"", 3),
                (""1011011"", 5),
                (""01001"", 4),
                (""011101"", 5),
                (""00111"", 5),
                (""1111"", 3),
                (""11100"", 2),
                (""0000"", 3),
                (""0100001"", 6)
              ]:
    rel = sol.maxScore(s)
    print(""{}: {}"".format(s, rel))
    assert ans == rel",Easy,41,1423,9.0,3,3.0,9.0,34.707317073170735,61.0,0.7763414634146333
952.0,maximum points you can obtain from cards,"class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        M = sum(cardPoints[:k])
        temp = M
        for i in range(1, k+1):
            temp += cardPoints[-i]
            temp -= cardPoints[k-i]
            if temp > M:
                M = temp
        
        return M",Medium,10,305,0.0,2,3.0,2.0,30.5,17.0,5.255
953.0,diagonal traverse ii,"class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        idx, val = [], []
        for i, row in enumerate(nums):
            for j, num in enumerate(row): 
                idx.append((i+j, -i))
                val.append(num)
        _, ans = zip(*sorted(zip(idx, val)))
        return ans",Medium,8,326,0.0,2,3.0,2.0,40.75,16.0,4.4325
954.0,constrained subsequence sum,"class Solution:
    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:
        stk = []
        subsum = 0
        best = float('-inf')
        for idx in range(len(nums)):
            while stk and nums[stk[-1]] < 0  and (len(stk) == 1 or idx - stk[-2] <= k) and nums[stk[-1]] < nums[idx]:
                subsum -= nums[stk.pop()]  # kick out more expensive negative bridge elements
            if nums[idx] > 0 and subsum < 0:
                stk = [idx]
                subsum = nums[idx]  # don't have a negative start
            else:
                stk.append(idx)
                subsum += nums[idx]
            best = max(best, subsum)
            
        return best",Hard,16,692,2.0,3,3.0,3.0,43.25,29.0,2.9275
955.0,kids with the greatest number of candies,"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        maxCandy = max(candies)
        boolResult = []
        
        for candy in candies:
            if candy + extraCandies >= maxCandy:
                boolResult.append(True)
            else:
                boolResult.append(False)
        
        return boolResult",Easy,11,377,0.0,2,3.0,2.0,34.27272727272727,14.0,5.215454545454546
956.0,max difference you can get from changing an integer,"class Solution:
    def maxDiff(self, num: int) -> int:
        
        num_string = str(num)
        
        def apply_transform( src_char: str, dest_char: str, s: str):
        
            return int( s.replace( src_char, dest_char ) )
        
        # -----------------------------------------------------------
        
        # digit replacement for maximum number
        
        max_num = num
        
        for char in num_string:
            if char < '9':
                max_num = apply_transform( char, '9', num_string ) 
                break
        
        # -----------------------------------------------------------
        
        # digit replacement for minimum number
        
        min_num = num
        
        if num_string[0] > '1':
            # leading digit cannot be zero
            min_num = apply_transform( num_string[0], '1', num_string )
        
        else:
            for char in num_string[1:]:
                if char > '1':
                    min_num = apply_transform( char, '0', num_string )
                    break
        
        return max_num - min_num",Medium,36,1119,5.0,2,3.0,12.0,31.08333333333333,34.0,3.702500000000001
957.0,check if a string can break another string,"class Solution:
    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        s1, s2 = sorted([char for char in s1]), sorted([char for char in s2])

        return all([s1[i] >= s2[i] for i in range(len(s1))]) or all([s1[i] <= s2[i] for i in range(len(s1))])",Medium,4,261,0.0,-1,2.0,5.0,65.25,14.0,2.6674999999999995
958.0,number of ways to wear different hats to each other,"class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        N = len(hats) # number of people
        h2p = collections.defaultdict(list) # hat -> people
        for person in range(N):
            for hat in hats[person]:
                h2p[hat].append(person)
                
        if len(h2p) < N: # when the number of hats < the number of people
            return 0
        
		# For each hat, dp stores the status of the people has been matched by a hat.
        # e.g. 0b0000000000 means no one wears a hat
        # 0b0010000000 means only person No.2 wears a hat
        # There are totally 2 ^ N different possible status.
        MASK = [1 << p for p in range(N)]
        dp = [[0] * (2 ** N) for _ in range(len(h2p) + 1)]
        dp[0][0] = 1
        
        i, MOD = 1, 1000000007
        while h2p: # O(H)
            _, people = h2p.popitem()
            for j, n in enumerate(dp[i - 1]): #O(2^P)
                if not n:
                    continue
                
                dp[i][j] += n # when mask = 0
                for p in people: #O(P)
                    if not (MASK[p] &amp; j):
                        dp[i][MASK[p] + j] += n
            i += 1
        
        return dp[-1][-1] % MOD",Hard,32,1245,11.0,6,3.0,12.0,38.90625,34.0,2.9984375
959.0,destination city,"class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        source = set([path[1] for path in paths])
        destination = set([path[0] for path in paths])
        destination_city = source.difference(destination)
        return destination_city.pop()",Easy,5,271,0.0,0,2.0,3.0,54.2,8.0,4.202
960.0,check if all 1s are at least length k places away,"class Solution:
    def kLengthApart(self, nums, k: int) -> bool:
        prev = -k - 1
        for i in range(len(nums)):
            if nums[i] == 1:
                if i - prev - 1 < k:
                    return False
                prev = i

        return True",Easy,9,267,0.0,2,3.0,3.0,29.666666666666668,15.0,5.53
961.0,longest continuous subarray with absolute diff less than or equal to limit,"class Solution:
    # no need of binary search, described below....
	def solve(self, nums, k):

        def valid(n):
            # slide a window length N
            minq = deque()  # stores (val, index)
            maxq = deque()  # descending

            for r, v in enumerate(nums):
                while maxq and maxq[-1][0] < v:
                    # i replace him as a maximum
                    # candidate in the current window
                    maxq.pop()
                while minq and minq[-1][0] > v:
                    # i replace him as a minimum
                    # candidate in the current window
                    minq.pop()
                # now adding self will maintain property
                maxq.append((v, r))
                minq.append((v, r))

                # lazy pop max/min whom no longer in window
                while maxq and maxq[0][1] <= (r - n):
                    maxq.popleft()
                while minq and minq[0][1] <= (r - n):
                    minq.popleft()

                # check if valid ;)
                # print(' ',maxq,minq)
                if r >= (n - 1) and maxq[0][0] - minq[0][0] <= k:
                    return True

            return False

        l, r = 1, len(nums) + 1
        while l < r:
            n = (l + r) // 2
            print(l, r, n)
            if valid(n):
                l = n + 1
            else:
                r = n
        return l - 1",Medium,43,1442,12.0,6,4.0,9.0,33.53488372093023,42.0,2.66186046511628
962.0,find the kth smallest sum of a matrix with sorted rows,"class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        row=len(mat)
        col=len(mat[0])
        temp=[i for i in mat[0]]
        for i in range(1,row):
            currSum=[]
            for j in range(col):
                for it in range(len(temp)):
                    currSum.append(temp[it]+mat[i][j])
            currSum.sort()
            temp.clear()
            maxSize=min(k,len(currSum))
            for size in range(maxSize):
                temp.append(currSum[size])
        return temp[k-1]",Hard,15,543,0.0,4,3.0,5.0,36.2,18.0,4.522
963.0,build an array with stack operations,"class Solution:
    def buildArray(self, t: List[int], n: int) -> List[str]:
        l=[]
        for i in range(1,t[-1]+1):
            l.append(""Push"")
            if i not in t:
                l.append(""Pop"")
            
        return l",Medium,8,242,0.0,2,3.0,2.0,30.25,11.0,5.8775
964.0,count triplets that can form two arrays of equal xor,"class Solution:
    def countTriplets(self, arr: List[int]) -> int:
        count = 0
        for i in range(len(arr)):
            x = arr[i]
            for k in range(i+1,len(arr)):
                x = x ^ arr[k]
                if x == 0:
                    count = count + (k-i)
        return count",Medium,9,305,0.0,3,3.0,3.0,33.888888888888886,16.0,4.99
965.0,minimum time to collect all apples in a tree,"class Solution:
    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        tree = dict()
        for fm, to in edges: tree.setdefault(fm, []).append(to)
            
        def fn(i):
            """"""Returns distance and found flag""""""
            dist, found = 0, hasApple[i]
            for j in tree.get(i, []):
                d, f = fn(j)
                dist += 2+d if f else 0
                found |= f
            return dist, found
        
        return fn(0)[0]",Medium,14,506,0.0,1,3.0,3.0,36.142857142857146,24.0,4.107142857142857
966.0,number of ways of cutting a pizza,"class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        m, n = len(pizza), len(pizza[0])
        
        prefix = [[0]*(n+1) for _ in range(m+1)] # prefix array 
        for i in range(m):
            for j in range(n): 
                prefix[i+1][j+1] = prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]
                if pizza[i][j] == ""A"": prefix[i+1][j+1] += 1
                
        @cache
        def fn(i, j, k):
            """"""Return number of ways of cutting pizza[i:][j:] for k people.""""""
            if i == m or j == n: return 0 # out of pizza 
            apples = prefix[-1][-1] - prefix[-1][j] - prefix[i][-1] + prefix[i][j]
            if apples < k+1: return 0 # not enough apple 
            if k == 0: return 1
            
            ans = 0 
            for ii in range(i, m): 
                if prefix[ii+1][-1] - prefix[ii+1][j] - prefix[i][-1] + prefix[i][j]: 
                    ans += fn(ii+1, j, k-1)
            for jj in range(j, n): 
                if prefix[-1][jj+1] - prefix[-1][j] - prefix[i][jj+1] + prefix[i][j]: 
                    ans += fn(i, jj+1, k-1)
            return ans % 1_000_000_007
        
        return fn(0, 0, k-1)",Hard,27,1197,3.0,5,3.0,12.0,44.333333333333336,53.0,0.3499999999999978
967.0,consecutive characters,"class Solution:
    def maxPower(self, s: str) -> int:
        curr = power = 1
        for i in range(1, len(s)):
            power = max(power, (curr := curr+1 if s[i] == s[i-1] else 1))
        return power",Easy,5,209,0.0,1,2.0,2.0,41.8,16.0,4.458
968.0,simplified fractions,"class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
                
        result, seen = [], set()
                
        for num in range(1, n+1):
            for denom in range(num+1, n+1):                
                if (num/denom) not in seen:
                    seen.add(num/denom)
                    result += [f""{num}/{denom}""]
                    
        return result",Medium,11,408,0.0,3,4.0,4.0,37.09090909090909,14.0,4.841818181818182
969.0,count good nodes in binary tree,"class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        
        def dfs(node,maxval):
            if not node:
                return 0
            
            
            res = 1 if node.val>=maxval else 0
            maxval = max(node.val, maxval)
            res+= dfs(node.left,maxval)
            res+=dfs(node.right, maxval)
            return res
        return dfs(root, root.val)",Medium,13,407,0.0,-1,3.0,2.0,31.307692307692307,18.0,5.262307692307693
970.0,form largest integer with digits that add up to target,"class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        
        @cache
        def fn(x): 
            """"""Return max integer given target x.""""""
            if x == 0: return 0
            if x < 0: return -inf 
            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))
        
        return str(max(0, fn(target)))",Hard,10,368,0.0,-2,3.0,3.0,36.8,16.0,5.0280000000000005
971.0,number of students doing homework at a given time,"class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        
		# make a pair with start-time and end-time
        homework_interval = zip(startTime, endTime)
        
		# compute the number of busy students by condition judgement
        return sum( ( start <= queryTime <= end ) for start, end in homework_interval )",Easy,7,373,2.0,0,2.0,1.0,53.285714285714285,16.0,3.564285714285714
972.0,rearrange words in a sentence,"class Solution:
    def arrangeWords(self, text: str) -> str:
        return "" "".join(sorted(str(text[0].lower()+text[1:]).split(),key=len)).capitalize()",Medium,2,153,0.0,0,2.0,0.0,76.5,8.0,2.1950000000000003
973.0,people whose list of favorite companies is not a subset of another list,"class Solution:
    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
        
        # convert to list of sets
        favoriteCompanies = [set(ele) for idx, ele in enumerate(favoriteCompanies)]
        
        # go through all subsets
        result = []
        for index, companies in enumerate(favoriteCompanies):
            
            # a bool whether we will add this set
            add_to_list = True
            
            for other_index, other_companies in enumerate(favoriteCompanies):
                
                # check whether we look at the same set
                if index == other_index:
                    continue
                
                # if we are subset we set add_to_list to false and break
                if companies.issubset(other_companies):
                    add_to_list = False
                    break
                
            # add if we want to
            if add_to_list:
                result.append(index)
                
        return result",Medium,28,1037,6.0,2,4.0,8.0,37.035714285714285,20.0,4.546785714285714
974.0,maximum number of darts inside of a circular dartboard,"class Solution:
    def numPoints(self, points: List[List[int]], r: int) -> int:
        
        def getPointsInside(i, r, n):
            # This vector stores alpha and beta and flag
            # is marked true for alpha and false for beta
            angles = []

            for j in range(n):
                
                if i != j and distance[i][j] <= 2 * r:
                    # acos returns the arc cosine of the complex
                    # used for cosine inverse
                    B = math.acos(distance[i][j] / (2 * r))

                    # arg returns the phase angle of the complex
                    x1, y1 = points[i]
                    x2, y2 = points[j]
                    
                    A = math.atan2(y1 - y2, x1 - x2)
                    
                    alpha = A - B
                    
                    beta = A + B
                    
                    angles.append((alpha, False))
                    
                    angles.append((beta, True))

            # angles vector is sorted and traversed
            angles.sort()
            # count maintains the number of points inside
            # the circle at certain value of theta
            # res maintains the maximum of all count
            cnt, res = 1, 1
            for angle in angles:
                # entry angle
                if angle[1] == False: 
                    cnt += 1
                # exit angle
                else: 
                    cnt -= 1

                res = max(cnt, res)

            return res

        # Returns count of maximum points that can lie
        # in a circle of radius r.
        #a dis array stores the distance between every
        # pair of points
        n = len(points)
        max_pts = n
        distance = [[0 for _ in range(max_pts)] for _ in range(max_pts)]
        for i in range(n - 1):
            for j in range(i + 1, n):
                # abs gives the magnitude of the complex
                # number and hence the distance between
                # i and j
                x1, y1 = points[i]
                x2, y2 = points[j]
                distance[i][j] = distance[j][i] = sqrt((x1 - x2)**2 + (y1 - y2)**2)

        # This loop picks a point p
        ans = 0
        # maximum number of points for point arr[i]
        for i in range(n):
            ans = max(ans, getPointsInside(i, r, n))

        return ans",Hard,69,2405,20.0,6,4.0,13.0,34.85507246376812,58.0,1.2630434782608706
975.0,check if a word occurs as a prefix of any word in a sentence,"class Solution:
    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        for i, word in enumerate(sentence.split()):
            if word.startswith(searchWord): return i+1
        return -1",Easy,4,209,0.0,1,2.0,2.0,52.25,10.0,4.117500000000001
976.0,maximum number of vowels in a substring of given length,"class Solution:
    def maxVowels1(self, s: str, k: int) -> int:
        vowel = {'a','e','i','o','u'}
        maxVowels = 0
        for all_windows in range(len(s) - k+1):
            currentVowels = 0
            for letter in s[all_windows:all_windows + k]:
                if vowel.intersection({letter}):
                    currentVowels+=1
            if currentVowels > maxVowels:
                maxVowels= currentVowels
        return maxVowels",Medium,11,454,0.0,4,3.0,4.0,41.27272727272727,22.0,3.665454545454546
977.0,pseudo palindromic paths in a binary tree,"class Solution:
    def pseudoPalindromicPaths (self, root: TreeNode) -> int:
        def dfs(root: TreeNode, bitmap: int) -> int:
            if not root:
                return 0
            bitmap ^= 1 << root.val
            if not root.left and not root.right:
                return int(bitmap &amp; (bitmap - 1) == 0)
            return dfs(root.left, bitmap) + dfs(root.right, bitmap)
        return dfs(root, 0)",Medium,9,420,0.0,-1,3.0,2.0,46.66666666666666,21.0,3.580000000000001
978.0,max dot product of two subsequences,"class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def fn(i, j): 
            """"""Return max dot product of nums1[i:] and nums2[j:].""""""
            if i == len(nums1) or j == len(nums2): return -inf
            return max(nums1[i]*nums2[j] + fn(i+1, j+1), nums1[i]*nums2[j], fn(i+1, j), fn(i, j+1))
        
        return fn(0, 0)",Hard,9,399,0.0,-2,3.0,1.0,44.333333333333336,25.0,3.45
979.0,make two arrays equal by reversing subarrays,"class Solution:
    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        return Counter(target)==Counter(arr)",Easy,2,129,0.0,0,2.0,0.0,64.5,10.0,3.075
980.0,check if a string contains all binary codes of size k,"class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        return all(bin(i)[2:].zfill(k) in s for i in range(2**k))",Medium,2,132,0.0,0,2.0,1.0,66.0,8.0,3.140000000000001
981.0,course schedule iv,"class Solution:
    def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
        
        def bfs(root, dest):
            
            stack = deque([root])
            seen = set()
            
            while stack:
                
                item = stack.popleft()
                if item == dest:
                    return True
                for child in graph[item]:
                    
                    if child not in seen:
                        seen.add(child)
                        stack.append(child)
            return False
        
        graph = {i: [] for i in range(n)}
        for a, b in prerequisites:
            graph[a].append(b)
         
        res = []
        for a, b in queries:
            
            res.append(bfs(a, b))
        return res",Medium,28,852,0.0,4,4.0,8.0,30.428571428571427,29.0,3.881428571428571
982.0,cherry pickup ii,"class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0])
        
        
        @cache
        def dfs(row1, col1, row2, col2, n, m):
			
            if (col1 >= m or col1 < 0) or (col2 >= m or col2 < 0) or row1 >= n or row2 >= n: return -math.inf
            
            temp = grid[row1][col1] if row1 == row2 and col1 == col2 else grid[row1][col1] + grid[row2][col2]
            
			# if reached the bottom of the grid then return the temp value
            if row1 == n-1 and row2 == n-1: return temp

            return temp + max(dfs(row1+1, a, row2+1, b, n, m)
                             for a in [col1-1, col1, col1+1]
                             for b in [col2-1, col2, col2+1])

        # one starting point is (0,0) and other is (0,m-1)
        return dfs(0, 0, 0, m-1, n, m)",Hard,21,857,2.0,-2,3.0,6.0,40.80952380952381,54.0,0.9471428571428576
983.0,maximum product of two elements in an array,"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        nums.sort()
        return (nums[len(nums)-1] - 1)*(nums[len(nums)-2] - 1)",Easy,3,148,0.0,0,2.0,0.0,49.333333333333336,5.0,4.94
984.0,maximum area of a piece of cake after horizontal and vertical cuts,"class Solution:
    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:
        horizontalCuts.sort()
        verticalCuts.sort()
        
        maxHorizontalArea = max(horizontalCuts[0], h - horizontalCuts[-1])
        maxVerticalArea = max(verticalCuts[0], w - verticalCuts[-1])
        
        for i in range(0, len(horizontalCuts) - 1):
            maxHorizontalArea = max(maxHorizontalArea, horizontalCuts[i + 1] - horizontalCuts[i])
            
        for i in range(0, len(verticalCuts) - 1):
            maxVerticalArea = max(maxVerticalArea, verticalCuts[i + 1] - verticalCuts[i])
        
        return (maxHorizontalArea * maxVerticalArea) % int(1e9 + 7)",Medium,14,713,0.0,2,3.0,2.0,50.92857142857143,23.0,2.816428571428572
985.0,reorder routes to make all paths lead to the city zero,"class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        visited = set()
        inDegree = collections.defaultdict(list)
        outDegree = collections.defaultdict(set)
        for con in connections:
            outDegree[con[0]].add(con[1])
            inDegree[con[1]].append(con[0])
        cnt = 0
        stack = [0]
        while stack:
            city = stack.pop()
            if city in visited:
                continue
            visited.add(city)
            stack.extend(inDegree[city])
            for c in outDegree[city]:
                if c not in visited:
                    cnt += 1
                    stack.append(c)
        return cnt",Medium,20,701,0.0,4,3.0,5.0,35.05,19.0,4.5255
986.0,probability of a two boxes having the same number of distinct balls,"class Solution:
    def getProbability(self, balls: List[int]) -> float:
        n = sum(balls)//2
        
        @cache 
        def fn(i, s0, s1, c0, c1):
            """"""Return number of ways to distribute boxes successfully (w/o considering relative order).""""""
            if s0 > n or s1 > n: return 0 # impossible 
            if i == len(balls): return int(c0 == c1)
            ans = 0 
            for x in range(balls[i]+1): 
                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)
            return ans
        
        return fn(0, 0, 0, 0, 0) / comb(2*n, n)",Hard,14,619,1.0,-1,3.0,3.0,44.21428571428572,36.0,2.340714285714286
987.0,shuffle the array,"class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        '''Time complexity: Olog(n as specified in the arg), Space complexity: O(1)'''
        
        # To manage space, we can work on the same variable (i.e. modifying in place)
        # We can iterate n times, while popping the last element and inserting in its right position in the same list
        
        for i in range(n, 0, -1):
            nums.insert(i, nums.pop())
            
        return nums",Easy,10,491,3.0,1,3.0,4.0,49.1,16.0,3.8610000000000007
988.0,the k strongest values in an array,"class Solution:
    def getStrongest(self, arr: List[int], k: int) -> List[int]:
        n = len(arr)
        
        if n == 1:
            return arr[:k]
        elif n == k:
            return arr
        
        arr.sort()
        m = arr[(n-1)//2]
        
        res = []
        i, j = 0, n-1
        while i < j:
            if abs(arr[i]-m) > abs(arr[j]-m):
                res.append(arr[i])
                i += 1
            elif abs(arr[i]-m) < abs(arr[j]-m):
                res.append(arr[j])
                j -= 1
            else: # abs(arr[i]-m) == abs(arr[j]-m)
                if arr[i] > arr[j]:
                    res.append(arr[i])
                    i += 1
                elif arr[i] < arr[j]:
                    res.append(arr[j])
                    j -= 1
                else:
                    res.append(arr[i])
                    i += 1
            if len(res) == k:
                return res",Medium,32,935,1.0,6,4.0,8.0,29.21875,46.0,2.210312499999999
989.0,paint house iii,"class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
    
        # check how many neighbors in initial state
        neighbor = 0
        prev = 0
        for house in houses:
            if house and house != prev:
                prev = house
                neighbor += 1
            
        if neighbor > target: return -1
        
        
        # dp[# index][# color][# neighbor]
        dp = [[[inf] * (target+1) for _ in range(n)] for _ in range(m)]
        if not houses[0]:
            for color in range(n):
                dp[0][color][1] = cost[0][color]
        else:
            dp[0][houses[0]-1][1] = 0
        
        for i in range(1, m):
            for color in range(n):
                for neighbor in range(1, target+1):
                    # i-th house is not painted yet
                    if not houses[i]:
                        # same color with i-1
                        dp[i][color][neighbor] = dp[i-1][color][neighbor] + cost[i][color]
                        # different color with i-1
                        for diff_color in range(n):
                            if color != diff_color:
                                dp[i][color][neighbor] = min(dp[i][color][neighbor], dp[i-1][diff_color][neighbor-1] + cost[i][color])
                    # i-th house is already painted
                    else:
                        if color+1 == houses[i]:
                            dp[i][color][neighbor] = dp[i-1][color][neighbor]
                            for diff_color in range(n):
                                if color != diff_color:
                                    dp[i][color][neighbor] = min(dp[i][color][neighbor], dp[i-1][diff_color][neighbor-1])
                        else:
                            dp[i][color][neighbor] = inf
                                          
        minCost = inf
        for j in range(n):
            minCost = min(minCost, dp[-1][j][target])
        return minCost if minCost != inf else -1",Hard,46,2051,6.0,14,5.0,25.0,44.58695652173913,58.0,-0.7128260869565235
990.0,final prices with a special discount in a shop,"class Solution:
    def finalPrices(self, prices: List[int]) -> List[int]:
#         each number in the array is a price
#         there is a discount where you will get that i term discounted by the next item in the array that is less than or equal to the current item's price

# you ONLY need to look ahead of i, never before. AND you stop when you've reached that discount amount

        finalSale = []
        
        for i in range(0, len(prices)):
            currentPrice = prices[i]
            discountAmount = 0
            for j in range(i + 1, len(prices)):
                possibleDiscount = prices[j]
                if possibleDiscount <= currentPrice:
                    currentPrice = currentPrice - possibleDiscount
                    break
            finalSale.append(currentPrice)
                    
        return finalSale",Easy,19,851,3.0,2,3.0,4.0,44.78947368421053,18.0,3.988947368421053
991.0,find two non overlapping sub arrays each with target sum,"class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        complements = {0: -1}
        cum_sum = 0
        intervals = []
        for i, el in enumerate(arr):
            cum_sum += el
            if cum_sum - target in complements:
                intervals.append((complements[cum_sum - target] + 1, i))
            complements[cum_sum] = i 

        if len(intervals) < 2:
            return -1

        intervals.sort(key=lambda x: x[1] - x[0])
        non_overlap_intervals = filter_non_overlap(intervals)

        if not non_overlap_intervals:
            return -1

        return sum(interval[1] - interval[0] + 1 for interval in non_overlap_intervals)


def filter_non_overlap(intervals):
    for i in range(len(intervals)):
        for j in range(i + 1, len(intervals)):
            if not (intervals[i][0] <= intervals[j][1] and intervals[j][0] <= intervals[i][1]):
                return intervals[i], intervals[j]",Medium,27,960,0.0,4,2.0,8.0,35.55555555555556,33.0,3.14
992.0,allocate mailboxes,"class Solution:
    def minDistance(self, houses: List[int], k: int) -> int:
        houses.sort()
        len_houses = len(houses)
        if k == len_houses:
            return 0
        cost = {**{(i,i): 0 for i in range(len_houses)},
                **{(i,i+1):houses[i+1] - houses[i]  for i in range(len_houses - 1)}}
        for i in range(len_houses):
            for r in range(1,min(i+1,len_houses-i)):
                cost[i-r,i+r] = cost[i-r+1,i+r-1] + houses[i+r] - houses[i-r]
                if i+r + 1 < len_houses:
                    cost[i-r,i+r+1] = cost[i-r+1,i+r] + houses[i+r+1] - houses[i-r]
        dp = {(j,1):cost[0,j] for j in range(len_houses)} # dp(i,k) is total cost of using k mail boxes for first i houses
        for box in range(2, k + 1):
            for j in range(box - 1, len_houses):
                dp[j,box] = min(dp[i,box-1] + cost[i+1,j] for i in range(box - 2, j))
        return dp[len_houses - 1, k]",Hard,17,945,1.0,5,3.0,11.0,55.588235294117645,45.0,0.0570588235294096
993.0,running sum of 1d array,"class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        runningSum = [nums[0]]
        for i in range(1, len(nums)):
            currentSum = 0
            for j in range(i+1):
                currentSum += nums[j]
            runningSum.append(currentSum)
        return runningSum",Easy,8,306,0.0,2,3.0,2.0,38.25,11.0,5.1575
994.0,least number of unique integers after k removals,"class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        most_common = Counter(arr).most_common()
        for i in range(len(most_common) - 1, -1, -1):
            if k >= most_common[i][1]:
                k -= most_common[i][1]
            else:
                return i + 1
            
        return 0",Medium,9,344,0.0,1,3.0,2.0,38.22222222222222,16.0,4.720000000000001
995.0,minimum number of days to make m bouquets,"class Solution:
    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
        if len(bloomDay) < m*k:
            return -1
        
        l = 1
        r = max(bloomDay)
        
        while l < r:
            mid = l + (r-l) // 2
            if self.condition(mid,bloomDay,k,m):
                r = mid
            else:
                l = mid+1
        return l
        
        
        
    def condition(self,n,nums,k,m):
        bouquets = 0
        flowers = 0
        for flower in nums:
            if flower <= n:
                bouquets += (flowers + 1) // k
                flowers = (flowers + 1) % k    
            else:
                flowers = 0
                
        return bouquets >= m",Medium,28,729,0.0,3,3.0,5.0,26.035714285714285,40.0,3.296785714285715
996.0,xor operation in an array,"class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        k = 0
        for x in range(start, start+(2*n),2):
            k ^= x
        
        return k",Easy,6,175,0.0,1,2.0,1.0,29.166666666666668,12.0,5.995
997.0,making file names unique,"class Solution:
    def getFolderNames(self, names: List[str]) -> List[str]:
        d, res = {}, []
        for name in names:
            if name in d:
                orig_name = name
                # get the smallest positive key
                key = d[name]
                while(name in d):
                    name = orig_name + ""({})"".format(key)
                    key += 1
                d[name] = 1
				# memoization done so as to get the latest version of this next time
                d[orig_name] = key
            else:
                d[name] = 1
            res.append(name)
        return res",Medium,17,615,2.0,2,4.0,4.0,36.1764705882353,19.0,4.564117647058823
998.0,avoid flood in the city,"class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        days = dict() #days of raining for a given lake 
        for d, lake in enumerate(rains): 
            if lake: days.setdefault(lake, deque()).append(d)
            
        ans, hp = [], [] #min-heap 
        full = set() #full lakes
        for d, lake in enumerate(rains): 
            if lake: 
                if lake in full: return []
                full.add(lake)
                days[lake].popleft()
                if days[lake]: heappush(hp, (days[lake][0], lake))
                ans.append(-1)
            else: 
                if hp: 
                    _, lake = heappop(hp)
                    full.remove(lake)
                    ans.append(lake)
                else: 
                    ans.append(1)
        return ans",Medium,22,824,3.0,6,4.0,8.0,37.45454545454545,26.0,3.549090909090909
999.0,find critical and pseudo critical edges in minimum spanning tree,"class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = dict()
        for u, v, w in edges: 
            graph.setdefault(u, []).append((v, w))
            graph.setdefault(v, []).append((u, w))
            
        ref = self.mst(n, graph)
        critical, pseudo = [], []
        for i in range(len(edges)):
            if self.mst(n, graph, exclude=edges[i][:2]) > ref: critical.append(i)
            elif self.mst(n, graph, init=edges[i]) == ref: pseudo.append(i)
        return [critical, pseudo]
            
        
    def mst(self, n, graph, init=None, exclude=None):
        """"""Return weight of MST of given graph using Prim's algo""""""

        def visit(u): 
            """"""Mark node and put its edges to priority queue""""""
            marked[u] = True
            for v, w in graph.get(u, []):
                if exclude and u in exclude and v in exclude: continue
                if not marked[v]: heappush(pq, (w, u, v))
                    
        ans = 0
        marked = [False]*n
        pq = [] #min prioirty queue
        
        if init: 
            u, v, w = init
            ans += w
            marked[u] = marked[v] = True
            visit(u) or visit(v)
        else:
            visit(0)

        while pq: 
            w, u, v = heappop(pq)
            if marked[u] and marked[v]: continue
            ans += w
            if not marked[u]: visit(u)
            if not marked[v]: visit(v)
                
        return ans if all(marked) else inf",Hard,44,1558,1.0,8,3.0,13.0,35.40909090909091,71.0,-0.9068181818181832
1000.0,average salary excluding the minimum and maximum salary,"class Solution:
    def average(self, salary: List[int]) -> float:
        salary.remove(min(salary))
        salary.remove(max(salary))
        avg = 0
        for i in range(0,len(salary)):
            avg += salary[i] 
        
        return float(avg / len(salary))",Easy,8,270,0.0,1,2.0,1.0,33.75,9.0,5.8825
1001.0,the kth factor of n,"class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        try:
            return list(filter(lambda x:n%x==0,range(1,n+1)))[k-1]
        except:
            return -1",Medium,5,181,0.0,-1,3.0,0.0,36.2,15.0,5.122
1002.0,longest subarray of 1s after deleting one element,"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        sums=0 #Summaries of our streaks before making two mistakes
        sumlist=list() #list of that summaries. So we can find our biggest streak later with max()
         
        if sum(nums)==len(nums): #First of all lets test the case there might be no penalties at all
            return sum(nums)-1
        
        s=0 #Penalty counter. Be careful, 2 penalties and streak is over!
        i=0 #lets start our journey from beginning of our list.
        while i< len(nums):
            if nums[i]==0 and s==0: #First Penalty!(0) You can continue, for now...
                s+=1 #Saving that you already done your first penalty
                p=i #Saving your first penalty's location.
                i+=1 #Go next one!
            elif nums[i]==0 and s!=0: #Second Penalty(0) stop now!!! And tell everything you count by far to 'SUMLIST'
                sumlist.append(sums) #saving your streak...
                s=0  #new beginning no penalties...
                sums=0 #but ofcourse youre starting from bottom
				i=p  #start from your first penalty's location!
                i+=1 #actually next of it. Since its a penalty, its not fair to start with a penalty already
            else:
                sums+=1 #No penalties? Add 1 more to your pocket
                i+=1 #Go next one
        sumlist.append(sums) #There might be only one zero so lets append sums just in case, we will return max of that sumlist so, no problem.
        return max(sumlist) #Returning maximum of our streaks with only one penalty!",Medium,25,1604,19.0,1,3.0,6.0,64.16,42.0,0.5456000000000003
1003.0,parallel courses ii,"class Solution:
    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:
        graph = collections.defaultdict(int)
        for x, y in dependencies:
            graph[y] |= 1 << (x - 1) # dependency mask of course y
        last_mask = (1 << n) - 1 # all course
        queue = collections.deque([(0, 0)]) # start with zero course taken
        visited = {0}
        while queue:
            mask, num_semesters = queue.popleft()
			# mask &amp; (1 << (x - 1)) == 0 course have not been taken
			# mask &amp; graph[x] == graph[x] but all its dependency course have been taken
            free_courses = [x for x in range(1, n + 1) if (mask &amp; (1 << (x - 1)) == 0) and mask &amp; graph[x] == graph[x]]
            for courses in itertools.combinations(free_courses, min(k, len(free_courses))):
                new_mask = mask
                for x in courses:
                    new_mask |= 1 << (x - 1)
                if new_mask == last_mask:
                    return num_semesters + 1
                if new_mask not in visited:
                    visited.add(new_mask)
                    queue.append((new_mask, num_semesters + 1))",Hard,21,1179,5.0,6,3.0,8.0,56.142857142857146,56.0,-0.9928571428571438
1004.0,path crossing,"class Solution:
    def isPathCrossing(self, path: str) -> bool:
        directions = {
            'N': (0,1),
            'E': (1,0),
            'W': (-1,0),
            'S': (0,-1)
        }
        
        s = (0, 0)
        storage = [(0,0)]
        for d in path:
            x,y = s
            i,j = directions[d]
            x, y = x+i, y+j
            s = x,y
            if s in storage:
                return True
            else:
                storage.append(s)
        
        return False",Easy,21,510,0.0,1,3.0,2.0,24.285714285714285,33.0,4.274285714285715
1005.0,check if array pairs are divisible by k,"class Solution:
    def canArrange(self, a: List[int], k: int) -> bool:
        d=[0]*k 
        for i in a: 
            d[i%k]+=1 
        for i in range(k):
            if i==0:
                if d[i]%2!=0:
                    return 0
            elif(d[i]!=d[k-i]):
                return 0
        return 1",Medium,11,313,0.0,2,3.0,5.0,28.454545454545453,19.0,5.239090909090909
1006.0,number of subsequences that satisfy the given sum condition,"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        nums.sort()
        
        ans = 0
        lo, hi = 0, len(nums)-1
        while lo <= hi: 
            if nums[lo] + nums[hi] > target: hi -= 1
            else: 
                ans += pow(2, hi - lo, 1_000_000_007)
                lo += 1
        
        return ans % 1_000_000_007",Medium,12,373,0.0,2,3.0,2.0,31.08333333333333,22.0,4.7025
1007.0,max value of equation,"class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        deque = collections.deque()
        res = -math.inf

        for point in points:
            x, y = point[0], point[1]
            
            while deque and x - deque[0][0] > k:
                deque.popleft()
            
            if deque:
                res = max(res, (y + deque[0][1]) + (x - deque[0][0]))
            
            # while deque AND any equation including (x, y) will always yield a greater
			# (or ==) result than any equation including (deque[-1][0], deque[-1][1])
            while deque and (deque[-1][0] - x) + (y - deque[-1][1]) >= 0:
                deque.pop()
            
            deque.append(point)
        
        return res",Hard,21,773,2.0,4,3.0,5.0,36.80952380952381,26.0,3.747142857142857
1008.0,can make arithmetic progression from sequence,"class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        diff=arr[0]-arr[1]
        for i in range(1,len(arr)-1):
            if arr[i]-arr[i+1]!=diff:
                return False
        else:
            return True",Easy,8,272,0.0,1,3.0,4.0,34.0,11.0,5.6000000000000005
1009.0,last moment before all ants fall out of a plank,"class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        left_max = max(left) if left else 0
        right_max = n - min(right) if right else 0
        return max(left_max, right_max)",Medium,4,229,0.0,0,2.0,2.0,57.25,12.0,3.5275
1010.0,count submatrices with all ones,"class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        n,m = len(mat), len(mat[0])
        nums = []
        for i in range(n):
            num = []
            for j in range(m-1,-1,-1):
                if mat[i][j] == 0:
                    num = [0] + num
                elif mat[i][j] == 1 and j == m-1:
                    num = [1] + num
                elif mat[i][j] == 1 and j != m-1:
                    num = [1 + num[0]] + num
            nums.append(num)
        ans = 0
        for i in range(n):
            for j in range(m):
                x = m + 1
                for k in range(i,n):
                    x = min(x,nums[k][j])
                    ans += x
        return ans",Medium,21,718,0.0,8,4.0,8.0,34.19047619047619,42.0,2.002857142857142
1011.0,minimum possible integer after at most k adjacent swaps on digits,"class Solution:
    def minInteger(self, num: str, k: int) -> str:
        n = len(num)
        if k >= n*(n-1)//2: return """".join(sorted(num)) #special case
        
        #find smallest elements within k swaps 
        #and swap it to current position 
        num = list(num)
        for i in range(n):
            if not k: break 
            #find minimum within k swaps
            ii = i
            for j in range(i+1, min(n, i+k+1)): 
                if num[ii] > num[j]: ii = j 
            #swap the min to current position 
            if ii != i: 
                k -= ii-i
                for j in range(ii, i, -1):
                    num[j-1], num[j] = num[j], num[j-1]
        return """".join(num)",Hard,19,715,5.0,5,3.0,7.0,37.63157894736842,30.0,3.3331578947368428
1012.0,reformat date,"class Solution:
    def reformatDate(self, date: str) -> str:
        month, date = {""Jan"":""01"", ""Feb"":""02"", ""Mar"":""03"", ""Apr"":""04"", ""May"":""05"", ""Jun"":""06"", ""Jul"":""07"", ""Aug"":""08"", ""Sep"":""09"", ""Oct"":""10"", ""Nov"":""11"", ""Dec"":""12""}, date.split()
        return date[2] + '-' + month[date[1]] + '-' + ''.join(['0']+[d for d in date[0] if d.isdigit()])[-2:]",Easy,3,352,0.0,1,2.0,3.0,117.33333333333331,32.0,-3.9399999999999977
1013.0,range sum of sorted subarray sums,"class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        ans = [nums[0]]
        for i in range(1, n):
            ans.append(nums[i])    
            nums[i] += nums[i-1]
            ans.append(nums[i])    
            for j in range(i-1): ans.append(nums[i] - nums[j])
        ans.sort()                
        return sum(ans[left-1:right]) % 1000000007",Medium,9,402,0.0,2,3.0,2.0,44.66666666666666,17.0,3.98
1014.0,minimum difference between largest and smallest value in three moves,"class Solution:
    def minDifference(self, nums: List[int]) -> int:
        heapq.heapify(nums)
        return min(map(lambda x, y: x-y, heapq.nlargest(4,nums), heapq.nsmallest(4,nums)[::-1]))",Medium,3,193,0.0,0,2.0,2.0,64.33333333333333,13.0,2.790000000000001
1015.0,stone game iv,"class Solution:
    def __init__(self):
        self.cache = {}
    
    def winnerSquareGame(self, n: int) -> bool:
        if not n: return False
        if n in self.cache:
            return self.cache[n]
        i = int(math.sqrt(n))
        while i >= 1:
            if not self.winnerSquareGame(n - i*i):
                self.cache[n] = True
                return self.cache[n]
            i -= 1
        self.cache[n] = False
        return self.cache[n]",Hard,15,463,0.0,1,3.0,4.0,30.866666666666667,17.0,5.282000000000001
1016.0,number of good pairs,"class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        repetitions = {}

        for value in nums:
            repetitions[value] = repetitions.get(value, -1) + 1
        
        return sum((v*(v+1))//2 for v in repetitions.values())",Easy,7,261,0.0,1,2.0,2.0,37.285714285714285,9.0,5.564285714285715
1017.0,number of substrings with only 1s,"class Solution:
    def numSub(self, s: str) -> int:
        return sum(map(lambda x: ((1+len(x))*len(x)//2)%(10**9+7), s.split('0')))",Medium,2,134,0.0,0,2.0,0.0,67.0,7.0,3.1500000000000004
1018.0,path with maximum probability,"class Solution:
	def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        edge_prob=[]
        for i in range(n):
            edge_prob.append([])
        for i in range(len(edges)):
            edge_prob[edges[i][0]].append([edges[i][1],succProb[i]])
            edge_prob[edges[i][1]].append([edges[i][0],succProb[i]])
        
        prob=[0]*n
        pq=[]
        pq.append((-1,start))
        while pq:
            current=heapq.heappop(pq)
            if prob[current[1]]==0:
                prob[current[1]]=-current[0]
                for neighbor in edge_prob[current[1]]:
                    heapq.heappush(pq,(-neighbor[1]*prob[current[1]],neighbor[0]))
                if current[1]==end:
                    break
        return prob[end]",Medium,20,817,0.0,5,3.0,6.0,40.85,35.0,2.3435000000000006
1019.0,best position for a service centre,"class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        #euclidean distance 
        fn = lambda x, y: sum(sqrt((x-xx)**2 + (y-yy)**2) for xx, yy in positions)
        #centroid as starting point
        x = sum(x for x, _ in positions)/len(positions)
        y = sum(y for _, y in positions)/len(positions)
        
        ans = fn(x, y)
        chg = 100 #change since 0 <= positions[i][0], positions[i][1] <= 100
        while chg > 1e-6: #accuracy within 1e-5
            zoom = True
            for dx, dy in (-1, 0), (0, -1), (0, 1), (1, 0):
                xx = x + chg * dx
                yy = y + chg * dy
                dd = fn(xx, yy)
                if dd < ans: 
                    ans = dd 
                    x, y = xx, yy
                    zoom = False 
                    break 
            if zoom: chg /= 2
        return ans",Hard,22,886,4.0,3,3.0,7.0,40.27272727272727,46.0,1.575454545454546
1020.0,water bottles,"class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        total = numBottles
        p = numBottles
        
        while p >= numExchange:
            p_int = p // numExchange
            p_rem = p % numExchange
            p = p_int + p_rem
            total += p_int
        
        return total",Easy,11,339,0.0,1,3.0,1.0,30.818181818181817,16.0,5.386363636363638
1021.0,number of nodes in the sub tree with the same label,"class Solution:
    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:
        graph = self.build_graph(edges)
        res = [0] * n
        visited = set()
		
        def add(seen1, seen2):
            seen = [0] * 26
            for i in range(26):
                seen[i] = seen1[i] + seen2[i]
            return seen
        
        def index(char):
            return ord(char) - ord('a')
        
        def dfs(node):
		    # Maintain a visited since the edge is represented in both directions in the graph
            visited.add(node)
            seen = [0] * 26
            for neigh in graph.get(node, []):
                if not neigh in visited:
                    seen = add(seen, dfs(neigh))
                
            seen[index(labels[node])] += 1
            res[node] = seen[index(labels[node])]
            return seen
        
        dfs(0)
        return res
        
    def build_graph(self, edges):
        graph = {}
        for edge in edges:
		     # Include edges in both directions since ordering of edges is not guaranteed
			 # e.g. case [[0, 2], [0, 3], [1, 2]]
			 # In above example we should traverse from 2 to 1.
            graph.setdefault(edge[0], []).append(edge[1])
            graph.setdefault(edge[1], []).append(edge[0])
        return graph",Medium,38,1324,4.0,0,3.0,4.0,34.8421052631579,38.0,3.0442105263157897
1022.0,maximum number of non overlapping substrings,"class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        
        # record last index(+1) and interval relations
        last, interval = {}, {}
        for i, c in enumerate(s):
            last[c] = i + 1
            if c not in interval:
                interval[c] = set(''.join(s.split(c)[1:-1]))
        
        # union-find
        parent = {c: c for c in s}
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            parent[find(x)] = find(y)
            return
        
        for c in interval:
            for n in interval[c]:
                if c in interval[n]:
                    union(c, n)
        
        # cut and remove redundant character
        splits, max_splits = [(s, 0)], []
        
        while splits:
            
            # cut
            splits_cut = []
            for string, start in splits:
                left = right = 0 
                for i, c in enumerate(string):
                    right = max(right, last[c] - start)
                    if i == right - 1:
                        splits_cut.append((string[left:right], start + left))
                        left = right
            
            # remove redundant
            splits_rem = []
            for string, start in splits_cut:
                len_splits_rem = len(splits_rem)
                redundant = find(string[0])
                
                left = 0
                while left < len(string):
                    if find(string[left]) == redundant:
                        left += 1
                    else:
                        right = left
                        while right < len(string) and find(string[right]) != redundant:
                            right += 1
                        splits_rem.append((string[left:right], start + left))
                        left = right

                if len_splits_rem == len(splits_rem):
                    max_splits.append(string)

            splits = splits_rem
        
        return max_splits",Hard,64,2128,5.0,13,4.0,16.0,33.25,75.0,-1.3125
1023.0,find a value of a mysterious function closest to target,"class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while n > m: 
            n &amp;= n-1 #unset last set bit
        return n",Hard,4,153,1.0,1,2.0,1.0,38.25,10.0,5.4175
1024.0,count odd numbers in an interval range,"class Solution:
    def countOdds(self, low: int, high: int) -> int:
        if low % 2 == 0:
            low += 1
        return (((high - low)//2) + 1)",Easy,4,153,0.0,1,2.0,1.0,38.25,12.0,5.1775
1025.0,number of sub arrays with odd sum,"class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        freq = [1, 0]
        ans = prefix = 0
        for x in arr: 
            prefix += x 
            ans += freq[1 ^ prefix&amp;1]
            freq[prefix&amp;1] += 1
        return ans % 1_000_000_007",Medium,8,276,0.0,1,3.0,1.0,34.5,13.0,5.355
1026.0,number of good ways to split a string,"class Solution:
    def numSplits(self, s: str) -> int:
        tail_d, head_d, ans = {}, {}, 0
        
        def add_c(d, c):
            if c not in d:
                d[c] = 1
            else:
                d[c] += 1
                
        def remove_c(d, c):
            n = d[c]
            n -= 1
            if n == 0:
                del d[c]
            else:
                d[c] = n
                                
        def is_same(d1, d2):
            return len(d1) == len(d2)
        
        # 0) Initialize tail_d
        for c in s:
            add_c(tail_d, c)
            
            
        # 1) Start searching number of good ways of split        
        for c in s:
            remove_c(tail_d, c)
            add_c(head_d, c)
            if is_same(tail_d, head_d):
                ans += 1
        
            if len(tail_d) < len(head_d):
                break
                
        # 3) Return the answer
        return ans",Medium,37,968,3.0,3,3.0,6.0,26.16216216216216,41.0,3.3054054054054056
1027.0,minimum number of increments on subarrays to form a target array,"class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        ans = 0 
        stack = [] # increasing stack
        for x in target: 
            while stack and stack[-1] >= x: 
                ans += stack.pop() - max(x, (stack or [0])[-1])
            stack.append(x)
        prev = 0
        for x in stack: 
            ans += x - prev 
            prev = x
        return ans",Hard,12,405,1.0,3,3.0,3.0,33.75,17.0,4.9425
1028.0,shuffle string,"class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        fs = ''
        num = 0
        for i in range(len(indices)):
            ind = indices.index(num)
            fs += s[ind]
            num += 1
        return fs",Easy,8,250,0.0,1,3.0,1.0,31.25,13.0,5.647500000000001
1029.0,minimum suffix flips,"class Solution:
    def minFlips(self, target: str) -> int:

        count = 0
        checkfor = 1

        for i in range(len(target)):
            if int(target[i]) == checkfor:
                count += 1
                checkfor ^= 1

        return count",Medium,11,259,0.0,2,2.0,5.0,23.545454545454547,14.0,6.24090909090909
1030.0,number of good leaf nodes pairs,"class Solution:
    def __init__(self):
        self.res = 0
        
    def traversal(self, node, dist):
        if not node:
            return []
        
        if not node.left and not node.right:
            return [1]
        
        dists_from_left = self.traversal(node.left, dist)
        dists_from_right = self.traversal(node.right, dist)
        
        for ld in dists_from_left:
            for rd in dists_from_right:
                if ld + rd <= dist:
                    self.res += 1
        
        return [d + 1 for d in dists_from_left + dists_from_right if d < dist]
        
        
    def countPairs(self, root: TreeNode, distance: int) -> int:
        self.traversal(root, distance)
        
        return self.res",Medium,25,749,0.0,2,3.0,7.0,29.96,26.0,4.4036
1031.0,string compression ii,"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        # Find min lenth of the code starting from group ind, if there are res_k characters to delete and 
		#       group ind needs to be increased by carry_over additional characters
        def FindMinLen(ind, res_k, carry_over=0): 
            
            # If we already found the min length - just retrieve it (-1 means we did not calculate it)
            if carry_over == 0 and dynamic[ind][res_k] != -1:
                return dynamic[ind][res_k]
            
            # Number of character occurences that we need to code. Includes carry-over.
            cur_count = carry_over + frequency[ind]

            # Min code length if the group ind stays intact. The code accounts for single-character ""s0"" vs. ""s""  situation.
            min_len = 1 + min(len(str(cur_count)), cur_count - 1) + FindMinLen(ind+1,res_k)

            # Min length if we keep only 0, 1, 9, or 99 characters in the group - delete the rest, if feasible
            for leave_count, code_count in [(0,0), (1, 1), (9, 2), (99, 3)]:
                if cur_count > leave_count and res_k >= cur_count - leave_count:
                    min_len = min(min_len, code_count + FindMinLen(ind + 1,res_k - (cur_count - leave_count)))

            # If we drop characters between this character group and next group, like drop ""a"" in ""bbbabb""
            next_ind = chars.find(chars[ind], ind + 1)
            delete_count = sum(frequency[ind+1:next_ind])
            if next_ind > 0 and res_k >= delete_count:
                min_len = min(min_len, FindMinLen(next_ind, res_k - delete_count, carry_over = cur_count))

            # If there was no carry-over, store the result
            if carry_over == 0: dynamic[ind][res_k] = min_len
            return min_len
        
        # Two auxiliary lists - character groups (drop repeated) and number of characters in the group
        frequency, chars = [], """"
        for char in s:
            if len(frequency)==0 or char != chars[-1]:
                frequency.append(0)
                chars = chars + char
            frequency[-1] += 1
        
        # Table with the results. Number of character groups by number of available deletions.  
        dynamic = [[-1] * (k + 1) for i in range(len(frequency))] + [[0]*(k + 1)]
        
        return FindMinLen(0, k)",Hard,42,2381,10.0,5,3.0,16.0,56.69047619047619,74.0,-2.5821428571428573
1032.0,count good triplets,"class Solution:
    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
        length=len(arr)
        count=0
        for i in range(length):
            for j in range(i+1,length):
                for k in range(j+1,length):
                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:
                        count+=1
                    else:
                        continue
                            
        return count",Easy,12,503,0.0,3,4.0,4.0,41.91666666666666,27.0,3.1075
1033.0,find the winner of an array game,"class Solution:
    def getWinner(self, arr: List[int], k: int) -> int:
        n = len(arr)
        winningInteger = arr[0]
        winCount = 0
        for i in range(1, n):
            if winningInteger > arr[i]:
                winCount += 1
            else:
                winningInteger = arr[i]
                winCount = 1
            if winCount == k:
                return winningInteger
        return winningInteger",Medium,13,430,0.0,2,3.0,3.0,33.07692307692308,22.0,4.523076923076923
1034.0,minimum swaps to arrange a binary grid,"class Solution:
    def minSwaps(self, grid: List[List[int]]) -> int:
        A = [sum(int(x == 0) for x in accumulate(row[::-1])) for row in grid]
        n = len(grid)

        res = 0
        for i in range(n):
            for j in range(i, n):
                if A[j] >= n - 1 - i:
                    A = A[:i] + A[j:j+1] + A[i:j] + A[j+1:]
                    res += j - i
                    break
            else:
                return -1
        
        return res",Medium,15,476,0.0,2,3.0,5.0,31.73333333333333,26.0,4.244000000000001
1035.0,get the maximum score,"class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        i = j = score1 = score2 = maxScore = 0
        m, n = len(nums1), len(nums2)
        MOD = 10 ** 9 + 7
        
        while i < m and j < n:
            if nums1[i] < nums2[j]:
                score1 += nums1[i]
                i += 1
            elif nums1[i] > nums2[j]:
                score2 += nums2[j]
                j += 1
            else:
                maxScore += nums1[i] + max(score1, score2)
                maxScore %= MOD
                score1 = score2 = 0
                i += 1
                j += 1
        
        while i < m:
            score1 += nums1[i]
            i += 1
        while j < n:
            score2 += nums2[j]
            j += 1
        
        maxScore += max(score1, score2)
        return maxScore % MOD",Hard,28,842,0.0,5,3.0,5.0,30.071428571428573,45.0,2.313571428571429
1036.0,kth missing positive number,"class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        check = [True]*2001
        for e in arr:
            check[e] = False
        ind = 1
        for i in range(k):
            while check[ind]==False:
                ind+=1
            ind+=1
        return ind-1",Easy,10,299,0.0,3,3.0,3.0,29.9,18.0,5.149000000000001
1037.0,can convert string in k moves,"class Solution:
    def canConvertString(self, s: str, t: str, k: int) -> bool:
        if len(s)!=len(t):return False
        
        lookup=collections.defaultdict(int)
        for i in range(len(s)):
            if s[i]!=t[i]:
                char = ord(t[i])-ord(s[i])
                if char<0:char+=26
                lookup[char] += 1        
        
        keys = sorted(lookup.keys())
        for key in keys:
            temp=key
            if key<k:
                lookup[key]-=1
                while lookup[key]:
                    temp+=26
                    if temp>k:break
                    if temp<=k:
                        lookup[key]-=1
            if temp>k or key>k:return False
        return True",Medium,22,730,0.0,7,4.0,10.0,33.18181818181818,37.0,2.653636363636364
1038.0,minimum insertions to balance a parentheses string,"class Solution:
    def minInsertions(self, s: str) -> int:
        stack = []
        ret = 0
        for c in s:
            if c == '(':
                if stack and not stack[- 1]:
                    ret += 1
                    stack.pop()
                stack.append(1)
            else:
                if not stack:
                    ret += 1
                    stack.append(1)
                if stack[- 1]:
                    stack[- 1] -= 1
                else:
                    stack.pop()
        while stack:
            ret += 1 + stack.pop()
        return ret",Medium,20,586,0.0,6,4.0,6.0,29.3,22.0,4.563
1039.0,find longest awesome substring,"class Solution:
    def longestAwesome(self, s: str) -> int:
        ans = prefix = 0
        seen = {0: -1}
        for i, c in enumerate(s):
            prefix ^= 1 << int(c) #toggle bit 
            ans = max(ans, i - seen.get(prefix, inf))
            for k in range(10): 
                x = prefix ^ (1 << k) #toggle kth bit 
                ans = max(ans, i - seen.get(x, inf))
            seen.setdefault(prefix, i)
        return ans",Hard,11,442,2.0,2,3.0,2.0,40.18181818181818,25.0,3.663636363636364
1041.0,find kth bit in nth binary string,"class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        '''
        length pattern:
            1-1
            2-2*1+1=3=2**2-1
            3-2*3+1=7=2**3-1
            4-2*7+1=15=16-1=2**4-1
            n-2**n-1
        k-th bit:
            k<2**(n-1)
        '''
        def helper(n,k):
            if n==1:
                return 0
            elif k==2**(n-1):
                return 1
            elif k<2**(n-1):
                return helper(n-1,k)
            else:
                return 1-helper(n-1,2**(n-1)-(k-2**(n-1)))
        return str(helper(n,k))",Medium,21,584,1.0,-1,3.0,3.0,27.80952380952381,33.0,4.117142857142857
1042.0,maximum number of non overlapping subarrays with sum equals target,"class Solution:
    def maxNonOverlapping(self, nums: List[int], target: int) -> int:
        
        moddict = {}
        moddict[0] = 0
        
        res = 0  # value to be returned
        
        cnt = 1
        s = 0 
        
        for num in nums:
            s += num
            if s-target in moddict:
                res += 1
                moddict = {}
            moddict[s] = cnt
            
            cnt += 1
        return res",Medium,19,454,1.0,2,3.0,2.0,23.894736842105264,19.0,5.689473684210526
1043.0,minimum cost to cut a stick,"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        
        # Function to make cut
        def makeCut(start, end, t=dict()):
            
            # Make key
            key = (start, end)
            
            # If key doesn't exist
            if key not in t:
            
                # Init
                currMin = float(""inf"")

                # For all cuts
                for cut in cuts:

                    # If cuts exist between the start and end, it's a valid cut.
                    if start < cut < end:

                        # Get the current cost of the cut 
                        cost = end - start

                        # Update currMin
                        currMin = min(currMin, cost + makeCut(start, cut, t) + makeCut(cut, end, t))

                # Update the currenty key, if nothing is processed, the value is 0
                t[key] = currMin if currMin != float(""inf"") else 0
            
            # return the current key
            return t[key]
        
        return makeCut(0,n)",Hard,33,1071,10.0,1,3.0,8.0,32.45454545454545,32.0,4.03909090909091
1044.0,three consecutive odds,"class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        return any(a % 2 == b % 2 == c % 2 == 1 for a, b, c in zip(arr, arr[1:], arr[2:]))",Easy,2,166,0.0,1,2.0,1.0,83.0,20.0,0.3500000000000014
1045.0,minimum operations to make array equal,"class Solution:
    def minOperations(self, n: int) -> int:
        k=[]
        val = [j for j in range(n)]
        arr = list(map(lambda i:((2*i)+1),val))
        avg = int((sum(arr))/n)
        for s in arr:
            if s<avg:                
                k.append(avg-s) 
        return(sum(k))",Medium,9,304,0.0,2,3.0,3.0,33.77777777777778,14.0,5.26
1046.0,magnetic force between two balls,"class Solution:
    def maxDistance(self, A, n):
        A.sort()
        L    = len(A)
        lo   = 1
        hi   = (A[-1]-A[0])//(n-1)
        best = 1
        n   -= 1
        def valid(mid):
            prev = A[0]
            i    = 0
            for j in range(n):
                d = prev + mid
                while i<L and A[i]<d:
                    i += 1
                if i==L:
                    return False
                prev = A[i]
            return True
        
        while lo<=hi:
            mid = (lo+hi) >> 1
            if valid(mid):
                best = mid
                lo   = mid + 1
            else:
                hi = mid - 1
        
        return best",Medium,28,702,0.0,3,3.0,5.0,25.071428571428573,34.0,3.983571428571429
1047.0,minimum number of days to eat n oranges,"class Solution:
    def minDays(self, n: int) -> int:
        memo = dict()
        def minimumDays(n):
            if n in memo:
                return memo[n]
            
            if n == 1:
                return 1
            if n== 2 or n == 3:
                return 2
            
            memo[n] = min(n%2+minimumDays(n//2)+1, n%3+minimumDays(n//3)+1)
            
            return memo[n]
        
        return minimumDays(n)",Hard,16,446,0.0,-1,3.0,3.0,27.875,21.0,5.271249999999999
1048.0,thousand separator,"class Solution:
    def thousandSeparator(self, n: int) -> str:
        n=str(n)
        res=""""
        if len(str(n)) <4:
            return str(n)
        count=0
        for i in range(len(n)-1,-1,-1):

            if count<3:
                res+=str(n[i])
                count+=1
            if count==3 and i!=0:
                res+="".""
                
                count=0
        return str(res[::-1])",Easy,16,415,0.0,3,3.0,4.0,25.9375,26.0,4.705625
1049.0,minimum number of vertices to reach all nodes,"class Solution:
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        d = {}
        ans = []
        for x,y in edges:
            if y not in d:
                d[y] = [x]
            else:
                d[y].append(x)
        
        for x in range(n):
            if x not in d:
                ans.append(x)
        
        return ans",Medium,14,383,0.0,4,3.0,4.0,27.357142857142858,16.0,5.517857142857142
1050.0,minimum numbers of function calls to make target array,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        return sum(bin(x).count(""1"") for x in nums) + len(bin(max(nums))) - 3",Medium,2,146,0.0,0,2.0,1.0,73.0,5.0,2.8100000000000005
1051.0,detect cycles in 2d grid,"class Solution:
    def containsCycle(self, grid: List[List[str]]) -> bool:
        sets_vals = defaultdict(set)
        for r, row in enumerate(grid):
            for c, v in enumerate(row):
                sets_vals[v].add((r, c))
        for _, set_val in sets_vals.items():
            while set_val:
                chain_len = 0
                start = set_val.pop()
                neighbours = {start}
                chain = {start: (chain_len, tuple())}
                while neighbours:
                    chain_len += 1
                    new_neighbours = set()
                    for r, c in neighbours:
                        for new_cell in [(r + 1, c), (r - 1, c), (r, c + 1),
                                         (r, c - 1)]:

                            if (new_cell in chain and
                                    new_cell != chain[(r, c)][1] and
                                    chain[new_cell][0] + chain_len > 3):
                                return True

                            if new_cell in set_val:
                                chain[new_cell] = (chain_len, (r, c))
                                new_neighbours.add(new_cell)
                                set_val.remove(new_cell)

                    neighbours = new_neighbours
        return False",Medium,30,1302,0.0,6,5.0,9.0,43.4,42.0,1.234
1052.0,most visited sector in a circular track,"class Solution:
    def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
        for i in range(len(rounds)-1):
            a, b = rounds[i],rounds[i+1]
            if a < b:
                for j in range(a+1,b):
                    rounds.append(j)
            else:
                for j in range(a+1,n+1):
                    rounds.append(j)
                for j in range(1,b):
                    rounds.append(j)
        m = 0
        v = []
        d = Counter(rounds)
        for i in d:
            if d[i] > m-1:
                v.append(i)
                m = d[i]
        return sorted(v)",Easy,19,612,0.0,7,4.0,7.0,32.21052631578947,27.0,3.741052631578947
1053.0,maximum number of coins you can get,"class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        if len(piles) == 0:
            return 0

        piles.sort()
        
        len_piles = len(piles)
        cnt = 0
        for i in range(len_piles - 2, len_piles //3 -1, -2):
            cnt += piles[i]
        return cnt",Medium,11,299,0.0,1,2.0,2.0,27.181818181818183,15.0,5.873636363636364
1054.0,find latest group of size m,"class Solution:
    def findLatestStep(self, arr: List[int], m: int) -> int:
        span = [0]*(len(arr)+2)
        freq = [0]*(len(arr)+1)
        ans = -1
        for i, x in enumerate(arr, 1): 
            freq[span[x-1]] -= 1
            freq[span[x+1]] -= 1
            span[x] = span[x-span[x-1]] = span[x+span[x+1]] = 1 + span[x-1] + span[x+1]
            freq[span[x]] += 1
            
            if freq[m]: ans = i
        return ans",Medium,12,446,0.0,2,3.0,2.0,37.16666666666666,21.0,4.255
1055.0,stone game v,"class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        # prefix sum 
        prefix = [0]
        for x in stoneValue: prefix.append(prefix[-1] + x)
        
        @lru_cache(None)
        def fn(lo, hi):
            """"""Return the score of arranging values from lo (inclusive) to hi (exclusive). """"""
            if lo+1 == hi: return 0 
            val = 0
            for mid in range(lo+1, hi): 
                lower = prefix[mid] - prefix[lo]
                upper = prefix[hi] - prefix[mid]
                if lower < upper: val = max(val, lower + fn(lo, mid))
                elif lower > upper: val = max(val, upper + fn(mid, hi))
                else: val = max(val, lower + max(fn(lo, mid), fn(mid, hi)))
            return val 
                
        return fn(0, len(stoneValue))",Hard,19,819,1.0,2,3.0,5.0,43.10526315789474,35.0,2.360526315789474
1056.0,detect pattern of length m repeated k or more times,"class Solution:
    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
        i=0
        d=m
        if m >len(arr) or k >len(arr):
            return(False)
        while d < len(arr):    
            p=arr[i:d]
            count=1
            j,l=i+m,d+m
            while l<len(arr)+1:
                if arr[j:l]==p:
                    count+=1
                else:
                    break
                if count>=k:
                    return(True)
                    break
                j+=m
                l+=m
            i+=1
            d+=1
        return(False)",Easy,22,601,0.0,1,4.0,5.0,27.318181818181817,38.0,3.4413636363636364
1057.0,maximum length of subarray with positive product,"class Solution:
    
    @staticmethod
    def process(st, end, cnt_neg, arr):
        if st >= 0 and st <= end and end >= 0:
            if not (cnt_neg % 2):
                return end - st + 1
            first_neg_ind = st 
            last_neg_ind = end
            while(first_neg_ind <= end and arr[first_neg_ind] >= 0):
                first_neg_ind += 1
            while(last_neg_ind >= st and arr[last_neg_ind] >= 0):
                last_neg_ind -= 1
            print((st, end, first_neg_ind, last_neg_ind))
            return max(last_neg_ind - st, end - first_neg_ind)
            
        return 0
    
    def getMaxLen(self, nums: List[int]) -> int:
        prev = 0
        ans = 0
        cnt_neg = 0
        for i in range(len(nums)):
            if not nums[i]:
                ans = max(ans, Solution.process(prev, i-1, cnt_neg, nums))
                prev = i + 1
                cnt_neg = 0
            if nums[i] < 0:
                cnt_neg += 1
        ans = max(ans, Solution.process(prev, len(nums)-1, cnt_neg, nums))
        return ans",Medium,30,1066,0.0,2,3.0,7.0,35.53333333333333,55.0,1.002000000000001
1058.0,minimum number of days to disconnect island,"class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension 
        grid = """".join("""".join(map(str, x)) for x in grid)
        
        @lru_cache(None)
        def fn(s): 
            """"""Return True if grid is disconnected.""""""
            row, grid = [], []
            for i, c in enumerate(s, 1):
                row.append(int(c))
                if i%n == 0: 
                    grid.append(row)
                    row = []
                    
            def dfs(i, j): 
                """"""""""""
                grid[i][j] = 0
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: dfs(ii, jj)
                return 1
            return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j])
        
        #bfs 
        queue = [grid]
        level = 0 
        seen = {grid}
        while queue: 
            tmp = []
            for node in queue: 
                if fn(node) == 0 or fn(node) >= 2: return level 
                for i in range(m*n):
                    if node[i] == ""1"": 
                        nn = node[:i] + ""0"" + node[i+1:]
                        if nn not in seen: 
                            seen.add(nn)
                            tmp.append(nn)
            queue = tmp
            level += 1",Hard,38,1390,2.0,7,4.0,15.0,36.578947368421055,66.0,-0.4721052631578946
1059.0,number of ways to reorder array to get same bst,"class Solution:
      

    def numOfWays(self, nums: List[int]) -> int:
        FACT = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063, 72847302, 602640637, 860734560, 657629300, 440732388, 459042011, 394134213, 35757887, 36978716, 109361473, 390205642, 486580460, 57155068, 943272305, 14530444, 523095984, 354551275, 472948359, 444985875, 799434881, 776829897, 626855450, 954784168, 10503098, 472639410, 741412713, 846397273, 627068824, 726372166, 318608048, 249010336, 948537388, 272481214, 713985458, 269199917, 75195247, 286129051, 595484846, 133605669, 16340084, 996745124, 798197261, 286427093, 331333826, 536698543, 422103593, 280940535, 103956247, 172980994, 108669496, 715534167, 518459667, 847555432, 719101534, 932614679, 878715114, 661063309, 562937745, 472081547, 766523501, 88403147, 249058005, 671814275, 432398708, 753889928, 834533360, 604401816, 187359437, 674989781, 749079870, 166267694, 296627743, 586379910, 119711155, 372559648, 765725963, 275417893, 990953332, 104379182, 437918130, 229730822, 432543683, 551999041, 407899865, 829485531, 925465677, 24826746, 681288554, 260451868, 649705284, 117286020, 136034149, 371858732, 391895154, 67942395, 881317771, 114178486, 473061257, 294289191, 314702675, 79023409, 640855835, 825267159, 333127002, 640874963, 750244778, 281086141, 979025803, 294327705, 262601384, 400781066, 903100348, 112345444, 54289391, 329067736, 753211788, 190014235, 221964248, 853030262, 424235847, 817254014, 50069176, 159892119, 24464975, 547421354, 923517131, 757017312, 38561392, 745647373, 847105173, 912880234, 757794602, 942573301, 156287339, 224537377, 27830567, 369398991, 365040172, 41386942, 621910678, 127618458, 674190056, 892978365, 448450838, 994387759, 68366839, 417262036, 100021558, 903643190, 619341229, 907349424, 64099836, 89271551, 533249769, 318708924, 92770232, 420330952, 818908938, 584698880, 245797665, 489377057, 66623751, 192146349, 354927971, 661674180, 71396619, 351167662, 19519994, 689278845, 962979640, 929109959, 389110882, 98399701, 89541861, 460662776, 289903466, 110982403, 974515647, 928612402, 722479105, 218299090, 96415872, 572421883, 774063320, 682979494, 693774784, 611379287, 166890807, 880178425, 837467962, 705738750, 616613957, 338771924, 497191232, 896114138, 560652457, 661582322, 224945188, 262995829, 859081981, 857116478, 279856786, 408062844, 406076419, 367193638, 985761614, 767884817, 77737051, 801784560, 410447512, 813374614, 702909132, 777826615, 11426636, 685259446, 721228129, 931065383, 593559607, 860745086, 578819198, 495425745, 893029457, 6156532, 502193801, 37480384, 220174401, 383076669, 3013247, 750298503, 574624441, 230733683, 144887710, 656590378, 773954850, 358485371, 772254339, 469363737, 95843299, 823414273, 87709482, 892174648, 749756145, 185864756, 68295241, 98238739, 131504392, 111672419, 928208089, 687974198, 753032165, 71715287, 506557931, 290314197, 546089425, 174590825, 187067364, 817659471, 309331349, 303445769, 964814732, 112937795, 848457973, 113604679, 263728612, 162653895, 519013648, 956915940, 591788795, 26960558, 818561771, 201473695, 830318534, 283328761, 298655153, 103269519, 567777414, 629890782, 707451727, 528064896, 419467694, 259775012, 452053078, 972081682, 512829263, 412924123, 354780756, 917691336, 648929514, 519218426, 957710940, 848100261, 607279584, 78508462, 651656900, 271922065, 927371945, 976904514, 655633282, 147015495, 44958071, 431540693, 956102180, 821001984, 4640954, 508310043, 709072863, 866824584, 318461564, 773853828, 371761455, 53040744, 609526889, 972452623, 799173814, 723225821, 3874155, 305590228, 289496343, 139259591, 348260611, 756867525, 848691744, 101266155, 835557082, 267191274, 448180160, 518514435, 443022120, 614718802, 151579195, 204297074, 912569551, 137049249, 515433810, 979001276, 524451820, 229298431, 88837724, 892742699, 387369393, 840349900, 206661672, 18186411, 619853562, 246548548, 236767938, 893832644, 930410696, 321544423, 971435684, 402636244, 780681725, 194281388, 661238608, 964476271, 643075362, 439409780, 96895678, 723461710, 915447882, 785640606, 114709392, 933696835, 539582134, 739120141, 300372431, 244129985, 722433522, 26638091, 388855420, 42468156, 647517040, 474194942, 832805846, 958306874, 489519451, 339220689, 9833277, 923477502, 390998217, 790283925, 694135631, 736657340, 609563281, 873127083, 489593220, 264439147, 891171227, 489029295, 502009550, 325923608, 280525558, 857054649, 820622208, 558213940, 216997416, 487921842, 951328535, 606653379, 794417402, 449723904, 783486165, 414645478, 809681447, 114612567, 824953206, 255016498, 147060381, 88903008, 228293174, 394357308, 362355866, 900088886, 638573794, 779598451, 904922263, 451026166, 549459329, 212643744, 563246709, 391796933, 174243175, 189725986, 238337196, 60051478, 782959006, 982673239, 237607992, 685987666, 694447544, 195840153, 519748540, 446086975, 523485236, 185780714, 716004996, 214280883, 140643728, 555470704, 516522055, 116665689, 899547947, 490696549, 683197147, 686671136, 988747143, 744912554, 619072836, 345158054, 224284246, 637879131, 78947725, 342273666, 237716550, 915360466, 711578771, 423071394, 228124918, 271834959, 480779410, 254894593, 859192972, 990202578, 258044399, 151532640, 644862529, 48049425, 448119239, 130306338, 850105179, 401639970, 606863861, 183881380, 837401090, 513536652, 714177614, 946271680, 243293343, 403377310, 688653593, 15447678, 754734307, 631353768, 202296846, 159906516, 912696536, 737140518, 467380526, 896686075, 309895051, 356369955, 461415686, 706245266, 10064183, 183054210, 455971702, 737368289, 956771035, 564163693, 365118309, 226637659, 304857172, 440299843, 717116122, 485961418, 615704083, 476049473, 354119987, 329471814, 620060202, 251964959, 45357250, 175414082, 671119137, 48735782, 122378970, 717506435, 18459328, 949577729, 771970076, 635808197, 608040366, 165916428, 258536202, 902229110, 617090616, 548564593, 613394864, 753777984, 577888302, 416452176, 881599549, 524547188, 599140122, 522765386, 657552586, 256787840, 287613719, 776067801, 597965522, 458655497, 764387515, 350167935, 494713961, 513386012, 576480762, 864589772, 86987059, 495636228, 512647986, 721997962, 982831380, 162376799, 204281975, 462134806, 189646394, 425968575, 209834628, 494248765, 664281698, 947663843, 540352769, 25662122, 986679150, 207298711, 477043799, 24708053, 528335066, 189351697, 717500453, 42764755, 316734785, 823726196, 293357001, 547414377, 258966410, 602945692, 561521296, 351253952, 752369730, 174204566, 871148004, 302242737, 554611874, 540181425, 349941261, 414343943, 921115587, 959388563, 227019335, 708812719, 793380997, 342547759, 324322556, 458370547, 356254978, 809319893, 159690374, 848340820, 971304725, 180230004, 103061704, 207441144, 443272953, 45593686, 541647240, 612817107, 849140508, 109375794, 906749744, 159084460, 541378020, 692284266, 908221578, 720697998, 363923522, 819281897, 701846632, 479994712, 196613531, 29272489, 792937812, 859009553, 202148261, 385627435, 115321267, 612859231, 132778909, 173511339, 782369566, 322583903, 324703286, 31244274, 433755056, 109559692, 871157455, 350443931, 592104988, 197184362, 141678010, 649163959, 746537855, 954594407, 850681817, 703404350, 467293824, 684978431, 565588709, 378843675, 825260479, 749777538, 850502015, 387852091, 412307507, 307565279, 914127155, 864079609, 845970807, 414173935, 638273833, 664477235, 173471099, 480759791, 839694748, 190898355, 956270620, 957911348, 43002811, 628936576, 966234409, 667971950, 236586166, 954211897, 223051884, 21058295, 656573222, 631532535, 809706350, 984734695, 314281677, 311454037, 640732448, 434907794, 175084834, 434807109, 973816812, 488481268, 844735329, 917344075, 314288693, 459259162, 992521062, 667512257, 603748166, 679935673, 833938466, 933875943, 522922384, 981191471, 457854178, 112860028, 484939649, 611363777, 627371454, 844300972, 962501388, 738504183, 631041465, 29224765, 334078303, 211237785, 626057542, 900175080, 728504100, 450509755, 575177363, 905713570, 416609984, 874776027, 334255451, 683287462, 999293262, 474888472, 317020697, 180417613, 591538360, 879151833, 605566485, 569294094, 970567518, 896200922, 943088633, 145735679, 884701203, 949403596, 749113557, 78958680, 850679027, 665376978, 686499745, 426302291, 842343474, 708066168, 962548572, 349652428, 833757979, 492365420, 136639914, 76093131, 591710464, 208764552, 166233017, 498121245, 545840935, 26721664, 736011124, 880639351, 137410283, 42609708, 235572009, 981737748, 718913567, 909319027, 906112184, 298059463, 274736280, 217450848, 351267027, 149682364, 249066734, 11785215, 333890217, 774940233, 302540697, 519852435, 802535369, 620684620, 306323295, 752310997, 848793393, 883503040, 569433124, 254795373, 855478464, 660158704, 87911700, 944741410, 351053939, 2634663, 134077016, 736459220, 4882454, 969435081, 120150411, 922584286, 828772112, 106810765, 371205161, 17024731, 960279329, 389323593, 23991206, 744762405, 684217429, 479374977, 963728237, 3246420, 688035746, 381629444, 752436308, 274567573, 440219140, 702541058, 919238277, 563955926, 467150839, 5249506, 399086000, 833151662, 847391187, 655983283, 337920422, 866913758, 675206635, 549602585, 963783662, 324756002, 393087771, 731515248, 787956453, 550936813, 398161393, 631665856, 442637251, 454846959, 348994181, 88011024, 513458067, 60476466, 9760396, 403700900, 990173371, 519613195, 945797344, 114696834, 327457551, 905694736, 143025346, 289024806, 451579463, 325709522, 18701196, 326143996, 49850509, 619195074, 414881030, 850660769, 880149960, 651809429, 592293509, 810577782, 929598726, 835669318, 731671946, 529667681, 285562083, 293565850, 686472980, 274474950, 282703792, 889076915, 56602629, 546147347, 255724802, 873696194, 831784350, 110556728, 279941051, 667003092, 302778600, 803516696, 772054724, 165410893, 531446229, 958833885, 703493734, 68812272, 481542542, 722167619, 172528691, 173636402, 356397518, 390931659, 311533827, 53449710, 959934024, 259493848, 215350798, 907381983, 791418522, 896453666, 530274270, 443147787, 468552325, 410897594, 491169384, 314015783, 406644587, 772818684, 721371094, 596483817, 922913559, 78344520, 173781169, 485391881, 326797438, 209197264, 227032260, 183290649, 293208856, 909531571, 778733890, 346053132, 674154326, 75833611, 738595509, 449942130, 545136258, 334305223, 589959631, 51605154, 128106265, 85269691, 347284647, 656835568, 934798619, 602272125, 976691718, 647351010, 456965253, 143605060, 148066754, 588283108, 104912143, 240217288, 49898584, 251930392, 868617755, 690598708, 880742077, 200550782, 935358746, 104053488, 348096605, 394187502, 726999264, 278275958, 153885020, 653433530, 364854920, 922674021, 65882280, 762280792, 84294078, 29666249, 250921311, 659332228, 420236707, 614100318, 959310571, 676769211, 355052615, 567244231, 840761673, 557858783, 627343983, 461946676, 22779421, 756641425, 641419708]

        MMI = [0, 1, 500000004, 333333336, 250000002, 400000003, 166666668, 142857144, 125000001, 111111112, 700000005, 818181824, 83333334, 153846155, 71428572, 466666670, 562500004, 352941179, 55555556, 157894738, 850000006, 47619048, 409090912, 739130440, 41666667, 280000002, 576923081, 370370373, 35714286, 758620695, 233333335, 129032259, 281250002, 939393946, 676470593, 628571433, 27777778, 621621626, 78947369, 717948723, 425000003, 658536590, 23809524, 395348840, 204545456, 822222228, 369565220, 404255322, 520833337, 448979595, 140000001, 784313731, 788461544, 56603774, 685185190, 763636369, 17857143, 385964915, 879310351, 50847458, 616666671, 688524595, 564516133, 15873016, 140625001, 30769231, 469696973, 686567169, 838235300, 579710149, 814285720, 98591550, 13888889, 410958907, 310810813, 93333334, 539473688, 831168837, 858974365, 202531647, 712500005, 123456791, 329268295, 84337350, 11904762, 670588240, 197674420, 252873565, 102272728, 415730340, 411111114, 164835166, 184782610, 43010753, 202127661, 231578949, 760416672, 268041239, 724489801, 646464651, 570000004, 940594066, 892156869, 572815538, 394230772, 209523811, 28301887, 224299067, 342592595, 9174312, 881818188, 873873880, 508928575, 893805316, 692982461, 147826088, 939655179, 239316241, 25423729, 478991600, 808333339, 438016532, 844262301, 886178868, 782258070, 856000006, 7936508, 480314964, 570312504, 798449618, 515384619, 190839696, 734848490, 165413535, 843283588, 274074076, 419117650, 58394161, 789855078, 604316551, 407142860, 134751774, 49295775, 832167838, 506944448, 151724139, 705479457, 149659865, 655405410, 530201346, 46666667, 483443712, 269736844, 594771246, 915584422, 625806456, 929487186, 343949047, 601265827, 685534596, 856250006, 962732926, 561728399, 116564418, 664634151, 587878792, 42168675, 5988024, 5952381, 242603552, 335294120, 795321643, 98837210, 791907520, 626436786, 325714288, 51136364, 683615824, 207865170, 435754193, 205555557, 933701664, 82417583, 562841534, 92391305, 524324328, 521505380, 577540111, 601063834, 338624341, 615789478, 439790579, 380208336, 694300523, 634020623, 343589746, 862244904, 969543154, 823232329, 507537692, 285000002, 228855723, 470297033, 108374385, 946078438, 131707318, 286407769, 526570052, 197115386, 832535891, 604761909, 90047394, 514150947, 32863850, 612149537, 79069768, 671296301, 875576043, 4587156, 470319638, 440909094, 950226251, 436936940, 125560539, 754464291, 364444447, 446902658, 35242291, 846491234, 711790398, 73913044, 277056279, 969827593, 90128756, 619658124, 880851070, 512711868, 67510549, 239495800, 280334730, 904166673, 406639007, 219008266, 707818935, 922131154, 89795919, 443089434, 165991904, 391129035, 28112450, 428000003, 912350604, 3968254, 339920951, 240157482, 556862749, 285156252, 70038911, 399224809, 517374521, 757692313, 417624524, 95419848, 836501907, 367424245, 611320759, 582706771, 138576780, 421641794, 743494429, 137037038, 450184505, 209558825, 388278391, 529197084, 752727278, 394927539, 252707583, 802158279, 681003589, 203571430, 718861215, 67375887, 650176683, 524647891, 77192983, 416083919, 808362375, 253472224, 961937723, 575862073, 756013751, 852739732, 522184304, 574829936, 210169493, 327702705, 215488217, 265100673, 441471575, 523333337, 770764125, 241721856, 646864691, 134868422, 137704919, 297385623, 749185673, 457792211, 857605184, 312903228, 787781356, 464743593, 492012783, 671974527, 403174606, 800632917, 652996850, 342767298, 614420067, 428125003, 741433027, 481366463, 597523224, 780864203, 406153849, 58282209, 3058104, 832317079, 343465048, 293939396, 631419944, 521084341, 624624629, 2994012, 737313438, 502976194, 41543027, 121301776, 631268441, 167647060, 284457480, 897660825, 206997086, 49418605, 715942034, 395953760, 985590785, 313218393, 521489975, 162857144, 413105416, 25568182, 175637395, 341807912, 19718310, 103932585, 826330538, 717877100, 713091927, 602777782, 113573408, 466850832, 812672182, 541208795, 882191787, 281420767, 376021801, 546195656, 295392956, 262162164, 436657685, 260752690, 16085791, 788770059, 618666671, 300531917, 212201593, 669312174, 195250661, 307894739, 160104988, 719895293, 172323761, 190104168, 966233773, 847150265, 932816544, 817010315, 951156819, 171794873, 102301791, 431122452, 63613232, 484771577, 840506335, 911616168, 760705295, 253768846, 55137845, 142500001, 855361602, 614427865, 779156333, 735148520, 424691361, 554187196, 238329240, 473039219, 188264060, 65853659, 352798056, 643203888, 578692498, 263285026, 16867470, 98557693, 534772186, 916267949, 844868741, 802380958, 966745850, 45023697, 44917258, 757075477, 134117648, 16431925, 526932088, 806074772, 610722615, 39534884, 761020887, 835648154, 614318711, 937788025, 50574713, 2293578, 354691078, 235159819, 642369025, 220454547, 716553293, 975113129, 88036118, 218468470, 83146068, 562780273, 176733782, 877232149, 285077953, 682222227, 605321512, 223451329, 161147904, 517621149, 432967036, 423245617, 172866522, 355895199, 198257082, 36956522, 321041217, 638528143, 820734347, 984913800, 208602152, 45064378, 775160605, 309829062, 240938168, 440425535, 447983018, 256355934, 763213536, 533755278, 646315794, 119747900, 228511532, 140167365, 206680586, 952083340, 355509358, 703319507, 654244311, 109504133, 653608252, 853909471, 607802879, 461065577, 38854806, 544897963, 641547866, 221544717, 632860045, 82995952, 529292933, 695564521, 156941651, 14056225, 266533068, 714000005, 1996008, 456175302, 282306165, 1984127, 588118816, 669960479, 747534522, 120078741, 491159139, 778431378, 344422703, 142578126, 598440550, 535019459, 314563109, 699612408, 400386850, 758687264, 597302509, 878846160, 191938581, 208812262, 921606125, 47709924, 441904765, 918250957, 301707782, 683712126, 510396979, 805660383, 561205277, 791353389, 589118203, 69288390, 844859819, 210820897, 811918069, 871747218, 404452693, 68518519, 60998152, 725092256, 311233888, 604779416, 801834868, 694139199, 541133459, 264598542, 854280516, 376363639, 39927405, 697463773, 457504524, 626353795, 174774776, 901079143, 457809698, 840501798, 491949914, 101785715, 525846706, 859430611, 433392543, 533687947, 578761066, 825088345, 446208116, 762323949, 732864680, 538596495, 334500878, 708041963, 813263531, 904181191, 229565219, 126736112, 771230508, 980968865, 898100179, 787931040, 869191056, 878006879, 732418530, 426369866, 447863251, 261092152, 724020448, 287414968, 585738544, 605084750, 656514387, 663851356, 160202362, 607744112, 95798320, 632550340, 835845902, 720735791, 410684477, 761666672, 296173047, 885382066, 76285241, 120860928, 887603312, 823432349, 729818786, 67434211, 36124795, 568852463, 492635028, 648692815, 696574230, 874592840, 377235775, 728896109, 716369535, 428802592, 953150249, 156451614, 842190022, 393890678, 630818624, 732371800, 571200004, 746006395, 944178635, 835987267, 36565978, 201587303, 438985740, 900316462, 30015798, 326498425, 696062997, 171383649, 880690744, 807210037, 677621288, 714062505, 720748835, 870716517, 43545879, 740683235, 359689925, 298761612, 119010820, 890432105, 640986137, 703076928, 291858681, 529141108, 29096478, 1529052, 438167942, 916158543, 823439884, 171732524, 698027319, 146969698, 216338882, 315709972, 983408755, 760542174, 33082707, 812312318, 163418292, 1497006, 41853513, 368656719, 62593145, 251488097, 493313525, 520771517, 454814818, 60650888, 320531760, 815634224, 609720181, 83823530, 345080766, 142228740, 530014645, 948830416, 411678835, 103498543, 237263466, 524709306, 927431066, 357971017, 444283650, 197976880, 92352093, 992795396, 520863313, 656609200, 862266864, 760744991, 696709590, 81428572, 489301002, 206552708, 85348507, 12784091, 626950359, 587818701, 991513444, 170903956, 385049368, 9859155, 355836852, 551966296, 701262277, 413165269, 366433569, 358938550, 93444910, 856545967, 318497916, 301388891, 224687935, 56786704, 802213007, 233425416, 630344832, 406336091, 696011009, 770604401, 235939645, 941095897, 729138172, 640710387, 66848568, 688010904, 29931973, 273097828, 698778838, 147696478, 538565633, 131081082, 721997306, 718328846, 590847918, 130376345, 506040272, 508042899, 676037488, 894385033, 889185587, 809333339, 215712385, 650265962, 304116868, 606100800, 896688748, 334656087, 952443864, 597625334, 779973655, 653947373, 582128782, 80052494, 1310616, 859947650, 518954252, 586161884, 850065195, 95052084, 855656703, 983116890, 690012975, 923575136, 648124196, 466408272, 525161294, 908505161, 839124845, 975578413, 613607193, 585897440, 645326509, 551150899, 805874846, 215561226, 868789815, 31806616, 419313853, 742385792, 278833969, 920253171, 841972193, 455808084, 822194205, 880352651, 537106922, 126884423, 877038902, 527568926, 964956202, 571250004, 46192260, 427680801, 764632633, 807213936, 592546588, 889578170, 581164812, 367574260, 102595798, 712345684, 755856972, 277093598, 816728173, 119164620, 223312885, 736519613, 73439413, 94132030, 462759466, 532926833, 618757617, 176399028, 52247874, 321601944, 917575764, 289346249, 617896014, 131642513, 712907122, 8433735, 84235861, 549278850, 496998803, 267386093, 601197609, 958133978, 560334532, 922434374, 696066751, 401190479, 853745547, 483372925, 239620405, 522511852, 848520716, 22458629, 348288078, 878537742, 216725561, 67058824, 722679206, 508215966, 690504108, 263466044, 359064330, 403037386, 792298722, 805361311, 67520373, 19767442, 269454125, 880510447, 718424107, 417824077, 158381504, 807159359, 987312579, 968894016, 200230151, 525287360, 360505169, 1146789, 918671255, 177345539, 265142859, 617579913, 891676175, 821184516, 840728106, 610227277, 759364364, 858276650, 612684036, 987556568, 736723169, 44018059, 559188279, 109234235, 497187855, 41573034, 738496077, 781390140, 705487127, 88366891, 287150840, 938616078, 813823863, 642538980, 314794218, 841111117, 591564932, 302660756, 256921375, 611725668, 786740337, 80573952, 324145537, 758810578, 882288235, 216483518, 963776077, 711622812, 371303398, 86433261, 712568311, 677947603, 741548533, 99128541, 41349293, 18478261, 916395229, 660520612, 776814740, 819264075, 304864867, 910367177, 952535066, 492456900, 252960174, 104301076, 23630505, 22532189, 595927121, 887580306, 515508025, 154914531, 16008538, 120469084, 164004261, 720212771, 568544106, 223991509, 115588548, 128177967, 467724871, 381606768, 551214365, 266877639, 262381456, 323157897, 884332288, 59873950, 383001052, 114255766, 687958120, 570083686, 204806689, 103340293, 8342023, 476041670, 746097820, 177754679, 580477678, 851659757, 338860106, 827122159, 260599795, 554752070, 199174408, 326804126, 669412981, 926954739, 943473799, 803901443, 468717952, 730532792, 584442174, 19427403, 492339125, 772448985, 1019368, 320773933, 399796544, 610772362, 793908635, 816430026, 447821685, 41497976, 17189080, 764646470, 172552978, 847782264, 877139986, 578470829, 901507544, 507028116, 911735212, 133266534, 874874881, 857000006]
        n = len(nums)
        lis = [0] * n
        def count(subnums):
            nonlocal lis
            if subnums:
                low = [num for num in subnums if num < subnums[0]]
                high = [num for num in subnums if num > subnums[0]]
                lis[subnums[0]-1] = len(subnums)
                count(low)
                count(high)
        
        count(nums)




        M = 10 ** 9 + 7
        denum = 1
        for k in range(1,n+1):
            denum = (denum * MMI[lis[k-1]]) % M
        return (FACT[n] * denum) % M - 1",Hard,27,22334,0.0,2,2.0,6.0,827.1851851851852,2021.0,-266.7866666666667
1060.0,matrix diagonal sum,"class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        
        n = len(mat)
        
        diagonal_sum = 0
        
        for i in range(n):
            diagonal_sum += mat[i][i]
            
			# Before adding the element for the second diagonal, 
			# make sure we are not in the middle element
            if n - i != i + 1: 
                diagonal_sum += mat[i][-i - 1]
        
        return diagonal_sum",Easy,15,443,2.0,2,2.0,4.0,29.53333333333333,13.0,5.882
1061.0,number of ways to split a string,"class Solution:
    def numWays(self, s: str) -> int:
        n = len(s)
        mod = 10**9+7
        numOnes = [0]*n
        numOnes[0] = 1 if s[0] == '1' else 0
        
        for i, ch in enumerate(s[1:]):
            numOnes[i+1] += numOnes[i]
            if ch == '1':
                numOnes[i+1] += 1
            i += 1

        if numOnes[-1]%3 != 0:
            return 0
        elif numOnes[-1] == 0:
            return ((n - 1)*(n-2)%mod)//2
        else:
			# get the required number of ones in each partition
            val = numOnes[-1]//3
        
        multiples = [val*1, val*2] # values to be counted in 'numOnes' array
        
        res = 1
        for multiple in multiples:
            res = res*numOnes.count(multiple)%mod
        
        return res",Medium,27,781,2.0,3,3.0,6.0,28.925925925925927,35.0,3.616666666666667
1062.0,shortest subarray to be removed to make array sorted,"class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        lo = next((i for i in range(len(arr)-1) if arr[i] > arr[i+1]), None)
        hi = next((i for i in reversed(range(1, len(arr))) if arr[i-1] > arr[i]), None)
        if lo is None: return 0 
        
        ll = bisect_right(arr, arr[hi], 0, lo+1)
        rr = bisect_left(arr, arr[lo], hi, len(arr))
        
        return min(hi - ll, rr - lo - 1)",Medium,9,441,0.0,0,2.0,5.0,49.0,22.0,3.27
1063.0,count all possible routes,"class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        # start = initial index
        # end = destination index     

        MOD = (10**9)+7 
        lenLocations = len(locations)

        @cache
        def dfs(index, fuel):
            # If you have no more fuel and you're at destination:
            # You cannot try another other routes, return 1 because you're at destination
            if fuel == 0 and index == finish:
                return 1

            # If no more fuel and not at route:
            # You cannot try another other routes, return 1 because you're not at destination
            if fuel <= 0:
                return 0
            
            # If your current index is destination index, you found an existing route
            countWays = 1 if index == finish else 0

            # Try every location index (dfs), but you cannot stay at your current index
            for nextIndex in range(len(locations)):
                if index != nextIndex:
                    cost = abs(locations[index]-locations[nextIndex])
                    countWays += dfs(nextIndex,fuel-cost)

            return countWays

        return dfs(start,fuel) % MOD",Hard,31,1236,8.0,1,3.0,8.0,39.87096774193548,44.0,2.0916129032258075
1064.0,replace all s to avoid consecutive repeating characters,"class Solution:
    def modifyString(self, s: str) -> str:
        if len(s) == 1 and s[0] != '?':
            return s[0]
        elif len(s) == 1 and s[0] == '?':
            return 'a'
        else:
            x = {'a','b','c'}
            res = ''
            for i in range(len(s)):
                if s[i] == '?':
                    if i == 0:
                        res += list(x.difference(set(s[i+1])))[0]
                    elif i == len(s)-1:
                        res += list(x.difference(set([s[i-1],res[i-1]])))[0]
                    else:
                        res += list(x.difference(set([s[i-1],s[i+1],res[i-1]])))[0]
                else:
                    res += s[i]
            return res",Easy,19,721,0.0,4,4.0,10.0,37.94736842105263,44.0,1.7047368421052624
1065.0,number of ways where square of number is equal to product of two numbers,"class Solution:
    # two-sum. search for nums1[i]^2/nums2[k]
    # O(mn) time : O(m + n) space
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        def count(arr1, arr2):
            res = 0
            for n1 in arr1:
                n2_freq = defaultdict(int)
                for n2 in arr2:
                    if n1*n1 / n2 in n2_freq:
                        res += n2_freq[n1*n1 / n2]
                    n2_freq[n2] += 1
            return res
        return count(nums1, nums2) + count(nums2, nums1)",Medium,13,533,2.0,2,4.0,4.0,41.0,19.0,4.13
1066.0,minimum time to make rope colorful,"class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        
        consecutives = dict()
        
        i = 1
        prev = colors[0]
        count = 0
        while i < len(colors):
            if colors[i] == prev:
                if count not in consecutives:
                    consecutives[count] = [neededTime[i-1]]
                consecutives[count].append(neededTime[i])
            else:
                prev = colors[i]
                count +=1
            i+=1

        sum_ = 0
        for list_ in consecutives.values():
            if len(list_) == 1:
                sum_ += list_[0]
            else:
                max_ = 0
                for i in list_:
                    sum_+=i
                    max_ = max(max_, i)
                sum_ -= max_
        return sum_",Medium,28,828,0.0,6,3.0,6.0,29.571428571428573,37.0,3.098571428571428
1067.0,special positions in a binary matrix,"class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        ans, m, n = 0, len(mat), len(mat[0])
        row, col = [0] * m, [0] * n
        for i in range(m):
            for j in range(n):
                row[i] += mat[i][j]
                col[j] += mat[i][j]
        for i in range(m):
            for j in range(n):
                if mat[i][j] and row[i] == 1 and col[j] == 1: ans += 1; break
        return ans",Easy,11,436,0.0,4,3.0,5.0,39.63636363636363,27.0,3.3127272727272725
1068.0,count unhappy friends,"class Solution:
    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:
        prefDict = {i:preferences[i] for i in range(n)}
        res = set()
        for i, (x1,y1) in enumerate(pairs):
            for j, (x2,y2) in enumerate(pairs):
                if i != j:
                    if prefDict[x1].index(y2) < prefDict[x1].index(y1): # smaller index means higher preference
                        if prefDict[y2].index(x1) < prefDict[y2].index(x2):
                            res.add(x1)
                    if prefDict[x1].index(x2) < prefDict[x1].index(y1):
                        if prefDict[x2].index(x1) < prefDict[x2].index(y2):
                            res.add(x1)
                    if prefDict[y1].index(x2) < prefDict[y1].index(x1):
                        if prefDict[x2].index(y1) < prefDict[x2].index(y2):
                            res.add(y1)
                    if prefDict[y1].index(y2) < prefDict[y1].index(x1):
                        if prefDict[y2].index(y1) < prefDict[y2].index(x2):
                            res.add(y1)
        return len(res)",Medium,19,1125,1.0,11,5.0,12.0,59.21052631578947,36.0,0.1510526315789455
1069.0,min cost to connect all points,"class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        graph = {}
        self.create_graph(points, graph)
        print(graph)
        visited = {0}
        min_heap = MinHeap(graph[0])

        result = 0

        while len(visited) < len(points):
            cost, vertex = min_heap.remove()
            if vertex not in visited:
                visited.add(vertex)
                result += cost
                
                if vertex not in graph:
                    continue
                
                for i in graph[vertex]:
                    cost, node = i
                    if node not in visited:
                        min_heap.insert((cost, node))

        return result
        
    def create_graph(self, points, graph):
        for point in range(len(points)):
            graph[point] = []
        
        for i in range(len(points) - 1):
            # can be with -1 or without
            for j in range(i + 1, len(points)):
                curr_point = points[i]
                next_point = points[j]
                result = self.difference(curr_point[0], curr_point[1],
                                        next_point[0], next_point[1])
                    
                graph[i].append((result, j))
                graph[j].append((result, i))
    
    
    def difference(self, a, b, c, d):
        return abs(a - c) + abs(b - d)
     

class MinHeap:
    def __init__(self, arr):
        self.heap = self.buildHeap(arr)
    
    def check(self):
        return len(self.heap) == 0
    
    def buildHeap(self, arr):
        parentIdx = (len(arr) - 2) // 2
        for i in reversed(range(parentIdx + 1)):
            self.siftDown(i, len(arr) - 1, arr)
        return arr
    
    def peek(self):
        return self.heap[0]
    
    def remove(self):
        to_remove = self.heap[0]
        node = self.heap.pop()
        if len(self.heap) > 0:
            self.heap[0] = node
            self.siftDown(0, len(self.heap) - 1, self.heap)
        return to_remove
    
    def insert(self, value):
        self.heap.append(value)
        self.siftUp()
    
    def siftDown(self, idx, length, arr):
        idxOne = idx * 2 + 1
        while idxOne <= length:
            idxTwo = idx * 2 + 2 if idx * 2 + 2 <= length else -1
            if idxTwo != -1 and arr[idxOne][0] > arr[idxTwo][0]:
                swap = idxTwo
            else:
                swap = idxOne
            
            if arr[swap][0] < arr[idx][0]:
                self.swapValues(swap, idx, arr)
                idx = swap
                idxOne = idx * 2 + 1
            else:
                return
    
    def swapValues(self, i, j, arr):
        arr[i], arr[j] = arr[j], arr[i]
    
    def siftUp(self):
        idx = len(self.heap) - 1
        while idx > 0:
            parentIdx = (idx - 1) // 2
            if self.heap[idx][0] < self.heap[parentIdx][0]:
                self.swapValues(idx, parentIdx, self.heap)
                idx = parentIdx
            else:
                return",Medium,101,3058,1.0,7,3.0,23.0,30.27722772277228,110.0,-4.284950495049506
1070.0,check if string is transformable with substring sort operations,"class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if sorted(s) != sorted(t): return False # edge case 
        
        pos = [deque() for _ in range(10)]
        for i, ss in enumerate(s): pos[int(ss)].append(i)
            
        for tt in t: 
            i = pos[int(tt)].popleft()
            for ii in range(int(tt)): 
                if pos[ii] and pos[ii][0] < i: return False # cannot swap 
        return True",Hard,11,449,2.0,3,3.0,7.0,40.81818181818182,17.0,4.346363636363637
1072.0,maximum sum obtained of any permutation,"class Solution:
    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:
        chg = [0]*len(nums) # change 
        for i, j in requests: 
            chg[i] += 1
            if j+1 < len(nums): chg[j+1] -= 1
        for i in range(1, len(nums)): chg[i] += chg[i-1] # cumulated change
        return sum(n*c for n, c in zip(sorted(nums), sorted(chg))) % 1_000_000_007",Medium,7,396,2.0,3,3.0,4.0,56.57142857142857,19.0,2.728571428571429
1073.0,make sum divisible by p,"class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        target = sum(nums) % p # targetted remainder 
        ans = inf
        seen = {(prefix := 0): -1}
        for i, x in enumerate(nums): 
            seen[(prefix := (prefix+x)%p)] = i # update seen before check 
            if (prefix-target) % p in seen: 
                ans = min(ans, i - seen[(prefix-target) % p])
        return ans if ans < len(nums) else -1 # not allowed to remove whole array",Medium,9,483,3.0,2,3.0,4.0,53.66666666666666,22.0,2.790000000000001
1074.0,strange printer ii,"class Solution(object):
    def isPrintable(self, targetGrid):
        """"""
        :type targetGrid: List[List[int]]
        :rtype: bool
        """"""
#doing reverse engineering like toposort concept find that reactangle which is completely independent,and remove and process futher
        m,n=len(targetGrid),len(targetGrid[0])
        # strore upper,left,right,bottom most for every color
        colors={}
        for i in range(m):
            for j in range(n):
                c=targetGrid[i][j]
                if c not in colors:
                    colors[c]=[sys.maxsize,sys.maxsize,-1*sys.maxsize,-1*sys.maxsize]
                colors[c][0]=min(colors[c][0],i)
                colors[c][1]=min(colors[c][1],j)
                colors[c][2]=max(colors[c][2],j)
                colors[c][3]=max(colors[c][3],i)
        # print(colors)
        # this is for check is it possible to fill with this color or not
        def isPossibleTofill(color):
            upper,left,right,bottom=colors[color]
            for i in range(upper,bottom+1):
                for j in range(left,right+1):
                    if targetGrid[i][j]>0 and targetGrid[i][j]!=color:return False
            for i in range(upper,bottom+1):
                for j in range(left,right+1):
                    targetGrid[i][j]=0
            return True
                                 
        c1=colors.keys()
        while c1:
            c2=set()
            for col in c1:
                if isPossibleTofill(col)==False:
                    c2.add(col)
            if len(c2)==len(c1):return False
            c1=c2
        if len(c1)==0:return True
        return False",Hard,40,1654,4.0,9,4.0,15.0,41.35,65.0,-0.8414999999999999
1075.0,rearrange spaces between words,"class Solution:
    def reorderSpaces(self, text: str) -> str:
        space = text.count(' ')                            # count how many space in total
        text = [word for word in text.split(' ') if word]  # split text to individual word in a list
        n = len(text)                                      # count total words
        if n == 1: return text[0] + space * ' '            # length == 1 is a special case, since no space in between only at the end
        avg, reminder = divmod(space, n-1)                 # get average space between words and spaces left (will be appended the end)
        return (' '*avg).join(text) + ' ' * reminder       # compose result",Easy,7,679,6.0,0,6.0,3.0,97.0,19.0,-0.75
1076.0,split a string into the max number of unique substrings,"class Solution:
    def maxUniqueSplit(self, s: str) -> int:
        strings = set()
        self.max_len = 0
        def split(s) :
            if not s :
                self.max_len = max(self.max_len, len(strings)) 
                return 
            
            for i in range(1,len(s)+1) :
                cs = s[:i] 
                if cs not in strings :
                    strings.add(cs)
                    split(s[i:])
                    strings.remove(cs)
                    
                        
        split(s)
        
        return self.max_len",Medium,19,572,0.0,2,4.0,3.0,30.105263157894736,17.0,5.230526315789473
1077.0,maximum non negative product in a matrix,"class Solution:
def maxProductPath(self, grid: List[List[int]]) -> int:
    
    MOD = 10**9+7
    m,n = len(grid),len(grid[0])
    dp = [[[0,0] for _ in range(n)] for _ in range(m)]
    dp[0][0][0]=grid[0][0]
    dp[0][0][1]=grid[0][0]
    for i in range(1,m):                     #First Column
        dp[i][0][0] = dp[i-1][0][0]*grid[i][0]
        dp[i][0][1] = dp[i-1][0][1]*grid[i][0]
    
    for j in range(1,n):                     #First Row
        dp[0][j][0] = dp[0][j-1][0]*grid[0][j]
        dp[0][j][1] = dp[0][j-1][1]*grid[0][j]
    
    for i in range(1,m):
        for j in range(1,n):
            if grid[i][j]<0:
                dp[i][j][0] = min(dp[i][j-1][1],dp[i-1][j][1])*grid[i][j]
                dp[i][j][1] = max(dp[i][j-1][0],dp[i-1][j][0])*grid[i][j]
            else:
                dp[i][j][0] = max(dp[i][j-1][0],dp[i-1][j][0])*grid[i][j]
                dp[i][j][1] = min(dp[i][j-1][1],dp[i-1][j][1])*grid[i][j]
    
    if dp[-1][-1][0]<0 and dp[-1][-1][1]<0:
        return -1
    
    return max(dp[-1][-1][0],dp[-1][-1][1])%MOD",Medium,28,1066,2.0,5,3.0,8.0,38.07142857142857,40.0,2.173571428571429
1078.0,minimum cost to connect two groups of points,"class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        mn = [min(x) for x in cost] # min cost of connecting points in 1st group 
        
        @lru_cache(None)
        def fn(j, mask):
            """"""Return min cost of connecting group1[i:] and group2 represented as mask.""""""
            if j == n: return sum(mn[i] for i in range(m) if not (mask &amp; (1<<i)))
            return min(cost[i][j] + fn(j+1, mask | 1<<i) for i in range(m))
                
        return fn(0, 0)",Hard,11,551,1.0,-2,3.0,5.0,50.09090909090909,22.0,3.2718181818181824
1079.0,crawler log folder,"class Solution:
    def minOperations(self, logs: List[str]) -> int:
        res=[]
        for word in logs:
            if word==""../"" and len(res)>0:
                res.pop()
            elif word==""./"":
                continue
            elif word!=""../"" and word!=""./"":
                res.append(word)
        return len(res)",Easy,10,334,0.0,3,3.0,4.0,33.4,19.0,4.734000000000001
1080.0,maximum profit of operating a centennial wheel,"class Solution:
    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
        i=0
        count=0
        profit=0
        rem=0
        onBoard=0
        max_profit_rounds=-1
        max_profit=0
        while True:
            if i>=len(customers)-1 and rem==0:              
                break
            if i<len(customers):
                rem+=customers[i]
                i+=1
            count+=1
            if rem>4:
                onBoard+=4
                rem-=4
            else:
                onBoard+=rem
                rem=0
            profit=(onBoard*boardingCost)-(count*runningCost)
            if profit>max_profit:
                max_profit=profit
                max_profit_rounds=count

            
        if max_profit<0:
            return -1
        
        return max_profit_rounds",Medium,31,872,0.0,4,3.0,6.0,28.12903225806452,42.0,2.848387096774193
1081.0,maximum number of achievable transfer requests,"class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        
        def fn(k, mask): 
            """"""Return maximum number of achievable transfer requests.""""""
            if k == len(requests): 
                net = [0]*n
                for i, (u, v) in enumerate(requests): 
                    if mask &amp; 1 << i: 
                        net[u] -= 1
                        net[v] += 1
                return 0 if any(net) else bin(mask).count(""1"")
            return max(fn(k+1, mask), fn(k+1, mask | 1 << k))
        
        return fn(0, 0)",Hard,14,588,0.0,0,4.0,4.0,42.0,28.0,3.18
1082.0,alert using same key card three or more times in a one hour period,"class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        ans = set()
        seen = {}
        for key, time in sorted(zip(keyName, keyTime)): 
            if key not in ans: 
                h, m = time.split("":"")
                time = int(h) * 60 + int(m)
                seen.setdefault(key, deque()).append(time)
                if len(seen[key]) == 3: 
                    if seen[key][-1] <= seen[key][0] + 60: ans.add(key)
                    seen[key].popleft()
        return sorted(ans)",Medium,12,543,0.0,4,4.0,4.0,45.25,25.0,2.9475
1083.0,find valid matrix given row and column sums,"class Solution:
    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        # 0) Initialization
        ROW_SIZE = len(rowSum)
        COL_SIZE = len(colSum)
        mtx = [[0] * COL_SIZE for ri in range(ROW_SIZE)]
        for i, rs in enumerate(rowSum):
            mtx[i][0] = rs
            
		# 1) Iteratively meet column sum by making reduction from first column
        valid_row_set = set(list(filter(lambda ri: mtx[ri][0], range(ROW_SIZE))))
        for ci in range(1, COL_SIZE):
            cs = colSum[ci]
            empty_ri_list = []
            for ri in valid_row_set:
                if mtx[ri][0] < cs:
                    cs -= mtx[ri][0]
                    mtx[ri][ci] = mtx[ri][0]
                    mtx[ri][0] = 0                     
                    empty_ri_list.append(ri)
                elif mtx[ri][0] == cs:
                    mtx[ri][ci] = mtx[ri][0]
                    mtx[ri][0] = cs = 0
                    empty_ri_list.append(ri)
                    break
                elif mtx[ri][0] > cs:
                    mtx[ri][ci] = cs
                    mtx[ri][0] -= cs
                    break
                    
            for eri in empty_ri_list:
                valid_row_set.remove(eri)
                                
        return mtx",Medium,33,1322,2.0,5,4.0,8.0,40.06060606060606,38.0,2.134545454545454
1084.0,find servers that handled most number of requests,"class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        busy = [] # min-heap
        free = list(range(k)) # min-heap 
        freq = [0]*k
        
        for i, (ta, tl) in enumerate(zip(arrival, load)): 
            while busy and busy[0][0] <= ta: 
                _, ii = heappop(busy)
                heappush(free, i + (ii - i) % k) # circularly relocate it
            if free: 
                ii = heappop(free) % k 
                freq[ii] += 1
                heappush(busy, (ta+tl, ii))
        
        mx = max(freq)
        return [i for i, x in enumerate(freq) if x == mx]",Hard,16,647,3.0,3,3.0,5.0,40.4375,32.0,2.920625
1085.0,special array with x elements greater than or equal x,"class Solution:
    def specialArray(self, nums: List[int]) -> int:
        nums.sort() 
        fn = lambda x: x - (len(nums) - bisect_left(nums, x))
        lo, hi = 0, nums[-1]
        while lo <= hi: 
            mid = lo + hi >> 1
            if fn(mid) < 0: lo = mid + 1
            elif fn(mid) == 0: return mid
            else: hi = mid - 1
        return -1",Easy,10,367,0.0,2,3.0,3.0,36.7,26.0,3.797
1086.0,even odd tree,"class Solution:
    def isEvenOddTree(self, root: TreeNode) -> bool:
        
        if not root: return True
        
        queue=[root]
        lvl=0
        while queue:
            order=[]
            for _ in range(len(queue)):
                node=queue.pop(0)
                
                if lvl%2==0:
                    if node.val&amp;1:
                        if not order: order.append(node.val)
                        else:
                            if order[-1]<node.val: order.append(node.val)
                            else: return False
                        if node.left:queue.append(node.left)
                        if node.right: queue.append(node.right)
                    else: return False
                else:
                    if node.val%2==0:
                        if not order: order.append(node.val)
                        else:
                            if order[-1]>node.val: order.append(node.val)
                            else: return False
                        if node.left:queue.append(node.left)
                        if node.right: queue.append(node.right)
                    else: return False
            lvl+=1
        return True",Medium,31,1206,0.0,9,5.0,14.0,38.903225806451616,39.0,1.758709677419354
1087.0,maximum number of visible points,"class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:
        
        array = []
        nloc = 0
        for p in points:
            if p == l:
                nloc += 1
            else:
                array.append(math.degrees(atan2(p[1]-l[1], p[0]-l[0])))
        array.sort()
        angles = array + [a+360 for a in array]
        left, maxm = 0, 0
        for right, a in enumerate(angles):
            if a-angles[left] > angle:
                left += 1
            maxm = max(right-left+1, maxm)
        
        return maxm + nloc",Hard,18,593,0.0,4,3.0,5.0,32.94444444444444,30.0,3.615
1088.0,minimum one bit operations to make integers zero,"class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        if not n: return 0 # edge case 
        if not (n &amp; (n-1)): return 2*n-1
        b = 1 << n.bit_length()-1 
        return self.minimumOneBitOperations((b>>1)^b^n) + b",Hard,5,249,1.0,0,2.0,2.0,49.8,12.0,4.238
1089.0,maximum nesting depth of the parentheses,"class Solution:
    def maxDepth(self, s: str) -> int:
        maxDepth:int = 0
        bracketNum:int = 0

        for c in s:
            if c == '(': 
                bracketNum += 1
                if bracketNum > maxDepth: maxDepth = bracketNum
            elif c == ')':
                bracketNum -= 1
        return maxDepth",Easy,11,332,0.0,4,3.0,4.0,30.181818181818183,23.0,4.563636363636364
1090.0,maximal network rank,"class Solution:
    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:
        
        g = defaultdict(list)
        
        for u, v in roads:  # create graph adjacency list
            g[u].append(v)
            g[v].append(u)
        
        res = 0
        
        for i in range(n):
            for j in range(i+1, n):
                val = len(g[i]) + len(g[j]) # sum the amount of roads for each city
                if j in g[i]:   # remove road connected to both cities
                    val -= 1
                res = max(res, val)
        
        
        return res",Medium,19,602,3.0,4,3.0,5.0,31.68421052631579,19.0,4.948421052631579
1091.0,split two strings to make palindrome,"class Solution(object):
    def checkPalindromeFormation(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: bool
        """"""
        if len(a) == 1 or len(b) == 1:
            return True  
        b = b[::-1] # reverse string b
        return (a[0] == b[0] and a[1] == b[1]) or (a[-1] == b[-1] and a[-2] == b[-2]) # search for same substrings : 1) start from head(a_prefix + b_suffix) 
																												# 2) start from tail(b_prefix + a_suffix).",Medium,11,489,3.0,1,2.0,3.0,44.45454545454545,33.0,2.6390909090909096
1092.0,count subtrees with max distance between cities,"class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        def maxDistance(subtree):
            edges,node,maxD=[0]*3
            for i in range(n):
                if (subtree>>i)&amp;1==0:continue
                node+=1
                for j in range(i+1,n):
                    if (subtree>>j)&amp;1==0:continue
                    edges+=dist[i][j]==1
                    maxD=max(maxD,dist[i][j])
            if edges!=node-1:
                return 0
            else:
                return maxD
        dist=[[float('inf')]*n for i in range(n)]
        for i,j in edges:
            dist[i-1][j-1]=dist[j-1][i-1]=1
        for mid in range(n):
            for n1 in range(n):
                for n2 in range(n):
                    dist[n1][n2]=min(dist[n1][n2],dist[n1][mid]+dist[mid][n2])
        ans=[0]*(n-1)
        for i in range(1,2**n):
            d=maxDistance(i)
            if d>0:
                ans[d-1]+=1
        return ans",Hard,27,1005,0.0,7,4.0,13.0,37.22222222222222,53.0,0.6899999999999995
1093.0,mean of array after removing some elements,"class Solution:
    def trimMean(self, arr: List[int]) -> float:
		# Calculate how many elements make the top/bottom 5%. 
		# Since the length of the array will always be a multiple 
		# of 20, we don't need to do any special checks, just divide
        numToRemove = len(arr) // 20
		
		# Remove the top and bottom 5% of the elements by finding 
		# the min/max of the list
        for i in range(numToRemove):
            arr.remove(max(arr))
            arr.remove(min(arr))
        
		# Return the average of the new list
		return sum(arr) / len(arr)",Easy,14,554,6.0,0,1.0,1.0,39.57142857142857,9.0,5.71857142857143
1094.0,coordinate with maximum network quality,"class Solution:
    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:
        return max(
            (
                (sum(qi // (1 + dist) for xi, yi, qi in towers if (dist := sqrt((xi - x) ** 2 + (yi - y) ** 2)) <= radius),
                 [x, y]) for x in range(51) for y in range(51)
            ),
            key=lambda x: (x[0], -x[1][0], -x[1][1])
        )[1]",Medium,8,398,0.0,1,3.0,4.0,49.75,20.0,3.2825000000000006
1095.0,number of sets of k non overlapping line segments,"class Solution:
    def numberOfSets(self, n: int, k: int) -> int:
        
        @cache
        def fn(n, k):
            """"""Return number of sets.""""""
            if n <= k: return 0 
            if k == 0: return 1
            return 2*fn(n-1, k) + fn(n-1, k-1) - fn(n-2, k)
        
        return fn(n, k) % 1_000_000_007",Medium,10,327,0.0,-2,3.0,2.0,32.7,20.0,4.997000000000001
1096.0,largest substring between two equal characters,"class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        if(len(s)==len(set(s))):
            return -1
			
        maxdiff=0
        dicts=collections.defaultdict(list)
		
        for index,char in enumerate(s):
            dicts[char]+=[index]
           
        for k,v in dicts.items():
            diff=v[-1]-v[0]-1
            if diff>maxdiff:
                maxdiff=diff
				
        return maxdiff",Easy,16,436,0.0,2,2.0,11.0,27.25,20.0,5.307499999999999
1097.0,lexicographically smallest string after applying operations,"class Solution:
    def __init__(self):
        self.mn = 'z' * 100
        self.vis = set()
    
    def solve(self, st):
        if ''.join(st) in self.vis:
            return
        self.vis.add(''.join(st))
        new = st
        for i in range(1, len(st), 2):
            st[i] = str((int(st[i]) + self.a) % 10)
        self.mn = min(''.join(st), self.mn)
        
        lp = new[-self.b:]
        fp = new[:self.l - self.b]
        new = lp + fp
        self.mn = min(self.mn, ''.join(new))
        
        self.solve(st)
        self.solve(new)
    
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        self.a = a ; self.b = b
        self.l = len(s)
        self.b = self.b % self.l
        s = list(s)
        self.solve(s)
        return self.mn",Medium,28,784,0.0,1,2.0,2.0,28.0,34.0,3.9
1098.0,best team with no conflicts,"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        ages, scores = zip(*sorted(zip(ages, scores)))
        
        @lru_cache(None)
        def fn(i): 
            """"""Return max score up to ith player included.""""""
            if i < 0: return 0 # boundary condition 
            return scores[i] + max((fn(ii) for ii in range(i) if ages[ii] == ages[i] or scores[ii] <= scores[i]), default=0)
        
        return max(fn(i) for i in range(len(scores)))",Medium,10,499,1.0,-2,3.0,4.0,49.9,20.0,3.4890000000000008
1099.0,slowest key,"class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        max_d = -1
        letter = None
        
        
        duration = [releaseTimes[0]]
        
        for i in range(1,len(releaseTimes)):
            duration.append(releaseTimes[i]- releaseTimes[i-1])
        
        for index, i in enumerate(duration):
            if(i > max_d):
                max_d = i
                letter = keysPressed[index]
            elif(i == max_d and ord(keysPressed[index])>ord(letter)):
                letter = keysPressed[index]
        return letter",Easy,17,592,0.0,2,3.0,4.0,34.8235294117647,24.0,4.165882352941177
1100.0,arithmetic subarrays,"class Solution:
    
    def checker(self,nums):
        i = 2
        n = len(nums)
        diff = nums[1] - nums[0]
        while i < n:
            if nums[i] - nums[i-1] != diff:
                return False
            i += 1
        return True
    
    def checkArithmeticSubarrays(self, nums: List[int], left: List[int], right: List[int]) -> List[bool]:
        m, i, ans = len(left), 0, []
        while i < m:
            l, r = left[i], right[i]
            sub = nums[l:r+1]
            sub.sort()
            ans.append(self.checker(sub))
            i += 1
        return ans",Medium,20,589,0.0,1,3.0,5.0,29.45,32.0,3.9095
1101.0,path with minimum effort,"class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        
        M, N = map(len, (heights, heights[0]))
        heap = [(0, 0, 0)]
        seen = set()
        result = 0
        
        while heap:
            
            # Pop
            effort, i, j = heapq.heappop(heap)
            
            # Mark seen
            seen.add((i, j))
            
            # Update minimum ""effort""
            result = max(result, effort)
            
            # Success condition
            if i == M-1 and j == N-1:
                break
                                    
            # BFS
            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if not (x >= 0 <= y): continue
                if x >= M or y >= N: continue
                if (x, y) in seen: continue
                effort = abs(heights[i][j] - heights[x][y])
                heapq.heappush(heap, (effort, x, y))
                                
        return result",Medium,31,1000,5.0,2,4.0,12.0,32.25806451612903,53.0,1.636774193548387
1102.0,rank transform of a matrix,"class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0])
        
        def find_root(x: int, y: int):
            if parent[x][y] == (x, y):
                return (x, y)
            else:
                r = find_root(parent[x][y][0], parent[x][y][1])
                parent[x][y] = r
                return r
        
        def union(x1, y1, x2, y2):
            root_a = find_root(x1, y1)
            root_b = find_root(x2, y2)
            parent[root_b[0]][root_b[1]] = root_a
            
        ########################################################
        
		# *parent* records the parent of each point in matrix form
		# points with same value in the same row/column should have the same parent
        parent = [[(j, i) for i in range(n)] for j in range(m)]
        
		# sort each row, if there are points with same value, union them
        for i in range(m):
            value = []
            for j in range(n):
                v = tuple([matrix[i][j], i, j])
                value.append(v)
            value.sort()
            for k in range(n - 1):
                if value[k][0] == value[k + 1][0]:
                    union(value[k][1], value[k][2], value[k + 1][1], value[k + 1][2])
					
        # sort each column, if there are points with same value, union them            
        for i in range(n):
            value = []
            for j in range(m):
                v = tuple([matrix[j][i], j, i])
                value.append(v)
            value.sort()
            for k in range(m - 1):
                if value[k][0] == value[k + 1][0]:
                    union(value[k][1], value[k][2], value[k + 1][1], value[k + 1][2])
        
        ########################################################
        
        dic = {} # point index : point that it directs ->
        in_degree = {} # point index : number of incoming arrows <-
		
		# Ex. [20, -21, 14]
		# sort: -21 (0, 1) -> 14 (0, 2) -> 20 (0, 0)
		# dic = { (0, 0) : [], (0, 1) : [(0, 2)], (0, 2) : [(0, 0)] }
		# in_degree = { (0, 0) : 1, (0, 1) : 0, (0, 2) : 1 }
		
		# only select ""root"" points that parent[point] = point itself
        for i in range(m):
            for j in range(n):
                if parent[i][j] == (i, j):
                    dic[(i, j)] = []
                    in_degree[(i, j)] = 0
                    
		# if there are points that parent[point] = its parent but not the ""root"" ancestor
		# make parent[point] = the ""root"" ancestor
		
		# Ex. before: parent[4][4] = (4, 4), parent[8][0] = (4, 4), parent[8][4] = (8, 0)
		# after: parent[4][4] = (4, 4), parent[8][0] = (4, 4), parent[8][4] = (4, 4)
		
        for i in range(m):
            for j in range(n):
                while parent[i][j] not in dic:
                    parent[i][j] = parent[parent[i][j][0]][parent[i][j][1]]
        
		# continue to construct *dic* and *in_degree*
		# make connections in each row
        for i in range(m):
            row = []
            for j in range(n):
                r = tuple([matrix[i][j], parent[i][j][0], parent[i][j][1]])
                row.append(r)
            row.sort()
            for k in range(n - 1):
                if row[k][0] < row[k + 1][0]:
                    if (row[k][1], row[k][2]) in dic and (row[k + 1][1], row[k + 1][2]) in dic:
                        if (row[k + 1][1], row[k + 1][2]) not in dic[(row[k][1], row[k][2])]:
                            dic[(row[k][1], row[k][2])].append((row[k + 1][1], row[k + 1][2]))
                            in_degree[(row[k + 1][1], row[k + 1][2])] += 1
        
		# and make connections in each column
        for i in range(n):
            col = []
            for j in range(m):
                c = tuple([matrix[j][i], parent[j][i][0], parent[j][i][1]])
                col.append(c)
            col.sort()
            for k in range(m - 1):
                if col[k][0] < col[k + 1][0]:
                    if (col[k][1], col[k][2]) in dic and (col[k + 1][1], col[k + 1][2]) in dic:
                        if (col[k + 1][1], col[k + 1][2]) not in dic[(col[k][1], col[k][2])]:
                            dic[(col[k][1], col[k][2])].append((col[k + 1][1], col[k + 1][2]))
                            in_degree[(col[k + 1][1], col[k + 1][2])] += 1
        
        #######################################################################
        
		# *distance* records the rank of the ""root"" points (just my naming habit)
        distance = {} # point index : rank
        for i in range(m):
            for j in range(n):
                if parent[i][j] == (i, j):
                    distance[(i, j)] = 0
        
		# first put ""root"" points that have 0 in_degree (meaning they are the smallest) in queue
        queue = []
        for i in in_degree:
            if in_degree[i] == 0:
                queue.append(i)
                distance[i] = 1
        
        head = 0
        tail = len(queue) - 1
        while head <= tail:
            h = queue[head]

            for p in dic[h]:
                in_degree[p] -= 1
                if in_degree[p] == 0:
                    queue.append(p)
                    distance[p] = distance[h] + 1

            head += 1
            tail = len(queue) - 1
        
        #######################################################################
        
		# *rank* records the final result in matrix form
        rank = [[0 for i in range(n)] for j in range(m)]
        
		# now we already got the rank of those ""root"" points recorded in *distance*
		# let's put them in *rank*, also their descendants'
        for i in range(m):
            for j in range(n):
                rank[i][j] = distance[parent[i][j]]
        
        return rank",Hard,144,5781,28.0,34,3.0,48.0,40.145833333333336,210.0,-15.713124999999998
1103.0,sort array by increasing frequency,"class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        counter = [(x[0], len(list(x[1]))) for x in groupby(sorted(nums))]
        sorted_new_array = sorted(counter, key=lambda x: (x[1], -x[0]))
        nums = []
        for i in sorted_new_array:
            nums += ([i[0]] * i[1])
        return nums",Easy,7,330,0.0,1,2.0,2.0,47.142857142857146,15.0,4.077142857142857
1104.0,widest vertical area between two points containing no points,"class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        last = None
        mx = None
        for i in sorted(points):
            i = i[0]
            if last is not None and (mx is None or i - last > mx):
                mx = i - last
            last = i
        return mx",Medium,9,313,0.0,2,3.0,2.0,34.77777777777778,13.0,5.2700000000000005
1105.0,count substrings that differ by one character,"class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        ans=0
        for i in range(len(s)):
            for j in range(len(t)):
                x=i
                y=j
                d=0
                while x<len(s) and y<len(t):
                    if s[x]!=t[y]:
                        d+=1
                    if d==1:
                        ans+=1
                    if d==2:
                        break
                    x+=1
                    y+=1
        return ans",Medium,17,508,0.0,5,5.0,6.0,29.88235294117647,30.0,3.710588235294118
1106.0,number of ways to form a target string given a dictionary,"class Solution:
    def numWays(self, words: List[str], target: str) -> int:
        @lru_cache(None)
		# dfs(i, j) is number of ways to construct taget[:i+1] using chars with index at most j in the word in the words dictionary. 
        def dfs(i, j):
            if i < 0:
                return 1
            if j < 0:
                return 0
            # 
            ans = dfs(i, j-1)
            if chars_count[j][target[i]] > 0:
                ans += dfs(i-1, j-1)*chars_count[j][target[i]]
                ans %= 10**9+7
            return ans
            
        
        m, n = len(target), len(words[0])
        chars_count = [Counter([word[idx] for word in words]) for idx in range(n)]
        return dfs(m-1, n-1)",Hard,19,730,2.0,0,3.0,5.0,38.42105263157895,27.0,3.742105263157895
1107.0,check array formation through concatenation,"class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        joined = ""##"".join([str(i) for i in arr])
        joined = ""#"" + joined + ""#""
        pieces.sort()
        for pce in pieces:
            pJoined = ""##"".join(str(i) for i in pce)
            replaceStr = ""#"" + pJoined + ""#""
            joined = joined.replace(replaceStr, """")
        
        if joined == """":
            return True
        return False",Easy,12,456,4.0,1,3.0,5.0,38.0,18.0,4.700000000000001
1108.0,count sorted vowel strings,"class Solution(object):
    def countVowelStrings(self, n, p=0):
        if n == 0:
            return 1
        
        return sum([self.countVowelStrings(n-1, i) for i in range(p, 5)])",Medium,5,187,0.0,0,2.0,2.0,37.4,11.0,5.414000000000001
1109.0,furthest building you can reach,"class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        s = 0
        for i in range(1,len(heights)):
            if heights[i] > heights[i-1]:
                s += heights[i] - heights[i-1]         # height to be climbed
                if bricks >= s:                     # if bricks are available, continue
                    continue
                elif ladders > 0:           # else use ladder and note: remove the height to be climbed from total sum
                    s -= heights[i] - heights[i-1]
                    ladders -= 1                              # remove a ladder
                else:
                    return i - 1                  # i-1 th building was the last building which was reached
                    
        return len(heights) - 1                # last building reached",Medium,14,864,6.0,1,6.0,5.0,61.71428571428572,25.0,1.7657142857142851
1110.0,kth smallest instructions,"class Solution:
    def fact(self, n):
		""""""factorial with cache""""""
        if n in self.fact_cache:
            return self.fact_cache[n]
        x = self.fact(n-1) * n
        self.fact_cache[n] = x
        return x
    def max_k(self, x, y):
		""""""number of combinations for ordering x and y identical elements
		if x < 0, return 0
		""""""
        if x < 0:  # special case for our problem where there is no H left
            return 0
        return self.fact(x+y) // self.fact(x) // self.fact(y)
    def kthSmallestPath(self, destination: List[int], k: int) -> str:
        self.fact_cache = {0: 1}
        y, x = destination  # numbers of V and H moves
        out = ''
        for i in range(x+y):
		    # the number of combinations if the next element is H
            split = self.max_k(x-1, y)
            if k > split:
                out += 'V'
                y -= 1
                k -= split
            else:
                out += 'H'
                x -= 1
        return out",Hard,29,990,3.0,-1,3.0,8.0,34.13793103448276,35.0,3.4275862068965512
1111.0,get maximum in generated array,"class Solution:
    def __init__(self):
        self.nums = [0, 1]
        for i in range(2, 101):
            d, r = divmod(i, 2)
            if r == 0:
                self.nums.append(self.nums[d])
            else:
                p = int(i/2)
                self.nums.append(self.nums[d] + self.nums[d+1])
                
        
    def getMaximumGenerated(self, n: int) -> int:
        '''
        0 1 2 3 4 5 6 7 8 9 ...
        0 1 1 2 1 3 2 3 1 4 ...
        '''
        return max(self.nums[:n+1])",Easy,17,511,1.0,2,3.0,2.0,30.058823529411764,20.0,5.034705882352942
1112.0,minimum deletions to make character frequencies unique,"class Solution:
    def minDeletions(self, s: str) -> int:
        
        cnt_dict = {}
        
        for c in s:
            if c in cnt_dict:
                cnt_dict[c]+=1
            else:
                cnt_dict[c]=1                                   #Store the frequency of each character in a dictionary
                
        cnt_dict = {k: v for k, v in sorted(cnt_dict.items(), reverse=True, key=lambda item: item[1])}  #Sort the dictionary in a non-increasing order of the frequencies
             
        freq_found = []                                         #Store which frequencies have been found till now
        res = 0                                                 #Store how many characters to remove to make frequencies unique
        for c in cnt_dict.keys():
            while cnt_dict[c]>0 and cnt_dict[c] in freq_found:  #Don't reduce the frequency if the frequency is already 0
                cnt_dict[c]-=1
                res+=1
            freq_found.append(cnt_dict[c])                      #Found a unique frequency, append to the list
            
            
        return res",Medium,22,1124,6.0,5,5.0,6.0,51.09090909090909,27.0,2.341818181818182
1113.0,sell diminishing valued colored balls,"class Solution:
    def maxProfit(self, inventory: List[int], orders: int) -> int:
        inventory.sort(reverse=True)
        N = len(inventory)
        width = 1
        total = 0
        
        # sum of Arthematic Progression
        def sumAP(startHeight, endHeight):
            sum1 = startHeight * (startHeight + 1) // 2
            sum2 = endHeight * (endHeight + 1) // 2
            return sum1 - sum2
        
        i = 0
        while orders > 0:
            startHeight = inventory[i]
            endHeight = inventory[i+1] if i < N-1 else 0
            if width * (startHeight - endHeight) < orders:
                total += width * sumAP(startHeight, endHeight)
                orders -= width * (startHeight - endHeight)
            else: # enters else only once at the end
                q, r = divmod(orders, width)
                endHeight = inventory[i] - q
                total += width * sumAP(startHeight, endHeight)
                total += r * (startHeight - q)
                return total % (10 ** 9 + 7)
            width += 1
            i += 1",Medium,27,1080,2.0,1,3.0,3.0,40.0,36.0,2.640000000000001
1114.0,defuse the bomb,"class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        
        s=0
        temp=0
        ans=[]
        
        for i in range(0,len(code)):
        
            temp=k
            s=0
            
            if temp==0:
                ans.append(0)
            
            elif temp>0:
                j=i+1
                while temp>0 and j<len(code):
                    s+=code[j]
                    j=j+1
                    temp=temp-1
                
                if temp>0:
                    j=0
                    while temp>0 and j<len(code):
                        s+=code[j]
                        j=j+1
                        temp=temp-1
                
                ans.append(s)
            
            else:
                temp=temp*(-1)
                j=i-1
                while j>=0 and temp>0:
                    s+=code[j]
                    j=j-1
                    temp=temp-1
                
                if temp>0:
                    j=len(code)-1
                    while j>=0 and temp>0:
                        s+=code[j]
                        j=j-1
                        temp=temp-1
                    
       
                ans.append(s)
        
        return ans",Easy,49,1266,0.0,9,4.0,9.0,25.83673469387756,56.0,1.294693877551019
1115.0,minimum deletions to make string balanced,"class Solution:
    def minimumDeletions(self, s: str) -> int:
                        
        a_idx = [0] + list(itertools.accumulate([1 if c == 'a' else 0 for c in s]))
        b_idx = [0] + list(itertools.accumulate([1 if c == 'b' else 0 for c in s]))
        
        result = float('inf')
        
        for idx in range(len(s)):
            result = min(
                result,
                a_idx[-1] - a_idx[idx+1] +  b_idx[idx] - b_idx[0]
            )
        
        return result",Medium,14,498,0.0,1,3.0,5.0,35.57142857142857,17.0,4.858571428571429
1116.0,minimum jumps to reach home,"class Solution:
    def minimumJumps(self, forbidden, a, b, x):
        limit, visited = max(x,max(forbidden)) + a + b, set()

        stack = [(0,0,False)]

        while stack:
            val, steps, par = stack.pop(0)

            if val > limit or val < 0 or val in forbidden or (val,par) in visited:
                continue
            else:
                visited.add((val,par))

            if val == x:
                return steps

            stack.append((val+a,steps+1,False))

            if not par:
                stack.append((val-b,steps+1,True))

        return -1",Medium,22,586,0.0,2,2.0,7.0,26.63636363636364,32.0,4.162727272727272
1117.0,distribute repeating integers,"class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        
        arr=[0]*(1001)
        for i in nums:
            arr[i]+=1
            
        arr.sort(reverse=True)
        #print(arr)
        arr=arr[:10]
        dict={}
        def dfs(ind,arr):
            if ind==m:
                return True
            if (ind,tuple(arr)) in dict:
                return dict[(ind,tuple(arr))]
            
            for i in range(0,10):
                if arr[i]>=quantity[ind]:
                    arr[i]-=quantity[ind]
                    a=dfs(ind+1,arr)
                    arr[i]+=quantity[ind]
                    if a:
                        dict[(ind,tuple(arr))]=True
                        
                        return True
                    
            dict[(ind,tuple(arr))]=False
            return False
        m=len(quantity)
        return dfs(0,arr)",Hard,30,918,1.0,2,4.0,6.0,30.6,39.0,3.026
1118.0,determine if two strings are close,"class Solution(object):
    def closeStrings(self, word1, word2):
        def ans(word):
            dict1 ={}
            for i in word:
                if i not in dict1:dict1[i]=1
                else:dict1[i]+=1
            return sorted(dict1.values())
        return ans(word1)==ans(word2) and set(word1)==set(word2)",Medium,8,322,0.0,1,3.0,2.0,40.25,17.0,4.437500000000001
1119.0,minimum operations to reduce x to zero,"class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        total_sum = sum(nums)
        
        left, right = 0, 0
        max_len_win = -1
        current_win_sum = 0
        
        while right < len(nums):
            current_win_sum += nums[right]
            
            while current_win_sum > total_sum - x and left <= right:
                current_win_sum -= nums[left]
                left += 1
            
            if current_win_sum == total_sum - x:
                max_len_win = max(max_len_win, right - left + 1)
        
            right += 1

        return len(nums) - max_len_win if max_len_win != -1 else -1",Medium,20,662,0.0,3,3.0,4.0,33.1,30.0,3.661000000000001
1120.0,maximize grid happiness,"class Solution:
    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:
        
        @cache
        def fn(prev, i, j, intro, extro): 
            """"""Return max grid happiness at (i, j).""""""
            if i == m: return 0 # no more position
            if j == n: return fn(prev, i+1, 0, intro, extro)
            if intro == extro == 0: return 0 
            
            prev0 = prev[:j] + (0,) + prev[j+1:]
            ans = fn(prev0, i, j+1, intro, extro)
            if intro: 
                val = 120 
                if i and prev[j]: # neighbor from above 
                    val -= 30 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: # neighbor from left 
                    val -= 30 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (1,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro-1, extro))
            if extro: 
                val = 40 
                if i and prev[j]: 
                    val += 20 
                    if prev[j] == 1: val -= 30 
                    else: val += 20 
                if j and prev[j-1]: 
                    val += 20 
                    if prev[j-1] == 1: val -= 30 
                    else: val += 20 
                prev0 = prev[:j] + (2,) + prev[j+1:]
                ans = max(ans, val + fn(prev0, i, j+1, intro, extro-1))
            return ans 
        
        return fn((0,)*n, 0, 0, introvertsCount, extrovertsCount)",Hard,38,1612,3.0,8,4.0,13.0,42.42105263157895,110.0,-5.417894736842106
1121.0,check if two string arrays are equivalent,"class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return """".join(word1) == """".join(word2)",Easy,2,143,0.0,0,2.0,0.0,71.5,10.0,2.4450000000000003
1122.0,smallest string with a given numeric value,"class Solution:
    def getSmallestString(self, n: int, k: int) -> str:
        # set all 'a' char
        res = ['a' for _ in range(n)]
        k -= n
        
        idx = n - 1
        while k > 0:
            k += 1 # return num value of current 'a' char
            char_num_val = min(k, 26) # 26 - num value of 'z' char
            
            k -= char_num_val
            res[idx] = chr(char_num_val + 97 - 1) # '97' ascii code of 'a', but 1-indexed, so we must remove 1
            idx -= 1 # move idx
            
        return ''.join(res)",Medium,15,553,5.0,0,3.0,2.0,36.86666666666667,20.0,4.702000000000001
1123.0,ways to make a fair array,"class Solution:
    def waysToMakeFair(self, nums: List[int]) -> int:
        
        even=[]
        odd=[]
        e=0
        o=0
        
        for i in range(len(nums)):
            if i%2==0:
                e+=nums[i]
                
            else:
                o+=nums[i]
            
            even.append(e)
            odd.append(o)
            
        ans=0
        
        for i in range(len(nums)):
            if i%2==0:
                
                e1=even[i]
                e1-=nums[i]
                e1+= odd[len(nums)-1]
                e1-=odd[i]
                
                o1=odd[i]
                o1+=even[len(nums)-1]
                o1-=even[i]
                
                if e1==o1:
                    ans+=1
            else:
                o1=odd[i]
                o1-=nums[i]
                o1+=even[len(nums)-1]
                o1-=even[i]
                
                e1=even[i]
                e1+=odd[len(nums)-1]
                e1-=odd[i]
                
                if o1==e1:
                    ans+=1
        return ans",Medium,46,1102,0.0,6,4.0,6.0,23.95652173913044,48.0,2.4439130434782603
1124.0,minimum initial energy to finish tasks,"class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        energy=0
        remain=0
        ar=[]
        
        for task in range(len(tasks)):
            ar.append((tasks[task][1]-tasks[task][0],task))
        ar.sort()

        for task in ar[::-1]:
            if tasks[task[1]][1]>remain:
                energy+=(tasks[task[1]][1]-remain)
                remain=task[0]
            else:
                remain-=tasks[task[1]][1]
                remain+=task[0]
                
        return energy",Hard,18,534,0.0,3,3.0,4.0,29.666666666666668,20.0,4.970000000000001
1125.0,maximum repeating substring,"class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        if word in sequence:
            replaced = sequence.replace(word, '0')
        else:
            return 0
        
        flag, ans = 0, 0
        for char in replaced:
            if char == '0':
                flag += 1
            else:
                ans = max(ans, flag)
                flag = 0
        ans = max(ans, flag)
        
        return ans",Easy,16,446,0.0,2,3.0,3.0,27.875,26.0,4.59125
1126.0,merge in between linked lists,"class Solution:
    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:
        head=list1
        c=0
        while(c<=b):
            if c==a-1:
                prev=list1
                list1=list1.next
                prev.next=list2
            else:
                list1=list1.next
            c+=1
        while(list2.next):
            list2=list2.next
        list2.next=list1
        return head",Medium,15,443,0.0,1,3.0,3.0,29.53333333333333,29.0,4.202000000000001
1127.0,minimum number of removals to make mountain array,"class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        
        def fn(nums): 
            """"""Return length of LIS (excluding x) ending at x.""""""
            ans, vals = [], []
            for i, x in enumerate(nums): 
                k = bisect_left(vals, x)
                if k == len(vals): vals.append(x)
                else: vals[k] = x
                ans.append(k)
            return ans 
        
        left, right = fn(nums), fn(nums[::-1])[::-1]
        
        ans = inf
        for i in range(1, len(nums)-1): 
            if left[i] and right[i]:
                ans = min(ans, len(nums) - left[i] - right[i] - 1)
        return ans",Hard,19,681,0.0,2,3.0,4.0,35.8421052631579,32.0,3.274210526315789
1128.0,richest customer wealth,"class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        maxwealth=0
        for i in range(len(accounts)):
            maxwealth=max(maxwealth,sum(accounts[i]))
        return maxwealth",Easy,5,216,0.0,1,2.0,1.0,43.2,9.0,5.032
1129.0,find the most competitive subsequence,"class Solution:   # time limit
    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:
        return min(combinations(nums, k))",Medium,2,141,1.0,0,2.0,0.0,70.5,8.0,2.7750000000000004
1130.0,minimum moves to make array complementary,"class Solution:
    def minMoves(self, nums: List[int], limit: int) -> int:
        freq = {} # frequency table 
        lower, upper = [], []
        
        for i in range(len(nums)//2): 
            x = nums[i] + nums[~i]
            freq[x] = 1 + freq.get(x, 0)
            lower.append(min(nums[i], nums[~i]))
            upper.append(max(nums[i], nums[~i]) + 1 + limit)
        
        lower.sort()
        upper.sort()
        
        ans = inf
        for x in freq: 
            k = len(lower) - bisect_left(lower, x)
            kk = bisect_right(upper, x)
            val = len(nums)//2 - freq[x] + k + kk
            ans = min(ans, val)
        return ans",Medium,20,670,1.0,2,3.0,2.0,33.5,26.0,4.125
1131.0,minimize deviation in array,"class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if nums[i]%2!=0:
                nums[i]*=2
        minVal=min(nums)
        nums=[-val for val in nums]
        nums,ans=nums,float('inf')
        heapify(nums)
        while nums and abs(nums[0])%2==0:
            maxVal=abs(heappop(nums))
            ans=min(ans,abs(maxVal-minVal))
            maxVal=maxVal//2
            minVal=min(minVal,maxVal)
            heappush(nums,-maxVal)
        return min(ans,abs(min(nums))-abs(max(nums)))",Hard,15,560,0.0,3,3.0,5.0,37.333333333333336,26.0,3.6800000000000006
1132.0,goal parser interpretation,"class Solution:
    def interpret(self, command: str) -> str:
        res = """"
        i = 0
        while i < len(command):
            if command[i] == ""G"":
                res += ""G""
                i += 1
            elif command[i] == ""("" and command[i+1] == "")"":
                res += ""o""
                i += 2
            else:
                res += ""al""
                i += 4
        return res",Easy,14,406,0.0,3,3.0,3.0,29.0,27.0,4.33
1133.0,max number of k sum pairs,"class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        ans = 0
        if not nums or len(nums) == 1:
            return ans
        nums.sort()
        l = 0
        r = len(nums) - 1
        while l < r:
            s = nums[l] + nums[r]
            if s == k:
                ans += 1
                l +=1
                r -=1
            elif s > k:
                r -= 1
            else:
                l += 1
        return ans",Medium,18,468,0.0,3,3.0,4.0,26.0,29.0,4.4
1134.0,concatenation of consecutive binary numbers,"class Solution:
    def concatenatedBinary(self, n: int) -> int:
        s=''
        for i in range(1, n+1):
            s+=bin(i).replace(""0b"", """")
            # print(s)
        return int(s,2)%1000000007",Medium,6,207,1.0,1,3.0,1.0,34.5,11.0,5.595000000000001
1135.0,minimum incompatibility,"class Solution:
    def minimumIncompatibility(self, nums: List[int], k: int) -> int:
                        
        partition_len = len(nums) // k        
                
        @functools.lru_cache(maxsize=None)
        def recurse(nums):            
            if not nums: return 0      
            
            result = float('inf')
            
            for combo in itertools.combinations(nums, partition_len):                
                
                if len(set(combo)) < partition_len: continue
                                                 
                updated_nums = list(nums) 
                for i in combo:
                    updated_nums.remove(i)
                                    
                result = min(
                    result,
                    max(combo) - min(combo) + recurse(tuple(updated_nums))
                )
                
            return result
        
        result = recurse(tuple(nums))
        
        return result if result != float('inf') else -1",Hard,28,1031,0.0,1,5.0,5.0,36.82142857142857,22.0,4.126071428571429
1136.0,count the number of consistent strings,"class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        
        consistentStringCount = 0
        setAllowed = set(allowed)
        
        for word in words:
            setWord = set(word)
            if len(setWord - setAllowed) == 0:
                consistentStringCount +=1
        return consistentStringCount",Easy,10,363,0.0,2,3.0,2.0,36.3,16.0,4.833000000000001
1137.0,sum of absolute differences in a sorted array,"class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)
        
        ans = []
        for i, x in enumerate(nums): 
            ans.append(prefix[-1] - 2*prefix[i] + (2*i - len(nums)) * nums[i])
        return ans",Medium,8,322,0.0,2,2.0,3.0,40.25,10.0,5.137499999999999
1138.0,stone game vi,"class Solution:
    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:
        pq = [(-x-y, x, y) for x, y in zip(aliceValues, bobValues)]
        heapify(pq)
        
        s0 = s1 = i = 0
        while pq: 
            _, x, y = heappop(pq)
            if i: s1 += y
            else: s0 += x
            i ^= 1
        if s0 > s1: return 1
        if s0 < s1: return -1
        return 0",Medium,13,416,0.0,2,3.0,6.0,32.0,28.0,4.0200000000000005
1139.0,delivering boxes from storage to ports,"class Solution:
    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
        dp = [0] + [inf]*len(boxes)
        trips = 2
        ii = 0
        for i in range(len(boxes)):
            maxWeight -= boxes[i][1]
            if i and boxes[i-1][0] != boxes[i][0]: trips += 1
            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:
                maxWeight += boxes[ii][1]
                if boxes[ii][0] != boxes[ii+1][0]: trips-=1
                ii += 1
            dp[i+1] = dp[ii] + trips
        return dp[-1]",Hard,13,603,0.0,4,3.0,4.0,46.38461538461539,32.0,2.205384615384615
1140.0,count of matches in tournament,"class Solution:
    def numberOfMatches(self, n: int) -> int:
        matches=0
        while n > 1:
            if n%2==0:
                matches+=int(n/2)
                n = n/2
            else:
                matches+=int((n-1)/2)
                n = (n+1)/2
        return matches",Easy,10,288,0.0,2,3.0,2.0,28.8,17.0,5.408
1141.0,partitioning into minimum number of deci binary numbers,"class Solution:
    def minPartitions(self, n: str) -> int:
        return int(max(n))",Medium,2,86,0.0,0,2.0,0.0,43.0,5.0,5.510000000000001
1142.0,stone game vii,"class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        n=len(stones)
        total=[stones[0]]
        for i in stones[1:]:
            total.append(total[-1]+i)
        new=[[0 for i in range(0,n)] for i in range(0,n)]
        for gap in range(1,n):
            for j in range(gap,n):
                i=j-gap
                if gap==1:
                    new[i][j]=max(stones[i],stones[j])
                else:
                    s1=total[j]-total[i]
                    if i==0:
                        s2=total[j-1]
                    else:
                        s2=total[j-1]-total[i-1]
                    new[i][j]=max(s1-new[i+1][j],s2-new[i][j-1])
        return new[0][-1]",Medium,19,710,0.0,5,4.0,7.0,37.36842105263158,34.0,2.696842105263157
1143.0,maximum height by stacking cuboids,"class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        cuboids = sorted((sorted(x, reverse=True) for x in cuboids), reverse=True)
        
        @lru_cache(None)
        def fn(i, h, l, w): 
            """"""Return max heights of stacking cuboids[i:].""""""
            if i == len(cuboids): return 0 # no cuboids left 
            hi, li, wi = cuboids[i]
            if hi <= h and li <= l and wi <= w: 
                return max(hi + fn(i+1, hi, li, wi), fn(i+1, h, l, w))
            else:
                return fn(i+1, h, l, w)
            
        return fn(0, inf, inf, inf)",Hard,14,606,1.0,-2,3.0,3.0,43.285714285714285,43.0,1.7842857142857138
1144.0,reformat phone number,"class Solution:
    def reformatNumber(self, number: str):
        pure_digits = number.replace(' ', '').replace('-', '')
        pure_digits_lengh = len(pure_digits)
        if pure_digits_lengh > 2:
            new_array = []
            count = 0
            temp = """"
            for d in pure_digits:
                if pure_digits_lengh - len("""".join(new_array)) == 4 and temp == """":
                    new_array.append(pure_digits[-4:-2])
                    new_array.append(pure_digits[-2:])
                    break
                count += 1
                temp += d
                if count == 3:
                    count = 0
                    new_array.append(temp)
                    temp = """"
            if temp:
                new_array.append(temp)

            return '-'.join(new_array)

        else:
            return pure_digits",Easy,25,860,0.0,3,4.0,6.0,34.4,33.0,3.184
1145.0,maximum erasure value,"class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        
        res = 0
        start = 0
        cur = 0
        d = defaultdict(int)
        
        for end in range(len(nums)):
            item = nums[end]
            cur += item
            d[item] += 1
            while d[item] > 1:
                d[nums[start]] -= 1
                cur -= nums[start]
                if d[nums[start]] == 0:
                    del d[nums[start]]
                start += 1
            res = max(res, cur)
        return res",Medium,19,547,0.0,3,3.0,3.0,28.789473684210527,24.0,4.648947368421053
1146.0,jump game vi,"class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        t = [0 for _ in range(n)]
        t[n-1] = nums[n-1]
        for i in range(n-2, -1, -1):
            start = i+1
            end = min(n-1, i+k)
            temp = max(t[start:end+1])
            t[i] = nums[i] + temp
        return t[0]",Medium,10,341,0.0,1,3.0,2.0,34.1,19.0,4.791
1147.0,checking existence of edge length limited paths,"class Solution:
    def distanceLimitedPathsExist(self, n: int, A: List[List[int]], B: List[List[int]]) -> List[bool]:
        par = {}
        A.sort(key = lambda x: x[2])
        
        for i, query in enumerate(B):
            query.append(i)
        B.sort(key = lambda x: x[2])
        
        def find(a):
            par.setdefault(a, a)
            if par[a] != a:
                par[a] = find(par[a])
            return par[a]
        
        def union(a, b):
            par.setdefault(a, a)
            par.setdefault(b, b)
            par[find(a)] = par[find(b)]
        
        ans = [False]*len(B)
        i = 0
        for a, b, lim, idx in B:
            while i < len(A) and A[i][2] < lim:
                union(A[i][0], A[i][1])
                i += 1
            
            if find(a) == find(b):
                ans[idx] = True
        return ans",Hard,29,874,0.0,4,3.0,5.0,30.13793103448276,42.0,2.6675862068965515
1148.0,number of students unable to eat lunch,"class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int: 
        counts = [len(students) - sum(students), sum(students)]        
        for s in sandwiches:
            if not counts[s]:
                return sum(counts)
            counts[s] -= 1            
        return 0",Easy,7,318,0.0,1,4.0,2.0,45.42857142857143,12.0,4.411428571428571
1149.0,average waiting time,"class Solution:
    def averageWaitingTime(self, customers: List[List[int]]) -> float:
        next_wt = customers[0][0]+customers[0][1]
        time = []
        
        time.append(next_wt-customers[0][0])
        
        for i  in range(1,len(customers)):
            arr = customers[i][0]
            dep = customers[i][1]
            if arr < next_wt:
                wt = (next_wt-arr)+(arr+dep)
            else:
                wt = arr+dep
            time.append(wt  - arr)
            next_wt = wt
        #print(time)
        return sum(time)/len(time)",Medium,17,566,1.0,2,3.0,2.0,33.294117647058826,17.0,5.043529411764705
1150.0,maximum binary string after change,"class Solution:
    def maximumBinaryString(self, binary: str) -> str:
        if binary.count(""0"") <= 1: return binary 
        ones = binary.count(""1"", binary.index(""0""))
        return (len(binary)-ones-1)*""1"" + ""0"" + ones*""1""",Medium,4,229,0.0,0,2.0,1.0,57.25,10.0,3.7275
1151.0,minimum adjacent swaps for k consecutive ones,"class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        loc = [i for i, x in enumerate(nums) if x]
        prefix = [0]
        for x in loc: prefix.append(prefix[-1] + x)
        
        ans = inf
        for i in range(len(loc)-k+1): 
            ans = min(ans, (prefix[i+k] - prefix[i+(k+1)//2]) - (prefix[i+k//2] - prefix[i]))
        return ans - (k//2)*((k+1)//2)",Hard,9,394,0.0,2,2.0,4.0,43.77777777777778,15.0,4.32
1152.0,determine if string halves are alike,"class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        return sum(1 if i < len(s)//2 else -1 for i, c in enumerate(s) if c in 'aeiouAEIOU') == 0",Easy,2,159,0.0,0,2.0,3.0,79.5,10.0,1.7250000000000014
1153.0,maximum number of eaten apples,"class Solution:
    def eatenApples(self, apples: List[int], days: List[int]) -> int:
        n=len(days)
        l=[]
        le=0
        for i in range(n):
            if days[i]!=0 or apples[i]!=0:
                l.append([apples[i],days[i]+i])
                le+=1
        l.sort(key=lambda x:x[1])
        day=0
        res=0
        i=0
        while(i<le):
            A=l[i][0]
            D=l[i][1]
            if day<D:
                diff_days=D-day
  
                mn=min(diff_days,A)
                day+=mn
                res+=mn
            i+=1
  
        return res",Medium,24,590,0.0,3,3.0,6.0,24.58333333333333,33.0,4.1275
1154.0,where will the ball fall,"class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        def DFS(rows, columns, cur_row, cur_column):
            //Base Case
            if cur_row == rows:
                return cur_column
            //If direction is Right
            if cur_column < columns - 1 and (grid[cur_row][cur_column] == 1 and grid[cur_row][cur_column + 1] == 1):
                return DFS(rows, columns,  cur_row + 1, cur_column + 1)
            //If direction if Left
            elif 0 < cur_column and (grid[cur_row][cur_column] == -1 and grid[cur_row][cur_column - 1] == -1):
                return DFS(rows, columns,  cur_row + 1, cur_column - 1)
            //If direction is invalid
            else:
                return ""X""

        rows = len(grid)
        columns = len(grid[0])
        res = deque([])
        for i in range(columns):
            temp = DFS(rows, columns, 0, i)
            res.append(-1) if temp == ""X"" else res.append(temp)
        return res",Medium,22,985,0.0,0,3.0,9.0,44.77272727272727,47.0,1.090454545454545
1155.0,maximum xor with an element from array,"class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        nums.sort()
        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))
        ans = [-1]*len(queries)
        
        trie = {}
        k = 0
        for m, x, i in queries: 
            while k < len(nums) and nums[k] <= m: 
                node = trie
                val = bin(nums[k])[2:].zfill(32)
                for c in val: node = node.setdefault(int(c), {})
                node[""#""] = nums[k]
                k += 1
            if trie: 
                node = trie
                val = bin(x)[2:].zfill(32)
                for c in val: node = node.get(1-int(c)) or node.get(int(c))
                ans[i] = x ^ node[""#""]
        return ans",Hard,20,775,2.0,5,3.0,6.0,38.75,37.0,2.4125000000000005
1156.0,maximum units on a truck,"class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        res = 0
        q = deque(sorted(boxTypes, key=lambda b: b[1], reverse=True))
        
        while q and truckSize:
            boxes, units = q.popleft()
            while boxes:
                if boxes <= truckSize:
                    res += boxes * units
                    truckSize -= boxes
                    boxes = 0
                else:
                    boxes -= 1
                    
        return res",Easy,15,525,0.0,3,4.0,3.0,35.0,26.0,3.83
1157.0,count good meals,"class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        """"""
        
            A + B == 1 << i
        
            A = 2 << i - B
        """"""
        
        result = 0
        seen = defaultdict(int)
        deliciousness.sort()
        
        for d in deliciousness:
            n = 1
            
            # because it is a sorted array. 
            # the maximum sum it can get by i-th number is deliciousness[i] + deliciousness[i]
            while n <= d + d:
                result = (result + seen[n-d]) % (10 ** 9 + 7)
                n = n << 1
                
            seen[d] += 1
        
        return result",Medium,24,664,2.0,2,3.0,2.0,27.666666666666668,25.0,4.79
1158.0,ways to split array into three subarrays,"class Solution:
    def waysToSplit(self, nums: List[int]) -> int:
        pre_sum = [0]
        for n in nums:
            pre_sum.append(pre_sum[-1] + n)
        length = len(nums)
        ret, mid_l, mid_r = 0, 0, 0
        for i in range(1, length): 
            mid_l = max(mid_l, i + 1)
            while mid_l < length and 2 * pre_sum[i] > pre_sum[mid_l]:
                mid_l += 1
            mid_r = max(mid_r, mid_l)
            while mid_r < length and 2 * pre_sum[mid_r] <= pre_sum[i] + pre_sum[-1]:
                mid_r += 1
            ret += mid_r - mid_l
        return ret % 1_000_000_007",Medium,15,607,0.0,4,3.0,4.0,40.46666666666667,29.0,3.0380000000000003
1159.0,minimum operations to make a subsequence,"class Solution(object):
    def minOperations(self, target, arr):
        d = {num: idx for idx, num in enumerate(target)}
        arr = [d.get(num, -1) for num in arr]
        res = []
        for num in arr:
            if num == -1: continue
            else:
                pos = bisect.bisect_left(res, num)
                if pos == len(res):
                    res.append(num)
                else:
                    res[pos] = min(res[pos], num)
        return len(target) - len(res)",Hard,13,495,0.0,2,3.0,5.0,38.07692307692308,25.0,3.773076923076923
1160.0,calculate money in leetcode bank,"class Solution:
    def totalMoney(self, n: int) -> int:
        return n//7*28 + n//7*(n//7-1)//2*7 + (n%7)*(n//7+1) + (n%7-1)*(n%7)//2
            

class Solution2:
    def totalMoney(self, n: int) -> int:
        fullWeeks=n//7
        reminder=n%7
        totalMoney=28*fullWeeks + 7*(fullWeeks-1)*fullWeeks//2 + reminder*(fullWeeks+1) + (reminder-1)*reminder//2
        return totalMoney
            

class Solution1:
    def totalMoney(self, n: int) -> int:
        fullWeeks=0
        totalMoney=0
        for day in range(n):
            if day%7==0: fullWeeks+=1
            totalMoney+=fullWeeks+day%7
        return totalMoney",Easy,20,639,0.0,0,2.0,2.0,31.95,27.0,4.3045
1161.0,maximum score from removing substrings,"class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
        a, b = ""a"", ""b""
        if x < y: 
            x, y = y, x
            a, b = b, a
        ans = cnt0 = cnt1 = 0
        for c in s: 
            if c not in ""ab"": 
                ans += min(cnt0, cnt1) * y
                cnt0 = cnt1 = 0 
            elif c == b:
                if cnt0: 
                    cnt0 -= 1
                    ans += x
                else: cnt1 += 1
            else: cnt0 += 1
        return ans + min(cnt0, cnt1) * y",Medium,17,533,0.0,5,4.0,5.0,31.352941176470587,41.0,2.538235294117647
1162.0,construct the lexicographically largest valid sequence,"class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
		# to check what all numbers have been used
        vis = [False] * (n + 1)
		
		# intermediate array to build the final sequence
        curr_list = [-1] * (2*n - 1)
        li, ans_list = self.recur(vis, curr_list, 0, n, n)
        return ans_list
        
    def recur(self, vis, curr_list, curr_ind, n, rem):
		# base conditon which is to check that we have used all the 'n' numbers
        if rem == 0:
            return True, curr_list
		
		# check what index we have to fill in the intermediate array
        while(curr_list[curr_ind] != -1 and curr_ind < 2 * n - 1):
            curr_ind += 1
        ans = False
        ans_list = None
        for i in range(len(vis) - 1, 0, -1):
			addition = i
			
			# special handling of '1'
            if i == 1:
                addition = 0
				
			# only numbers that are not already used and check for feasibility using the constraints given
           if not vis[i] and self.check_feasible(curr_list, curr_ind, addition, n):
                vis[i] = True
                curr_list[curr_ind] = i
                curr_list[curr_ind + addition] = i
                is_list, li = self.recur(vis, curr_list, curr_ind + 1, n, rem - 1)
                if is_list:
                    ans = True
                    ans_list = li
                    break
                curr_list[curr_ind] = -1
                curr_list[curr_ind + addition] = -1
                vis[i] = False
        return ans, ans_list
    
    def check_feasible(self, curr_list, curr_ind, addition, n):
        if curr_ind + addition < 2*n - 1 and curr_list[curr_ind] == -1 and curr_list[curr_ind + addition] == -1:
            return True
        return False",Medium,45,1762,6.0,1,3.0,8.0,39.15555555555556,72.0,-0.7240000000000002
1163.0,number of ways to reconstruct a tree,"class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        nodes = set()
        graph = {}
        degree = {}
        for x, y in pairs: 
            nodes |= {x, y}
            graph.setdefault(x, set()).add(y)
            graph.setdefault(y, set()).add(x)
            degree[x] = 1 + degree.get(x, 0)
            degree[y] = 1 + degree.get(y, 0)
        
        if max(degree.values()) < len(nodes) - 1: return 0 # no root
        for n in nodes: 
            if degree[n] < len(nodes)-1: 
                nei = set()
                for nn in graph[n]: 
                    if degree[n] >= degree[nn]: nei |= graph[nn] # brothers &amp; childrens
                if nei - {n} - graph[n]: return 0 # impossible
        
        for n in nodes: 
            if any(degree[n] == degree[nn] for nn in graph[n]): return 2 # brothers 
        return 1",Hard,22,871,4.0,6,3.0,10.0,39.59090909090909,35.0,2.5568181818181817
1164.0,decode xored array,"class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr = [first]
        for i in range(len(encoded)):
            arr.append(arr[i]^encoded[i])
        return arr",Easy,5,203,0.0,1,2.0,1.0,40.6,9.0,5.266
1165.0,swapping nodes in a linked list,"class Solution:
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        fast = head
        slow = head
        for i in range(1,k):
            fast = fast.next
        beg = fast
        while fast.next:
            fast = fast.next
            slow = slow.next
        
        tmp = beg.val
        beg.val = slow.val
        slow.val = tmp
        return head",Medium,14,397,0.0,2,3.0,2.0,28.357142857142858,19.0,5.247857142857143
1166.0,minimize hamming distance after swap operations,"class Solution:
    def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:
        
        # idx to group id
        idx_to_group = {}
        # group id to index set
        group_to_idx = {}
        global_group_id = 0
        
        for swap in allowedSwaps:
            foundGroups = set()
            
            for idx in swap:
                if idx in idx_to_group:
                    foundGroups.add(idx_to_group[idx])
            
            if foundGroups:
                pivot = min(foundGroups)
                for group_id in foundGroups:
                    if pivot != group_id:
                        group_to_idx[pivot].update(group_to_idx[group_id])
                        group_to_idx.pop(group_id)

                group_to_idx[pivot].update(swap)

                for idx in group_to_idx[pivot]:
                    idx_to_group[idx] = pivot
            else:
                for idx in swap:
                    idx_to_group[idx] = global_group_id
                group_to_idx[global_group_id] = set(swap)
                global_group_id += 1
                
        ans = 0
        if group_to_idx == {}:
            for i in range(len(source)):
                if source[i]!=target[i]:
                    ans += 1
        else:
            for group_id in group_to_idx:
                src = {}
                tgt = {}
                for idx in group_to_idx[group_id]:
                    if source[idx] not in src:
                        src[source[idx]] = 0
                    src[source[idx]] += 1

                    if target[idx] not in tgt:
                        tgt[target[idx]] = 0
                    tgt[target[idx]] += 1

                for key in src:
                    if key in tgt:
                        if src[key] > tgt[key]:
                            ans += src[key] - tgt[key]
                    else:
                        ans += src[key]
            
            for i in range(len(source)):
                if i not in idx_to_group and source[i]!=target[i]:
                    ans += 1
            
        return ans",Medium,62,2150,2.0,20,4.0,20.0,34.67741935483871,59.0,-0.3809677419354838
1167.0,find minimum time to finish all jobs,"class Solution:    
    def minimumTimeRequired(self, jobs: List[int], num_workers: int) -> int:
        n = len(jobs)
        worker_cost = [0] * (1 << n)
        for state in range(1 << n):
            for i in range(n):
                if state &amp; (1 << i):
                    worker_cost[state] += jobs[i]
                    
        @functools.cache
        def compute_time(state: int, curr_workers: int) -> int:
            if curr_workers == 1:
                return worker_cost[state]
            
            best = float(""inf"")
            worker_state = state
            while worker_state:
                if worker_cost[worker_state] < best:
                    best = min(best, max(compute_time(state ^ worker_state, curr_workers - 1), worker_cost[worker_state]))
                worker_state = (worker_state - 1) &amp; state
            
            return best
            
        return compute_time((1 << n) - 1, num_workers)",Hard,23,952,0.0,4,4.0,6.0,41.391304347826086,41.0,1.694782608695652
1168.0,number of rectangles that can form the largest square,"class Solution:
    def countGoodRectangles(self, r: List[List[int]]) -> int:
        
        an=0
        ans=0
        for j in r:
            a=min(j)
            if a > an:
                an= a
                ans=1
            elif a==an:
                ans+=1
                
            
        return ans",Easy,14,317,0.0,3,3.0,3.0,22.642857142857142,18.0,5.802142857142858
1169.0,tuple with same product,"class Solution:
    def tupleSameProduct(self, nums: List[int]) -> int:
        hmap = {}
        output = 0
        for i in range(len(nums)):
            for j in range(i):
				# Skip if same number
                if i == j:
                    continue
                candidate = nums[i] * nums[j]
                if candidate in hmap:
                    output += hmap[candidate] * 8
                    hmap[candidate] += 1
                else:
                    hmap[candidate] = 1
        return output",Medium,15,515,1.0,3,4.0,5.0,34.333333333333336,19.0,4.63
1170.0,largest submatrix with rearrangements,"class Solution:
    def largestSubmatrix(self, matrix: List[List[int]]) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions
        ans = 0
        hist = [0] * n
        for i in range(m): 
            for j in range(n): 
                hist[j] = hist[j] + 1 if matrix[i][j] else 0
            for i, x in enumerate(sorted(hist, reverse=True)): 
                ans = max(ans, x*(i+1))
        return ans",Medium,10,418,1.0,3,3.0,4.0,41.8,19.0,4.018000000000001
1171.0,cat and mouse ii,"class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        m, n = len(grid), len(grid[0]) # dimensions 
        walls = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ""F"": food = (i, j)
                elif grid[i][j] == ""C"": cat = (i, j)
                elif grid[i][j] == ""M"": mouse = (i, j)
                elif grid[i][j] == ""#"": walls.add((i, j))
                    
        @lru_cache(None)
        def fn(cat, mouse, turn): 
            """"""Return True if mouse wins.""""""
            if cat == food or cat == mouse or turn >= m*n*2: return False 
            if mouse == food: return True  # mouse reaching food
            
            if not turn &amp; 1: # mouse moving 
                x, y = mouse
                for dx, dy in (-1, 0), (0, 1), (1, 0), (0, -1): 
                    for jump in range(0, mouseJump+1):
                        xx, yy = x+jump*dx, y+jump*dy
                        if not (0 <= xx < m and 0 <= yy < n) or (xx, yy) in walls: break 
                        if fn(cat, (xx, yy), turn+1): return True 
                return False 
            else: # cat moving
                x, y = cat
                for dx, dy in (-1, 0), (0, 1), (1, 0), (0, -1): 
                    for jump in range(0, catJump+1):
                        xx, yy = x+jump*dx, y+jump*dy
                        if not (0 <= xx < m and 0 <= yy < n) or (xx, yy) in walls: break 
                        if not fn((xx, yy), mouse, turn+1): return False
                return True
                    
        return fn(cat, mouse, 0)",Hard,34,1641,5.0,8,4.0,18.0,48.26470588235294,114.0,-6.263823529411766
1172.0,find the highest altitude,"class Solution:
    def largestAltitude(self, gain: List[int]) -> int:
        return max(0,max(itertools.accumulate(gain)))",Easy,2,124,0.0,0,2.0,0.0,62.0,6.0,3.7
1173.0,minimum number of people to teach,"class Solution:
    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        
        languages = [None] + list(map(set, languages))
        friendships = [[u, v] for u, v in friendships if not languages[u] &amp; languages[v]]
        
        # teach whoever needs it
        return min([len({u
                        for pair in friendships
                        for u in pair
                        if lan not in languages[u]})
                   for lan in range(1, n+1)])",Medium,11,532,1.0,0,4.0,6.0,48.36363636363637,15.0,3.9472727272727273
1174.0,decode xored permutation,"class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        x = reduce(xor, list(range(1, len(encoded) + 2)))
        for i in range(1, len(encoded), 2): x ^= encoded[i]
        ans = [x]
        for x in encoded: ans.append(ans[-1] ^ x)
        return ans",Medium,6,275,0.0,2,2.0,2.0,45.833333333333336,14.0,4.234999999999999
1175.0,count ways to make array with product,"class Solution:
    def __init__(self):
        self.dp = {}
        
    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        mod = 10 ** 9 + 7
        
        def dfs(n, val):
            if (n, val) not in self.dp:
                if n == 1: return 1
                temp = 1
                for k in range(val//2, 0, -1):
                    if val % k == 0:
                        temp += dfs(n-1, val // k)
                self.dp[n, val] = temp % mod
            return self.dp[n, val]
        
        res = []
        for n, val in queries:
            res.append(dfs(n, val))
        return res",Hard,20,627,0.0,3,3.0,5.0,31.35,33.0,3.5185000000000004
1176.0,latest time by replacing hidden digits,"class Solution:
    def maximumTime(self, time: str) -> str:
        maxValues = {
            '0': '2',
            '1': {'0': '9', '1': '9', '2': '3'},
            '3': '5',
            '4': '9'
        }

        result = []
        for i, char in enumerate(time):
            if char == '?':
                if i == 0 and time[i + 1] != '?' and time[i + 1] >= '4':
                    result.append('1')
                elif i == 1:
                    result.append(maxValues['1'][result[i - 1]])

                else:
                    result.append(maxValues[str(i)])
            else:
                result.append(char)

        return ''.join(result)",Easy,22,663,0.0,4,3.0,4.0,30.13636363636364,38.0,3.0677272727272724
1177.0,change minimum characters to satisfy one of three conditions,"class Solution:
    def minCharacters(self, a: str, b: str) -> int:
        pa, pb = [0]*26, [0]*26
        for x in a: pa[ord(x)-97] += 1
        for x in b: pb[ord(x)-97] += 1
        
        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3
        for i in range(25): 
            pa[i+1] += pa[i]
            pb[i+1] += pb[i]
            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2
            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1
        return ans",Medium,12,486,3.0,3,3.0,3.0,40.5,22.0,3.915
1178.0,find kth largest xor coordinate value,"class Solution:
    def kthLargestValue(self, matrix, k: int) -> int:
        large = [matrix[0][0]]
        n = len(matrix)
        m = len(matrix[0])
        for i in range(1, n):
            matrix[i][0] ^= matrix[i - 1][0]
            large.append(matrix[i][0])

        for j in range(1, m):
            matrix[0][j] ^= matrix[0][j - 1]
            large.append(matrix[0][j])

        for i in range(1, n):
            for j in range(1, m):
                matrix[i][j] ^= matrix[i][j - 1] ^ matrix[i - 1][j] ^ matrix[i - 1][j - 1]
                large.append(matrix[i][j])

        large.sort()
        return large[-k]",Medium,19,626,0.0,4,3.0,4.0,32.94736842105263,20.0,4.614736842105264
1179.0,building boxes,"class Solution:
    def minimumBoxes(self, n: int) -> int:
        boxesPlaced = 0
        maxFloor = 1
        boxesOnFloor = 0
        while boxesPlaced < n:
            for i in range(1, maxFloor + 1):
                boxesPlaced += i
                boxesOnFloor += 1
                if boxesPlaced >= n:
                    break
            maxFloor += 1
        return boxesOnFloor",Hard,12,388,0.0,2,3.0,3.0,32.333333333333336,18.0,4.99
1180.0,maximum number of balls in a box,"class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        d = {}
        for i in range(lowLimit, highLimit+1):
            d[sum(list(map(int,list(str(i)))))] = d.get(sum(list(map(int,list(str(i))))),0) + 1
        return max(d.values())",Easy,5,268,0.0,1,2.0,1.0,53.6,14.0,3.596
1181.0,restore the array from adjacent pairs,"class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        # map the relations between two elements using dictionary
        # key=element, value=[elements it is paired with]
        dict1={}
        for ii in adjacentPairs:
            if ii[0] in dict1.keys():
                dict1[ii[0]].append(ii[1])
            if ii[0] not in dict1.keys():
                dict1[ii[0]]=[ii[1]]
            if ii[1] in dict1.keys():
                dict1[ii[1]].append(ii[0])
            if ii[1] not in dict1.keys():
                dict1[ii[1]]=[ii[0]]
                
                
        # 1st and last element of series will have only pairing element in the list
        # finding those 2 elements
        #temp array to store those 2 elements
        gajab=[]  
        for ii in dict1.keys():
            if len(dict1[ii])==1:    # if len==1 it can be start or ending elemnt of list
                gajab.append(ii)
                
        # Initializing Solution array with all elemnts as Zero
        # len of solution array = len(pairs)+1
        ans=[0]*((len(adjacentPairs))+1)
        
        #Placing 1st and last element in array.You can make any of two element as STARTING or ENDING
        ans[0]=gajab[0]
        ans[-1]=gajab[1]
        
        #using 1st element in ANS array to find its relation element and then so on...
        for ii in range(len(ans)-1):
            pp=dict1[ans[ii]][0]
            dict1[pp].remove(ans[ii]) # removing the element relation that is already in ANS array
            ans[ii+1]=pp              # adding the element in ANS array at correct position
    
        return(ans)",Medium,38,1664,12.0,8,3.0,9.0,43.78947368421053,32.0,2.6789473684210527
1182.0,can you eat your favorite candy on your favorite day,"class Solution:
    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum 
        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",Medium,4,288,1.0,1,2.0,2.0,72.0,13.0,2.080000000000001
1183.0,palindrome partitioning iv,"class Solution:
    def checkPartitioning(self, s: str) -> bool:
        n=len(s)
        pal=[[False]*n for i in range(n)]
        for i in range(n):
            pal[i][i]=True

        for i in range(n-1,-1,-1):
            for j in range(i+1,n):
                if i+1==j and s[i]==s[j]:
                    pal[i][j]=True
                if pal[i+1][j-1] and s[i]==s[j]:
                    pal[i][j]=True

        dp=[[False for i in range(4)] for j in range(n+1)]
        dp[n][3]=True     
        for ind in range(n-1,-1,-1):
            for i in range(ind,n):
                if pal[ind][i]:
                    dp[ind][2] |= dp[i+1][3]
                    dp[ind][1] |= dp[i+1][2]
                    dp[ind][0] |= dp[i+1][1]
        return dp[0][0]",Hard,22,759,0.0,8,3.0,11.0,34.5,38.0,2.4350000000000005
1184.0,sum of unique elements,"class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        c = Counter(nums)
        return sum(n for n, c in c.items() if c == 1)",Easy,3,146,0.0,0,2.0,2.0,48.66666666666666,10.0,4.5
1185.0,maximum absolute sum of any subarray,"class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        
        def kadane(x):
            cmax = 0
            gmax = 0
            
            for i in x:
                if cmax < 0:
                    cmax = i
                else:
                    cmax+=i
                gmax = max(cmax, gmax)
            return gmax
        
        return max(kadane(nums), kadane(-i for i in nums))",Medium,15,419,0.0,1,4.0,3.0,27.933333333333334,17.0,5.486
1186.0,minimum length of string after deleting similar ends,"class Solution:
    def minimumLength(self, s: str) -> int:
        left = 0
        right = len(s)-1
        if len(s) == 1:
            return 1
        while left < right and s[left] == s[right] :
            while left < right and s[left] == s[left + 1]:
                left+=1
            if left == right:
                return 0
            left+=1
            while left < right and s[right] == s[right - 1]:
                right-=1
            right-=1
        return right - left + 1
		
``",Medium,17,502,0.0,3,3.0,5.0,29.529411764705884,34.0,3.5823529411764703
1187.0,maximum number of events that can be attended ii,"class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        n=len(events)
        events.sort()
        @lru_cache(None)
        def dfs(ind,k):
            if ind==n or k==0:
                return 0
            ans=dfs(ind+1,k)
            nextInd=bisect.bisect_left(events,[events[ind][1]+1])
            ans=max(ans,events[ind][2]+dfs(nextInd,k-1))
            return ans
        return dfs(0,k)",Hard,12,427,0.0,-1,3.0,1.0,35.583333333333336,25.0,4.177499999999999
1188.0,check if array is sorted and rotated,"class Solution:
    
    def check(self, nums: List[int]) -> bool:
        res = 0
        n = len(nums)
        for i in range(n):
            if nums[i] > nums[(i+1) % n]:
                res += 1
        return res <= 1",Easy,8,222,0.0,2,3.0,2.0,27.75,13.0,5.9025
1189.0,maximum score from removing stones,"class Solution:
    def maximumScore(self, a: int, b: int, c: int) -> int:
        a, b, c = sorted((a, b, c))
        
        if a + b <= c:
            return a + b
        
        return a + (b + c - a) // 2",Medium,7,212,0.0,0,2.0,1.0,30.285714285714285,17.0,5.454285714285715
1190.0,largest merge of two strings,"class Solution:
    def largestMerge(self, w1: str, w2: str) -> str:
        
        def dfs(m, w1, w2):
            if not w1 or not w2:
                return m + (w1 if w1 else w2)
            if w1 >= w2:
                return dfs(m+w1[0], w1[1:], w2)
            elif w1 < w2:
                return dfs(m+w2[0], w1, w2[1:])
            #else:
                #return max(dfs(m+w1[0], w1[1:], w2), dfs(m+w2[0], w1, w2[1:]))
        return dfs("""", w1, w2)",Medium,12,461,2.0,-1,3.0,4.0,38.41666666666666,32.0,3.3025
1191.0,closest subsequence sum,"class Solution:
    def solve(self, nums, i, val, sums):
        if i == len(nums):
            sums.append(val)
            return
        self.solve(nums, i+1, val+nums[i], sums)
        self.solve(nums, i+1, val, sums)
        
    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        n = len(nums)
        sum1, sum2 = [], []
        self.solve(nums[:n//2], 0, 0, sum1)
        self.solve(nums[n//2:], 0, 0, sum2)
        
        sum2 = sorted(sum2)
        #print(sum1, sum2)
        n2 = len(sum2)
        ans = float(""inf"")
        for s in sum1:
            rem = goal-s
            i = bisect_left(sum2, rem)
            if i < n2:
                ans = min(ans, abs(rem-sum2[i]))
            if i > 0:
                ans = min(ans, abs(rem-sum2[i-1]))
        return ans",Hard,25,800,1.0,3,3.0,5.0,32.0,50.0,1.799999999999999
1192.0,minimum changes to make alternating binary string,"class Solution:
    def minOperations(self, s: str) -> int:
        return min((cnt := s[::2].count('1') + s[1::2].count('0')), len(s) - cnt)",Easy,2,141,0.0,0,2.0,0.0,70.5,12.0,2.335
1193.0,count number of homogenous substrings,"class Solution:
    def countHomogenous(self, s: str) -> int:
        cnt = 0
        i = 0
        j = 1
        
        while j < len(s):
            if s[i] != s[j]:
                diff = j-i
                cnt += ((diff) * (diff+1)) // 2
                i = j
                j += 1
            
            else:
                j += 1
        
        diff = j-i
        cnt += ((diff) * (diff+1)) // 2
        
        return cnt % ((10**9) + 7)",Medium,19,455,0.0,2,3.0,8.0,23.94736842105263,20.0,5.544736842105263
1194.0,minimum limit of balls in a bag,"class Solution:
    def minimumSize(self, nums: List[int], maxOperations: int) -> int:
        l = 1
        r = max(nums)
        
        while l < r:
            mid = l + (r-l) // 2
            count = self.count(mid,nums)
            if count <= maxOperations:
                r = mid
            else:
                l = mid+1
        return r  # or l
    
    
    def count(self,n,arr):
        return sum((a-1) // n for a in arr)",Medium,16,439,1.0,1,3.0,3.0,27.4375,23.0,5.030625000000001
1195.0,minimum degree of a connected trio in a graph,"class Solution:
    def getAdjLists(self, edges):
        adj = defaultdict(list)
        for u,v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return adj
    def getAdjSets(self, edges):
        adj = defaultdict(set)
        for u,v in edges:
            adj[u].add(v)
            adj[v].add(u)
        return adj
    
    def minTrioDegree1TLE(self, n: int, edges: List[List[int]]) -> int:
        # somehow compress the trio so it is considered a single node?
        # O(N^3) keep picking random three points, check if trio and 
        res = math.inf

        adj = self.getAdjLists(edges)
        adjSet = self.getAdjSets(edges)
        
        for u in range(1,n+1):
            for v in adj[u]:
                for choice in adj[v]:
                    if choice in adjSet[u] or u in adjSet[choice]: 
                        # it is a common point!
                        res = min(res, len(adj[u]) + len(adj[v]) + len(adj[choice]) - 3)
        return res if res < math.inf else -1
    
    def minTrioDegree2TLE(self, n: int, edges: List[List[int]]) -> int:
        # O(EN) pick any random two connected points(edge), search for 
        # possible third points e.g. [1,2] is an edge so adj[1] intersect adj[2]
        res = math.inf
        # after getting this how to get the degree?
        # len(adj[1]) + len(adj[2]) + len(adj[3]) - 6 (the trio edges)
        adj = self.getAdjSets(edges)
        for u,v in edges:
            # search for all the 'trio' points
            for trio_point in adj[u] &amp; adj[v]:
                res = min(res, len(adj[u]) + len(adj[v]) + len(adj[trio_point]) - 3 - 3)
                
        return res if res < math.inf else -1
    
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        # O(N^3) pick any random two connected points(edge), search for 
        res = math.inf
        adj = self.getAdjSets(edges)

        for u in range(1,n+1):
            for v in range(u+1, n+1):
                for trio_point in range(v+1, n+1):
                    if v in adj[u] and trio_point in adj[u] and trio_point in adj[v]:
                        res = min(res, len(adj[u]) + len(adj[v]) + len(adj[trio_point]) - 3 - 3)
        
        return res if res < math.inf else -1",Hard,55,2274,9.0,8,3.0,19.0,41.345454545454544,64.0,-0.4210909090909105
1196.0,longest nice substring,"class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        def isNice(s):
            pivot = -1
            if len(s) < 2:
                return ["""", 0]
            unorderedSet = set([x for x in s])
            for i in range(len(s)):
                if ord(s[i])<96:
                    if s[i].lower() not in unorderedSet:
                        pivot = i
                else:
                    if s[i].upper() not in unorderedSet:
                        pivot = i                        
            if pivot>=0:
                if pivot == len(s)-1:
                    return isNice(s[:pivot])
                a = isNice(s[:pivot])
                b = isNice(s[pivot+1:])            
                return a if a[1]>=b[1] else b
            else:
                print(s, len(s))
                return [s, len(s)]
        [x1, x2] = isNice(s)
        return x1",Easy,24,891,0.0,3,5.0,9.0,37.125,38.0,2.37875
1197.0,form array by concatenating subarrays of another array,"class Solution:
    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
        groups_n = sum(len(group) for group in groups)
        nums_n = len(nums)
        
        if groups_n > nums_n:
            return False
        
        i = 0
        for group in groups:
            n = len(group)
            while nums_n - i >= n:
                if nums[i:i+n] == group:
                    break
                i += 1
            if nums_n - i < n:
                return False
            else:
                i += n
        return True",Medium,19,561,0.0,2,3.0,6.0,29.526315789473685,27.0,4.342631578947368
1198.0,map of highest peak,"class Solution:
    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
        queue = deque()
        rows = len(isWater)
        cols = len(isWater[0])
        
        for i in range(rows):
            for j in range(cols):
                if isWater[i][j] == 1:
                    queue.append((i,j))
                    isWater[i][j] = 0 # set height of water as 0
                else:
                    isWater[i][j] = '$' # mark the land
                    
        while queue:
            row, col = queue.popleft()
            
            for x, y in [(0,1),(1,0),(0,-1),(-1,0)]:
                nRow = row + x
                nCol = col + y
                
                if 0<=nRow<rows and 0<=nCol<cols and isWater[nRow][nCol] == '$':
                    isWater[nRow][nCol] = isWater[row][col]+1
                    queue.append((nRow, nCol))
                    
        return isWater",Medium,25,925,2.0,6,4.0,6.0,37.0,44.0,1.75
1199.0,tree of coprimes,"class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        
        gcdset = [set() for i in range(51)]
        for i in range(1,51):
            for j in range(1,51):
                if math.gcd(i,j) == 1:
                    gcdset[i].add(j)
                    gcdset[j].add(i)
        
        graph = defaultdict(list)
        for v1, v2 in edges:
            graph[v1].append(v2)
            graph[v2].append(v1)
        
        ans = [-1]*len(nums)
        q = [[0, {}]]
        seen = set([0])
        depth = 0
        while q:
            temp = []
            for node, ancestors in q:
                index_depth = (-1,-1)
                for anc in list(ancestors.keys()):
                    if anc in gcdset[nums[node]]:
                        index, d = ancestors[anc]
                        if d > index_depth[1]:
                            index_depth = (index,d)
                ans[node] = index_depth[0]
                
                copy = ancestors.copy()
                copy[nums[node]] = (node,depth)
                
                for child in graph[node]:
                    if child not in seen:
                        seen.add(child)
                        temp.append([child, copy])
            q = temp
            depth += 1
        return ans
'''

**:)**",Hard,42,1346,0.0,11,4.0,12.0,32.04761904761905,49.0,1.3157142857142858
1200.0,merge strings alternately,"class Solution(object):
    def mergeAlternately(self, word1, word2):
        """"""
        :type word1: str
        :type word2: str
        :rtype: str
        """"""
        # edge cases - 
        if word1 is None:
            return word2
        if word2 is None:
            return word1
        if word1 is None and word2 is None:
            return """"
        else:
            strr = """"
            l1 = len(word1)
            l2 = len(word2)
            for (i,j) in zip(range(l1), range(l2)):
                strr +=word1[i]
                strr +=word2[j]
            if i!=l1-1:
                strr += word1[i+1:]
            if j!=l2-1:
                strr += word2[j+1:]
            #print(strr)
            return strr",Easy,26,732,2.0,3,3.0,6.0,28.15384615384616,30.0,4.186153846153847
1201.0,minimum number of operations to move all balls to each box,"class Solution:
    def minOperations(self, b: str) -> List[int]:
        l=[]
        for i in range(len(b)):
            a=0
            for j in range(len(b)):
                if(i!=j and b[j]==""1""):
                    a+=abs(j-i)
            l.append(a)
        return l",Medium,9,275,0.0,2,3.0,3.0,30.55555555555556,15.0,5.45
1202.0,maximum score from performing multiplication operations,"class Solution:
    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        m, n = len(multipliers), len(nums)
        # let dp[i][j] denote the maximum score using the first i elements
        # and last j elements from nums
        dp = [[-float(""inf"")]*(m+1) for _ in range(m+1)]
        
        # initialization, populate the first row and column of the
        # dp table
        dp[0][0] = 0
        for i in range(1, m+1):
            dp[i][0] = dp[i-1][0]+multipliers[i-1]*nums[i-1]
            dp[0][i] = dp[0][i-1]+multipliers[i-1]*nums[-i]
        
        # state transition, populate the dp table inward
        # dp[n_left][n_right] = max(score if the last num used was from the left,
        #                           score if the last num used was from the right)
        ret = -float(""inf"")
        for n_used in range(1, m+1):
            for n_left in range(n_used+1):
                n_right = n_used-n_left
                dp[n_left][n_right] = max(dp[n_left-1][n_right]+multipliers[n_used-1]*nums[n_left-1],
                                          dp[n_left][n_right-1]+multipliers[n_used-1]*nums[-n_right])
                if n_used == m:
                    ret = max(ret, dp[n_left][n_right])
                    
        return ret",Hard,26,1286,7.0,4,4.0,7.0,49.46153846153846,33.0,2.048461538461539
1204.0,count items matching a rule,"class Solution(object):
  def countMatches(self, items, ruleKey, ruleValue):
    output = 0
    itemsi = [""type"",""color"",""name""]
    ruleKey = itemsi.index(ruleKey)
    for i in items:
      if i[ruleKey] == ruleValue:
        output += 1
    return output",Easy,8,256,0.0,2,1.0,2.0,32.0,16.0,5.34
1205.0,closest dessert cost,"class Solution:
    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:        
        @lru_cache(None)
        def dp(t, i):
            if t <= 0 or i == len(toppingCosts):
                return t
            
            useOne = dp(t - toppingCosts[i], i + 1)
            if useOne == 0:
                return 0
            useTwo = dp(t - toppingCosts[i] * 2, i + 1)
            if useTwo == 0:
                return 0
            useNone = dp(t, i + 1)
            if useNone == 0:
                return 0
            
            minimum = min((abs(useOne), -useOne), (abs(useTwo), -useTwo), (abs(useNone), -useNone))
            return -minimum[1]
        
        minimum = float('inf')
        for b in baseCosts:
            toFind = target - b
            res = b + toFind - dp(toFind, 0)
            minimum = min((abs(target - minimum), minimum), (abs(target - res), res))[1]
            if minimum == target:
                return minimum
        
        return minimum",Medium,28,1029,0.0,0,3.0,6.0,36.75,54.0,1.1125000000000007
1206.0,equal sum arrays with minimum number of operations,"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
                        
        # Get the delta
        # We want sum(nums1) > sum(nums2) so we can use logic below
        delta = sum(nums1) - sum(nums2) 
        if delta < 0:
            nums1, nums2 = nums2, nums1
            delta = -delta
            
        # Dumb edge case
        if delta == 0: return 0
            
        # Their ranges do not overlap, impossible to return result
        if len(nums1)*1 > len(nums2)*6: return -1
        
        # Calculate the max subtractions
        max_subtract = collections.defaultdict(int)        
        for i in nums1: max_subtract[i-1] += 1
        for j in nums2: max_subtract[6-j] += 1
            
        # Greedily subtract from delta
        result = 0
        for val, count in sorted(max_subtract.items(), key = lambda x: x[0], reverse=True):
            for _ in range(count):                
                delta -= min(val, delta)
                result += 1       
                if delta == 0:
                    return result
                    
        return result",Medium,30,1136,6.0,4,3.0,8.0,37.86666666666667,43.0,2.112
1207.0,car fleet ii,"class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        times = [float(-1) for _ in range(len(cars))]
        for i in range(1, len(cars)):
            if cars[i-1][1] > cars[i][1]:
                times[i-1] = self.timeToCollide(cars, i-1, i)
        for i in range(len(cars)-3, -1, -1):
            if times[i+1] == - 1.0: continue
			# if car[i+1] collided before car[i], then we have to adjust times[i]
            if times[i] > times[i+1]:
                times[i] = self.correctTime(cars, times, i)
                cars[i+1][1] = cars[i+2][1]
			# if car[i+1] collided and speed became slower than cars[i], then we also have to adjust times[i]
            elif cars[i][1] <= cars[i+1][1] and times[i+1] > 0.0:
                if cars[i][1] > cars[i+2][1]:
                    times[i] = self.timeToCollide(cars, i, i+2)
        return times
        
    def timeToCollide(self, cars, i, j): 
        return (cars[j][0]-cars[i][0])/(cars[i][1] - cars[j][1])
    def correctTime(self, cars, times, i):
        return times[i+1] + (times[i]-times[i+1])*(cars[i][1] - cars[i+1][1])/(cars[i][1] - cars[i+2][1])",Hard,21,1150,2.0,4,3.0,11.0,54.76190476190476,45.0,0.2314285714285731
1208.0,find nearest point that has the same x or y coordinate,"class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        
		def manhattan_dist(x1, y1, x2, y2):
            return abs(x1-x2) + abs(y1-y2)
        
		# It's always handy to initialize using float('inf') or float('-inf') if you want really
		# large or small numbers! :)
        min_dist = float('inf')
        min_idx = -1
        
        for i in range(len(points)):
			# If coordinate is valid, then do checks on manhattan_dist
            if points[i][0] == x or points[i][1] == y:
			
				# If the valid coordinate is smaller, then update the index and min_dist
				dist = manhattan_dist(x, y, points[i][0], points[i][1])
                if min_dist > dist:
                    min_dist = dist
                    min_idx = i
                
        return min_idx",Easy,21,818,4.0,2,2.0,6.0,38.95238095238095,34.0,3.0142857142857142
1209.0,check if number is a sum of powers of three,"class Solution:
    def checkPowersOfThree(self, n: int) -> bool:
        
        '''
        Here we make a ternary representation of given n
        If n has '2' in it return False, else return True
        [See: hint]
        '''
        
        ternary = ''                       #ternary string is the reverse representation of original ternary
        
        while n>0:
            ternary+=str(n%3)              #ternary means base 3
            n=n//3
            
        if '2' in ternary:
            return False
        return True",Medium,17,548,3.0,-1,3.0,3.0,32.23529411764706,13.0,5.798823529411765
1210.0,sum of beauty of all substrings,"class Solution(object):
    def beautySum(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        res = 0
        h = [0 for _ in range(26)]
        for i in range(len(s)):
            h = [0 for _ in range(26)]
            for j in range(i, len(s)):
                h[ord(s[j]) - ord('a')] += 1
                minv, maxv = 501, -1
                for x in h:
                    if x > 0:
                        minv = min(minv, x)
                        maxv = max(maxv, x)
                res += maxv - minv
        return res",Medium,18,559,0.0,4,4.0,6.0,31.05555555555556,25.0,4.225
1211.0,count pairs of nodes,"class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        degree = [0]*n
        freq = defaultdict(int)
        for u, v in edges: 
            degree[u-1] += 1
            degree[v-1] += 1
            freq[min(u-1, v-1), max(u-1, v-1)] += 1
        
        vals = sorted(degree)
        
        ans = []
        for query in queries: 
            cnt = 0 
            lo, hi = 0, n-1
            while lo < hi: 
                if query < vals[lo] + vals[hi]: 
                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid
                    hi -= 1
                else: lo += 1
            for u, v in freq: 
                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1
            ans.append(cnt)
        return ans",Hard,23,839,1.0,6,3.0,6.0,36.47826086956522,48.0,1.4169565217391291
1212.0,check if binary string has at most one segment of ones,"class Solution:
def checkOnesSegment(self, s: str) -> bool:
    flag=0
    for i in s:
        if i=='1' and flag==1:
            return False 
        elif i=='0':
            flag=1
            
    return True",Easy,9,212,0.0,2,2.0,3.0,23.55555555555556,19.0,5.739999999999999
1213.0,minimum elements to add to form a given sum,"class Solution:
def minElements(self, nums: List[int], limit: int, goal: int) -> int:
    return abs(goal-sum(nums))//limit+(abs(goal-sum(nums))%limit!=0)*1",Medium,2,156,0.0,0,1.0,0.0,78.0,10.0,1.92
1214.0,number of restricted paths from first to last node,"class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        # Dijkstra's algorithm
        distances = {i: float('inf') for i in range(1, n+1)}
        distances[n] = 0
        graph = defaultdict(list)
        for edge in edges:
            graph[edge[0]].append((edge[1], edge[2]))
            graph[edge[1]].append((edge[0], edge[2]))
        pq = [(0, n)]
        while len(pq) > 0:
            curDistance, curVertex = heapq.heappop(pq)
			# skip the following steps if we've already visited the vertex
            if curDistance > distances[curVertex]:
                continue
            for edge in graph[curVertex]:
                neighbor = edge[0]
                weight = edge[1]
                distance = curDistance + weight
                # update neighbor's distance if the path via cur node has a shorter distance
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
		# Bottom-up DP
        # initialize dp array, which stores how many restricted paths between endnode and curnode
        dp = [0]*(n+1)
        dp[n] = 1
        dist = sorted(list(distances.keys()), key=lambda item:distances[item])
        for index in dist:
            neighbors = [edge[0] for edge in graph[index]]
            for neighbor in neighbors:
                if distances[neighbor] < distances[index]:
                    dp[index] += dp[neighbor]
                    dp[index] = int(dp[index]%(1e9+7))
            # when we've reached node 1 (start node), we could return the result
            if index == 1:
                return dp[1]
        return -1",Medium,37,1711,6.0,6,3.0,13.0,46.24324324324324,51.0,0.4381081081081088
1215.0,make the xor of all segments equal to zero,"class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        freq = defaultdict(lambda: defaultdict(int))
        for i, x in enumerate(nums): freq[i%k][x] += 1 # freq by row
        
        n = 1 << 10
        dp = [0] + [-inf]*(n-1)
        for i in range(k): 
            mx = max(dp)
            tmp = [0]*n
            for x, c in enumerate(dp): 
                for xx, cc in freq[i].items(): 
                    tmp[x^xx] = max(tmp[x^xx], c + cc, mx)
            dp = tmp 
        return len(nums) - dp[0]",Hard,14,535,1.0,4,3.0,4.0,38.21428571428572,27.0,3.480714285714286
1216.0,check if one string swap can make strings equal,"class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if not set(s1) == set(s2):
            return False
        return sum(1 for i in range(len(s1)) if not s1[i] == s2[i]) < 3",Easy,4,203,0.0,0,2.0,3.0,50.75,15.0,3.8125
1217.0,find center of star graph,"class Solution:
    def findCenter(self, edge: List[List[int]]) -> int:
        if edge[0][0] in edge[1]:
            return edge[0][0]
        else:
            return edge[0][1]",Easy,5,179,0.0,0,3.0,1.0,35.8,7.0,5.898000000000001
1218.0,maximum average pass ratio,"class Solution:
    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
        heap_classes = []
        for p, t in classes:
            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))
        for _ in range(extraStudents):
            diff, p, t = heappop(heap_classes)
            p += 1
            t += 1
            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))
        return sum(p / t for d, p, t in heap_classes) / len(classes)",Medium,10,495,0.0,2,3.0,4.0,49.5,24.0,2.845
1219.0,maximum score of a good subarray,"class Solution:
    def maximumScore(self, n: List[int], kk: int) -> int:
        
        vmin = n[kk]
        for i in range(kk,-1,-1):
            if n[i]<vmin:
                vmin = n[i]
            else:
                n[i] = vmin

        vmin = n[kk]
        for i in range(kk,len(n)):
            if n[i]<vmin:
                vmin = n[i]
            else:
                n[i] = vmin

        good = 0
        li = 0
        ri = len(n)-1
        while li<=kk and ri>= kk:
            vmin = min(n[li],n[ri])
            if vmin*(ri-li+1)>good:
                good = min(n[li],n[ri])*(ri-li+1)
            
            if li == ri:
                break
                
            while li<kk and n[li]==vmin:
                li += 1
                
            while ri>kk and n[ri]==vmin:
                ri -= 1
            
        
        return good",Hard,35,871,0.0,8,3.0,9.0,24.88571428571429,54.0,1.7002857142857142
1220.0,second largest digit in a string,"class Solution:
    def secondHighest(self, s: str) -> int:
        seen = set()
        for c in s: 
            if c.isdigit(): 
                seen.add(int(c))
        return -1 if len(seen) < 2 else sorted(seen)[-2]",Easy,6,220,0.0,2,3.0,3.0,36.66666666666666,9.0,5.5
1221.0,maximum number of consecutive values you can make,"class Solution:
    def getMaximumConsecutive(self, coins: List[int]) -> int:
        ans = 1
        for x in sorted(coins): 
            if ans < x: break 
            ans += x
        return ans",Medium,6,197,0.0,1,3.0,2.0,32.833333333333336,10.0,5.805000000000001
1222.0,maximize score after n operations,"class Solution:
    def maxScore(self, nums: List[int]) -> int:
        def combination(count=1, bitmask=0):
            if count==size//2+1:
                return 0
            max_ = 0
            for i in range(size):
                if bitmask>>i&amp;1:
                    continue
                newBitmask = bitmask|1<<i
                for j in range(size):
                    if newBitmask>>j&amp;1:
                        continue
                    newBitmask = bitmask|1<<i|1<<j
                    if dp[newBitmask]:
                        max_ = max(max_, table[i][j]*count+dp[newBitmask])
                    else:
                        max_ = max(max_, table[i][j]*count+combination(count+1, newBitmask))
            dp[bitmask] = max_
            return max_
        size = len(nums)
        dp = [0]*(2**size)
        table = [[0]*size for i in range(size)]
        for i in range(size):
            for j in range(i+1, size):
                table[i][j] = table[j][i] = math.gcd(nums[i], nums[j])
        return combination()",Hard,26,1052,0.0,4,4.0,9.0,40.46153846153846,47.0,1.1784615384615371
1223.0,maximum ascending subarray sum,"class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        total = 0
        max_total = 0
        i = 0

        while i < len(nums):
            if nums[i] <= nums[i-1]:
                total = 0
            total += nums[i]
            max_total = max(total, max_total)
            i += 1
        return max_total",Easy,12,336,0.0,2,3.0,2.0,28.0,18.0,5.38
1224.0,number of orders in the backlog,"class Solution:
    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:
        backlog = defaultdict(list)
        for price, amount, ordertype in orders:
            #sell
            if ordertype == 1:
                if backlog[0]:
                    condition = True
                    while condition and backlog[0]:
                        bp, ba = heapq.heappop(backlog[0])
                        if -bp >= price:
                            if amount < ba:
                                ba -= amount
                                amount = 0
                                heapq.heappush(backlog[0], [bp, ba])
                                condition = False
                            elif amount > ba:
                                amount -=ba 
                            else:
                                amount = 0
                        else:
                            heapq.heappush(backlog[0], [bp,ba])
                            heapq.heappush(backlog[1], [price, amount])
                            amount = 0
                            condition = False
                    if amount:
                        heapq.heappush(backlog[1], [price, amount])
                else:
                    heapq.heappush(backlog[1], [price, amount])
            #buy
            if ordertype == 0:
                if backlog[1]:
                    condition = True
                    while condition and backlog[1]:
                        sp, sa = heapq.heappop(backlog[1])
                        if sp <= price:
                            if amount < sa:
                                sa -= amount
                                amount = 0
                                heapq.heappush(backlog[1], [sp, sa])
                                condition = False
                            elif amount > sa:
                                amount -=sa
                            else:
                                amount = 0
                        else:
                            heapq.heappush(backlog[1], [sp, sa])
                            heapq.heappush(backlog[0], [-price, amount])
                            amount = 0
                            condition = False
                    if amount:
                        heapq.heappush(backlog[0], [-price, amount])
                else:
                    heapq.heappush(backlog[0], [-price, amount])
            #print(backlog[0], backlog[1])
        res = 0
        for i,j in backlog[0]:
            res += j
        for i,j in backlog[1]:
            res += j
        return res % (10**9 + 7)",Medium,60,2616,3.0,17,6.0,17.0,43.6,91.0,-4.283999999999999
1225.0,maximum value at a given index in a bounded array,"class Solution:

    @classmethod
    def min_area(cls, len_arr, idx, target):
        if target + idx >= len_arr:
            sum_r = (2 * target - len_arr + idx) * (len_arr - 1 - idx) // 2
        else:
            sum_r = target * (target - 1) // 2 + len_arr - idx - target
        if target - idx >= 1:
            sum_l = (2 * target - 1 - idx) * idx // 2
        else:
            sum_l = target * (target - 1) // 2 + idx - target + 1
        return sum_l + sum_r + target

    def maxValue(self, n: int, index: int, maxSum: int) -> int:
        left, right = 1, maxSum - n + 2
        while left + 1 < right:
            middle = (left + right) // 2
            if Solution.min_area(n, index, middle) <= maxSum:
                left = middle
            else:
                right = middle
        return left",Medium,22,817,0.0,3,3.0,4.0,37.13636363636363,39.0,2.3977272727272734
1226.0,number of different integers in a string,"class Solution:
    def numDifferentIntegers(self, word: str) -> int:
        nums = ""0123456789""
        for i in range(len(word)):
            if word[i] not in nums:
                word = word.replace(word[i], "" "")
    
        w = word.split()
        for i in range(len(w)):
            w[i] = int(w[i])
        w = set(w)
       return len(w)",Easy,11,349,0.0,3,3.0,4.0,31.727272727272727,14.0,5.384545454545455
1227.0,minimum number of operations to reinitialize a permutation,"class Solution:
    def reinitializePermutation(self, n: int) -> int:
        perm=[i for i in range(n)]
        op=list(perm)
        arr=[0]*n
        c=0
        nn=n//2
        
        while arr!=op:
            for i in range(n):
                if i%2 == 0:
                    arr[i] = perm[i // 2]
                else:
                    arr[i] = perm[int(nn + (i - 1) // 2)]
            perm = list(arr)

            c+=1
        return c",Medium,17,450,0.0,3,3.0,4.0,26.47058823529412,22.0,5.05764705882353
1228.0,evaluate the bracket pairs of a string,"class Solution:
    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        answers = {}
        keys = [n.split('(')[-1] for n in s.split(')')][:-1]
        
        for k, v in knowledge:
            answers[k] = v

        for key in keys:
            s = s.replace(f'({key})', answers.get(key, '?'))

        return s",Medium,11,336,0.0,3,2.0,3.0,30.545454545454547,17.0,5.250909090909091
1229.0,maximize number of nice divisors,"class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        mod = 1_000_000_007
        if primeFactors % 3 == 0: return pow(3, primeFactors//3, mod)
        if primeFactors % 3 == 1: return 1 if primeFactors == 1 else 4*pow(3, (primeFactors-4)//3, mod) % mod
        return 2*pow(3, primeFactors//3, mod) % mod",Hard,5,332,0.0,0,2.0,3.0,66.4,23.0,1.604000000000001
1230.0,determine color of a chessboard square,"class Solution:
    def squareIsWhite(self, c: str) -> bool:
        return True if (ord(c[0])-96 + int(c[1]))%2!=0 else False",Easy,2,126,0.0,0,2.0,1.0,63.0,6.0,3.61
1231.0,sentence similarity iii,"class Solution:
    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        # this is the solution for comparing char-wise, but the question is asking for word-wise :(
        #############################################################################
        # According to the 'similarity' definition given, 
        # if we can insert some chars (could be empty) to make 
        # inserted sentence1 == sentence2 (assume len(sentence1) <= len(sentence2))
        #############################################################################
        # Idea: 
        #       view sentence 1 as prefix + arbitrary sentence to insert (possibly empty) + suffix 
        #       view sentence 2 as prefix + middle chars + suffix 
        # 1. compare sentence1 and sentence2 until they are not matched (it is prefix)
        # 2. rest of sentence2 is suffix -> if this suffix exists in sentence1 -> similar (otherwise not)
        ''' this is the solution for comparing char-wise, but the question is asking for word-wise :(
        if len(sentence1) == len(sentence2):
            return sentence1 == sentence2 
        
        # make sure sentence1 has shorted length 
        if len(sentence1) > len(sentence2):
            sentence1, sentence2 = sentence2, sentence1

        # find the end of prefix 
        # if char is unmatched => compare suffix
        for idx, c in enumerate(sentence1):
            if not (c == sentence2[idx]):
                return sentence1[idx:] == sentence2[-(len(sentence1)-idx):]
        return True 
        '''
        
        # adjust from our char-wise solution
        # w for word 
        s1 = sentence1.split() 
        s2 = sentence2.split() 
        if len(s1) == len(s2):
            return all([w1==w2 for (w1, w2) in zip(s1, s2)])
        
        # make sure sentence1 has shorted length 
        if len(s1) > len(s2):
            s1, s2 = s2, s1 

        # find the end of prefix &amp; compare suffix 
        for idx, w in enumerate(s1):
            if not (w == s2[idx]):
                return all([w1==w2 for (w1, w2) in zip(s1[idx:], s2[-(len(s1)-idx):])])
        return True",Medium,44,2160,16.0,6,3.0,18.0,49.09090909090909,74.0,-1.718181818181817
1232.0,count nice pairs in an array,"class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        ans = 0 
        freq = defaultdict(int)
        for x in nums: 
            x -= int(str(x)[::-1])
            ans += freq[x]
            freq[x] += 1
        return ans % 1_000_000_007",Medium,8,264,0.0,1,3.0,1.0,33.0,13.0,5.490000000000001
1233.0,maximum number of groups getting fresh donuts,"class Solution:
    def maxHappyGroups(self, bs: int, gs: List[int]) -> int:
        c = {i: 0 for i in range(bs)}
        for g in gs:
            c[g % bs] += 1
        ret = c[0]
        c[0] = 0
        
        
        def get_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        def get_diff_keys(num):
            keys = []
            def rec(stack):
                if len(stack) == num:
                    if sum(stack) % bs == 0:
                        keys.append(Counter(stack))
                else:
                    for i in range(stack[-1] - 1 if stack else bs - 1, - 1, - 1):
                        stack.append(i)
                        rec(stack)
                        stack.pop()
            rec([])
            return keys
        
        for tc in range(2, bs):
            for keys in get_diff_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
        tc = 2
        while True:
            for keys in get_keys(tc):
                add = min(c[key] // keys[key] for key in keys)
                if add == 0: continue
                ret += add
                for key in keys:
                    c[key] -= add * keys[key]
            if tc > sum(c.values()): break
            tc += 1
        return ret + bool(sum(c.values()))
            
        ```",Hard,56,1870,0.0,11,4.0,23.0,33.392857142857146,68.0,-0.7053571428571441
1234.0,truncate sentence,"class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        return ' '.join(s.split()[0:k])",Easy,2,110,0.0,0,2.0,0.0,55.0,8.0,4.13
1235.0,finding the users active minutes,"class Solution:
    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        log = defaultdict(set)
        for x, y in logs:
            log[x].add(y)
        
        output = [0]*k
        for i in log.values():
            output[len(i)-1] += 1
        
        return output",Medium,10,311,0.0,2,3.0,2.0,31.1,13.0,5.601
1236.0,minimum absolute sum difference,"class Solution:
    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:
        
        n = len(nums1)
        MOD = 10**9+7
        
        # Maintain a MAX heap defined as structure - (abs_diffi, nums1[i], nums[j])
        heap = []
        abs_sum = 0
        for i in range(n):
            abs_diff = abs(nums1[i]-nums2[i])
            abs_sum = (abs_sum+abs_diff)%MOD
            heapq.heappush(heap,(-abs_diff, nums1[i], nums2[i])) # note the -ve sign to make it max_heap
        
        print(heap)
        
        # Get the element with max absolute difference from heap
        top = heapq.heappop(heap)
        abs_sum -= abs(top[0]) # subtract previous abs_diff as we'll update it below
        k = top[2]
        
        # find a new_val closest to k
        # and min_diff is the new absoulte diff with k
        min_diff = abs(top[0])
        new_val = 0
        for num1 in nums1:
            new_diff = abs(num1-k)
            if new_diff<min_diff:
                min_diff = new_diff
                new_val = num1
        
        # add the new diff to calculate updated sum
        abs_sum = (abs_sum+min_diff)%MOD
        
        return abs_sum",Medium,34,1191,7.0,3,3.0,20.0,35.029411764705884,31.0,3.667352941176471
1237.0,number of different subsequences gcds,"class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        nums = set(nums)
        
        ans = 0
        m = max(nums)
        for x in range(1, m+1): 
            g = 0
            for xx in range(x, m+1, x): 
                if xx in nums: 
                    g = gcd(g, xx)
            if g == x: ans += 1
        return ans",Hard,12,366,0.0,4,3.0,5.0,30.5,22.0,4.635
1238.0,sign of the product of an array,"class Solution:
    def arraySign(self, nums: List[int]) -> int:
        if 0 in nums:
            return 0
        count = 1
        for i in nums:
            if i < 0:
                count *= -1
        return count",Easy,8,219,0.0,2,3.0,3.0,27.375,11.0,6.13625
1239.0,find the winner of the circular game,"class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        class Node:
            def __init__(self,val):
                self.prev = None
                self.next = None
                self.val = val
        
        head = Node(1)
        temp = head
        i = 2
        while i<n:
            nnode = Node(i)
            temp.next = nnode
            nnode.prev = temp
            temp = temp.next
            i += 1
        lastnode = Node(n)
        temp.next = lastnode
        lastnode.prev = temp
        lastnode.next = head
        head.prev = lastnode
        
        
        ##game
        start,prevnode = head,head.prev
        while start:
            if start == start.next:                             #case to check if this node is the winner
                return start.val
            i = 1
            while i<k:                                             #move k number of steps 
                prevnode = start
                start = start.next
                i += 1
            
            #delete this node
            p = start.next
            prevnode.next = p
            p.prev = prevnode
            start = p",Medium,39,1170,4.0,4,4.0,5.0,30.0,46.0,2.379999999999999
1240.0,minimum sideway jumps,"class Solution:
    def minSideJumps(self, obstacles: List[int]) -> int:
        lanes = [1, 0, 1]
        for obstacle_id in obstacles:
            if obstacle_id == 0:
                lanes[0] = min(lanes[0], lanes[1] + 1, lanes[2] + 1)
                lanes[1] = min(lanes[1], lanes[0] + 1, lanes[2] + 1)
                lanes[2] = min(lanes[2], lanes[0] + 1, lanes[1] + 1)
            elif obstacle_id == 1:
                lanes[0] = inf
                lanes[1] = min(lanes[1], lanes[2] + 1)
                lanes[2] = min(lanes[1] + 1, lanes[2])
            elif obstacle_id == 2:
                lanes[1] = inf
                lanes[0] = min(lanes[0], lanes[2] + 1)
                lanes[2] = min(lanes[2], lanes[0] + 1)
            elif obstacle_id == 3:
                lanes[2] = inf
                lanes[0] = min(lanes[0], lanes[1] + 1)
                lanes[1] = min(lanes[1], lanes[0] + 1)
        return min(lanes)",Medium,20,930,0.0,5,4.0,5.0,46.5,49.0,0.3749999999999982
1241.0,minimum operations to make the array increasing,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        minimumOperations = 0
        
        for i in range(1, len(nums)): # Note that for loop starts with index 1 (we skip the index 0)
            if nums[i] <= nums[i-1]:
                oldNumber = nums[i]
                nums[i] = nums[i-1] + 1 # update the current number to new number in the input list
                newNumber = nums[i]
                
                minimumOperations += (newNumber - oldNumber)
                
        return minimumOperations",Easy,12,545,2.0,2,3.0,3.0,45.41666666666666,15.0,4.192500000000001
1242.0,queries on number of points inside a circle,"class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        
        res = []
        for x,y,r in queries:
            rsq = pow(r,2)
            count = 0
            for px,py in points:
                ans = pow(px-x,2)+pow(py-y,2)
                if ans<= rsq:
                    count += 1
            res.append(count)
        return res",Medium,12,400,0.0,3,3.0,3.0,33.333333333333336,23.0,4.34
1243.0,maximum xor for each query,"class Solution:
    '''
    Step 1: Building a xor array.
    eg :[0,1,1,3]
    xor = [0]
    now 0 xor 1 [0,1]
    now 1 xor 1 [0,1,0]
    finally 0 xor 3 [0,1,0,3]
    
    step 2:
    Now to find the value of k at each query we just want to take the len(2^maxbit-1 )so here its 2 digit(maxBit =2 so 2^2 = 4 ) .
    no.of bits in 3 are 2
    value of k will be inverse of xor value[i]
    eg :
    when i = 0 xor[i] = 0 what will be the value of k in this case when bits are 2
    00 xor inverse(00)
    inverse(00) = 11
    hence k = 3
    
    '''
    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:
        xor = []
        maxb = len(bin(pow(2,maximumBit)-1)[2:])
        
        n = len(nums)
        xor.append(nums[0])
        for i in range(1,n):                                        #step 1
            xor.append(nums[i]^xor[i-1])
        
        res = []
        for xor_val in xor: 
            bin_xor_val = list(bin(xor_val)[2:])
            temp = []
            for i in range(maxb-len(bin_xor_val)):                  
                temp.append('1')
            
            for bit in bin_xor_val:                                 #performing inverse of the xor value
                if bit == '0':
                    temp.append('1')
                else:
                    temp.append('0')
            res.append(int(''.join(temp),2))
        
        res.reverse()
        return res",Medium,44,1437,3.0,5,3.0,6.0,32.65909090909091,47.0,2.00068181818182
1244.0,minimum number of operations to make string sorted,"class Solution:
    def makeStringSorted(self, s: str) -> int:
        freq = [0]*26
        for c in s: freq[ord(c) - 97] += 1
        
        MOD = 1_000_000_007
        fac = cache(lambda x: x*fac(x-1)%MOD if x else 1)
        ifac = cache(lambda x: pow(fac(x), MOD-2, MOD)) # Fermat's little theorem (a**(p-1) = 1 (mod p))
        
        ans, n = 0, len(s)
        for c in s: 
            val = ord(c) - 97
            mult = fac(n-1)
            for k in range(26): mult *= ifac(freq[k])
            for k in range(val): ans += freq[k] * mult
            n -= 1
            freq[val] -= 1
        return ans % MOD",Hard,17,622,1.0,4,3.0,7.0,36.588235294117645,28.0,3.527058823529412
1245.0,check if the sentence is pangram,"class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        s=set(sentence)
        if len(s)==26:
            return True
        return False",Easy,5,160,0.0,0,2.0,2.0,32.0,10.0,6.0
1246.0,maximum ice cream bars,"class Solution:
    def maxIceCream(self, costs: List[int], coins: int) -> int:
        if min(costs) > coins:
            return 0
        if sum(costs) < coins:
            return len(costs)
        costs.sort()
        count = 0
        for i in costs:
            if coins < i:
                break
            count += 1
            coins -= i
        return count",Medium,13,370,0.0,1,3.0,4.0,28.46153846153846,17.0,5.498461538461539
1247.0,single threaded cpu,"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        for i in range(len(tasks)):
            tasks[i] = [tasks[i][0],tasks[i][1],i]   #add index into tasks array
        tasks.sort(key = lambda x: (x[0],x[1]))   #sort task according to arrival time and burst time
        cpu_timestamp = tasks[0][0] + tasks[0][1]  #save the current cpu time arrival + burst
        temp = []   #array for heapq operations
        res = [tasks[0][2]] #store the starting index result, this is final since we have sorted and got the optimal
        i = 1
        while i<len(tasks):
            if cpu_timestamp < tasks[i][0]: #cant use a time which is less than current cpu time
                if temp: #process already stored items in heap
                    burst,index,arri = heapq.heappop(temp)
                    res.append(index)
                    cpu_timestamp += burst
                else: #if heap is empty, we need to jump to the next value . This is for case like [100,100],[1000000000,100000000]
                    heapq.heappush(temp, [tasks[i][1],tasks[i][2],tasks[i][0]])
                    i+=1
            if i < len(tasks) and cpu_timestamp >=tasks[i][0]: #store all times that are greater than current cpu time
                heapq.heappush(temp, [tasks[i][1],tasks[i][2],tasks[i][0]])
                i+=1
        while temp: # if we reached the end of tasks array, but still have items in heap, pop one by one
            burst,index,arri = heapq.heappop(temp)
            res.append(index)
        return res",Medium,24,1554,10.0,6,4.0,10.0,64.75,49.0,-0.9274999999999984
1248.0,find xor sum of all pairs bitwise and,"class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        """"""
        (a^b) &amp; (d^e^f) = a&amp;d ^ a&amp;e ^ a&amp;f ^ b&amp;d ^ b&amp;e ^ b&amp;f
        """"""
        N1 = len(arr1)
        N2 = len(arr2)
        tmp1 = 0
        tmp2 = 0
        for i in range(max(N1, N2)):
            if i < N1:
                tmp1 = tmp1^arr1[i]
            if i < N2:
                tmp2 = tmp2^arr2[i]
        return tmp1 &amp; tmp2",Hard,14,459,0.0,3,3.0,3.0,32.785714285714285,20.0,4.689285714285715
1249.0,sum of digits in base k,"class Solution:
    def sumBase(self, num: int, base: int) -> int:
            tot = 0
            base_num = """"
            while num>0:
                dig = int(num%base)
                if dig<10:
                    base_num += str(dig)
                else:
                    base_num += chr(ord('A')+dig-10)  
                num //= base

            base_num = base_num[::-1]  
            tot = 0
            for i in base_num:
                tot += int(i)
            return tot",Easy,16,492,0.0,3,4.0,3.0,30.75,24.0,4.4125
1250.0,frequency of the most frequent element,"class Solution:        
    def maxFrequency(self, nums: List[int], k: int) -> int:
        def freqExists(freq):
            for i in range(freq, n):
                if freq * nums[i-1] - (prefix_sum[i] - prefix_sum[i-freq]) <= k:
                    return True
            return False
        
        nums.sort()
        prefix_sum = [0] + list(accumulate(nums))             
		n = len(prefix_sum)
        l, r = 1, len(nums)+1
        ret = 1

        while l < r:
            mid = (l+r)//2
            if freqExists(mid):
                ret = mid
                l = mid + 1
            else:
                r = mid
                
        return ret",Medium,22,661,0.0,2,3.0,4.0,30.045454545454547,27.0,4.295909090909091
1251.0,longest substring of all vowels in order,"class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        if word == 'aeiou':
            return 5
        def check(s):
            res = ''
            ind = []
            for i,c in enumerate(s):
                if res =='':
                    res+=c
                    ind.append(i)
                elif c == 'a' and res[-1] != c:
                    res+=c
                    ind.append(i)
                elif c == 'u' and res[-1] == c:
                    ind[-1] = i
                elif res[-1] != c:
                    res+=c
                    ind.append(i)
            return ind
        ind = check(word)
        #print(ind)
        mx = 0
        for i in range(len(ind)):
            for j in range(i,i+5):
                if j+4 <len(ind):
                    if (word[ind[j]],word[ind[j+1]],word[ind[j+2]],word[ind[j+3]],word[ind[j+4]]) == ('a','e','i','o','u'):
                        mx = max(mx, ind[j+4]-ind[j]+1)
                        #print(ind[j+4], ind[j])
        return mx",Medium,29,1033,2.0,8,4.0,11.0,35.62068965517241,58.0,0.3541379310344812
1252.0,maximum building height,"class Solution:
    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        if not restrictions:
            return n - 1
        restrictions.append([1, 0])  # Add the restriction for the initial position
        restrictions.sort(key=lambda x: x[1] + x[0])  # Sort by increasing i + h
        idx = 0  # The index in the restrictions array
        max_height = 0
        while idx < len(restrictions):
            pos, h = restrictions[idx]
            idx += 1
            while idx < len(restrictions) and restrictions[idx][1] - restrictions[idx][0] >= h - pos:
				# skip the next restriction if it is ""above"" the line starting from the current one
                idx += 1
            if idx == len(restrictions):
				# Handles the last restriction: fill the line until the last position at n
                max_height = max(max_height, h + n - pos)
                break
            next_pos, next_h = restrictions[idx]
			# A bit of maths gives us the formula for the maximum height between two consecutive
			# restrictions
            max_height = max(max_height, (h + next_h + next_pos - pos) // 2)
        return max_height",Hard,22,1157,7.0,2,3.0,8.0,52.59090909090909,34.0,1.8468181818181824
1253.0,replace all digits with characters,"class Solution:
    def replaceDigits(self, s: str) -> str:
        o=''
        for i in range(0,len(s),2):
            if i!= len(s)-1:
                o+=s[i]+chr((ord(s[i])+int(s[i+1])))
            else:
                o+=s[i]
        return o",Easy,8,249,0.0,2,3.0,2.0,31.125,14.0,5.49875
1254.0,maximum element after decreasing and rearranging,"class Solution:
    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
        arr.sort() # sort the elements
        if arr[0] == 1: # if arr[0] is 1 then simply give pass as it satisfies the 1st condition
            pass
        else: # else make arr[0] to 1 to satisfy condition 1
            arr[0] = 1
        for i in range(len(arr)-1): #run the loop upto length of the array -1 times
            arr[i+1] = min(arr[i+1],arr[i]+1)# assign arr[i+1] to minimum value of arr[i+1], arr[i]+1
        return arr[-1]#return max(arr)",Medium,9,561,6.0,1,3.0,3.0,62.333333333333336,15.0,2.890000000000001
1255.0,closest room,"class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = [0] * len(queries)
        
        # sort queries to handle largest size queries first
        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))

        # sort rooms by descending size
        rooms = deque(sorted(rooms, key=lambda x: -x[1]))

        # current available room ids
        cands = []
        
        
        while q:
            size, room, i = q.popleft()
            # add room ids to candidates as long as top of room size meet the requirements
            while rooms and rooms[0][1] >= size:
                bisect.insort(cands, rooms.popleft()[0])
                    
            # if no room size available, return -1
            if not cands: ans[i] = -1
                
            # else use bisect to find optimal room ids
            else:
                loc = bisect.bisect_left(cands, room)
                if loc == 0: ans[i] = cands[loc]
                elif loc == len(cands): ans[i] = cands[-1]
                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]
        
        return ans",Hard,30,1255,6.0,5,3.0,8.0,41.833333333333336,51.0,0.8949999999999996
1256.0,minimum distance to the target element,"class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        mini = 10**9
        for i,num in enumerate(nums):
            if num == target:
                mini = min(mini,abs(i-start))
        return mini",Easy,6,249,0.0,2,3.0,2.0,41.5,18.0,4.165
1257.0,splitting a string into descending consecutive values,"class Solution:
    def splitString(self, s: str) -> bool:
        
        def fn(i, x): 
            """"""Return True if s[i:] can be split following x.""""""
            if i == len(s): return True 
            if x == 0: return False 
            ans = False 
            for ii in range(i, len(s) - int(i == 0)):
                if x is None or int(s[i:ii+1]) == x - 1: 
                    ans = ans or fn(ii+1, int(s[i:ii+1]))
            return ans 
        
        return fn(0, None)",Medium,13,488,0.0,1,3.0,5.0,37.53846153846154,31.0,3.281538461538462
1258.0,minimum adjacent swaps to reach the kth smallest number,"class Solution:
    def getMinSwaps(self, num: str, k: int) -> int:
        nums = [int(i) for i in num]
        orig = [int(i) for i in num]
        right = len(nums) - 1

        ans = 0
        for _ in range(k):
            for x in range(right, 0, -1):
                if nums[x] > nums[x-1]:
                    iter = x
                    mini = (float('inf'), -1)
                    while iter <= right:
                        # Number should be greater than nums[x-1]
                        # Number should be closer to nums[x-1] than the temp value at mini[0]
                        if nums[iter] > nums[x-1] and (mini[0] - nums[x-1]) > (nums[iter] - nums[x-1]):
                            mini = (nums[iter], iter)
                        iter += 1

                    # Swap the item found at index that is immediately greater than number at x-1
                    nums[x-1], nums[mini[1]] = nums[mini[1]], nums[x-1]
                    ans += (mini[1] - (x-1))

                    # Sort the numbers to the right of swapped number
                    nums[x:] = sorted(nums[x:])
                    # print ("""".join([str(i) for i in nums]))
                    break

        # print (nums, orig)

        i = 0
        count = 0
        
        # minimum number of adjacent swaps to get to nums from orig. 
        # check where the number differs in the array and count the number of swaps to get the right number in the slot. 
        while i < len(nums):
            if nums[i] == orig[i]:
                i+=1
            else:
                j = i
                while nums[i] != orig[j]:
                    j+=1

                while j > i:
                    ## swap the number so that the calculations are correct as you traverse!
                    orig[j-1], orig[j] = orig[j], orig[j-1]
                    j -= 1
                    count += 1

        return count",Medium,49,1907,9.0,8,4.0,13.0,38.91836734693877,58.0,0.337346938775509
1259.0,minimum interval to include each query,"class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        
        # sort queries from small to large
        q = deque(sorted([(x, i) for i, x in enumerate(queries)]))
        
        # answer to queries, initial state set to -1
        ans = [-1] * len(queries)

        # sort intervals by low, high and size
        ivals = deque(sorted([(a, b, b - a + 1) for a, b in intervals]))
        
        # available intervals
        cands = []

        
        while q:
            x, i = q.popleft()
            
            # if lower bound of intervals on the top of stack <= current query
            while ivals and x >= ivals[0][0]:
                a, b, c = ivals.popleft()
                # if higher bound of intervals also meets the requirements
                # if not then discard the interval
                if x <= b:
                    heappush(cands, (c, b, a))
            
            # udpate available intervals by removing old ones which no longer has a eligible higher bound
            while cands:
                c, b, a = heappop(cands)
                if x <= b:
                    ans[i] = c
                    heappush(cands, (c, b, a))
                    break

        return ans",Hard,35,1271,8.0,4,3.0,10.0,36.31428571428572,46.0,2.031714285714285
1260.0,maximum population year,"class Solution:
    def maximumPopulation(self, logs: List[List[int]]) -> int:
        
        
        u=[0]*(3000)
        
        
        for j in logs:
            u[j[0]]+=1
            
            u[j[1]]-=1
            
        p=[u[0]]
        
        for j in range(1,len(u)):
            p.append(p[-1]+u[j])
            
        return p.index(max(p))",Easy,17,367,0.0,2,3.0,2.0,21.58823529411765,12.0,6.557058823529411
1261.0,maximum distance between a pair of values,"class Solution:
    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        ###################################################################
        # Assumption/Requirement
        ###################################################################
        # nums1 and nums2 are both decreasing 
        # return max distance (j-1) where j >= i and nums2[j] >= nums1[i]
        ###################################################################
        
        ###################################################################
        # Explanation 
        ###################################################################
        # 1. if i is fixed, we want to find out the largest j 
        # --> keep increase j if the condition ""nums2[j] >= nums1[i]"" is valid 
        # 2. if (i, j) is valid, but (i, j+1) is not valid, 
        # --> start with (i+1, j+1) instead of (i+1, i+1)
        # --> since (i, j) is valid, it indicates (i+1, j) must be also valid (nums1[i] >= nums1[i+1])
        # --> we will start with (i+1, j+1) to test whether it is valid ornot 
        ###################################################################
        
        res = 0 
        i, j = 0, 0 
        while i < len(nums1) and j < len(nums2):
            if nums2[j] >= nums1[i]:
                res = max(res, j-i)
                j += 1 
            else: 
                i += 1
            
        return res",Medium,29,1438,16.0,1,3.0,5.0,49.58620689655172,45.0,1.4372413793103451
1262.0,maximum subarray min product,"class Solution:
    def maxSumMinProduct(self, nums: List[int]) -> int:
        n = len(nums)
        s = list(accumulate(nums)) # sum
        t = sorted([(v, i) for i, v in enumerate(nums)], reverse=True) # to greedily iterate over values
        j = [i for i in range(n)] # jump array, at first one can only jump in it's own position
        seen = [False] * n # to keep check if already seen a position(i.e. index) or not
        mx = 0 # keep the maximum
        for v, p in t:
            if seen[p]: # if already seen position `p`, then just skip
                continue
            l, r = p, p # we start from position p
            while l >= 0 and nums[l] >= v: # jump left as long as we found values >= v
                seen[l] = True # marked the position as seen
                l = j[l] - 1;
            l += 1
            while r < n and nums[r] >= v: # jump right as long as we find values >= v
                seen[r] = True # marked the position as seen
                r = j[r] + 1
            r -= 1
            ls = 0 if l == 0 else s[l-1]
            rs = s[r]
            mx = max(mx, v * (rs - ls)) # now update the maximum min-product
            j[l], j[r] = r, l # update the jump pointers for position  l and r
        return mx % (10**9+7)",Medium,24,1269,13.0,3,3.0,10.0,52.875,52.0,0.2012499999999999
1263.0,largest color value in a directed graph,"class Solution:
    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        d = defaultdict(list)
        for v1, v2 in edges:
            d[v1].append(v2)
        visited = {}
        counts = [[0] * 26 for _ in range(len(colors))]
        stack = []
        global_max = 0
        for root in d.keys():
            if root in visited:
                continue
            stack.append(root)
            while stack:
                v1 = stack[-1]
                if v1 in visited:
                    if visited[v1] == 1:
                        visited[v1] = 2
                        stack.pop()
                        if v1 in d:
                            for v2 in d[v1]:
                                for c in range(26):
                                    counts[v1][c] = max(counts[v1][c], counts[v2][c])
                        counts[v1][ord(colors[v1])-ord('a')] += 1
                else:
                    visited[v1] = 1
                    if v1 in d:
                        for v2 in d[v1]:
                            if v2 in visited:
                                if visited[v2] == 1:
                                    return -1
                            else:
                                stack.append(v2)
            global_max = max(global_max, max(counts[root]))
        if global_max == 0 and len(d) < len(colors): # in case input is like (""abcde"", [])
            global_max = 1
        return global_max",Hard,36,1471,1.0,12,5.0,15.0,40.86111111111112,49.0,0.4424999999999972
1264.0,sorting the sentence,"class Solution:
    def sortSentence(self, s: str) -> str:
        
        words = s.split(' ')
		
		# sort based on last char ex. is2 this1 nice3
        words.sort(key=lambda x: x[-1])
                
        return ' '.join(i[:-1] for i in words)",Easy,8,251,1.0,0,2.0,1.0,31.375,9.0,6.19625
1265.0,incremental memory leak,"class Solution(object):
    def memLeak(self, m1, m2):
        i=1
        while(1):
            if(m1>=m2):
                if(m1>=i):
                    m1-=i
                else:
                    break
            else:
                if(m2>=i):
                    m2-=i
                else:
                    break
            i+=1
        return [i,m1,m2]",Medium,15,370,0.0,-2,4.0,4.0,24.666666666666668,23.0,5.359999999999999
1266.0,rotating the box,"class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        rows=[]
        for i in box:
            row = """".join(i).split(""*"")
            for j in range(len(row)):
                row[j]="""".join(sorted(row[j], reverse=True))
            row=""*"".join(row)
            rows.append(row)
        return zip(*rows[::-1])",Medium,9,352,0.0,2,3.0,2.0,39.11111111111112,15.0,4.680000000000001
1267.0,sum of floored pairs,"class Solution:
    def sumOfFlooredPairs(self, nums: List[int]) -> int:
        ans, hi, n, c = 0, max(nums)+1, len(nums), Counter(nums)
        pre = [0] * hi
        for i in range(1, hi):
            pre[i] = pre[i-1] + c[i]
        for num in set(nums):
            for i in range(num, hi, num):
                ans += c[num] * (pre[-1] - pre[i-1])
        return ans % (10**9 + 7)",Hard,9,386,0.0,3,3.0,3.0,42.888888888888886,21.0,3.6800000000000015
1268.0,sum of all subset xor totals,"class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        n = len(nums)
        def helper(i):
            if i == n:
                return [0]
            
            xors = helper(i + 1)
            return xors + [nums[i] ^ xor for xor in xors]     
        
        return sum(helper(0))",Easy,10,310,0.0,-1,3.0,2.0,31.0,12.0,5.89
1269.0,minimum number of swaps to make the binary string alternating,"class Solution:
    def minSwaps(self, s: str) -> int:
        if abs(s.count('1') - s.count('0')) > 1:
            return -1
        
        ln = len(s)
        x, y = ""10""*(ln//2), ""01""*(ln//2)
        cnt = 0
        
        if s.count('1') > s.count('0'):
            x = x + ""1""
            for i in range(ln):
                if s[i]!=x[i]: cnt+=1
            
        elif s.count('1') < s.count('0'):
            y = y + ""0""
            for i in range(ln):
                if s[i]!=y[i]: cnt+=1
        else:
            cntx = cnty = 0
            for i in range(ln):
                if s[i]!=x[i]: cntx+=1
            for i in range(ln):
                if s[i]!=y[i]: cnty+=1
            cnt = min(cntx, cnty)
        
        return cnt//2",Medium,26,753,0.0,10,3.0,11.0,28.96153846153846,39.0,2.713461538461539
1270.0,number of ways to rearrange sticks with k sticks visible,"class Solution:
    def rearrangeSticks(self, n: int, k: int) -> int:
        
        @cache 
        def fn(n, k): 
            """"""Return number of ways to rearrange n sticks to that k are visible.""""""
            if n == k: return 1
            if k == 0: return 0
            return ((n-1)*fn(n-1, k) + fn(n-1, k-1)) % 1_000_000_007
        
        return fn(n, k)",Hard,10,368,0.0,-2,3.0,2.0,36.8,20.0,4.628000000000001
1271.0,longer contiguous segments of ones than zeros,"class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        
        numOnes = s.count('1')
        numZeros = s.count('0')
        
        while True:
            if '1'*numOnes in s:
                break
            else:
                numOnes -= 1
        
        while True:
            if '0'*numZeros in s:
                break
            else:
                numZeros -= 1
        return numOnes > numZeros",Easy,17,430,0.0,2,3.0,4.0,25.294117647058822,16.0,5.823529411764706
1272.0,minimum speed to arrive on time,"class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        len_dist = len(dist)
        if sum(dist) <= hour:
            return 1
        elif len_dist - 1 > hour:
            return -1
        elif len_dist - 1 == int(hour):
            if int(hour) == hour:
                return -1
            return max(max(dist), ceil(round(dist[-1] / (hour - int(hour)), 2)))
        left, right = 1, max(dist)
        while left + 1 < right:
            middle = (left + right) // 2
            travel_time = (sum(ceil(d / middle) for d in dist[:-1])
                           + dist[-1] / middle)
            if travel_time > hour:
                left = middle
            else:
                right = middle
        return right",Medium,20,758,0.0,3,3.0,7.0,37.9,36.0,2.6290000000000013
1274.0,stone game viii,"class Solution:
    def stoneGameVIII(self, stones: List[int]) -> int:
        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)
        
        @cache
        def fn(i): 
            """"""Return max score difference.""""""
            if i+1 == len(stones): return prefix[-1]
            return max(fn(i+1), prefix[i+1] - fn(i+1))
        
        return fn(1)",Hard,11,375,0.0,-1,3.0,3.0,34.09090909090909,13.0,5.511818181818182
1275.0,substrings of size three with distinct characters,"class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        substring = []
        for i in range(0,len(s)-2):
            a = s[i:i+3]
            substring.append(a)

        ans = 0
        for i in substring:
            if len(set(i)) == 3:
                ans += 1
        return ans",Easy,11,303,0.0,3,3.0,3.0,27.545454545454547,17.0,5.460909090909091
1276.0,minimize maximum pair sum in array,"class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        start, end = 0, len(nums) - 1
        max_sum = 0
        while start <= end:
            curr_sum = nums[start] + nums[end]
            max_sum = max(max_sum,curr_sum)
            start += 1
            end -= 1
        return max_sum
    #TC -> O(n*logn)
    #SC -> O(1)",Medium,12,366,2.0,1,3.0,1.0,30.5,19.0,5.195
1277.0,get biggest three rhombus sums in a grid,"class Solution:
    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0]) # dimensions 
        anti, diag = {}, {}
        for i in range(m):
            for j in range(n): 
                key = i+j
                if key not in anti: anti[key] = [0]
                anti[key].append(anti[key][-1] + grid[i][j])
                
                key = i-j 
                if key not in diag: diag[key] = [0]
                diag[key].append(diag[key][-1] + grid[i][j])
        
        def fn(i, j, k): 
            """"""Return sum of k diagonal elements starting from (i, j)""""""
            if i >= j: return diag[i-j][j+k] - diag[i-j][j]
            return diag[i-j][i+k] - diag[i-j][i]
        
        def gn(i, j, k):
            """"""Return sum of k anti-diagonal elements starting from (i, j)""""""
            if i+j < n: return anti[i+j][i+k] - anti[i+j][i]
            return anti[i+j][n-1-j+k] - anti[i+j][n-1-j]
        
        ans = set()
        for i in range(m):
            for j in range(n): 
                ans.add(grid[i][j])
                for ii in range(i+2, m, 2): 
                    r = (ii-i)//2
                    if j-r < 0 or j+r >= n: break 
                    val = 0 
                    val += fn(i, j, r+1)
                    val += gn(i, j, r+1)
                    val += fn((ii+i)//2, j-r, r+1)
                    val += gn((ii+i)//2, j+r, r+1)
                    val -= grid[i][j] + grid[(ii+i)//2][j-r] + grid[(ii+i)//2][j+r] + grid[ii][j]
                    ans.add(val)
        return sorted(ans, reverse=True)[:3]",Medium,38,1608,1.0,3,4.0,10.0,42.31578947368421,60.0,-0.1884210526315808
1278.0,minimum xor sum of two arrays,"class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        
        @cache 
        def fn(mask, k): 
            """"""Return min xor sum.""""""
            if not mask: return 0 
            ans = inf 
            for i in range(n): 
                if mask &amp; (1<<i): 
                    ans = min(ans, (nums1[i]^nums2[k]) + fn(mask^(1<<i), k+1))
            return ans 
        
        return fn((1<<n)-1, 0)",Hard,14,471,0.0,0,3.0,3.0,33.642857142857146,24.0,4.392142857142857
1279.0,check if word equals summation of two words,"class Solution:
    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:
        d1={'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'g':6,'h':7,'i':8,'j':9}
        a=0
        x=[0]
        y=[0]
        z=[0]
        for i,v in enumerate(firstWord):
            if d1[v]==0 and a==0:
                continue
            x.append(d1[v])
            a=1
        b=0
        for i,v in enumerate(secondWord):
            if d1[v]==0 and b==0:
                continue
            y.append(d1[v])
            b=1
        c=0
        for i,v in enumerate(targetWord):
            if d1[v]==0 and c==0:
                continue
            z.append(d1[v])
            c=1
        if a==1:
            x=int("""".join(map(str,x)))
        else:
            x=0
        if b==1:
            y=int("""".join(map(str,y)))
        else:
            y=0
        if c==1:
            z=int("""".join(map(str,z)))
        else:
            z=0
        print(x,y,z)
        if(x+y==z):
            return True
        return False",Easy,39,1028,0.0,5,3.0,10.0,26.35897435897436,95.0,-2.352307692307693
1280.0,maximum value after insertion,"class Solution:
    def maxValue(self, n: str, x: int) -> str:
        x = str(x)
        if n[0] == ""-"": 
            for i in range(1, len(n)): 
                if x < n[i]: return n[:i] + x + n[i:]
        else: 
            for i in range(0, len(n)): 
                if x > n[i]: return n[:i] + x + n[i:]
        return n + x",Medium,9,330,0.0,3,3.0,5.0,36.66666666666666,25.0,3.8400000000000007
1281.0,process tasks using servers,"class Solution:
    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
        ans = [0] * len(tasks)
        free_servers = []
        busy_servers = []
        for idx, weight in enumerate(servers):
            heappush(free_servers, (weight, idx))
        for sec, task_len in enumerate(tasks):
            if busy_servers:
                sec_free, weight, idx = heappop(busy_servers)
                while sec_free <= sec:
                    heappush(free_servers, (weight, idx))
                    if busy_servers:
                        sec_free, weight, idx = heappop(busy_servers)
                    else:
                        break
                if sec_free > sec:
                    heappush(busy_servers, (sec_free, weight, idx))
            if free_servers:
                weight, idx = heappop(free_servers)
                ans[sec] = idx
                heappush(busy_servers, (sec + task_len, weight, idx))
            else:
                sec_free, weight, idx = heappop(busy_servers)
                ans[sec] = idx
                heappush(busy_servers, (sec_free + task_len, weight, idx))
        return ans",Medium,26,1161,0.0,6,4.0,7.0,44.65384615384615,50.0,0.3811538461538468
1282.0,minimum skips to arrive at meeting on time,"class Solution:
    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        if sum(dist)/speed > hoursBefore: return -1 # impossible 
        
        @cache
        def fn(i, k): 
            """"""Return min time (in distance) of traveling first i roads with k skips.""""""
            if k < 0: return inf # impossible 
            if i == 0: return 0 
            return min(ceil((fn(i-1, k) + dist[i-1])/speed) * speed, dist[i-1] + fn(i-1, k-1))
        
        for k in range(len(dist)):
            if fn(len(dist)-1, k) + dist[-1] <= hoursBefore*speed: return k",Hard,12,590,2.0,0,3.0,8.0,49.16666666666666,27.0,2.7750000000000004
1283.0,egg drop with 2 eggs and n floors,"class Solution:
    def twoEggDrop(self, n: int) -> int:
        N = 0
        res = 0
		# find k = 1+2+3+...+i , where i is the maximum number that allows k <= n then return k
        while res < n:
            N += 1
            res += N
        return N",Medium,8,256,1.0,0,2.0,1.0,32.0,15.0,5.54
1284.0,determine whether matrix can be obtained by rotation,"class Solution:
def findRotation(self, matrix: List[List[int]], target: List[List[int]]) -> bool:
    
    def transpose(mat):
        n=len(mat)
        for i in range(n):
            for j in range(i,n):
                mat[i][j],mat[j][i]=mat[j][i],mat[i][j]
    
    def reverse(mat):
        n=len(mat)
        for i in range(n):
            for j in range(n//2+n%2):
                mat[i][j],mat[i][n-j-1]=mat[i][n-j-1],mat[i][j]
        
    if target==matrix:
        return True
    # Rotating 1st time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True
    # Rotating 2nd time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True
    # Rotating 3rd time
    transpose(matrix)
    reverse(matrix)
    if target==matrix:
        return True

    return False",Easy,33,833,3.0,4,2.0,8.0,25.24242424242424,38.0,3.6881818181818176
1285.0,reduction operations to make the array elements equal,"class Solution:
    def reductionOperations(self, nums: List[int]) -> int:
        return sum(i * len(tuple(g)) for i, (_, g)
                   in enumerate(groupby(sorted(nums))))",Medium,3,181,0.0,0,3.0,1.0,60.333333333333336,7.0,3.69
1286.0,minimum number of flips to make the binary string alternating,"class Solution:
    def minFlips(self, s: str) -> int:
        n = len(s)

        s = s+s
        fip1 = [('0' if i%2==0 else '1') for i in range(len(s))]
        fip2 = [('1' if i%2==0 else '0') for i in range(len(s))]
        i = 0
        min1 = 0
        min2 = 0
        final = len(s)
        for j in range(len(s)):
            
            if fip1[j]!=(s[j]):
                min1+=1
            if fip2[j]!= (s[j]):
                min2+=1

            if (j-i+1) == n:
                final = min(final,min1,min2)
                if (s[i]) != fip1[i]:
                    min1-=1
                if (s[i]) != fip2[i]:
                    min2-=1
                i+=1
        return final",Medium,25,698,0.0,6,3.0,10.0,27.92,40.0,2.9472
1287.0,minimum space wasted from packaging,"class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        # prefix sum to save time
        acc = [0] + [*accumulate(packages)]
        packages.sort()

        ans = float('inf')
        for box in boxes:
            tmp = 0
            # deal with smallest box first
            box.sort()
            
            # record number of packages already dealt with
            start = 0
            
            for b in box:
                loc = bisect.bisect(packages, b)
                if loc == 0: continue
                tmp += b * (loc - start) - (acc[loc] - acc[start])
                
                # all are packaged
                if loc == len(packages):
                    ans = min(ans, tmp)
                    break
                    
                start = loc
        
        return ans % (10 **9+7) if ans != float('inf') else -1",Hard,27,906,4.0,2,4.0,5.0,33.55555555555556,28.0,3.98
1288.0,check if all the integers in a range are covered,"class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        
        seen = set()
        
        for interval in ranges:
            
            start = interval[0]
            end = interval[1]
            
			# adds all numbers in range to the seen numbers
            for x in range(start, end+1):
                seen.add(x)
            
		# make sure all numbers from left to right have been seen
        for x in range(left, right+1):
            if x not in seen:
                return False
        
        return True",Easy,19,576,2.0,3,3.0,4.0,30.31578947368421,18.0,5.191578947368422
1289.0,find the student that will replace the chalk,"class Solution:
    def chalkReplacer(self, chalk: List[int], k: int) -> int:
        k %= sum(chalk)
        n = len(chalk)
        for i in range(n):
            if chalk[i] > k:
                return i
            k -= chalk[i]",Medium,7,231,0.0,2,3.0,2.0,33.0,13.0,5.430000000000001
1290.0,largest magic square,"class Solution:

    @staticmethod
    def is_magic(mat: List[List[int]]):
        n, s = len(mat), sum(mat[0])
        for r in range(1, n):
            if sum(mat[r]) != s:
                return False
        if any(sum(col) != s for col in zip(*mat)):
            return False
        d1 = d2 = 0
        n1 = n - 1
        for i in range(n):
            d1 += mat[i][i]
            d2 += mat[n1 - i][i]
        return d1 == d2 == s

    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        max_size = 1
        for r in range(rows):
            if rows - r < max_size:
                break
            for c in range(cols):
                if cols - c < max_size:
                    break
                max_len = min(rows - r, cols - c) + 1
                for size in range(max_size + 1, max_len):
                    sub_mat = [grid[row_id][c: c + size]
                               for row_id in range(r, r + size)]
                    if Solution.is_magic(sub_mat):
                        max_size = size
        return max_size",Medium,32,1104,0.0,5,3.0,12.0,34.5,47.0,1.715
1291.0,minimum cost to change the final value of expression,"class Solution:
    def minOperationsToFlip(self, expression: str) -> int:
        loc = {}
        stack = []
        for i in reversed(range(len(expression))):
            if expression[i] == "")"": stack.append(i)
            elif expression[i] == ""("": loc[stack.pop()] = i 
        
        def fn(lo, hi): 
            """"""Return value and min op to change value.""""""
            if lo == hi: return int(expression[lo]), 1
            if expression[hi] == "")"" and loc[hi] == lo: return fn(lo+1, hi-1) # strip parenthesis 
            mid = loc.get(hi, hi) - 1 
            v, c = fn(mid+1, hi)
            vv, cc = fn(lo, mid-1)
            if expression[mid] == ""|"": 
                val = v | vv 
                if v == vv == 0: chg = min(c, cc)
                elif v == vv == 1: chg = 1 + min(c, cc)
                else: chg = 1 
            else: # expression[k] == ""&amp;""
                val = v &amp; vv
                if v == vv == 0: chg = 1 + min(c, cc)
                elif v == vv == 1: chg = min(c, cc)
                else: chg = 1
            return val, chg
                    
        return fn(0, len(expression)-1)[1]",Hard,27,1142,2.0,6,4.0,10.0,42.2962962962963,92.0,-3.526666666666668
1292.0,redistribute characters to make all strings equal,"class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        x = {}
        for word in words:
            for i in word:
                if i in x:
                    x[i]+=1
                else:
                    x[i]=1
        return all(i%len(words) == 0 for i in x.values())",Easy,9,297,0.0,3,4.0,4.0,33.0,15.0,5.11
1293.0,maximum number of removable characters,"class Solution:
    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:
        indices = {}
        for i in range(len(removable)):
            indices[removable[i]] = i
        
        def check(mid):
            i, j = 0, 0
            while i < len(s) and j < len(p):
                if s[i] == p[j] and (i not in indices or indices[i] > mid):
                    j += 1
                i += 1
            
            if j == len(p):
                return True
            else:
                return False
        
        l, r = 0, len(removable) - 1
        ans = -1
        
        while l <= r:
            mid = (l + r) // 2
            if check(mid):
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
                
        return ans + 1",Medium,29,826,0.0,4,3.0,6.0,28.48275862068965,44.0,2.6165517241379312
1294.0,merge triplets to form target triplet,"class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        x = y = z = -inf 
        for a, b, c in triplets: 
            if a <= target[0] and b <= target[1] and c <= target[2]: 
                x, y, z = max(x, a), max(y, b), max(z, c)
        return [x, y, z] == target",Medium,6,321,0.0,2,3.0,2.0,53.5,33.0,1.5850000000000009
1295.0,the earliest and latest rounds where players compete,"class Solution:
    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed
        
        @cache
        def fn(k, mask): 
            """"""Return earliest and latest rounds.""""""
            can = deque()
            for i in range(n): 
                if mask &amp; (1 << i): can.append(i)
                    
            cand = [] # eliminated player
            while len(can) > 1: 
                p1, p2 = can.popleft(), can.pop()
                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest 
                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated 
                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated 
                else: cand.append([p1, p2]) # both could be elimited 
            
            minn, maxx = inf, -inf
            for x in product(*cand): 
                mask0 = mask
                for i in x: mask0 ^= 1 << i
                mn, mx = fn(k+1, mask0)
                minn = min(minn, mn)
                maxx = max(maxx, mx)
            return minn, maxx
        
        return fn(1, (1<<n)-1)",Hard,28,1277,6.0,5,4.0,8.0,45.60714285714285,65.0,-0.9046428571428572
1296.0,find a peak element ii,"class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        M = len(mat)
        N = len(mat[0])
        @cache
        def rmax(r):
            return max(mat[r])
        l,r = 0,M
        while r-l>1:
            m = l+(r-l)//2
            assert(m>0)
            if rmax(m)>rmax(m-1):
                l = m
            else:
                r = m
        return [l, mat[l].index(rmax(l))]",Medium,15,418,0.0,1,3.0,2.0,27.866666666666667,21.0,5.152
1297.0,largest odd number in string,"class Solution:
    def largestOddNumber(self, num: str) -> str:
        val, idx = '', len(num) - 1
        
        while idx > -1:
            odd = int(num[idx]) % 2
            while odd and idx > -1:
                val = num[idx] + val
                idx -= 1
            idx -= 1
        return val",Easy,10,307,0.0,2,3.0,2.0,30.7,16.0,5.337000000000001
1298.0,the number of full rounds you have played,"class Solution:
    def numberOfRounds(self, startTime: str, finishTime: str) -> int:
        start_time = sum(t if i else 60 * t
                         for i, t in enumerate(map(int, startTime.split("":""))))
        finish_time = sum(t if i else 60 * t
                          for i, t in enumerate(map(int, finishTime.split("":""))))
        if finish_time < start_time:
            finish_time += 1440
        return (floor(finish_time / 15) - ceil(start_time / 15)
                if finish_time - start_time >= 15 else 0)",Medium,9,527,0.0,3,4.0,6.0,58.55555555555556,20.0,2.3100000000000005
1299.0,count sub islands,"class Solution:
    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
        
        rows = len(grid1)
        cols = len(grid1[0])
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        
        islands = 0
        
        for row in range(rows):
            for col in range(cols):
                if grid2[row][col] == 1 and grid1[row][col] == 1:
                    grid2[row][col] = '#'
                    q = collections.deque([])
                    q.append((row, col))
                    is_island = True
                    while q:
                        r, c = q.popleft()
                        for y, x in directions:
                            nr = r + y
                            nc = c + x
                            if 0 <= nr < rows and 0 <= nc < cols and grid2[nr][nc] == 1:
                                if grid1[nr][nc] != 1:
                                    is_island = False
                                grid2[nr][nc] = '#'
                                q.append((nr, nc))
                                
                    if is_island:
                        islands += 1
                    
        return islands",Medium,30,1199,2.0,8,5.0,8.0,39.96666666666667,55.0,0.2029999999999994
1300.0,minimum absolute difference queries,"class Solution:
    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        loc = {}
        for i, x in enumerate(nums): loc.setdefault(x, []).append(i)
        keys = sorted(loc)
        
        ans = []
        for l, r in queries: 
            prev, val = 0, inf
            for x in keys: 
                i = bisect_left(loc[x], l)
                if i < len(loc[x]) and loc[x][i] <= r: 
                    if prev: val = min(val, x - prev)
                    prev = x 
            ans.append(val if val < inf else -1)
        return ans",Medium,15,579,0.0,5,3.0,7.0,38.6,30.0,3.0460000000000003
1301.0,remove one element to make the array strictly increasing,"class Solution:
    def canBeIncreasing(self, nums: List[int]) -> bool:
        for i in range(len(nums)):
            x = nums[:i]+nums[i+1:]
            if sorted(x)==x and len(set(x))==len(x): return True
        return False",Easy,5,228,0.0,1,3.0,2.0,45.6,16.0,4.056
1302.0,remove all occurrences of a substring,"class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        if part in s:
            a = s.index(part)
            return self.removeOccurrences(s[:a] + s[a+len(part):], part)
        else:
            return s",Medium,6,234,0.0,0,3.0,1.0,39.0,13.0,5.010000000000001
1303.0,maximum alternating subsequence sum,"class Solution:
    def maxAlternatingSum(self, nums: List[int]) -> int:
        n = len(nums)
        dp_odd = [0]*n
        dp_even = [0]*n
        dp_even[0] = nums[0]
        max_even = nums[0]
        max_odd = 0
        ans = nums[0]
        i = 1
        while i<n:
            dp_odd[i] = max_even - nums[i]
            dp_even[i] = max_odd + nums[i]
            max_even = max(max_even, dp_even[i])
            max_odd = max(max_odd,dp_odd[i] )
            ans = max(ans, dp_odd[i], dp_even[i])
            i += 1
        return ans",Medium,17,541,0.0,1,3.0,1.0,31.823529411764707,25.0,4.395882352941177
1304.0,maximum product difference between two pairs,"class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        nums.sort()
        return nums[-1] * nums[-2] - nums[0] * nums[1]",Easy,3,150,0.0,0,2.0,1.0,50.0,5.0,4.88
1305.0,cyclically rotating a grid,"class Solution:
    def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        ans = [[0] * n for _ in range(m)]
        # x, y is starting point; m, n is desired length and width of the layer
        def helper(x, y, l, w):
            tmp = deque([grid[x][y]])
            a, b = 0, 0
            # extract all number in the layer
            while len(tmp) < 2 * (l + w) - 4:
                if a == 0 and b < w - 1:
                    b += 1
                elif b == w - 1 and a < l - 1:
                    a += 1
                elif a == l - 1 and b > 0:
                    b -= 1
                elif b == 0 and a > 0:
                    a -= 1
                tmp.append(grid[x + a][y + b])
            
            # rotate counter-clockwise
            tmp.rotate(len(tmp) - k % len(tmp))

            # reassign
            a, b = 0, 0
            ans[x][y] = tmp.popleft()
            while tmp:
                if a == 0 and b < w - 1:
                    b += 1
                elif b == w - 1 and a < l - 1:
                    a += 1
                elif a == l - 1 and b > 0:
                    b -= 1
                elif b == 0 and a > 0:
                    a -= 1
                ans[x + a][y + b] = tmp.popleft()
        
        x, y = 0, 0
        while m >= 2 and n >= 2:
            helper(x, y, m, n)
            x += 1
            y += 1
            m -= 2
            n -= 2
        
        return ans",Medium,45,1497,4.0,11,4.0,12.0,33.266666666666666,92.0,-2.934000000000001
1306.0,number of wonderful substrings,"class Solution:
    def wonderfulSubstrings(self, word: str) -> int:
        n = len(word)
        mask = 0
        prefix = defaultdict(int)
        prefix[0] += 1
        ans = 0
        for w in word:
            mask ^= 1 << (ord(w) - ord('a'))
            # no difference
            ans += prefix[mask]
            for i in range(10):
                # only differed by one digit 
                tmp = mask ^ (1 << i)
                ans += prefix[tmp]
            prefix[mask] += 1
        return ans",Medium,16,508,2.0,2,3.0,4.0,31.75,21.0,4.822500000000001
1307.0,count ways to build rooms in an ant colony,"class Solution:
    def waysToBuildRooms(self, prevRoom: List[int]) -> int:
        tree = defaultdict(list)
        for i, x in enumerate(prevRoom): tree[x].append(i)
        
        def fn(n): 
            """"""Return number of nodes and ways to build sub-tree.""""""
            if not tree[n]: return 1, 1 # leaf 
            c, m = 0, 1
            for nn in tree[n]: 
                cc, mm = fn(nn)
                c += cc
                m = (m * comb(c, cc) * mm) % 1_000_000_007
            return c+1, m
        
        return fn(0)[1]",Hard,15,543,1.0,0,3.0,3.0,36.2,21.0,4.502
1308.0,build array from permutation,"class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        x=[nums[nums[i]] for i in range(0,len(nums))]
        return x;",Easy,3,143,0.0,0,2.0,1.0,47.66666666666666,7.0,4.89
1309.0,eliminate maximum number of monsters,"class Solution:
def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
    
    time = [d/s for d,s in zip(dist,speed)]
    time.sort()
    c=0
    for i,t in enumerate(time):
        if i<t:
            c+=1
        else:
            break
    
    return c",Medium,12,273,0.0,1,2.0,3.0,22.75,17.0,6.0725
1310.0,count good numbers,"class Solution:
    def countGoodNumbers(self, n: int) -> int:
        odds = n // 2
        return (pow(5, n - odds, 1_000_000_007) * pow(4, odds, 1_000_000_007)
                % 1_000_000_007)",Medium,4,195,0.0,0,3.0,0.0,48.75,10.0,4.4325
1311.0,count square sum triples,"class Solution:
    cache = {1:0, 2:0, 3:0, 4:0}
    
    def countTriples(self, n: int) -> int:        
        if n in self.cache.keys():
            return self.cache[n]
        else:
            self.cache[n] = self.findTriples(n) + self.countTriples(n-1)
            return self.cache[n]
        
    def findTriples(self, n: int) -> int:
        count = 0
        
        for a in range(0, n):
            for b in range(a, n):
                if self.isSquareTriple(a, b, n):
                    count += 1
                    
        return count*2
        
    def isSquareTriple(self, a: int, b: int, c: int) -> bool:
        if ((a*a) + (b*b) == (c*c)):
            return True
        else:
            return False",Easy,24,729,0.0,1,3.0,5.0,30.375,42.0,2.826250000000001
1312.0,nearest exit from entrance in maze,"class Solution:
    def nearestExit(self, maze, entrance) -> int:
        '''
        for val in maze:
            print(val)
        '''
        m, n = len(maze), len(maze[0])
        q, ans = [entrance], 0

        while q:
            num = len(q)
            for i in range(num):
                x, y = q[0]
                if (x == 0 or y == 0 or x == m - 1 or y == n - 1) and ans > 0:
                    return ans
                q.pop(0)
                maze[x][y] = '+'
                if x > 0 and maze[x - 1][y] == '.':
                    q.append([x - 1, y])
                if y > 0 and maze[x][y - 1] == '.':
                    q.append([x, y - 1])
                if x < m - 1 and maze[x + 1][y] == '.':
                    q.append([x + 1, y])
                if y < n - 1 and maze[x][y + 1] == '.':
                    q.append([x, y + 1])
            ans += 1

        return -1",Medium,27,899,1.0,7,4.0,8.0,33.2962962962963,57.0,0.6833333333333318
1313.0,sum game,"class Solution:
    def sumGame(self, num: str) -> bool:
        diff = qm = 0 
        for i, ch in enumerate(num): 
            if ch == ""?"": qm += 1 if i < len(num)//2 else -1
            else: diff += int(ch) if i < len(num)//2 else -int(ch)
        return diff * 2 + qm * 9 != 0",Medium,6,283,0.0,2,3.0,7.0,47.16666666666666,19.0,3.5550000000000006
1314.0,minimum cost to reach destination in time,"class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], fee: List[int]) -> int:
        g = defaultdict(lambda: defaultdict(lambda: float('inf')))
        n = len(fee)
        
        # select edges with minimal time
        for u, v, t in edges:
            if t < g[u][v]:
                g[u][v] = t
            if t < g[v][u]:
                g[v][u] = t
        
        
        vis = defaultdict(tuple, {0: (0, fee[0])})
        
        q = [(fee[0], 0, 0)]
        while q:
            f, t, cur = heappop(q)
            if cur == n - 1:
                return f
            for nei in g[cur]:
                nf = f + fee[nei]
                nt = t + g[cur][nei]
                if nt > maxTime: continue
                    
                # global vis set (either less time or fare)
                if not vis[nei] or (nt < vis[nei][0] or nf < vis[nei][1]):
                    if not vis[nei]: 
                        vis[nei] = (nt, nf)
                    else:
                        vis[nei] = (min(nt, vis[nei][0]), min(nf, vis[nei][1]))
                    heappush(q, (nf, nt, nei))
        return -1",Hard,32,1145,2.0,7,4.0,9.0,35.78125,56.0,0.5996874999999999
1315.0,concatenation of array,"class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums * 2",Easy,2,101,0.0,0,2.0,0.0,50.5,5.0,4.835
1316.0,unique length 3 palindromic subsequences,"class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        
        first = {}
        last = {}
        
        for i,c in enumerate(s):
            if c not in first:
                first[c] = i
            last[c] = i
            
        ans = 0
        for c in ""abcdefghijklmnopqrstuvwxyz"":
            if c not in last:
                continue
            uniq = set()
            for i in range(first[c]+1,last[c]):
                uniq.add(s[i])
            ans += len(uniq)
            
        return ans",Medium,20,541,0.0,4,3.0,5.0,27.05,19.0,5.2455
1317.0,painting a grid with three different colors,"class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        M = 10**9 + 7
        ans = 3
        if m == 1:
            for i in range(n-1):
                ans *= 2
                ans %= M
            return ans % M
        
        def IsValid(a):
            return all ( a[i] != a[i+1] for i in range(len(a) - 1) )
            
        if m >= 2:
            # AllStates contains all colorings of a single row of length m using 3 colors (0, 1, 2), hence of size 3^m
            # For example, m = 2, AllStates = [(0,0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
            AllStates = [[0], [1], [2]]
            colors = [0, 1, 2]
            for j in range(m-1):
                L = len(AllStates)
                for i in range(L):
                    x = AllStates.pop(0)
                    for c in colors:
                        AllStates.append(tuple([*x, c]))
            
            # v contains all valid colorings of a single row of length m using 3 colors
            v = set()
            for a in AllStates:
                if IsValid(a):
                    v.add(a)
            d = {i:a for i, a in enumerate(v)}
            
            # construct a graph where vertices are valid single row colorings
            # an edge is present if two colorings satisfy the constraints
            numStates = len(v)
            def IsValidNeigbor(a, b):
                if a not in v or b not in v:
                    return False
                else:
                    for i in range(len(a)):
                        if a[i] == b[i]:
                            return False
                    return True
            
            adj = {i:[] for i in range(numStates)}
            for i in range(numStates):
                for j in range(i+1, numStates):
                    if IsValidNeigbor(d[i], d[j]):
                        adj[i].append(j)
                        adj[j].append(i)
            
            # then the problem becomes: finding the number of paths of length n in the constructed graph,
            # which can be done by an easy-to-understand dp.
            dp = [[0 for _ in range(n+1)] for _ in range(numStates)]
            for i in range(numStates):
                dp[i][1] = 1
            
            
            for j in range(2, n+1):
                for i in range(numStates):
                    for k in adj[i]:
                        dp[i][j] += dp[k][j-1]
                        dp[i][j] %= M
            return sum(dp[i][n] for i in range(numStates)) % M",Hard,63,2558,7.0,13,4.0,26.0,40.6031746031746,91.0,-3.4942857142857147
1318.0,merge bsts to create single bst,"class Solution:
    def canMerge(self, trees: List[TreeNode]) -> TreeNode:
        roots, leaves, loners, n = {}, {}, set(), len(trees)
        if n == 1:
            return trees[0]
        for tree in trees:
            if not tree.left and not tree.right:
                loners.add(tree.val)
                continue
            roots[tree.val] = tree
            for node in [tree.left, tree.right]:
                if node:
                    if node.val in leaves:
                        return None
                    leaves[node.val] = node
                
        for loner in loners:
            if loner not in leaves and loner not in roots:
                return None
            
        orphan = None
        for val, tree in roots.items():
            if val not in leaves:
                if orphan:
                    return None
                orphan = tree
        if not orphan:
            return None
        
        def build(node, small, big):
            nonlocal roots
            if not node:
                return True
            if small >= node.val or node.val >= big:
                return False
            
            if node.val in roots:
                node.left, node.right = roots[node.val].left, roots[node.val].right
                del roots[node.val]
            return build(node.left, small, node.val) and build(node.right, node.val, big)
        del roots[orphan.val]
        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)
        return orphan if result and not roots.keys() else None",Hard,42,1583,0.0,6,4.0,16.0,37.69047619047619,55.0,0.5078571428571426
1319.0,maximum number of words you can type,"class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        t=text.split("" "")
        b=list(brokenLetters)
        print(t,b)
        ans=[]
        for i in range(len(t)):
            c=0
            for j in range(len(b)):
                if(b[j] in t[i]):
                    c+=1
                    break
            if(c==0):
                ans.append(t[i])
        return len(ans)",Easy,14,422,0.0,1,3.0,4.0,30.142857142857142,20.0,5.047142857142858
1320.0,add minimum number of rungs,"class Solution:
    def addRungs(self, rungs: List[int], dist: int) -> int:
        n = len(rungs)
        count = 0
        if dist == 1:
            if rungs[0]>1:
                count += rungs[0]-1
            for i in range(n-1):
                if rungs[i+1]-rungs[i] > 1:
                    count+= rungs[i+1]-rungs[i] - 1
            return count
        else:
            if rungs[0] > dist:
                count += (rungs[0]-1)//dist
            for i in range(n-1):
                if rungs[i+1] - rungs[i] > dist:
                    count += (rungs[i+1] - rungs[i] -1)//dist
            return count",Medium,17,614,0.0,6,4.0,7.0,36.11764705882353,28.0,3.3494117647058816
1321.0,maximum number of points with cost,"class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        for i in range(1, m): 
            for j in range(n-2, -1, -1): 
                points[i-1][j] = max(points[i-1][j], points[i-1][j+1]-1)
            prefix = 0 
            for j in range(n): 
                points[i][j] += max(prefix, points[i-1][j])
                prefix = max(prefix, points[i-1][j]) - 1
        return max(points[-1])",Medium,10,465,0.0,3,3.0,3.0,46.5,21.0,3.3550000000000004
1322.0,check if all characters have equal number of occurrences,"class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        counts = list(Counter(s).values())
        return all(count == counts[0] for count in counts)",Easy,3,168,0.0,0,2.0,1.0,56.0,9.0,3.94
1323.0,the number of the smallest unoccupied chair,"class Solution:
    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
      #track the friend of interest since we are going to 
      #sort the array later
      target_start, target_end = times[targetFriend]
	  
      #sort array by the time each friend arrive
      times.sort(key = lambda x : x[0])
	  
      #preallocate the maximum num of chairs needed
      #priority queue 1 - chairs, since we always want to
      #get the chair with smallest index
      chairs = list(range(len(times)+1))
      heapify(chairs)
	  
      #priority queue 2 - occupied, we release chairs by
      #the time they are done occupied
      occupied = []
      heapify(occupied)
	  
      for start, end in times:
        #release the chairs that has no one sitting on 
        while occupied and occupied[0][0] <= start:
          time, release = heappop(occupied)
          heappush(chairs, release)
		  
        #get the chair with smallest index
        target_chair = heappop(chairs)
		
        #if friend of interest if found, return chair index
        if start == target_start and end == target_end:
          return target_chair
        #otherwise, label this chair as occupied
        heappush(occupied, (end, target_chair))",Medium,33,1245,12.0,2,2.0,7.0,37.72727272727273,35.0,3.3445454545454547
1324.0,describe the painting,"class Solution:
    def splitPainting(self, segment: List[List[int]]) -> List[List[int]]:
        f=[]
        for a,b,c in segment:
            f.append([a,c])
            f.append([b,-c])
        f.sort()
        s=0
        ft=[]
        n=len(f)
        for i in range(n-1):
            s+=f[i][1]
            if(f[i][0]!=f[i+1][0] and s!=0):
                ft.append([f[i][0],f[i+1][0],s])
        
        return ft",Medium,15,422,0.0,2,3.0,3.0,28.133333333333333,21.0,5.0680000000000005
1325.0,number of visible people in a queue,"class Solution:
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        stk=[heights[-1]]
        ans=[0]*len(heights)
        for i in range(len(heights)-2,-1,-1):
            h=heights[i]
            cansee=0
            while stk and h>stk[0]:
                cansee+=1
                stk.pop(0)
            ans[i]=cansee+1 if stk else cansee
            stk.insert(0,h)
        return ans",Hard,12,412,0.0,2,3.0,3.0,34.333333333333336,17.0,4.909999999999999
1326.0,sum of digits of string after convert,"class Solution:
    def getLucky(self, s: str, k: int) -> int:
        al = {""a"":1,""b"":2,""c"":3,""d"":4,""e"":5,""f"":6,""g"":7,""h"":8,""i"":9,""j"":1,""k"":2,""l"":3,""m"":4,""n"":5,""o"":6,""p"":7,""q"":8,""r"":9,""s"":10,""t"":2,""u"":3,""v"":4,""w"":5,""x"":6,""y"":7,""z"":8}
        res, tmp = 0, 0
        for c in s:
            res += al[c]
        for _ in range(k-1):
            tmp = str(res)
            res = 0
            for char in tmp:
                res += int(char)
        return res",Easy,11,460,0.0,3,3.0,3.0,41.81818181818182,69.0,-1.0236363636363637
1327.0,largest number after mutating substring,"class Solution:
    def maximumNumber(self, num: str, change: List[int]) -> str:
        
        res = ''
        startChange = False
        for idx,i in enumerate(num):
            val = int(i)
            if change[val] > val:
                startChange = True
                res += str(change[val])
            else:
                if startChange and not change[val] == val:
                    break
                res += str(val)
        
        return res + num[idx:] if len(res) < len(num) else res",Medium,15,512,0.0,2,3.0,4.0,34.13333333333333,24.0,4.228
1328.0,maximum compatibility score sum,"class Solution:
    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        return self.mySoldfs(students, mentors, set(), 0)
        
    def mySoldfs(self, students, mentors, hashSet, indS):
        if indS>=len(students):
            return 0
        res=0
        maxx=0
        for i in range(len(mentors)):
            if i not in hashSet:
                res = self.match(students[indS], mentors[i])
                hashSet.add(i)
                maxx = max(maxx, res+self.mySoldfs(students, mentors, hashSet, indS+1))
                hashSet.remove(i)
        return maxx
    
    def match(self, x, y):
        res=0
        i=j=0
        while(i<len(x)and j<len(y)):
            if x[i]==y[j]:
                res+=1
            i+=1;
            j+=1;
        return res",Medium,25,824,0.0,1,3.0,5.0,32.96,45.0,2.2936000000000005
1329.0,delete duplicate folders in system,"class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        leaves = []
        trie_lambda = lambda: collections.defaultdict(trie_lambda)
        trie = trie_lambda()
        trie['*'] = trie['**'] = '*'
        
        for p in paths:
            t = trie
            for f in p:
                parent, t = t, t[f]
                t['*'] = parent
                t['**'] = f
        
        def traverse(t):
            if len(t) == 2:
                leaves.append(t)
            else:
                for k, v in t.items():
                    if k[0] != '*':
                        traverse(v)
        traverse(trie)
        
        leaf_ids = set(id(leaf) for leaf in leaves)
        candidates = {id(leaf['*']):leaf['*'] for leaf in leaves}
        
        while candidates:
            new = {}
            dup = collections.defaultdict(list)
            for cand in candidates.values():
                if any(id(v) not in leaf_ids for k, v in cand.items() if k[0] != '*'):
                    continue
                dup[','.join(sorted(cand.keys()))].append(cand)
            for k, v in dup.items():
                if len(v) > 1:
                    for cand in v:
                        f = cand['**']
                        parent = cand['*']
                        del parent[f]
                        leaf_ids.add(id(parent['*' + f]))
                        new[id(parent)] = parent
            candidates = new
        path = []
        ans = []
        def dfs(t):
            for f in t:
                if f[0] != '*':
                    path.append(f)
                    ans.append(list(path))
                    dfs(t[f])
                    path.pop()
        dfs(trie)
        return ans",Hard,52,1771,0.0,12,4.0,17.0,34.05769230769231,55.0,0.4748076923076922
1330.0,three divisors,"class Solution:
    def isThree(self, n: int) -> bool:
        is_div = [i * (n//i) == n for i in range(2, int(math.sqrt(n))+1)]
        return sum(is_div) == 1 and is_div[-1] == 1",Easy,3,180,0.0,0,2.0,1.0,60.0,16.0,2.88
1331.0,maximum number of weeks for which you can work,"class Solution(object):
    def numberOfWeeks(self, milestones):
        """"""
        :type milestones: List[int]
        :rtype: int
        """"""
        milestones.sort()
        s = sum(milestones[:-1])
        if milestones[-1] > s:
            return s * 2 + 1
        else:
            return s + milestones[-1]",Medium,11,315,0.0,0,3.0,1.0,28.63636363636364,12.0,6.042727272727273
1332.0,minimum garden perimeter to collect enough apples,"class Solution:
    def minimumPerimeter(self, neededApples: int) -> int:
        total=0
        for i in range(neededApples):
            total+=12*(i+1)*(i+1)
            if total>=neededApples:
                return 8*(i+1)",Medium,6,228,0.0,2,3.0,2.0,38.0,11.0,5.180000000000001
1333.0,count number of special subsequences,"class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        MOD = 1_000_000_007 
        s0 = s1 = s2 = 0 
        for x in nums: 
            if x == 0: s0 = (1 + 2*s0) % MOD
            elif x == 1: s1 = (s0 + 2*s1) % MOD
            else: s2 = (s1 + 2*s2) % MOD
        return s2",Hard,8,310,0.0,3,3.0,3.0,38.75,22.0,3.952500000000001
1334.0,delete characters to make fancy string,"class Solution:
    def makeFancyString(self, s: str) -> str:
        fancy = []
        for idx in range(len(s)):
            if idx < 2 or not s[idx] == s[idx-1] == s[idx-2]:
                fancy.append(s[idx])
        return """".join(fancy)",Easy,6,243,0.0,2,3.0,2.0,40.5,15.0,4.555000000000001
1337.0,maximum product of the length of two palindromic substrings,"class Solution:
    def maxProduct(self, s: str) -> int:
        n = len(s)
        
        # Manacher's algo
        hlen = [0]*n # half-length
        center = right = 0 
        for i in range(n): 
            if i < right: hlen[i] = min(right - i, hlen[2*center - i])
            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: 
                hlen[i] += 1
            if right < i+hlen[i]: center, right = i, i+hlen[i]
        
        prefix = [0]*n
        suffix = [0]*n
        for i in range(n): 
            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)
            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)
        
        for i in range(1, n): 
            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)
            suffix[i] = max(suffix[i], suffix[i-1]-2)
        
        for i in range(1, n): 
            prefix[i] = max(prefix[i-1], prefix[i])
            suffix[~i] = max(suffix[~i], suffix[~i+1])
        
        return max(prefix[i-1]*suffix[i] for i in range(1, n))",Hard,27,1052,2.0,7,3.0,8.0,38.96296296296296,47.0,1.2733333333333334
1338.0,check if string is a prefix of array,"class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        n = len(s)
        m = 0
        c = """"
        for i in words:
            m+=len(i)
            c+=i
            if m > n:
                return False
            elif m == n and s == c:
                return True
        return False",Easy,12,326,0.0,1,3.0,3.0,27.166666666666668,22.0,5.115000000000001
1339.0,remove stones to minimize the total,"class Solution:
def minStoneSum(self, piles: List[int], k: int) -> int:
    
    local = [-p for p in piles]
    heapq.heapify(local)
    for i in range(k):
        tmp = -1*heapq.heappop(local)
        tmp = (tmp+1)//2
        heapq.heappush(local,-tmp)
    
    return -sum(local)",Medium,10,282,0.0,1,2.0,3.0,28.2,12.0,6.082
1340.0,minimum number of swaps to make the string balanced,"class Solution:
    def minSwaps(self, s: str) -> int:
        return (reduce(lambda mismatch, ch: mismatch + (-1 if (mismatch > 0 and ch == ']') else 1), s, 0) + 1) // 2",Medium,2,170,0.0,0,2.0,1.0,85.0,13.0,0.9300000000000016
1341.0,find the longest valid obstacle course at each position,"class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        ans, vals = [], []
        for i, x in enumerate(obstacles): 
            k = bisect_right(vals, x)
            ans.append(k+1)
            if k == len(vals): vals.append(x)
            else: vals[k] = x
        return ans",Hard,8,332,0.0,2,3.0,2.0,41.5,18.0,4.165
1342.0,number of strings that appear as substrings in word,"class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        count=0
        for i in range(len(patterns)):
            if patterns[i] in word:
                count+=1
        return count",Easy,6,219,0.0,2,3.0,2.0,36.5,11.0,5.315
1343.0,array with elements not equal to average of neighbors,"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        for i in range(1, len(nums)-1): 
            if nums[i-1] < nums[i] < nums[i+1] or nums[i-1] > nums[i] > nums[i+1]: 
                nums[i], nums[i+1] = nums[i+1], nums[i]
        return nums",Medium,5,276,0.0,2,3.0,2.0,55.2,15.0,3.232
1344.0,minimum non zero product of the array elements,"class Solution:
    def minNonZeroProduct(self, p: int) -> int:
        MOD = 10 ** 9 + 7
        res = pow(pow(2, p, MOD) - 2, pow(2, (p - 1)) - 1, MOD) * (pow(2, p, MOD) - 1)
        return int(res) % MOD",Medium,4,206,0.0,0,2.0,0.0,51.5,14.0,3.845
1345.0,last day where you can still cross,"class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        _board = [[0 for _ in range(col)] for _ in range(row)]
        board = None
        
        def search(days):
            def dfs(x, y):
                res = False
                for _x, _y in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                    if not (0 <= _x < row and 0 <= _y < col):
                        continue
                    if board[_x][_y]:
                        continue
                    if _x == row - 1:
                        return True
                    board[_x][_y] = 1
                    res |= dfs(_x, _y)
                return res
            
            flood(days)
            for j in range(col):
                if not board[0][j]:
                    board[0][j] = 1
                    if dfs(0, j):
                        return True
            return False
        
        def flood(days):
            nonlocal board
            board = deepcopy(_board)
            for i in range(days):
                board[cells[i][0] - 1][cells[i][1] - 1] = 1
        
        l, r = 0, len(cells)
        while l < r:
            mid = l + (r - l) // 2
            if search(mid):
                l = mid + 1
            else:
                r = mid
        return l - 1",Hard,40,1338,0.0,4,4.0,12.0,33.45,58.0,0.7094999999999985
1346.0,find if path exists in graph,"class Solution:
    def validPath(self, n: int, edges: List[List[int]], start: int, end: int) -> bool:
        if start == end: return True
        if len(edges) == 0: return False
        
        adj = [set() for _ in range(n)]
        seen = set()
        for u, v in edges:
            adj[u].add(v)
            adj[v].add(u)
        queue = []
        queue.append(start)
        while len(queue)>0:
            st = queue.pop(0)
            if st == end:
                return True
            if st not in seen: 
                queue += list(adj[st])
            seen.add(st)
        return False",Easy,19,605,0.0,3,3.0,7.0,31.84210526315789,33.0,3.4742105263157903
1347.0,minimum time to type word using special typewriter,"class Solution:
def minTimeToType(self, word: str) -> int:
    count = 0
    curr = ""a""
    
    for i in word:
        t = abs(ord(i)-ord(curr))
        if t <= 12:
            count += 1 + t
            curr = i
        else:
            count += 1 + 26 - t
            curr = i
    
    return count",Easy,14,302,0.0,2,2.0,2.0,21.571428571428573,17.0,6.118571428571428
1348.0,maximum matrix sum,"class Solution(object):
    def maxMatrixSum(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: int
        """"""
        n = len(matrix)
        s = 0 
        s_abs = 0 
        neg = 0 
        maxneg = float('-inf')
        minabs = float('inf')
        for i in range(n):
            for j in range(n):
                s += matrix[i][j]
                s_abs += abs(matrix[i][j])
                if matrix[i][j] <= 0:
                    neg += 1
                if abs(matrix[i][j]) < abs(minabs):
                    minabs = matrix[i][j]
       
        if neg % 2 == 0:
            return s_abs
        else:
            return s_abs - 2*abs(minabs)",Medium,24,686,0.0,4,3.0,5.0,28.58333333333333,29.0,4.1075
1349.0,number of ways to arrive at destination,"class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        g = defaultdict(set)
        deg = [0] * n
        for u, v, t in roads:
            if u > v:
                u, v = v, u
            g[u].add((v, t))
            deg[v] += 1

        vis = defaultdict(lambda: float('inf'), {0: 0})
        q = [(0, 0)]
        ways = [0] * n
        ways[0] = 1
        while q:
            t, cur = heappop(q)
            for nei, nei_t in g[cur]:
                deg[nei] -= 1
                if vis[nei] > t + nei_t:
                    vis[nei] = t + nei_t
                    ways[nei] = ways[cur]
                elif vis[nei] == t + nei_t:
                    ways[nei] += ways[cur]
                
                # only traverse if degree = 0 or spent time starts to exceed minimum
                if deg[nei] == 0 or vis[nei] < t + nei_t:
                    if nei == n - 1 and deg[nei] == 0:
                        return ways[-1] % (10 ** 9 + 7)
                    heappush(q, (vis[nei], nei))
        
        return ways[-1]",Medium,30,1066,1.0,7,4.0,9.0,35.53333333333333,57.0,0.4819999999999993
1350.0,number of ways to separate numbers,"class Solution:
    def numberOfCombinations(self, num: str) -> int:
        n = len(num)
        lcs = [[0]*(n+1) for _ in range(n)]
        for i in reversed(range(n)): 
            for j in reversed(range(i+1, n)): 
                if num[i] == num[j]: lcs[i][j] = 1 + lcs[i+1][j+1]
        
        def cmp(i, j, d): 
            """"""Return True if """"""
            m = lcs[i][j]
            if m >= d: return True 
            return num[i+m] <= num[j+m]
        
        dp = [[0]*(n+1) for _ in range(n)]
        for i in range(n): 
            if num[i] != ""0"": 
                for j in range(i+1, n+1): 
                    if i == 0: dp[i][j] = 1
                    else: 
                        dp[i][j] = dp[i][j-1]
                        if 2*i-j >= 0 and cmp(2*i-j, i, j-i): dp[i][j] += dp[2*i-j][i]
                        if 2*i-j+1 >= 0 and not cmp(2*i-j+1, i, j-i-1): dp[i][j] += dp[2*i-j+1][i]
        return sum(dp[i][n] for i in range(n)) % 1_000_000_007",Hard,23,977,0.0,7,4.0,14.0,42.47826086956522,49.0,0.6169565217391302
1352.0,find unique binary string,"class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        n = len(nums[0])
        for i in range(len(nums)):
            nums[i] = int(nums[i],2)
        for i in range(2**n):
            if i not in nums:
                return bin(i)[2:].zfill(n)",Medium,7,280,0.0,3,3.0,4.0,40.0,12.0,4.840000000000001
1353.0,minimize the difference between target and chosen elements,"class Solution:
    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        mask = 0b1
        for row in mat: 
            temp = 0
            for x in row: temp |= mask << x
            mask = temp 
        
        for x in range(5000): 
            if mask >> (target+x) &amp; 1 or x <= target and mask >> (target-x) &amp; 1: return x",Medium,9,366,0.0,4,3.0,5.0,40.66666666666666,23.0,3.62
1354.0,find array given subset sums,"class Solution:
    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        sums.sort()
        ans = []
        for _ in range(n): 
            diff = sums[1] - sums[0]
            ss0, ss1 = [], []
            freq = defaultdict(int)
            on = False 
            for i, x in enumerate(sums): 
                if not freq[x]: 
                    ss0.append(x)
                    freq[x+diff] += 1
                    if x == 0: on = True 
                else: 
                    ss1.append(x)
                    freq[x] -= 1
            if on: 
                ans.append(diff)
                sums = ss0 
            else: 
                ans.append(-diff)
                sums = ss1
        return ans",Hard,23,732,0.0,5,4.0,9.0,31.82608695652174,30.0,3.5956521739130443
1355.0,minimum difference between highest and lowest of k scores,"class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        

        minimal=float('inf')
        
        counter=defaultdict(int)

        maximum=float('-inf')
        minimum=float('inf')
        sortedArray=[]
        for num in nums:
            counter[num]+=1
            maximum=max(num,maximum)
            minimum=min(num,minimum)

        for i in range(minimum, maximum+1):
            if i in counter:
                while counter[i]:
                    sortedArray.append(i)
                    counter[i]-=1

        first=0
        second=k-1
        
        while second < len(sortedArray):
            minimal=min(minimal,sortedArray[second]-sortedArray[first])
            first+=1
            second+=1
            
        return minimal",Easy,30,792,0.0,5,3.0,6.0,26.4,31.0,4.0440000000000005
1356.0,find the kth largest integer in the array,"class Solution:
    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        for i in range(len(nums)):
            nums[i] = int(nums[i])
        nums.sort()
        nums.reverse()
        return str(nums[k-1])",Medium,6,222,0.0,1,2.0,1.0,37.0,9.0,5.59
1357.0,minimum number of work sessions to finish the tasks,"class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -> int:
        n = len(tasks)

        @lru_cache(None)
        def dp(mask, t):
            if mask == (1 << n) - 1:
                return 0
            ans = n
            for i in range(n):
                if mask &amp; (1 << i): continue
                if tasks[i] > t:
                    ans = min(ans, 1 + dp(mask ^ (1 << i), sessionTime - tasks[i]))
                else:
                    ans = min(ans, dp(mask ^ (1 << i), t - tasks[i]))
            return ans

        return dp(0, 0)",Medium,17,578,0.0,1,3.0,4.0,34.0,35.0,3.2
1358.0,number of unique good subsequences,"class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        f0 = f1 = 0
        for ch in binary: 
            if ch == ""0"": f0 += f1
            else: f1 += f0 + 1
        return (f0 + f1 + int(""0"" in binary)) % 1_000_000_007",Hard,6,256,0.0,2,3.0,2.0,42.66666666666666,15.0,4.36
1359.0,find the middle index in array,"class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        right = sum(nums)
        left = 0 
        for i in range(len(nums)):
            right -= nums[i]
            if left == right:
                return i
            left += nums[i]

        return -1",Easy,10,280,0.0,1,3.0,2.0,28.0,14.0,5.840000000000001
1360.0,find all groups of farmland,"class Solution:
def findFarmland(self, land: List[List[int]]) -> List[List[int]]:
    
    m=len(land)
    n=len(land[0])
    def dfs(i,j,ei,ej):
        nonlocal ex,ey
        if i<0 or j<0 or i>=m or j>=n or land[i][j]==0:
            return
        ex=max(i,ei)
        ey=max(j,ej)
        land[i][j]=0
        dfs(i+1,j,ex,ey)
        dfs(i,j+1,ex,ey)
        dfs(i,j-1,ex,ey)
        dfs(i-1,j,ex,ey)
        
    res=[]
    for x in range(m):
        for y in range(n):
            if land[x][y]==1:
                ex,ey = x,y
                dfs(x,y,ex,ey)
                res.append([x,y,ex,ey])
    
    return res",Medium,25,625,0.0,3,2.0,4.0,25.0,55.0,1.9499999999999995
1361.0,the number of good subsets,"class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

        cands = {}
        for x in range(1, 31):
            orig = x
            mask = 0
            for p in primes:
                if x % p: continue
                if p > x: break
                x //= p
                mask ^= (1 << p)
            if x == 1:
                cands[orig] = mask


        cnt = {k: v for k, v in Counter(nums).items() if k in cands}
        cnt_key = list(filter(lambda x: x> 1, sorted(cnt)))
        n = len(cnt_key)
        M = 10**9 + 7
        
        @lru_cache(None)
        def dp(i, mask):
            if i == n:
                return mask > 0
            ans = dp(i+1, mask)
            if mask &amp; cands[cnt_key[i]] == 0:
                ans += cnt[cnt_key[i]] * dp(i+1, mask ^ cands[cnt_key[i]])
            return ans % M
        
        return (dp(0, 0) * pow(2, cnt.get(1, 0))) % M",Hard,31,971,0.0,3,3.0,9.0,31.32258064516129,60.0,0.820967741935485
1362.0,count special quadruplets,"class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        idx = defaultdict(list)
        for i, n in enumerate(nums):
            idx[n].append(i)
        
        count = 0 
        for i in range(len(nums)-3):
            for j in range(i+1, len(nums)-2):
                for k in range(j+1, len(nums)-1):
                    s = nums[i] + nums[j] + nums[k]
                    count += sum(l > k for l in idx[s])
                        
        return count",Easy,13,484,0.0,4,3.0,5.0,37.23076923076923,17.0,4.529230769230769
1363.0,the number of weak characters in the game,"class Solution:
    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
        if not properties:
            return 0
        
        properties.sort(key = lambda x: (x[0], -x[1]))
        
        stack = []
        size = len(properties)
        
        for i in range(size):
            defen = properties[i][-1]
            if not stack:
                stack.append(defen)
            else:
                while stack and defen > stack[-1]:
                    stack.pop()
                    
                stack.append(defen)
        
        return size - len(stack)",Medium,20,599,0.0,3,3.0,4.0,29.95,17.0,5.2445
1364.0,first day where you have been in all the rooms,"class Solution:
    def firstDayBeenInAllRooms2(self, next_visit: List[int]) -> int:
        p = 10**9 + 7
        n = len(next_visit)
        dp = [0]*n

        for i in range(1,n):
            dp[i] = (2 * dp[i-1] - dp[next_visit[i-1]] + 2) % p

        return dp[-1]

    def firstDayBeenInAllRooms(self, next_visit: List[int]) -> int:
        p = 10**9 + 7
        n = len (next_visit)
        not_visited = set(range(n))

        visits = [0] * n
        last_day = [float('-inf')] * n

        def simulate (room, day):
            not_visited.discard(room)
            while not_visited:
                visits[room] += 1
                last_day[room] = day
                if visits[room] &amp; 1:
                    # This room has been visited an odd number of times.
                    day = (2*day - last_day[next_visit[room]] + 1) % p

                # This room has been visited an even number of times.
                day += 1
                room = (room + 1) % n
                not_visited.discard(room)

            return day

        return simulate (0, 0) % p",Medium,35,1087,2.0,1,3.0,3.0,31.057142857142857,30.0,4.044857142857144
1365.0,reverse prefix of word,"class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        
        idx = word.find(ch)
        if idx==-1:
            return word
        else:
            res = list(word)
            first = res[idx::-1]
            last = res[idx+1:]
            ans = first+last
            return ''.join(ans)",Easy,11,320,0.0,0,3.0,1.0,29.09090909090909,20.0,5.201818181818182
1366.0,number of pairs of interchangeable rectangles,"class Solution:
    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
        counts = {}
        for i in range(len(rectangles)):
            rectangles[i] = rectangles[i][0]/rectangles[i][1]
            if rectangles[i] in counts:
                counts[rectangles[i]] += 1
            else:
                counts[rectangles[i]] = 1
        tc = 0
        for c in counts:
            tc += (counts[c]*(counts[c]-1))//2
        return tc",Medium,12,463,0.0,3,3.0,3.0,38.583333333333336,15.0,4.6675
1367.0,maximum product of the length of two palindromic subsequences,"class Solution:
    def maxProduct(self, s: str) -> int:
        if len(s) < 2:
            return 0
        if len(s) == 2:
            return 1
        self.ans = -1
        visited = set()
        def dfs(arr1, arr2, idx):
            if tuple(sorted([arr1, arr2]) + [idx]) in visited:
                return
            visited.add(tuple(sorted([arr1, arr2]) + [idx]))
            if arr1 == arr1[::-1] and arr2 == arr2[::-1]:
                self.ans = max(self.ans, len(arr1) * len(arr2))
            if idx == len(s):
                return
            dfs(arr1+s[idx], arr2, idx+1)
            dfs(arr1, arr2+s[idx], idx+1)
            dfs(arr1, arr2, idx+1)
        dfs("""", """", 0)
        return self.ans",Medium,20,713,0.0,1,3.0,5.0,35.65,44.0,2.1515000000000004
1368.0,smallest missing genetic value in each subtree,"class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        ans = [1] * len(parents)
        if 1 in nums: 
            tree = {}
            for i, x in enumerate(parents): 
                tree.setdefault(x, []).append(i)
                
            k = nums.index(1)
            val = 1
            seen = set()
            
            while k != -1: 
                stack = [k]
                while stack: 
                    x = stack.pop()
                    seen.add(nums[x])
                    for xx in tree.get(x, []): 
                        if nums[xx] not in seen: 
                            stack.append(xx)
                            seen.add(nums[xx])
                while val in seen: val += 1
                ans[k] = val
                k = parents[k]
        return ans",Hard,24,858,0.0,7,4.0,7.0,35.75,28.0,3.3225
1369.0,count number of pairs with absolute difference k,"class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        ans = 0 
        freq = defaultdict(int)
        for x in nums: 
            ans += freq[x - k] + freq[x + k]
            freq[x] += 1
        return ans",Easy,7,241,0.0,1,3.0,2.0,34.42857142857143,12.0,5.461428571428572
1370.0,find original array from doubled array,"class Solution:
    def findOriginalArray(self, changed: List[int]) -> List[int]:
        # first check if array is even
        # create counter map
        # sort the array and iterate from beginning by crossing off doubled value
        # Time: O(n log n)
        # Space: O(n)
        
        if len(changed) % 2 != 0:
            return []

        counter = defaultdict(int)
        for val in changed:
            counter[val] += 1
        
        changed.sort()
        ans = []
        for val in changed:
            if val in counter and counter[val] != 0:
                if val*2 not in counter or counter[val*2] == 0:
                    return []
                counter[val] -= 1
                counter[val*2] -= 1
                ans.append(val)
        return ans",Medium,24,784,5.0,3,3.0,6.0,32.666666666666664,22.0,4.700000000000001
1371.0,maximum earnings from taxi,"class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:

        rides_from_start = defaultdict(list)
        for start, end, tip in rides:
            rides_from_start[start].append((end, tip))
            
        @cache
        def recursive(actual_position):
            if actual_position == n: # We are at the end
                return 0
            elif actual_position in rides_from_start:
                maximum = 0
                # take any of the rides starting at actual_position
                for end, tip in rides_from_start[actual_position]:
                    maximum = max(maximum, end - actual_position + tip + recursive(end))
                    
                # dont take the ride and check the next position
                maximum = max(maximum, recursive(actual_position + 1))
                
                return maximum
            else:
                # check the next position
                return recursive(actual_position+1)
        
        return recursive(0)",Medium,25,1034,4.0,1,4.0,4.0,41.36,26.0,3.5376000000000003
1372.0,minimum number of operations to make array continuous,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
                
        n = len(nums)
        ans = n
        nums.sort()
        cnt = Counter(nums)
        
        # build key for repeated occurance
        repeat = sorted(k for k in cnt if cnt[k] > 1)
        
        # build prefix sum for repeated occurance need to be changed
        repeat_change = list(accumulate([cnt[x] - 1 for x in repeat], initial=0))


        for i in range(n):
            # numbers left side all need to be changed
            left = i
            
            # numbers right side all need to be changed
            loc = bisect.bisect(nums, nums[i] + n - 1)
            right = n - loc
            
            # calculate occurance of repeated number within [nums[i], nums[i] + n - 1]
            repeat_l = bisect.bisect_left(repeat, nums[i])
            repeat_r = bisect.bisect(repeat, nums[i] + n - 1)
            ans = min(ans, left + right + repeat_change[repeat_r] - repeat_change[repeat_l])
        
        return ans",Hard,28,1036,5.0,1,3.0,6.0,37.0,25.0,4.130000000000001
1373.0,final value of variable after performing operations,"class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        X=0
        for i in operations:
            X= X+1 if i[1]==""+""  else X-1
        return X",Easy,5,186,0.0,1,2.0,2.0,37.2,11.0,5.372
1374.0,sum of beauty in the array,"class Solution:
    def sumOfBeauties(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        maxPre = nums[0]
        minNums = nums[-1]
        minPost = [0]*(n-1)
        for i in range(n-2, 0, -1):
            minPost[i] = minNums
            if nums[i] < minNums:
                minNums = nums[i]
        for i in range(1, n-1):
            if nums[i] > maxPre and nums[i] < minPost[i]:
                ans += 2
            elif nums[i] > nums[i-1] and nums[i] < nums[i+1]:
                ans += 1
            if nums[i] > maxPre:
                maxPre = nums[i]
        return ans",Medium,18,610,0.0,6,3.0,6.0,33.888888888888886,30.0,3.41
1375.0,longest subsequence repeated k times,"class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        def helper(subString, string):
            string = iter(string)
            return all(c in string for c in subString)
        
        counter = defaultdict(lambda: 0)
        
        for char in s: 
            counter[char] += 1
            
        chars = """"
        for key in counter: 
            if counter[key]//k: 
                chars += key*(counter[key]//k)
                
        for i in range(len(chars), 0, -1):
            possibilities = set()        
            for comb in combinations(chars, i):
                for perm in permutations(comb):                    
                    subString = """".join(perm)
                    possibilities.add(subString)
                    
            possibilities = sorted(possibilities, key = lambda item: (len(item), item), reverse = True)
        
            for pos in possibilities: 
                if helper(pos*k, s):
                    return pos
                    
        return """"",Hard,29,1057,0.0,6,4.0,9.0,36.44827586206897,36.0,2.5196551724137928
1376.0,maximum difference between increasing elements,"class Solution:
    
    def maximumDifference(self, nums: List[int]) -> int:
        
		# <2 elements in nums seq
		if not nums or len(nums) <= 1:
            return -1
		
		# initialize current min el (val, index) and max diff
        current_min = (float('inf'), -1)
        current_diff = nums[1]-nums[0] # min 2 el's in sequence
		
		# O(n) iterations
        for i in range(0, len(nums)):
		
            if nums[i] < current_min[0]:
                current_min = (min(nums[i], current_min[0]), i) # update min elem
			
            current_diff = max(current_diff, nums[i] - nums[current_min[1]]) # update max diff
        
		return current_diff if current_diff else -1",Easy,20,674,6.0,2,2.0,12.0,33.7,22.0,4.767
1377.0,grid game,"class Solution:
def gridGame(self, grid: List[List[int]]) -> int:
    
    res = float('inf')
    top_right_sum = sum(grid[0][1:])
    bottom_left_sum = 0
    
    n =  len(grid[0])
    for i in range(n):
        res = min(res,max(top_right_sum,bottom_left_sum))
        if i+1<n:
            top_right_sum -= grid[0][i+1]
        bottom_left_sum += grid[1][i]
    
    return res",Medium,14,380,0.0,2,2.0,2.0,27.142857142857142,18.0,5.517142857142857
1378.0,check if word can be placed in crossword,"class Solution:
    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
        abc='abcdefghijklmnopqrstuvwxyz'
        n=len(board)
        m=len(board[0])
        def check(a,b):
            la=len(a)
            lb=len(b)
            b_=b[::-1]
            start=[]
            n=0
            for i in range(la):
                if i==0 and (a[i]=="" "" or a[i] in abc):
                    start.append(i)
                    n+=1
                elif i>0 and (a[i]=="" "" or a[i] in abc) and a[i-1]==""#"":
                    start.append(i)
                    n+=1
                elif i>0 and a[i]=='#' and (a[i-1]==' ' or a[i-1] in abc):
                    start.append(i)
                if i==la-1 and (a[i]==' ' or a[i] in abc):
                    start.append(i+1)
            for i in range(n):
                flag=0
                flag1=0
                if start[2*i+1]-start[2*i] == lb:
                    
                    for j in range(start[2*i],start[2*i+1]):
                        k=j-start[2*i]
                        if not (a[j]==' ' or a[j]==b[k]):
                            # print(a[j],b[k])
                            flag=1
                            break
                    for j in range(start[2*i],start[2*i+1]):
                        k=j-start[2*i]
                        if not (a[j]==' ' or a[j]==b_[k]):
                            # print(a[j],b[k])
                            flag1=1
                            break                   
                    if flag==0 or flag1==0:
                        return True
            return False                          
        new=[["""" for _ in range(n)] for _ in range(m)]
        for i in range(n):
            for j in range(m):
                new[j][i]=board[i][j]
        s=set()
        for i in range(n):
            s.add("""".join(board[i]))
        for i in range(m):
            s.add("""".join(new[i]))
        for i in s:
            if check(i,word):
                return True
        return False",Medium,54,2040,4.0,13,5.0,20.0,37.77777777777778,100.0,-4.32
1379.0,the score of students solving math expression,"class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        @lru_cache(None)
        def allEval(x):
            lo = eval(x)
            if lo > 1000:
                return set()
            ans = set([lo])
            if '*' not in x or '+' not in x or lo==1000:
                return ans
            for pos, char in enumerate(x):
                if char not in ['+', '*']:
                    continue
                left, right = allEval(x[:pos]), allEval(x[pos+1:])
                if char == '+':
                    ans |= {a + b for a in left for b in right if a+b<=1000}
                if char == '*':
                    ans |= {a * b for a in left for b in right if a*b<=1000}
            return ans
        S = allEval(s)
        correct = eval(s)
        return sum(5 if x==correct else (2 if x in S else 0) for x in answers)",Hard,21,873,0.0,2,4.0,15.0,41.57142857142857,44.0,1.498571428571429
1380.0,convert 1d array into 2d array,"class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        if m*n != len(original):
            return []
        a1 = []
        for i in range(0, m):
            a2 = []
            for j in range(0, n):
                a2.append(original[i*n + j])
            a1.append(a2)
        return a1",Easy,10,347,0.0,2,3.0,3.0,34.7,17.0,4.877
1381.0,number of pairs of strings with concatenation equal to target,"class Solution:
    def numOfPairs(self, nums: List[str], target: str) -> int:
        count=0
        for i in range(len(nums)):
            for j in range(len(nums)):
                if(i!=j):
                    if(nums[i] + nums[j] == target):
                        count+=1
        return count",Medium,8,301,0.0,2,4.0,4.0,37.625,17.0,4.55375
1382.0,maximize the confusion of an exam,"class Solution:
    def maxConsecutiveAnswers(self, nums: str, k: int) -> int:
        n = len(nums)
        
        def util(char, K):
            ans, l = 0, 0
            for r in range(n):
                if nums[r] == char:
                    if K == 0:
                        while nums[l] != char: 
                            l += 1
                        l += 1
                    else : 
                        K-= 1
                        
                ans = max(ans, r - l + 1)
            return ans
        
        return max(util('F', k), util('T', k))",Medium,18,578,0.0,3,4.0,4.0,32.111111111111114,33.0,3.39
1383.0,maximum number of ways to partition an array,"class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        """"""This is a good problem. It's not difficult, but is quite complex.

        The idea is that once we change a position at i, for all the pivots at
        1...i, the sum of the left half stay the same whereas the sum of
        the right half changes by delta = k - nums[i]. Similarly, for all the
        pivots at i + 1...n - 1, the left half changes by delta, whereas the
        right half stay the same.

        We can pre-compute all the differences at each pivot position and make
        that into a diffs = [d1, d2, .... , dn-1]

        Then after a change at i, if we want the pivots at 1...i to form a good
        partition, we must have left - (right + delta) = 0 => delta = left - right
        In other words, the number of good partitions is the count of d1, d2, ...
        di that are equal to delta. Similarly, if we want the pivots at i + 1...
        n - 1 to form a good partition, we must have left + delta - right = 0
        => left - right = -delta. In other words, the number of good partitions
        is the count of di+1, ...., dn-1 that are equal to -delta.

        Based on this, we progressively build a left sum and right sum to
        compute the diffs array. And then progressively build a left counter
        and right counter to compute the number of matches to delta and -delta.

        The difficulty is in the implementation, especially with the indices.

        O(N), 7339 ms, faster than 32.20%
        """"""
        N = len(nums)
        diffs = []
        sl, sr = 0, sum(nums)
        for i in range(N - 1):
            sl += nums[i]
            sr -= nums[i]
            diffs.append(sl - sr)
        diffs.append(math.inf)  # to prevent error in the counter arithemtic
        
        cl, cr = Counter(), Counter(diffs)
        res = cl[0] + cr[0]
        for i in range(N):
            d = k - nums[i]
            res = max(res, cl[d] + cr[-d])
            cl[diffs[i]] += 1
            cr[diffs[i]] -= 1
        return res",Hard,45,2067,1.0,2,2.0,19.0,45.93333333333333,58.0,-0.1340000000000003
1384.0,minimum moves to convert string,"class Solution:

    def safe_val_by_index(self, arr, start, end):
        try:
            val = arr[start:end]
        except IndexError:
            return []
        return val
    
    def minimumMoves(self, s: str) -> int:
        
        a = list(s)
        n = len(a)
        p = 'X'
        
        template = ['O']*3
        ans = 0
        
        idx = a.index(p) if p in a else -1
        
        while idx >= 0:
            
            # possible substring
            # idx-2 .. idx, idx-1 .. idx+1, idx .. idx + 2
            moves = [
                [(max(0, idx), min(len(a), idx+3)), -1],
                [(max(0, idx-1), min(len(a), idx+2)), -1],
                [(max(0, idx-2), min(len(a), idx+1)), -1]   
            ]
            
            # default
            best_move = moves[0]
            
            for move in moves:
                # find susbstring with the most 'X's
                move[1] = self.safe_val_by_index(a, *move[0]).count('X')
                if move[1] >= best_move[1]:
                    best_move = move
            
            a[best_move[0][0]:best_move[0][1]] = template   
            ans += 1
            
            idx = a.index(p) if p in a else -1
        
        return ans",Easy,44,1249,4.0,1,3.0,5.0,28.38636363636364,51.0,2.265227272727273
1385.0,find missing observations,"class Solution:
    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        #finding the equal distribution of remaining sum
        temp = mean*(n+len(rolls)) - sum(rolls)
        each = temp//n
        rem = temp%n
        
        #return empty if out of dice range
        if (not (1<=(each + 1)<=6) and rem>0) or not (1<=each<=6):
            return []
        
        res = [each]*n
        i = 0
        #adding the remainder to each possible
        while rem > 0 and i<n:
            res[i] += 1
            rem -= 1
            i += 1
            
        return res",Medium,19,603,3.0,0,3.0,3.0,31.73684210526316,30.0,4.083684210526316
1386.0,stone game ix,"class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        stones = [v % 3 for v in stones]
        
        d = defaultdict(int)
        for v in stones:
            d[v] += 1
        
        while d[1] >= 2 and d[2] >= 2:
            d[2] -= 1
            d[1] -= 1
        
        if d[0] % 2 == 0: # number of 0s will not influent the result
            if (d[1] == 1 and d[2] >= 1) or (d[2] == 1 and d[1] >= 1):
                return True
        else:
            if (d[1] == 0 and d[2] >= 3) or (d[2] == 0 and d[1] >= 3):
                return True
            if (d[1] == 1 and d[2] >= 4) or (d[2] == 1 and d[1] >= 4):
                return True

        return False",Medium,21,699,1.0,3,3.0,7.0,33.285714285714285,54.0,1.2842857142857138
1387.0,smallest k length subsequence with occurrences of a letter,"class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        rest = sum(x == letter for x in s)
        stack = []
        for i, x in enumerate(s): 
            while stack and stack[-1] > x and len(stack) + len(s) - i > k and (stack[-1] != letter or repetition < rest): 
                if stack.pop() == letter: repetition += 1
            if len(stack) < k and (x == letter or len(stack) + repetition < k): 
                stack.append(x)
                if x == letter: repetition -= 1
            if x == letter: rest -= 1
        return """".join(stack)",Hard,11,610,0.0,6,3.0,7.0,55.45454545454545,44.0,0.0690909090909102
1388.0,two out of three,"class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        return [v for v, c in Counter(itertools.chain(set(nums1), set(nums2), set(nums3))).items() if c >=2]",Easy,2,220,0.0,0,2.0,2.0,110.0,14.0,-1.42
1389.0,minimum operations to make a uni value grid,"class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        m,n = len(grid),len(grid[0])
        count = 0
        li = []
        
        for i in range(m):
            for j in range(n):
                li.append(grid[i][j])
                
        li.sort()
        med = li[len(li)//2]
        
        for num in li:
            if num < med or num > med: 
                need = abs( (med - num)//x)
                if need == 0:
                    return -1
                count += need
        return count",Medium,19,549,0.0,4,3.0,5.0,28.894736842105264,25.0,4.479473684210527
1390.0,partition array into two arrays to minimize sum difference,"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 2;
        sum1, sum2 = sum(nums[:n]), sum(nums[n:]);
        psum1, psum2 = [{0}], [{0}];
        
        for ns, ps in zip([nums[:n], nums[n:]], [psum1, psum2]):
            for i, x in enumerate(ns):
                if len(ps) <= n//2: ps.append({s + x for s in ps[-1]});
                
                for j in range(len(ps) - 1, 0, -1):
                    ps[j] = ps[j].union({s + x for s in ps[j-1]});
                    
        target = sum1 - sum2;
        answer = abs(target);

        # 2p1 - 2p2 ~ sum1 - sum2
        
        for i in range(len(psum1)):
            p1, p2 = sorted(list(psum1[i])), sorted(list(psum2[i]));
            idx1, idx2 = 0, 0;
            len1, len2 = len(p1), len(p2);
            
            while idx1 < len1 and idx2 < len2:
                diff = p1[idx1] - p2[idx2];
                offset = 2 * diff - target;
                
                answer = min(answer, abs(offset));
                if offset < 0: idx1 += 1;
                else: idx2 += 1;
                    
        return answer;",Hard,31,1148,1.0,7,3.0,12.0,37.03225806451613,54.0,0.7070967741935483
1391.0,minimum number of moves to seat everyone,"class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats = sorted(seats)
        students = sorted(students)
        count = 0
        for i in range(len(seats)):
            count += abs(seats[i] - students[i])
        return count",Easy,7,281,0.0,1,2.0,1.0,40.142857142857146,12.0,5.007142857142857
1392.0,remove colored pieces if both neighbors are the same color,"class Solution:
    def winnerOfGame(self, arr: str) -> bool:
        n = len(arr)
        
        def count(char):
            i, j = 0, 0
            res = 0
            while j < n:
                temp = 0
                while j < n and arr[j] == char:
                    temp += 1
                    j += 1
                    
                res += (temp-2) if temp > 2 else 0
                j += 1
                i = j
            return res
        
        return count('A') > count('B')",Medium,18,503,0.0,1,4.0,3.0,27.944444444444443,26.0,4.585
1393.0,the time when the network becomes idle,"class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        graph = collections.defaultdict(list)
        for a, b in edges:                                       # build graph
            graph[a].append(b)
            graph[b].append(a)
        dq = collections.deque([(0, 0)])                         # prepare bfs using deque
        ans, n = 0, 1
        visited = set()
        while dq:
            for _ in range(n):
                cur, step = dq.popleft()
                n -= 1                                           # keep track of size of dq
                visited.add(cur)
                for nei in graph[cur]:
                    if nei in visited: continue
                    visited.add(nei)
                    n += 1
                    dq.append((nei, step+1))
                if cur:
                    time = step * 2                              # first msg round trip time    
                    mod = time % patience[cur]                   
                    finished = patience[cur] if not mod else mod # last msg finished moves
                    total = time + (time - finished)             # total time = time + last_msg_unfinished_moves
                    ans = max(ans, total)
        return ans + 1",Medium,25,1292,6.0,5,6.0,7.0,51.68,33.0,1.6288
1394.0,kth smallest product of two sorted arrays,"class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        result = []
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                temp = nums1[i]*nums2[j]
                result.append(temp)
        result.sort()
        return result[k-1]",Hard,8,322,0.0,2,3.0,2.0,40.25,13.0,4.7775
1395.0,check if numbers are ascending in a sentence,"class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        s = s.split(' ')
        last = float('-inf')
        
        for char in s:
            if char.isnumeric():
                if int(char) <= last:
                    return False
                else:
                    last = int(char)
                    
        return True",Easy,12,356,0.0,2,4.0,3.0,29.666666666666668,14.0,5.569999999999999
1396.0,count number of maximum bitwise or subsets,"class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        len_nums = len(nums)
        max_val = 0
        count_max = 0
        for len_c in range(1, len_nums + 1):
            for comb in combinations(nums, len_c):
                val = 0
                for n in comb:
                    val |= n
                if val > max_val:
                    count_max = 1
                    max_val = val
                elif val == max_val:
                    count_max += 1
        return count_max",Medium,15,522,0.0,5,4.0,5.0,34.8,24.0,3.928
1397.0,second minimum time to reach destination,"class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        g = defaultdict(set)
        for u, v in edges:
            g[u].add(v)
            g[v].add(u)              
        
        q = deque([(1, 0)])
        # to store the two minimum node counts for each visited node
        vis = defaultdict(set, {0: {0}})
        minval = set()
        while q:
            node, cnt = q.popleft()
            if node == n:
                minval.add(cnt)
                if len(minval) == 2: break
            for nei in g[node]:
                if len(vis[nei]) > 1 and cnt + 1 >= max(vis[nei]): continue
                vis[nei] = {min(vis[nei])} | {cnt + 1} if vis[nei] else {cnt + 1}
                q.append((nei, cnt + 1))
        
        minval = sorted(minval)
        def helper(nodes):
            t = 0
            while nodes > 0:
                t += time
                nodes -= 1
                if nodes == 0: break
                # if current time exceeds change and change frequency is odd
                if t >= change and (t // change) % 2:
                    t = (t // change + 1) * change
            return t
        
        if len(minval) == 1:
            return helper(minval[0] + 2)
        
        # either use the 2nd minimum path or the 1st path add two more nodes (like example 2)
        return min(helper(minval[0]+2), helper(minval[1]))",Hard,37,1429,3.0,5,3.0,13.0,38.62162162162162,58.0,0.3640540540540531
1398.0,number of valid words in a sentence,"class Solution:
    def countValidWords(self, sentence: str) -> int:
        valid = 0
        digits = set(string.digits)
        punctuation = set(['!', '.', ','])
        for token in sentence.split():
            ts = set(token)
            if digits &amp; ts:
                continue
            if p := punctuation &amp; set(ts):
                if len(p) > 1 or token[-1] not in punctuation:
                    continue
                if max(token.count(c) for c in punctuation) > 1:
                    continue
            if token.count('-') > 1:
                continue
            if token.count('-') == 1:
                idx = token.find('-')
                if idx == 0 or idx == len(token) - 1 or not token[idx-1].islower() or not token[idx+1].islower():
                    continue                
            valid += 1
        return valid",Easy,21,863,0.0,3,4.0,9.0,41.095238095238095,36.0,2.281428571428572
1399.0,next greater numerically balanced number,"class Solution:
    def nextBeautifulNumber(self, n: int) -> int:

        def count(n):
            cnt = [0]*10
            while n:
                cnt[n%10] += 1
                n //= 10
            return cnt
        
        def valid(cnt):
            for i, c in enumerate(cnt):
                if c > 0 and c != i:
                    return False
            return True

        x = n+1
        while True:
            cnt = count(x)
            if valid(cnt):
                return x
            x += 1",Medium,21,515,0.0,2,3.0,6.0,24.52380952380953,21.0,5.392857142857143
1400.0,count nodes with the highest score,"class Solution:
    def countHighestScoreNodes(self, parents: List[int]) -> int:
        hmap=defaultdict(list)
        n=len(parents)
        for i in range(n):
            hmap[i]=[]
        for i in range(1,n):
            hmap[parents[i]].append(i)
        self.childCount=[1 for i in range(n)]
        for i in hmap[0]:
            self.childCount[0]+=self.dfs(i,hmap)
        ans=0
        count=0
        for i in range(n):
            currProd=1
            currSum=0
            for j in hmap[i]:
                currProd*=self.childCount[j]
                currSum+=self.childCount[j]
            rem=(n-1)-(currSum)
            if rem>=1:
                currProd*=rem
            if ans==currProd:
                count+=1
            if ans<currProd:
                count=1
                ans=currProd
        return count
    def dfs(self,curr,hmap):
        if hmap[curr]==[]:
            return 1
        for it in hmap[curr]:
            self.childCount[curr]+=self.dfs(it,hmap)
        return self.childCount[curr]",Medium,33,1034,0.0,8,3.0,11.0,31.33333333333333,47.0,1.8200000000000005
1401.0,parallel courses iii,"class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        
        g = defaultdict(set)
        deg = defaultdict(int)
        for a, b in relations:
            deg[b-1] += 1
            g[a-1].add(b-1)
            
        cnt = 0
        
        # time to finish all prerequisites
        prev_max_t = defaultdict(int)
        
        q = [(time[x], x) for x in range(n) if deg[x] == 0]
        heapify(q)
        
        while q:
            t, course = heappop(q)
            cnt += 1
            if cnt == n:
                return t
            for nei in g[course]:
                deg[nei] -= 1
                prev_max_t[nei] = max(prev_max_t[nei], t)
                if deg[nei] == 0:
                    heappush(q, (prev_max_t[nei] + time[nei], nei))",Hard,26,819,1.0,5,3.0,8.0,31.5,39.0,2.825
1402.0,kth distinct string in an array,"class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str: 
        unique = [v for v, count in Counter(arr).items() if count == 1]
        return unique[k-1] if k <= len(unique) else """"",Easy,3,201,0.0,0,2.0,3.0,67.0,14.0,2.45
1403.0,two best non overlapping events,"class Solution:
    def maxTwoEvents(self, events: List[List[int]]) -> int:
        end_max = defaultdict(int)
        for start, end, val in events:
            end_max[end] = max(end_max[end], val)
        max_val = max(end_max.values())
        lst_ends = sorted(end_max.keys())
        for i in range(1, len(lst_ends)):
            end_max[lst_ends[i]] = max(end_max[lst_ends[i]],
                                       end_max[lst_ends[i - 1]])
        for start, end, val in events:
            idx = bisect_right(lst_ends, start)
            if idx > 0 and start > lst_ends[idx - 1]:
                max_val = max(max_val, end_max[lst_ends[idx - 1]] + val)
            elif idx > 1 and start > lst_ends[idx - 2]:
                max_val = max(max_val, end_max[lst_ends[idx - 2]] + val)
        return max_val",Medium,16,815,0.0,5,3.0,5.0,50.9375,32.0,1.7356250000000006
1404.0,plates between candles,"class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        pref=[0]
		#prefix sum array for calculating *
        for x in s:
            if x=='*':
                pref.append(pref[-1]+1)
            else:
                pref.append(pref[-1])
        ans=[]
		#array for finding the next |
        nex=[0]*len(s)
        stack=[]
        for x in range(len(s)-1,-1,-1):
            if not stack:
                nex[x]=inf
            elif s[x]=='|':
                nex[x]=x
            else:
                nex[x]=stack[-1]
            if s[x]=='|':
                stack.append(x)
        #array for finding the previous |
		prev=[0]*len(s)
        for x in range(len(s)):
            if not stack:
                prev[x]=-inf
            elif s[x]=='|':
                prev[x]=x
            else:
                prev[x]=stack[-1]
            if s[x]=='|':
                stack.append(x)
            
        for x in queries:
			#if | from both ends coincide or cross
            if nex[x[0]]>=prev[x[1]]:
                ans.append(0)
            else:
                #find the next | and the previous | and calculate the * in between
                ans.append(pref[prev[x[1]]]-pref[nex[x[0]]])
        return ans",Medium,41,1275,5.0,12,3.0,16.0,31.09756097560976,53.0,1.20121951219512
1405.0,number of valid move combinations on chessboard,"class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        n = len(pieces)
        mp = {""bishop"": ((-1, -1), (-1, 1), (1, -1), (1, 1)),
              ""queen"" : ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)), 
              ""rook""  : ((-1, 0), (0, -1), (0, 1), (1, 0))}
        
        dirs = [[]] # directions
        for piece in pieces: dirs = [x+[xx] for x in dirs for xx in mp[piece]]
        
        positions = tuple(map(tuple, positions))
        
        def fn(*args): 
            """"""Return possible moves along given direction.""""""
            stack = [((1<<n)-1, positions)]
            while stack: 
                mask, pos = stack.pop()
                ans.add(pos)
                m = mask
                while m: 
                    p = []
                    for i in range(n): 
                        if m &amp; (1 << i): 
                            p.append((pos[i][0] + args[i][0], pos[i][1] + args[i][1]))
                            if not (1 <= p[i][0] <= 8 and 1 <= p[i][1] <= 8): break 
                        else: p.append(pos[i])
                    else: 
                        cand = tuple(p)
                        if len(set(cand)) == len(cand) and m: stack.append((m, cand))
                    m = mask &amp; (m-1)

        ans = set()
        for d in dirs: fn(*d)
        return len(ans)",Hard,33,1411,1.0,6,4.0,10.0,42.75757575757576,84.0,-2.8081818181818186
1406.0,smallest index with equal value,"class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i, n in enumerate(nums):
            if n == i % 10:
                return i
        return -1",Easy,5,176,0.0,1,3.0,2.0,35.2,11.0,5.492
1407.0,find the minimum and maximum number of nodes between critical points,"class Solution:
    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
        '''
        5->3->1->2->5->1->2
              C     C. C
        c = [2,4,5]
        '''
        if head.next.next is None:
            return [-1,-1]
        
        def calc(head):
            prev = head
            temp = head.next
            while temp:
                next_node = temp.next
                if next_node is not None:
                    if prev.val > temp.val < next_node.val or prev.val < temp.val > next_node.val:
                        break
                    prev,temp = temp,next_node
                else:
                    break
            
            max_dis = 0
            min_dis = pow(10,5)+1
            count = 0
            mi_count = pow(10,5)+1
            while temp:
                next_node = temp.next
                if next_node is not None:
                    if prev.val > temp.val < next_node.val or prev.val < temp.val > next_node.val:
                        max_dis = count
                        min_dis = min(min_dis,mi_count)
                        mi_count = 0
                    count += 1
                    mi_count += 1
                    prev,temp = temp,next_node
                else:
                    break
            
            if max_dis != 0 and min_dis != pow(10,5)+1:        
                return [min_dis,max_dis]
            return [-1,-1]
			
        return calc(head)",Medium,43,1468,1.0,2,4.0,8.0,34.13953488372093,61.0,0.5074418604651161
1408.0,minimum operations to convert number,"class Solution:
    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        nums.sort()
        q = collections.deque([(start, 0)])
        visited = set()
        
        while q:
            for _ in range(len(q)):
                x, step = q.popleft()
                if x == goal:
                    return step
                
                if x < 0 or x > 1000:
                    continue
                
                if x in visited:
                    continue
                visited.add(x)

                for num in nums:
                    q.append((x+num, step+1))
                    q.append((x-num, step+1))
                    q.append((x^num, step+1))
                    
        
        return -1",Medium,25,759,0.0,3,4.0,6.0,30.36,28.0,4.0476
1409.0,check if an original string exists given two encoded strings,"class Solution:
    def possiblyEquals(self, s1: str, s2: str) -> bool:
        
        def gg(s): 
            """"""Return possible length.""""""
            ans = {int(s)}
            for i in range(1, len(s)): 
                ans |= {x+y for x in gg(s[:i]) for y in gg(s[i:])}
            return ans
        
        @cache
        def fn(i, j, diff): 
            """"""Return True if s1[i:] matches s2[j:] with given differences.""""""
            if i == len(s1) and j == len(s2): return diff == 0
            if i < len(s1) and s1[i].isdigit(): 
                ii = i
                while ii < len(s1) and s1[ii].isdigit(): ii += 1
                for x in gg(s1[i:ii]): 
                    if fn(ii, j, diff-x): return True 
            elif j < len(s2) and s2[j].isdigit(): 
                jj = j 
                while jj < len(s2) and s2[jj].isdigit(): jj += 1
                for x in gg(s2[j:jj]): 
                    if fn(i, jj, diff+x): return True 
            elif diff == 0: 
                if i < len(s1) and j < len(s2) and s1[i] == s2[j]: return fn(i+1, j+1, 0)
            elif diff > 0: 
                if i < len(s1): return fn(i+1, j, diff-1)
            else: 
                if j < len(s2): return fn(i, j+1, diff+1)
            return False 
            
        return fn(0, 0, 0)",Hard,32,1309,0.0,7,4.0,27.0,40.90625,76.0,-1.9415625
1410.0,count vowel substrings of a string,"class Solution:
    def countVowels(self, word: str) -> int:
        vowels = [""a"", ""e"", ""i"", ""o"", ""u""]
        res = []
        vowels_cop = set(vowels.copy())

        for j in range(len(word)):
            if word[j] not in vowels:
                continue
            string = """"
            for i in range(j, len(word)):
                flag = False
                if word[i] in vowels:
                    string += str(i)
                    vowels_cop.discard(word[i])
                    if not vowels_cop:
                        res.append(string)
                    flag = True
                if not flag:
                    string = """"
                    vowels_cop = set(vowels.copy())
            string = """"
            vowels_cop = set(vowels.copy())

        print(len(set(res)))",Easy,24,802,0.0,6,4.0,6.0,33.416666666666664,27.0,3.6925
1411.0,vowels of all substrings,"class Solution:
    def countVowels(self, word: str) -> int:
        vowels=""aeiou""
        n=len(word)
        prefix=[0]
        for s in word:
            prefix.append(prefix[-1]+ (s in vowels))
        prefix.pop(0)
        total=sum(prefix)
        diff=0
        res=total
        for i in range(1,n):
            diff+=prefix[i-1]
            res+=total-(n-i)*prefix[i-1]-diff
        
        return res",Medium,15,412,0.0,2,3.0,5.0,27.466666666666665,16.0,5.628
1412.0,minimized maximum of products distributed to any store,"class Solution:
    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:
        left, right = 1, max(quantities)
        while left < right:
            middle = (left + right) // 2
            if sum(ceil(q / middle) for q in quantities) > n:
                left = middle + 1
            else:
                right = middle
        return right",Medium,9,361,0.0,2,3.0,3.0,40.11111111111112,18.0,4.29
1413.0,maximum path quality of a graph,"class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
        graph = defaultdict(list)
        dist = defaultdict(int)
        parent = defaultdict(int)
        R2Bpath = defaultdict(list)
        for u, v, w in edges:
            graph[u].append( (v, w) )
            graph[v].append( (u, w) )
        
        ## calc Djik: Q[ (time, node, parent) ]
        Q = [ (0, 0, -1) ]
        while Q:
            time, node, par = heapq.heappop(Q)
            if node not in dist:
                dist[node] = time
                parent[node] = par
                for v, w in graph[node]:
                    alt = time + w
                    heapq.heappush(Q, (alt, v, node) )
        
        ## get ancesters of each nodes
        for node in range(len(values)):
            if node in dist:
                curr = node
                while curr != -1:
                    R2Bpath[node].append(curr)
                    curr = parent[curr]
        
        
        def get_score(ancesters: List[int]) -> int:
            score = 0
            for node in set(ancesters):
                score += values[node]
            return score
        
        self.maxScore = 0
        def dfs(curr=0, cost=0, path=[0]):
            self.maxScore = max( self.maxScore, get_score(path+R2Bpath[curr]) )
            for v, time in graph[curr]:
                if cost+time+dist[v] <= maxTime:
                    dfs(v, cost+time, path+[v])
                        
        dfs()
        return self.maxScore",Hard,44,1560,2.0,9,3.0,10.0,35.45454545454545,65.0,-0.3309090909090919
1414.0,check whether two strings are almost equivalent,"class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        f1 = Counter(word1)
        f2 = Counter(word2)
        for ch in string.ascii_lowercase:
            if abs(f1[ch]-f2[ch]) > 3:
                return False
        return True",Easy,7,270,0.0,1,3.0,2.0,38.57142857142857,12.0,5.08857142857143
1415.0,most beautiful item for each query,"class Solution:
    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:
        class Node:
            def __init__(self, key, maximum):
                self.key = key
                self.maximum = maximum
                self.left = None
                self.right = None
        head = Node(items[0][0], items[0][1])
        for i in range(1, len(items)):
            node = head
            new_node = Node(items[i][0], items[i][1])
            while True:
                if new_node.key > node.key:
                    new_node.maximum = max(new_node.maximum, node.maximum)
                    if node.right:
                        node = node.right
                    else:
                        node.right = new_node
                        break
                elif new_node.key < node.key:
                    node.maximum = max(new_node.maximum, node.maximum)
                    if node.left:
                        node = node.left
                    else:
                        node.left = new_node
                        break
                else:
                    node.maximum = max(new_node.maximum, node.maximum)
                    break
            
        answer = []
        for query in queries:
            node = head
            maximum = 0
            while node:
                if query > node.key:
                    maximum = max(maximum, node.maximum)
                    node = node.right
                elif query < node.key:
                    node = node.left
                else:
                    maximum = max(maximum, node.maximum)
                    break
            answer.append(maximum)
        return answer",Medium,45,1706,0.0,6,5.0,10.0,37.91111111111111,58.0,0.1280000000000001
1416.0,maximum number of tasks you can assign,"class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        
        from sortedcontainers import SortedList
        
        tasks.sort()
        workers.sort()
        
        def check_valid(ans):
            
            # _tasks = SortedList(tasks[:ans])
            _tasks = deque(tasks[:ans])
            _workers = workers[-ans:]
            remain_pills = pills
            
            for worker in _workers:
                task = _tasks[0]
                if worker >= task:
                    # the worker can finish the min task without pill, just move on
                    # _tasks.pop(0)
                    _tasks.popleft()
                elif worker + strength >= task and remain_pills:
                    # the worker cannot finish the min task without pill, but can solve it with pill
                    # remove the max task that the strengthened worker can finish instead
                    # remove_task_idx = _tasks.bisect_right(worker + strength)
                    remove_task_idx = bisect.bisect_right(_tasks, worker + strength)
                    # _tasks.pop(remove_task_idx - 1)
                    del _tasks[remove_task_idx - 1]
                    remain_pills -= 1
                else:
                    return False
            return True
        
        lo, hi = 0, min(len(workers), len(tasks))
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if check_valid(mid):
                lo = mid
            else:
                hi = mid - 1
        return lo",Hard,40,1595,7.0,3,4.0,5.0,39.875,45.0,1.7712500000000002
1417.0,time needed to buy tickets,"class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        total = sum(tickets)
        n = len(tickets)
        idx = 0 
        days = 0     
        
        while total > 0:
            idx = idx % n 
            if tickets[idx] > 0:
                tickets[idx] -= 1
                days += 1
                total -= 1
                if idx == k and tickets[idx] == 0:
                    return days 
            idx += 1
        return days",Easy,16,482,0.0,2,3.0,3.0,30.125,27.0,4.28875
1418.0,reverse nodes in even length groups,"class Solution:
    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.helper(head, 1)
    
    def helper(self, head, size, lvl = 0):
        
        # check if we should reverse
        count, node = 0, head
        for _ in range(size):
            if not node:
                break
            count += 1
            node = node.next
        
        if count == 0:
            return head
        
        #print(lvl * 2 * ' ', count, size)

        
        if count % 2 == 1:
            # do not reverse
            node = head
            for _ in range(count - 1):
                node = node.next
            node.next = self.helper(node.next, size + 1, lvl + 1)
            return head
        else:
            # perform reverse
            prev, curr = None, head
            for _  in range(count):
                tmp = curr.next  # prepare
                
                curr.next = prev # link
                
                prev = curr     # move
                curr = tmp      # move

            head.next = self.helper(curr, size + 1, lvl + 1)
            return prev",Medium,39,1148,8.0,2,3.0,8.0,29.435897435897434,46.0,2.770769230769231
1419.0,decode the slanted ciphertext,"class Solution:
    def decodeCiphertext(self, et: str, rows: int) -> str:
        L = len(et)
        if not L: return et
        
        cols, ans, start = L//rows, et[0], 0
        i, j = 0, start
        while start < cols - 1:
            i, j = i + 1, j + 1
            if i == rows or j == cols:
                start += 1
                i, j = 0, start
                ans += et[start]
                continue
            
            ans += et[cols*i + j]
                    
        return ans.rstrip()",Medium,17,516,0.0,1,3.0,3.0,30.352941176470587,35.0,3.528235294117648
1420.0,process restricted friend requests,"class Solution:
    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        
        result = [False for _ in requests]
        
        connected_components = [{i} for i in range(n)]
        
        connected_comp_dict = {}
        for i in range(n):
            connected_comp_dict[i] = i
        
        banned_by_comps = [set() for i in range(n)]
        for res in restrictions:
            banned_by_comps[res[0]].add(res[1])
            banned_by_comps[res[1]].add(res[0])
        for i,r in enumerate(requests):
            n1, n2 = r[0], r[1]
            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]
            if c1 == c2:
                result[i] = True
            else:
                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):
                    connected_components[c1].update(connected_components[c2])
                    banned_by_comps[c1].update(banned_by_comps[c2])
                    for node in connected_components[c2]:
                        connected_comp_dict[node] = c1
                    result[i] = True
                
        return result",Hard,27,1238,0.0,6,4.0,9.0,45.851851851851855,34.0,1.873333333333333
1421.0,two furthest houses with different colors,"class Solution:
    def maxDistance(self, colors: List[int]) -> int:
        n = len(colors)
        for i in range(n - 1, 0, -1):
            for j in range(n - i):
                if colors[j] != colors[j + i]:
                    return i",Easy,6,241,0.0,3,3.0,3.0,40.16666666666666,12.0,4.825000000000001
1422.0,watering plants,"class Solution:
    def wateringPlants(self, arr: List[int], capacity: int) -> int:
        n = len(arr)
        cur = capacity
        steps = 0
        
        for i in range(n):
            if arr[i] <= cur:
                steps += 1
            else:
                steps += (2*i+1)  #including forward and return steps
                cur = capacity
                
            cur -= arr[i]
            
        return steps",Medium,15,434,1.0,1,3.0,3.0,28.933333333333334,19.0,5.296
1423.0,sum of k mirror numbers,"class Solution:
    def kMirror(self, k: int, n: int) -> int:
        
        # start from single digit base k
        cands = [str(i) for i in range(1, k)]
        ans = 0
        
        while n > 0:
            # check current canddiates to see if base 10 is also mirroring
            for cand in cands:
                b10 = str(int(cand, k))
                if b10 == b10[::-1]:
                    ans += int(b10)
                    n -= 1
                    if n == 0: return ans

            # construct new candidates 
            # if previous cand length is even just insert number between 0 and k - 1 into the middle
            # if previous cand length is odd just insert number after len//2+1 and should be the same with left part end digit
            new_cands = []
            for cand in cands:
                m = len(cand)
                for i in range(k):
                    if m % 2 == 0:
                        new_cands.append(cand[:m//2] + str(i) + cand[m//2:])
                    else:
                        left, right = cand[:m//2+1], cand[m//2+1:]
                        if str(i) == left[-1]:
                            new_cands.append(left + str(i) + right)
            cands = new_cands

            
        
        return ans",Hard,33,1275,5.0,7,4.0,12.0,38.63636363636363,48.0,1.2627272727272718
1424.0,count common words with one occurrence,"class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        w1 = set(w for w, c in Counter(words1).items() if c == 1)
        w2 = set(w for w, c in Counter(words2).items() if c == 1)
        return  len(w1 &amp; w2)",Easy,4,251,0.0,0,2.0,4.0,62.75,17.0,2.5325
1425.0,minimum number of food buckets to feed the hamsters,"class Solution:
    def minimumBuckets(self, street: str) -> int:
        l=list(street.strip())
        c=0
        n=len(street)
        i=1
        while i < len(street)-1:#fill the buckets containg houses on both sides and change H to T
            if l[i-1]==""H"" and l[i+1]==""H"" and l[i]==""."":
                l[i-1]=""T""
                l[i+1]=""T""
                l[i]=""B""
                c+=1

            i+=1
        i=0
        while i<len(street):#fill buckets for remaining houses
            if i-1>=0:
                if l[i-1]==""H"":
                    if l[i]==""."":
                        c+=1
                        l[i-1]=""T""
                        l[i]=""B""
            if i+1<len(l):
                if l[i+1]==""H"":
                    if l[i]==""."":
                        c+=1
                        l[i]=""B""
                        l[i+1]=""T""
            i+=1
        if ""H"" in l:
            return -1
        return c",Medium,31,944,2.0,9,4.0,11.0,30.451612903225808,58.0,0.759354838709676
1426.0,minimum cost homecoming of a robot in a grid,"class Solution:
    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
        
        rm=0
        lm=0
        rm=startPos[0]-homePos[0]# number of ups or downs
        lm=startPos[1]-homePos[1] # number of lefts or rights
        ans=0
        if rm<0:#we need to down
            a=startPos[0]
            while rm!=0:
                rm+=1
                ans+=rowCosts[a+1]#add costs according to the row numbers
                a+=1
        elif rm>0:#up
            a=startPos[0]
            while rm!=0:
                rm-=1
                ans+=rowCosts[a-1]
                a-=1
        if lm<0:#left
            a=startPos[1]
            while lm!=0:
                lm+=1
                ans+=colCosts[a+1]
                a+=1
        elif lm>0:#right
            a=startPos[1]
            while lm!=0:
                lm-=1
                ans+=colCosts[a-1]
                a-=1
        return ans",Medium,32,973,7.0,8,3.0,8.0,30.40625,48.0,2.0834375000000005
1427.0,count fertile pyramids in a land,"class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n, res = len(grid), len(grid[0]), 0
        dp = [row[:] for row in grid]
		
        for i, j in product(range(m-2,-1,-1), range(1, n-1)):
            if grid[i][j]:
                dp[i][j] = min(dp[i+1][k] for k in range(j-1, j+2))+1
                res += dp[i][j]-1
				
        dp[0] = grid[0][:]
        for i, j in product(range(1, m), range(1, n-1)):
            if grid[i][j]:
                dp[i][j] = min(dp[i-1][k] for k in range(j-1, j+2))+1
                res += dp[i][j]-1
        return res",Hard,15,594,0.0,4,3.0,7.0,39.6,33.0,2.716
1428.0,find target indices after sorting array,"class Solution:
    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        nums.sort()
        output = []
        for idx in range(len(nums)):
            if nums[idx] == target:
                output.append(idx)
        return output",Easy,7,257,0.0,2,3.0,2.0,36.71428571428572,13.0,5.095714285714286
1429.0,k radius subarray averages,"class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        output = [-1] * len(nums)
        running = 0
        for idx, i in enumerate(nums):
            running += i
            if idx >= k*2:
                output[idx - k] = running // (k*2+1)
                running -= nums[idx - k*2]
                
        return output",Medium,10,360,0.0,2,3.0,2.0,36.0,17.0,4.760000000000001
1430.0,removing minimum and maximum from array,"class Solution:
    def minimumDeletions(self, nums: List[int]) -> int:
        min_arr = max_arr = nums[0]
        min_i = max_i = 0
        n = len(nums)
        
		# finding max and min indices
        for i in range(1, n):
            if nums[i] > max_arr:
                max_arr = nums[i]
                max_i = i
                
            if nums[i] < min_arr:
                min_arr = nums[i]
                min_i = i
                
		# checking possibilities
        if min_i <= max_i:
            return min(min_i+1+n-max_i, max_i+1, n-min_i)
        else:
            return min(max_i+1+n-min_i, min_i+1, n-max_i)",Medium,20,632,2.0,3,3.0,4.0,31.6,28.0,4.0760000000000005
1431.0,find all people with secret,"class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        secretHolders = set()
        secretHolders.add(0)
        secretHolders.add(firstPerson)
        
        tupleMeetings = {}
        for meeting in meetings:
            time = meeting[2]
            if(time in tupleMeetings):
                tupleMeetings[time].append((meeting[0], meeting[1]))
            else:
                tupleMeetings[time] = [(meeting[0], meeting[1])]
        
        #print(tupleMeetings)
        for key in sorted (tupleMeetings):
            edgeList = tupleMeetings[key]
            adjacencyList = {}
            for edge in edgeList:
                if(edge[0] not in adjacencyList):
                    adjacencyList[edge[0]] = set()
                adjacencyList[edge[0]].add(edge[1])
                if(edge[1] not in adjacencyList):
                    adjacencyList[edge[1]] = set()
                adjacencyList[edge[1]].add(edge[0])
            
            frontier = set()
            for edgeNode in adjacencyList:
                if(edgeNode in secretHolders):
                    frontier.add(edgeNode)

            while(len(frontier) > 0):
                newFrontier = set()
                for item in frontier:
                    if(item in adjacencyList):
                        for neighbor in adjacencyList[item]:
                            if(neighbor not in secretHolders):
                                secretHolders.add(neighbor)
                                newFrontier.add(neighbor)
                frontier = newFrontier
        return list(secretHolders)",Hard,40,1644,1.0,6,4.0,13.0,41.1,37.0,2.0409999999999995
1432.0,finding 3 digit even numbers,"class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        n = len(digits)
        res = []
        
        for i in range(n):
            if digits[i] != 0:
                for j in range(n):
                    if j != i:
                        for k in range(n):
                            if digits[k] % 2 == 0 and k not in (i, j):
                                res.append(digits[i]*100+digits[j]*10+digits[k])
                            
        res = list(set(res))
        res.sort()
        return res",Easy,15,543,0.0,6,4.0,6.0,36.2,20.0,4.142
1433.0,delete the middle node of a linked list,"class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None:
            return head
        if head.next == None:
            return head.next
        node = head
        n = 0
        while(node != None):
            n+=1
            node = node.next
        mid = n//2
        print(mid)
        n = 0
        node = head
        while(node != None):
            if(n == mid-1):
                node.next = node.next.next
                break
            n += 1
            node = node.next  
        return head",Medium,21,572,0.0,-1,3.0,5.0,27.23809523809524,31.0,4.328571428571428
1434.0,step by step directions from a binary tree node to another,"class Solution:
    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        graph = defaultdict(set) # from.val -> (dest_node, 'L')
        
        que = deque([root])

        while que:
            size = len(que)
            for _ in range(size):
                node = que.popleft()
                if node.left:
                    que.append(node.left)
                    graph[node.val].add((node.left, 'L'))
                    graph[node.left.val].add((node, 'U'))
                if node.right:
                    que.append(node.right)
                    graph[node.val].add((node.right, 'R'))
                    graph[node.right.val].add((node, 'U'))
        
        
        
        que = deque([(startValue, '')])
        visited = set([startValue])
        while que:
            cnt, path = que.popleft()
            
            if cnt == destValue:
                return path
            
            for nei, label in graph[cnt]:
                if nei.val in visited:
                    continue
                que.append([nei.val, path + label])
                visited.add(nei.val)",Medium,33,1156,1.0,7,4.0,8.0,35.03030303030303,37.0,2.5272727272727264
1435.0,valid arrangement of pairs,"class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        
        # in degree table for each node
        in_degree = defaultdict(int)
        
        # out degree table for each node
        out_degree = defaultdict(int)
        
        # adjacency matrix for each node
        adj_matrix = defaultdict(list)
        
        
        # update table with input edge pairs
        for src, dst in pairs:
            
            in_degree[dst] += 1
            out_degree[src] += 1
            adj_matrix[src].append(dst)
            
        
        ## Case_#1:
        # There is eular circuit in graph, any arbitrary node can be start point, here we use source node of first edge just for convenience
        start_node_idx = pairs[0][0]
        
        
        ## Case_#2
        # There is no eular circuit. But there is eular path, find the start node by indegree and outdegree relation
        for node in adj_matrix:
            
			# find the node whose outdegree is one more than indegree
            if out_degree[node] - in_degree[node] == 1:
                start_node_idx = node
                break
        
        # ------------------------------------------------
        def eular_path( adjMatrix, path, cur_node):
            
            # Keep traverse to next node in DFS until all edges of current node are visited
            while adjMatrix[cur_node]:
                
                # pop one edge and get next visit node
                next_visit_node = adjMatrix[cur_node].pop()
                
                eular_path( adjMatrix, path, next_visit_node )
                
                # post-order style
                # current explorer is finished, record current edge pair 
                path.append([cur_node, next_visit_node])
                
                
        # ------------------------------------------------
        record = []
        eular_path(adj_matrix, record, start_node_idx)
        
        # reversed of post-order record is the answer of eular path        
        return reversed(record)",Hard,56,2105,16.0,3,3.0,8.0,37.58928571428572,35.0,3.3969642857142857
1436.0,find subsequence of length k with the largest sum,"class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)

        window = nums[:k]

        for i in range(k,n):
            curr_min = min(window)
            
            if nums[i] > curr_min:
                window.remove(curr_min)
                window.append(nums[i])

        return window",Easy,13,347,0.0,2,2.0,2.0,26.692307692307693,15.0,5.857692307692307
1437.0,find good days to rob the bank,"class Solution:
    def goodDaysToRobBank(self, sec: List[int], time: int) -> List[int]:
        result = []
        
        n = len(sec) - 1
        
        if time == 0:
            copied = sec
            copied.sort()
            if copied == sec:
                return list(range(n+1))
        
        if n <= time:
            return
        
        else:
            t = time
            while t - time >= 0 and t + time <= n:
                temp = time
                s = t - time
                u = t + time
                flag = True
				
                while temp:
                    if sec[s] < sec[s+1]:
                        flag = False
                        break
                    else:
                        s += 1
        
                    if sec[u] < sec[u-1]:
                        flag = False
                        break
                    else:
                        u -= 1
						
                    temp -= 1
					
                if flag == True:
                    result.append(t)
                t += 1
        
        return result",Medium,42,1094,0.0,4,4.0,8.0,26.047619047619047,49.0,2.275714285714285
1438.0,detonate the maximum bombs,"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        graph = defaultdict(set)
        for i, (x, y, r) in enumerate(bombs):
            for j, (a, b, _) in enumerate(bombs):
                if i != j and pow(x - a, 2) + pow(y - b, 2) <= r * r:
                    graph[i].add(j)
        max_bombs = 1
        for start in graph:
            detonated = set()
            layer = {start}
            while layer:
                new_layer = set()
                for current_bomb in layer:
                    if current_bomb not in detonated:
                        detonated.add(current_bomb)
                        if current_bomb in graph:
                            new_layer.update(graph[current_bomb])
                layer = new_layer
            max_bombs = max(max_bombs, len(detonated))
        return max_bombs",Medium,20,860,0.0,8,4.0,8.0,43.0,32.0,2.209999999999999
1439.0,rings and rods,"class Solution:
    def countPoints(self, rings: str) -> int:
        colors = {'R': 0, 'G': 1, 'B': 2}
        result = 0
        rods = [0] * 10 
        for i in range(0, len(rings), 2):
            color = rings[i]
            rod = int(rings[i+1])
            if rods[rod] != 7:
                rods[rod] |= 1 << colors[color]
                if rods[rod] == 7:
                    result += 1
                    
        return result",Easy,13,441,0.0,3,3.0,3.0,33.92307692307692,28.0,3.7869230769230775
1440.0,sum of subarray ranges,"class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        result = 0
        n = len(nums)
        for i in range(n) :
            Min, Max = nums[i], nums[i]
            
            for j in range(i, n, 1) :
                Min = min(Min, nums[j])
                Max = max(Max, nums[j])
                result -= Max - Min
            
        return abs(result)",Medium,12,385,0.0,2,3.0,2.0,32.083333333333336,19.0,4.9125
1441.0,watering plants ii,"class Solution:
    def minimumRefill(self, nums: List[int], capacityA: int, capacityB: int) -> int:
        
        
        n = len(nums)
        
        i = 0
        j = n-1
        
        canA = capacityA
        canB = capacityB
        
        count = 0
        
        while(i<j):
    
            # water the left plant
            if canA < nums[i]:
                canA = capacityA   
                count += 1
            canA -= nums[i]
            i += 1
            
            # water the right plant
            if canB < nums[j]:
                canB = capacityB
                count += 1
            canB -= nums[j]
            j -= 1
        
        # if both point to same plant in cases (it'll only happen if n is odd)
        if i==j:
            if canA > canB:
                if canA < nums[i]:
                    canA = capacityA    
                    count += 1
                canA -= nums[i]
            else:
                if canB < nums[j]:
                    canB = capacityB 
                    count += 1
                canB -= nums[j]
                
        
        return count",Medium,44,1135,3.0,6,3.0,9.0,25.795454545454547,46.0,2.6584090909090907
1442.0,maximum fruits harvested after at most k steps,"class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        
        f = [0] * (2 * 10**5 + 1)
        for a, b in fruits:
            f[a] = b

        f_acc = list(accumulate(f, initial=0))
        n = len(f_acc)
        
        startPos += 1
        left_only = f_acc[startPos] - f_acc[max(0, startPos - k - 1)]
        right_only = f_acc[min(n - 1, startPos + k)] - f_acc[startPos - 1]
        ans = max(left_only, right_only)
        
        # turn left and then right
        for i in range(1, (k - 1) // 2 + 1):
            
            first_left = f_acc[startPos] - f_acc[max(0, startPos - i - 1)]
            then_right = f_acc[min(n - 1, startPos + k-2*i)] - f_acc[startPos]
        
            first_right = f_acc[min(n - 1, startPos + i)] - f_acc[startPos - 1]
            then_left = f_acc[startPos - 1] - f_acc[max(0, startPos - (k - 2*i) - 1)]
            ans = max(ans, first_left + then_right, first_right + then_left)
        
        return ans",Hard,25,1016,1.0,2,3.0,2.0,40.64,37.0,2.3824000000000005
1443.0,find first palindromic string in the array,"class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]: return word
        return """"",Easy,4,163,0.0,1,2.0,2.0,40.75,12.0,4.952500000000001
1444.0,adding spaces to a string,"class Solution:
    def addSpaces(self, s: str, spaces: List[int]) -> str:
        outpur=""""
        rest=0
        for k in range(len(s)):
            if rest<len(spaces) and k == spaces[rest]:
                outpur=outpur+"" ""
                rest=rest+1
            outpur=outpur+s[k]
        return(outpur)",Medium,9,310,0.0,2,3.0,2.0,34.44444444444444,18.0,4.800000000000001
1445.0,number of smooth descent periods of a stock,"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        lastPrice = None
        counter = 0
        seen = 0
        
        for price in prices:
            if lastPrice and lastPrice - price == 1:
                counter += 1 + seen
                seen += 1
            else:
                seen = 0
                
            counter += 1
            lastPrice = price
            
        return counter",Medium,16,440,0.0,2,3.0,2.0,27.5,19.0,5.325
1446.0,minimum operations to make the array k increasing,"class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        n = len(arr)
        
        def lis(nums):
            '''
            Patience sort
            Time: O(NlogN)
            Space: O(N)
            '''
            n = len(nums)
            if n <= 1:
                return n
            # num, pointer
            c = []
            size = 0

            for x in nums:
			    # bisect as it is non-decreasing
                l = bisect.bisect_right(c, x)
                if l < size:
                    c[l] = x
                else:
                    c.append(x)
                    size = max(size, l+1)

            return size
        
        ans = 0
        for i in range(k):
            sub = []
            for j in range(i, n, k):
                sub.append(arr[j])
            ans += len(sub) - lis(sub)
        
        return ans",Hard,35,881,3.0,3,3.0,5.0,25.17142857142857,34.0,4.094571428571429
1447.0,maximum number of words found in sentences,"class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int: 
        c=0
        m=0
        for i in range(len(sentences)):
            c=sentences[i].count(' ')
            if c+1>m:
                m=c+1
        return m",Easy,8,238,0.0,2,3.0,2.0,29.75,12.0,5.8225
1448.0,find all possible recipes from given supplies,"class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        available_ingredients=[]
        
        cook={}
        for ing in supplies:
            available_ingredients.append(ing)
        
        for rec in range(len(recipes)):
            cook[recipes[rec]]=ingredients[rec]
        
        def canCook(recipe,waiting):
            
            
            needed_ingrediants=cook[recipe]
            
            count=0
            for ing in needed_ingrediants:
                if ing in waiting:
                    return False
                if ing in available_ingredients:
                    count+=1
                elif ing in recipes:
                    waiting.append(ing)
                    if canCook(ing,waiting):
                        available_ingredients.append(ing)
                        count+=1
                    
                
            return count==len( needed_ingrediants)
            
        
        result=[]
        for recipe in recipes:

            if canCook(recipe,[]):
                result.append(recipe)
        
        return result",Medium,38,1175,0.0,7,4.0,9.0,30.92105263157895,33.0,3.2571052631578947
1449.0,check if a parentheses string can be valid,"class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        if len(s) % 2 == 1:
            return False
        
        # Left to right, try to balance "")""
        balance = 0
        for i in range(len(s)):
            if s[i] == ""("" or locked[i] == ""0"":
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                return False
                
        # Right to left, try to balance ""(""
        balance = 0
        for i in range(len(s) - 1, -1, -1):
            if s[i] == "")"" or locked[i] == ""0"":
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                return False
        
        return True",Medium,25,744,2.0,4,3.0,7.0,29.76,43.0,2.6816000000000004
1450.0,abbreviating the product of a range,"class Solution:
    def abbreviateProduct(self, left: int, right: int) -> str:
        ans = 1                                                                  //Initialise the product with 1
        while left <= right:                                               // Start the multiplying numbers in
            if left == right:                                                 // Exception case when left is right else the number will be multiplied 2 times
                ans *= left                                                   //then only multiply either left or right
            else:
                ans *= left * right                                        // Else multiply left and right numbers and multiply with ans
            left += 1                                                         // Increment left by one
            right -= 1                                                        //Decrement right by 1
        count = 0                                                           // Initialise count of trailing zeroes
        ans = str(ans)                                                    // Converting integer to string
        i = len(ans) - 1                                                  // Start the pointer with end of string
        while i >= 0 and ans[i] == '0':                          // Decrement pointer by one while the value at pointer is 0
            count += 1                                                   //and increase the count of trailing zeroes
            i -= 1
        fans = ''                                                            //Empty string which will store the number without the trailing zeroes
        for j in range(i+1):                                            // will use the i pointer which stored the last location of the trailing zero
            fans += ans[j]                                              //store each character until the trailing zero isn't reached
        final = ''                                                           //Final ans which will give the required result 
        if len(fans) > 10:                                              //If the length of the number without the trailing zeroes has a length greater than 10
            temp1 = ''                                                   //Will store the first 5 character of the number
            for j in range(5):                                          // Adding the first 5 characters
                temp1 += fans[j]
            temp2 = ''                                                   //Will store the last 5 characters of the number
            for j in range(-5,0):                                      // Add the last 5 characters
                temp2 += fans[j]
            final = temp1 + '...' + temp2 + 'e' + str(count)           //Final ans with first 5 character, last 5 characters + e + count of trailing zeroes
        else:                                                                    //If length of the number is less than 10
            final = fans + 'e' + str(count)                         // Final ans with number without trailing zeroes + e + count of trailing zeroes
        return final                                                      //Return the final string",Hard,30,3293,0.0,6,13.0,10.0,109.76666666666668,48.0,-5.818999999999999
1451.0,a number after a double reversal,"class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        return num == 0 or num % 10",Easy,2,105,0.0,0,2.0,0.0,52.5,8.0,4.355
1452.0,execution of all suffix instructions staying in a grid,"class Solution:
    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:
        grid = [[0]*n for _ in range(n)]
        directions = {'R':(0,1),'L':(0,-1),'U':(-1,0),'D':(1,0)}
        l = len(s)
        ans = [0]*l
        temp = startPos.copy()
        for i in range(l):
            step = 0
            startPos = temp.copy()
            for j in range(i,l):
                d = directions[s[j]]
                new_start  = [startPos[0]+d[0],startPos[1]+d[1]]
                if 0<=new_start[0]<n and 0<=new_start[1]<n :
                    step += 1
                    startPos = new_start
                else:
                    break
            ans[i] = step
        
        return ans",Medium,20,728,0.0,2,3.0,4.0,36.4,44.0,2.024
1453.0,intervals between identical elements,"class Solution:
    def getDistances(self, arr: List[int]) -> List[int]:
        indices = defaultdict(list)
        prefsum = {}
        for i, a in enumerate(arr):
            indices[a].append(i)
            if a not in prefsum:
                prefsum[a] = [i]
            else:
                prefsum[a].append(i + prefsum[a][-1])
        res = []
        for i, a in enumerate(arr):
            idx = bisect_right(indices[a], i) - 1
            # count of smaller, count of larger
            sc, lc = idx, len(indices[a]) - idx - 1
            ss = prefsum[a][idx - 1] if idx > 0 else 0  # sum of smaller
            ls = prefsum[a][-1] - prefsum[a][idx]  # sum of larger
            res.append(i * sc - ss + ls - i * lc)
        return res",Medium,18,748,3.0,3,3.0,4.0,41.55555555555556,24.0,3.62
1454.0,recover the original array,"class Solution:
    def recoverArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        n = len(nums)
        
        def check(k):
            cnt = defaultdict(int)
            ans = []
            for x in nums:
                if cnt[x - 2*k] > 0:
                    cnt[x - 2*k] -= 1
                    ans.append(x - k)
                else:
                    cnt[x] += 1
            if len(ans) == n // 2: return ans
            return []
                       
	    # maximum k should not exceed half of the array
        cand_k = sorted(set((nums[i] - nums[0]) // 2 for i in range(1, n // 2 + 1) if (nums[i] - nums[0]) % 2 == 0))
        for k in cand_k:
            if k == 0: continue
            ans = check(k)
            if ans: return ans",Hard,22,773,1.0,3,3.0,8.0,35.13636363636363,31.0,3.417727272727274
1455.0,check if all as appears before all bs,"class Solution:
    def checkString(self, s: str) -> bool:
        return ""ba"" not in s",Easy,2,87,0.0,0,2.0,0.0,43.5,5.0,5.465
1456.0,number of laser beams in a bank,"class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        prev, res = 0, 0
        for i in range(len(bank)):
            ones = bank[i].count(""1"")
            if ones == 0: continue  #we can ignore rows without any ""1""
            
            if prev > 0:  #if we have some 1's in prev row we multiply with current ones to get number of lasers
                res += prev * ones
            prev = ones  #storing curr 1's to find lasers from current to next row
            
        return res",Medium,11,514,3.0,2,3.0,4.0,46.72727272727273,18.0,3.8145454545454553
1457.0,destroying asteroids,"class Solution:
    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:
      asteroids.sort()
      while asteroids:
        ind = bisect.bisect_right(asteroids, mass)
        if ind == len(asteroids): return True
        elif ind == 0: return False
        else:
          #it can collide with all asteroids before this index
          mass += sum(asteroids[:ind])
          asteroids = asteroids[ind:]",Medium,10,423,1.0,2,2.0,4.0,42.3,23.0,3.693000000000001
1458.0,maximum employees to be invited to a meeting,"class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        n = len(favorite)
        graph = [[] for _ in range(n)]
        for i, x in enumerate(favorite): graph[x].append(i)
        
        def bfs(x, seen): 
            """"""Return longest arm of x.""""""
            ans = 0 
            queue = deque([x])
            while queue: 
                for _ in range(len(queue)): 
                    u = queue.popleft()
                    for v in graph[u]: 
                        if v not in seen: 
                            seen.add(v)
                            queue.append(v)
                ans += 1
            return ans 
        
        ans = 0 
        seen = [False]*n
        for i, x in enumerate(favorite): 
            if favorite[x] == i and not seen[i]: 
                seen[i] = seen[x] = True 
                ans += bfs(i, {i, x}) + bfs(x, {i, x})
                
        dp = [0]*n
        for i, x in enumerate(favorite): 
            if dp[i] == 0: 
                ii, val = i, 0
                memo = {}
                while ii not in memo: 
                    if dp[ii]: 
                        cycle = dp[ii]
                        break
                    memo[ii] = val
                    val += 1
                    ii = favorite[ii]
                else: cycle = val - memo[ii]
                for k in memo: dp[k] = cycle
        return max(ans, max(dp))",Hard,41,1428,0.0,9,4.0,13.0,34.829268292682926,56.0,0.4853658536585357
1459.0,capitalize the title,"class Solution:
    def capitalizeTitle(self, title: str) -> str:
        li=title.split()
        ans=[]
        for i in range(0,len(li)):
            if len(li[i])==1 or len(li[i])==2:
                li[i]=li[i].lower()
            else:
                li[i]=li[i].capitalize()

        return "" "".join(li)",Easy,10,311,0.0,2,3.0,2.0,31.1,19.0,5.001
1460.0,maximum twin sum of a linked list,"class Solution:
    def _findMid(self, head):
        prev = None
        fast = slow = head
        while fast and fast.next:
            prev, slow, fast = slow, slow.next, fast.next.next
        if prev: prev.next = None
        return slow
    
    def _revList(self, head):
        prev = None
        while head:
            head.next, prev, head = prev, head, head.next
        return prev
            
    
    def pairSum(self, head: Optional[ListNode]) -> int:
        # Find 2nd middle node
        mid = self._findMid(head)
        #Reverse list from mid
        tail = self._revList(mid)
        mx = 0
        while head:
            mx = max(mx, head.val + tail.val)
            head, tail = head.next, tail.next
        return mx",Medium,25,745,2.0,2,2.0,4.0,29.8,36.0,3.558
1461.0,longest palindrome by concatenating two letter words,"class Solution:
    def longestPalindrome(self, words: List[str]) -> int:
        
        palindromicPairsFinder = collections.Counter(); count = 0
        for word in words:
            reversedWord = word[::-1]
            if palindromicPairsFinder[reversedWord] > 0:
                count += 1
                palindromicPairsFinder[reversedWord] -= 1
            else:
                palindromicPairsFinder[word] += 1

        return 2 * (2 * count + any(word[0] == word[1] for word in palindromicPairsFinder if palindromicPairsFinder[word] > 0))",Medium,12,552,0.0,2,3.0,4.0,46.0,21.0,3.46
1462.0,stamping the grid,"class Solution:
    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
        m, n = len(grid), len(grid[0])
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m):
            for j in range(n): 
                prefix[i+1][j+1] = grid[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
        
        seen = [[0]*n for _ in range(m)]
        for i in range(m-stampHeight+1): 
            for j in range(n-stampWidth+1): 
                diff = prefix[i+stampHeight][j+stampWidth] - prefix[i+stampHeight][j] - prefix[i][j+stampWidth] + prefix[i][j]
                if diff == 0: seen[i][j] = 1
                    
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m): 
            for j in range(n): 
                prefix[i+1][j+1] = seen[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]
                
        for i in range(m):
            ii = max(0, i-stampHeight+1)
            for j in range(n): 
                jj = max(0, j-stampWidth+1)
                if grid[i][j] == 0 and prefix[i+1][j+1] - prefix[i+1][jj] - prefix[ii][j+1] + prefix[ii][jj] == 0: return False 
        return True",Hard,24,1198,0.0,9,3.0,15.0,49.91666666666666,42.0,0.5875000000000021
1463.0,check if every row and column contains all numbers,"class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        n=len(matrix)
        
        return all(len(set(row))==n for row in matrix) and all(len(set(col))==n for col in zip(*matrix))",Easy,4,210,0.0,0,2.0,2.0,52.5,12.0,3.955
1464.0,minimum swaps to group all 1s together ii,"class Solution:
    def minSwaps(self, nums: List[int]) -> int:

        cntone = 0
        
		# First, compute how many 1s here
        for n in nums:
            if n == 1:
                cntone += 1
    
        l, res = 0, float('inf')
		
		# Doing this for circular array
        nums.extend(nums)
        
        need = {0:0, 1:0}
		
		# Start sliding window
        for r, val in enumerate(nums):
            need[val] += 1
             
			# our window should group all 1 together 
            if need[0] + need[1] == cntone:
                res = min(res, need[0])
                need[nums[l]] -= 1
                l += 1
                
        return res if res != float('inf') else 0",Medium,27,699,4.0,4,2.0,6.0,25.88888888888889,32.0,4.27
1465.0,count words obtained after adding a letter,"class Solution:
    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:
        # turns word into binary string
        # i.e., 'ab' -> b11
        # 'ac' -> b101
        # 'ad' -> b1001
        # a-z -> b11111111111111111111111111
        def bin_word(word):
            num = 0
            for c in word:
                cn = ord(c) - ord('a')
                mask = 1 << cn
                num ^= mask
            return num
        
        # take out a letter from a binary string
        def bin_take_out(word, letter):
            cn = ord(letter) - ord('a')
            mask = 1 << cn
            return word ^ mask

        starts = set([bin_word(w) for w in startWords])
            
        count = 0
        for t in targetWords:
            t_b = bin_word(t)
            for c in t:
                # try taking out each letter in t
                # and see if the resulting binary
                # in starts
                if bin_take_out(t_b, c) in starts:
                    count += 1
                    break
        return count",Medium,33,1075,9.0,1,3.0,6.0,32.57575757575758,34.0,3.788181818181819
1466.0,earliest possible day of full bloom,"class Solution:
    def earliestFullBloom(self, plantTime, growTime):
        PLANT, GROW = 0,1
        #create array of (plant, grow) tuples
        times = list(zip(plantTime, growTime))

        #sort by grow time
        times.sort(key=lambda i:i[GROW], reverse=True)

        prev_plant = prev_bloom = 0
        for time in times:
            cur_bloom = time[PLANT]+time[GROW]

            #get the time of the last bloom
            prev_bloom = max(prev_bloom, prev_plant+cur_bloom)

            prev_plant += time[PLANT]

        return prev_bloom",Hard,18,556,3.0,1,2.0,1.0,30.88888888888889,21.0,5.0600000000000005
1467.0,divide a string into groups of size k,"class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        
		# s = ""abcdefghij"", k = 3, fill = ""x""
		
        res = []
        for i in range(0, len(s), k):
            res.append(s[i:i+k])
            # print(res) ['abc', 'def', 'ghi', 'j']
            
            while len(res[-1]) < k:
                    res[-1] += fill
        return res",Easy,12,379,2.0,2,3.0,2.0,31.58333333333333,25.0,4.437500000000001
1468.0,minimum moves to reach target score,"class Solution:
    def minMoves(self, target: int, maxDoubles: int) -> int:
        step = 0
        while target != 1  :
            if target % 2 == 1:
                if maxDoubles == 0:
                    step += target -1
                    target = 1
                else:
                    target -= 1
                    step +=1
            else:
                if maxDoubles > 0:
                    target = target/ 2
                    step +=1
                    maxDoubles -=1
                else:
                    step +=1
                    target -=1
        return int(step)",Medium,19,605,0.0,4,4.0,4.0,31.84210526315789,32.0,3.454210526315789
1469.0,solving questions with brainpower,"class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions)
        
        # set dp array
        dp = [0]*n
        
        # start from last
        dp [-1] = questions[-1][0]
        
        # start setting the rest
        for i in reversed(range(n-1)):
            points, skip = questions[i]
            
            # dp formula
            if i + skip + 1 < n : dp[i] = max(dp[i+1], points + dp[i + skip + 1])
            else: dp [i] = max(points, dp[i+1])
    
        return dp[0]",Medium,18,539,4.0,2,3.0,3.0,29.944444444444443,18.0,5.365
1470.0,maximum running time of n computers,"class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        l, h = min(batteries), sum(batteries)
        
        batteries.sort()
        cands = batteries[-n:]
        rest = sum(batteries[:-n])
        
        def bs(t):
            tmp = rest
            for x in cands:
			    # all rest batteries on computer can run more than t time
                if x >= t: return True
				# need t - x batteries to fill
                tmp -= t - x
				if tmp < 0: return False
            return True
            
        
        while l < h:
            mid = l + (h - l + 1) // 2
            if bs(mid):
                l = mid
            else:
                h = mid  - 1
        
        return l",Hard,26,727,2.0,2,3.0,5.0,27.96153846153846,30.0,4.263461538461539
1471.0,minimum cost of buying candies with discount,"class Solution:
    def minimumCost(self, cost: List[int]) -> int:
        cost.sort(reverse=True)
        res = sum(cost)
        i = 2
        while i < len(cost):
            res -= cost[i]
            i += 3 #skip every 2 elements to eliminate the max possible price
            
        return res",Easy,9,302,1.0,1,3.0,1.0,33.55555555555556,12.0,5.58
1472.0,count the hidden sequences,"class Solution:
    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int: 
        total_sequences = 0
        sequence = [lower] 
        
        for j in range(len(differences)):
            x = sequence[j] + differences[j]
            sequence.append(x)
        
        minn, maxx = min(sequence), max(sequence)
        
        if lower <= minn <= upper and lower <= maxx <= upper: total_sequences += 1
            
        for i in range(lower + 1, upper+1):
            minn = minn + 1
            maxx = maxx + 1
            
            if lower <= minn <= upper and lower <= maxx <= upper: total_sequences += 1
            
        return total_sequences",Medium,19,692,0.0,4,3.0,7.0,36.42105263157895,40.0,2.3021052631578947
1473.0,k highest ranked items within a price range,"class Solution:
    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
        q = deque([tuple(start)])
        m, n = len(grid), len(grid[0])
        lower, upper = pricing[0], pricing[1]
        ranked_arr = []
        visited = {tuple(start)}
        adj = [(-1, 0), (0, -1), (0, 1), (1, 0)]
        while q:
            next_q = []
            for _ in range(len(q)):
                cur = q.popleft()
                x, y = cur
                if lower <= grid[x][y] <= upper:
                    ranked_arr.append(list(cur))
                
                for dx, dy in adj:
                    if ((x + dx, y + dy) in visited or
                        not (0 <= x + dx < m and 0 <= y + dy < n) or
                        grid[x + dx][y + dy] == 0
                    ):
                        continue
                    next_q.append((x + dx, y + dy))
                    visited.add((x + dx, y + dy))
            next_q.sort(key=lambda xy: xy[1])
            next_q.sort(key=lambda xy: xy[0])
            next_q.sort(key=lambda xy: grid[xy[0]][xy[1]])
            q = deque(next_q)
        return ranked_arr[:k]",Medium,28,1194,0.0,3,4.0,5.0,42.642857142857146,62.0,-0.4578571428571436
1474.0,number of ways to divide a long corridor,"class Solution:
    def numberOfWays(self, corridor: str) -> int:
        n = len(corridor)
        if n==1:
            return 0
        d = defaultdict(int)
        numS = 0
        
        for i in range(n):
            if (numS==0 or numS%2==1) and corridor[i]=='P':
                continue
            if corridor[i]=='P':
                d[numS//2] += 1
            else:
                numS += 1

        if numS==0 or numS%2:
            return 0
        if corridor[-1]=='P':
            d[numS//2] = 0

        ret = 1
        for v in d.values():
            ret *= (v+1)
        return ret%(10**9+7)",Hard,24,614,0.0,4,3.0,7.0,25.58333333333333,42.0,3.077500000000001
1475.0,count elements with strictly smaller and greater elements,"class Solution:
    def countElements(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        # sort the num
        nums.sort()
        i = 1
        j = len(nums)-2
        while i < len(nums) and nums[i] == nums[i-1]:
            i+=1
        while j >= 0 and nums[j] == nums[j+1]:
            j-=1
        return max(0,j-i+1)",Easy,12,359,1.0,2,3.0,3.0,29.916666666666668,23.0,4.7475000000000005
1476.0,rearrange array elements by sign,"class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        a=[0]*len(nums)
        p=0
        n=1
        for i in nums:
            if i<0:
                a[n]=i
                n+=2
            else:
                a[p]=i
                p+=2
        return a",Medium,12,289,0.0,2,3.0,2.0,24.08333333333333,16.0,5.9325
1477.0,find all lonely numbers in the array,"class Solution:
    def findLonely(self, nums: List[int]) -> List[int]:
        d = {}
        for num in nums:
            d[num] = d.get(num, 0) + 1
        
        ans = []
        for num in nums:
            if d[num] == 1 and (num-1) not in d and (num+1) not in d:
                ans.append(num)
        
        return ans",Medium,11,331,0.0,3,3.0,3.0,30.09090909090909,15.0,5.431818181818183
1478.0,maximum good people based on statements,"class Solution:
    def maximumGood(self, s: List[List[int]]) -> int:
        """"""
        brute force: try if all N people are good, if not, try N-1 etc.
        """"""
        N = len(s)
        
        gooddict = defaultdict(set)
        baddict = defaultdict(set)
        
        for r in range(N):
            for c in range(N):
                if s[r][c]==1: 
                    gooddict[r].add(c)
                elif s[r][c] == 0:
                    baddict[r].add(c)
     
        def valid(good):
            bad = set(x for x in range(N) if x not in good)
            for g in good:
                for gg in gooddict[g]:
                    if gg not in good:
                        return False
                for gb in baddict[g]:
                    if gb not in bad:
                        return False
            return True
        
        for t in range(len(s),0,-1):
            choices = set(itertools.combinations(range(N), t))
            for c in choices:
                if valid(c):
                    return t
                
        return 0",Hard,34,1076,0.0,8,4.0,17.0,31.647058823529413,35.0,2.931764705882353
1479.0,keep multiplying found values by two,"class Solution:
    def findFinalValue(self, nums: List[int], x: int) -> int:
        nums = set(nums)
        while True:
            if x in nums:
                x *= 2
            else:
                break
        return x",Easy,8,228,0.0,1,3.0,2.0,28.5,12.0,5.995
1480.0,all divisions with the highest score of a binary array,"class Solution:
    def maxScoreIndices(self, nums: List[int]) -> List[int]:
	
        t1 = [0]                                                              #Initialise array for prefix sum
        t2 = [0]*(len(nums)+1)                                      #Initialise array for suffix sum
		
		#Create preffix sum
        for i in nums:
            if not t1:
                t1.append(0)
            else:
                if i == 0:
                    t1.append(t1[-1]+1)
                else:
                    t1.append(t1[-1])
					
		#Create suffix sum
        for i in range(len(nums) - 1, -1, -1):
            t2[i] = nums[i]+t2[i+1]
        ans = []
		
		#Assign score to each index
        for i in range(len(t1)):
            ans.append((t1[i]+t2[i], i))
			
		#Sort in reverse order
        ans.sort(reverse = True)
		
		#Take the max score
        ans1 = ans[0][0]
        t = []
		
		#Check for indexes having the max score
        for i in ans:
            if i[0] == ans1:
                t.append(i[1])
        return t",Medium,36,1040,8.0,7,3.0,10.0,28.88888888888889,30.0,4.120000000000001
1481.0,find substring with given hash value,"class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        sol = 0
        powr = 1
        
        for i in range(0, k, 1):
            sol += (ord(s[i]) - ord('a') + 1) * powr
            powr = powr * power
        if sol % modulo == hashValue: 
            return s[:k]
        
        powr = powr // power
        for i in range(1, len(s) - k + 1, 1):
            sol = ((sol - (ord(s[i - 1]) - ord('a') + 1)) // power) + ((ord(s[i + k - 1]) - ord('a') + 1) * powr)
            if (sol % modulo == hashValue):
                return s[i:i + k]
            
        return """"",Hard,17,636,0.0,2,3.0,4.0,37.41176470588236,35.0,2.8329411764705883
1482.0,minimum sum of four digit number after splitting digits,"class Solution:
    def minimumSum(self, num: int) -> int:
        string = str(num)
        arr = [char for char in string]
        arr.sort()
        
        # two possible combination
        result1 = int(arr[0]+ arr[2]) + int(arr[1] + arr[3])
        result2 = int(arr[1]+ arr[2]) + int(arr[0] + arr[3])
        
        return min(result1, result2)",Easy,10,355,1.0,0,2.0,1.0,35.5,10.0,5.725
1483.0,partition array according to given pivot,"class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lessthan = []
        for i in nums:
            if i < pivot:
                lessthan.append(i)
        equal = []
        for i in nums:
            if i == pivot:
                equal.append(i)
        great = []
        for i in nums:
            if i > pivot:
                great.append(i)
        return lessthan + equal + great",Medium,14,430,0.0,6,3.0,6.0,30.714285714285715,21.0,4.595714285714286
1484.0,minimum cost to set cooking time,"class Solution:
    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:   
        mins = targetSeconds // 60
        secs = targetSeconds % 60
        min_cost = math.inf
        
        if mins <= 99:
            cost1 = cost(mins, secs, startAt, moveCost, pushCost)
            min_cost = min(min_cost, cost1)
        if secs <= 39:
            cost2 = cost(mins - 1, secs + 60, startAt, moveCost, pushCost)
            min_cost = min(min_cost, cost2)
            
        return min_cost
        
def cost(mins, secs, startAt, moveCost, pushCost):
    cost = 0
    has_prev = False
    
    for digit in [mins // 10, mins % 10, secs // 10, secs % 10]:
        if has_prev or digit != 0:
            if digit != startAt:
                cost += moveCost
                startAt = digit
            cost += pushCost
            has_prev = True
    
    return cost",Medium,27,912,0.0,4,3.0,5.0,33.77777777777778,53.0,1.2400000000000002
1485.0,minimum difference in sums after removal of elements,"class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums)//3
        pq0 = [-x for x in nums[:n]]
        pq1 = nums[-n:]
        
        heapify(pq0)
        heapify(pq1)
        
        ans = -sum(pq0) - sum(pq1)
        prefix = [0]
        for i in range(n, 2*n): 
            prefix.append(prefix[-1])
            if nums[i] < -pq0[0]: 
                prefix[-1] += nums[i] + pq0[0]
                heapreplace(pq0, -nums[i])
        extra = prefix[-1]
        suffix = 0 
        for i in reversed(range(n, 2*n)): 
            if nums[i] > pq1[0]: 
                suffix += pq1[0] - nums[i]
                heapreplace(pq1, nums[i])
            extra = min(extra, prefix[i-n] + suffix)
        return ans + extra",Hard,23,759,0.0,5,3.0,8.0,33.0,28.0,3.750000000000001
1486.0,sort even and odd indices independently,"class Solution:
    def sortEvenOdd(self, nums: List[int]) -> List[int]:
        return reduce(add, zip_longest(sorted([nums[i] for i in range(0,len(nums),2)]), sorted([nums[i] for i in range(1,len(nums),2)])[::-1]))[:len(nums)]",Easy,2,228,0.0,1,2.0,2.0,114.0,14.0,-1.84
1487.0,smallest value of the rearranged number,"class Solution:
    def smallestNumber(self, num: int) -> int:
        if num//10==0:
            return num
        if num<0:
            sign=-1
        else:
            sign=1
        num=abs(num)    
        if sign==-1:
            s=sorted(str(num),reverse=True)
            return sign*int("""".join(s))
        else:
            s=sorted(str(num))
            zeros=s.count('0')
            if zeros!=0:
                s[0],s[zeros]=s[zeros],s[0]
            return sign*int("""".join(s))",Medium,17,494,0.0,2,3.0,4.0,29.058823529411764,30.0,4.084705882352941
1488.0,minimum time to remove all cars containing illegal goods,"class Solution:
    def minimumTime(self, s: str) -> int:
        costL2R = [None]*len(s)
        cost = 0 if s[0]=='0' else 1
        costL2R[0]=cost
        for i in range(1,len(s)):
            if s[i]=='1':
                cost = min(cost+2,i+1)
            costL2R[i]=cost           
                
        costR2L = [None]*len(s)
        cost = 0 if s[-1]=='0' else 1
        costR2L[-1] = cost
        for i in range(len(s)-2,-1,-1):
            if s[i]=='1':
                cost = min(cost+2,len(s) - (i+1)+1)
            costR2L[i] = cost
        costR2L.append(0)
            
        minCost = len(s)
        for i in range(len(s)):
            minCost = min(minCost,costL2R[i]+costR2L[i+1])
        return minCost",Hard,22,728,0.0,5,3.0,7.0,33.09090909090909,40.0,2.541818181818182
1489.0,count operations to obtain zero,"class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        count = 0
        while num1 > 0 and num2 > 0:
            if num1 >= num2:
                num1 -= num2
            else:
                num2 -= num1
            count += 1
        return count",Easy,9,279,0.0,2,3.0,2.0,31.0,18.0,5.11
1490.0,minimum operations to make the array alternating,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        x,y={},{}
        for i in range(0,len(nums),2):         # count the occurence of number 
            x[nums[i]]=x.get(nums[i],0)+1
        for i in range(1,len(nums),2):          # count the occurence of number
            y[nums[i]]=y.get(nums[i],0)+1
        sum1=sum(x.values())                  # count the total occurence of number
        sum2=sum(y.values())                   # count the occurence of number
        l1=[(k,x[k]) for k in x.keys()]           # make list 
        l2=[(k,y[k]) for k in y.keys()]           # make list
        l1=sorted(l1,key=lambda x:x[1],reverse=True)     # sort in reverse order
        l2=sorted(l2,key=lambda x:x[1],reverse=True)
        for i in l1:
            for j in l2:
                if i[0]!=j[0]:        # check the given condition
                    return sum1-i[1]+sum2-j[1]      # convert list into nums[i-1] and nums[i]
        return min(sum1,sum2)     # return minimum occurance",Medium,17,1023,10.0,3,4.0,7.0,60.1764705882353,41.0,0.4641176470588242
1491.0,removing minimum number of magic beans,"class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        #sort the array
        beans = sorted(beans)
        #create array for dynamic programming
        dp = [0] * len(beans)
        #prefix sum
        for i in range(len(beans)):
            dp[i] = dp[i-1] + beans[i]
        #find the minimum number looping through the dp array 
        res = (dp[-1] - dp[0]) - beans[0] * (len(beans) - 1)
        for i in range(1, len(beans)):
            res = min(res, (dp[-1] - dp[i]) - beans[i] * (len(beans) - i - 1) + dp[i-1] )
        return res",Medium,13,567,4.0,2,3.0,3.0,43.61538461538461,14.0,4.534615384615385
1492.0,maximum and sum of array,"class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        
        @lru_cache(None)
        def dp(i, m1, m2):
            if i == len(nums):
                return 0

            ans = float('-inf')
            for j in range(numSlots):
                if m1 &amp; (1 << j):
                    ans = max(ans, (nums[i] &amp; (j + 1)) + dp(i + 1, m1 ^ (1 << j), m2))
                elif m2 &amp; (1 << j):
                    ans = max(ans, (nums[i] &amp; (j + 1)) + dp(i + 1, m1, m2 ^ (1 << j)))
            return ans

        return dp(0, (1<<numSlots)-1, (1<<numSlots)-1)",Hard,16,610,0.0,2,3.0,4.0,38.125,40.0,2.26875
1493.0,count equal and divisible pairs in an array,"class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        count=0
        n=len(nums)
        for i in range(n):
            for j in range(i+1,n):
                if nums[i]==nums[j] and (i*j)%k==0:
                    count+=1
        
        return count",Easy,9,282,0.0,3,3.0,3.0,31.33333333333333,20.0,4.82
1494.0,find three consecutive integers that sum to a given number,"class Solution:
    def sumOfThree(self, num: int) -> List[int]:
        rightHandSide = num - 3
        if rightHandSide % 3 != 0:
            return []
        firstNumber = rightHandSide // 3
        
        return [firstNumber, firstNumber + 1, firstNumber + 2]",Medium,7,266,0.0,0,2.0,1.0,38.0,11.0,5.36
1495.0,maximum split of positive even integers,"class Solution:
    def maximumEvenSplit(self, f: int) -> List[int]:
        if f%2!=0:      # if odd then return 
            return []
        count= (-1 + sqrt(1 + 4 * f)) // 2        # find x
        ans=[]
        i=2
        while len(ans)!=count:
            ans.append(i)          # add even integers in list 
            i=i+2
        if sum(ans)==f:         # check if sum is euqal to finalSum
            return ans
        ans[-1]=ans[-1]+(f-sum(ans))     # else add difference in the last element
        return ans",Medium,13,528,5.0,0,3.0,6.0,40.61538461538461,18.0,4.564615384615386
1496.0,count good triplets in an array,"class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        N = len(nums1)
        BIT = [0] * (N+1)
        nums = [0] * N
        num1 = [0] * N
        num2 = [0] * N
        for i, n in enumerate(nums1):
            num1[n]=i
        for i, n in enumerate(nums2):
            num2[n]=i
        for i, n in enumerate(num1):
            nums[n] = num2[i]
        def lowbit(i):
            return i&amp;(-i)
        def add(i):
            i+=1
            while i <= N:
                BIT[i]+=1
                i+=lowbit(i)
        def query(i):
            i += 1
            re = 0
            while i:
                re += BIT[i]
                i -= lowbit(i)
            return re
        smaller = []
        bigger = []
        for i, n in enumerate(nums):
            smaller.append(query(n))
            bigger.append(N-1-i-n+smaller[-1])
            add(n)
        return sum(i*j for i, j in zip(smaller, bigger))
		```",Hard,34,969,0.0,4,3.0,7.0,28.5,41.0,2.914999999999999
1497.0,count integers with even digit sum,"class Solution:
    def countEven(self, num: int) -> int:
        count = 0
        for i in range(1, num + 1):
            summetion = 0
            for digit in str(i):
                summetion += int(digit)
                
            if summetion % 2 == 0 :
                count += 1
                
        return count",Easy,11,328,0.0,3,3.0,3.0,29.818181818181817,16.0,5.356363636363637
1498.0,merge nodes in between zeros,"class Solution:
    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        temp=head.next
        s=0
        
        newHead=dummy=ListNode(-1)
        
        while temp:
            if temp.val==0:
                newHead.next=ListNode(s)
                newHead=newHead.next
                s=0
            else:
                s+=temp.val
            
            temp=temp.next
            
        
        return dummy.next",Medium,19,466,0.0,2,3.0,2.0,24.526315789473685,20.0,5.4926315789473685
1499.0,construct string with repeat limit,"class Solution:
    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
        # MaxHeap method
        arr = [0] * 26
        result = """"
        
        # count the num of each char
        for char in s:
            arr[ord(char) - ord('a')] += 1
        
        # in the maxHeap, the largest char is on the top
        maxHeap = []
        for i in range(26):
            if arr[i] != 0:
                maxHeap.append((-i, arr[i]))
        
        heapq.heapify(maxHeap)
        
        while maxHeap:
            # pop out the largest char
            largestChar, times = heapq.heappop(maxHeap)
            # to make sure we didn't add the same char in the next iteration
            if result and result[-1] == chr(-largestChar + ord('a')):
                return result                         
            if times > repeatLimit:
                result += repeatLimit * chr(-largestChar + ord('a'))
                if maxHeap:
                    SecondLargestChar, times2 = heapq.heappop(maxHeap)
                    result += chr(-SecondLargestChar + ord('a'))
                    if times2 > 1:
                        heapq.heappush(maxHeap, (SecondLargestChar, times2-1))
                heapq.heappush(maxHeap, (largestChar, times-repeatLimit))
            else:
                result += times * chr(-largestChar + ord('a'))
            
            if len(result) == len(s):
                return result",Medium,36,1439,5.0,8,4.0,10.0,39.97222222222222,43.0,1.5825000000000014
1500.0,count array pairs divisible by k,"class Solution:
    def coutPairs(self, nums: List[int], k: int) -> int:
        for i in range(len(nums)):
            g = gcd(nums[i], k)
            nums[i] = g if g != k else 0
        
        c = Counter(nums)
        r = 0
		
		# 0 to other number
        for i in c:
            if i == 0: continue
            r += c[i]
        r *= c[0]
		
		# 0 to 0
        r += (c[0] * (c[0]-1)) // 2
        
        del c[0]  # 0 is dealt with
        del c[1]  # 1 is useless
        
		# brute-force check for key pairs
        ckeys = list(c.keys())
        for a in range(len(ckeys)):
            i = ckeys[a]
            for b in range(a, len(ckeys)):
                j = ckeys[b]
                if (i * j) % k: continue
                if j != i:
                    r += c[i] * c[j]
                else:
                    r += (c[i] * (c[i]-1)) // 2
                
        return r",Hard,33,892,5.0,5,3.0,10.0,27.03030303030303,34.0,3.887272727272728
1501.0,counting words with a given prefix,"class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        res = 0
        for i in words:
            if i.startswith(pref):
                res += 1
        return res",Easy,6,197,0.0,2,3.0,2.0,32.833333333333336,11.0,5.6450000000000005
1502.0,minimum number of steps to make two strings anagram ii,"class Solution:
    def minSteps(self, s: str, t: str) -> int:
        count_s=Counter(s)
        count_t=Counter(t)
        count=0
        
        for i in count_t:
            if i not in count_s:
                count+=count_t[i]
                count_s[i]=count_t[i]
            elif count_t[i]>count_s[i]:
                count+=count_t[i]-count_s[i]
                count_s[i]+=count_t[i]-count_s[i]
                count_s[i]=count_t[i]
            elif count_t[i]<count_s[i]:
                count+=count_s[i]-count_t[i]
                count_t[i]+=count_s[i]-count_t[i]
                count_t[i]=count_s[i]
                
        for i in count_s:
            if i not in count_t:
                count+=count_s[i]
                count_t[i]=count_s[i]
            else:
                count+=abs(count_t[i]-count_s[i])
                count_t[i]=count_t[i]+abs(count_t[i]-count_s[i])
        return count",Medium,26,920,0.0,6,4.0,6.0,35.38461538461539,31.0,3.115384615384614
1503.0,minimum time to complete trips,"class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        def condition(mid,nums,totalTrips):
            ans=0
            for num in nums:
                ans+=mid//num
            if ans>=totalTrips:
                return True
            return False
        
        lo=0 #minimum time any truck can take
        hi=totalTrips*min(time)  #maximum time any truck can take
        
        while lo<=hi:
            mid=lo+(hi-lo)//2
            if condition(mid, time,totalTrips):
                hi=mid-1
            else:
                lo=mid+1
        return lo",Medium,19,605,2.0,2,3.0,4.0,31.84210526315789,28.0,4.11421052631579
1504.0,minimum time to finish the race,"class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        @cache
        def lapTime(tire,x):
            f,r = tire
            return f*(r**(x-1))
        
        best_laps = {}
        
        for tire in tires:
            tire = tuple(tire)
            time = 0
            # stop at max time for a tire without changing
            for i in range(1,1001):
                currtime = lapTime(tire,i)
                if currtime >= lapTime(tire,1)+changeTime:
                    break
                time += currtime
                
                # update dictionary
                if i in best_laps:
                    best_laps[i] = min(best_laps[i],time+changeTime)
                else:
                    best_laps[i] = time+changeTime
        
        # dynamic programming
        dp = [float('inf') for _ in range(numLaps)]
        for i in range(numLaps):
            # if could get lap i using a single tire
            if i+1 in best_laps:
                dp[i] = best_laps[i+1]
                
            # or get lap i changing from last tire
            for k,v in best_laps.items():
                if i-k>=0:
                    dp[i] = min(dp[i], dp[i-k]+v)
        
		# subtract change time because first tire doesn't need to change
        return dp[numLaps-1] - changeTime",Hard,38,1369,6.0,6,4.0,11.0,36.026315789473685,42.0,2.1976315789473686
1505.0,most frequent number following key in an array,"class Solution:
    def mostFrequent(self, nums: List[int], key: int) -> int:
        d={}
        for i in range(len(nums)-1):
            if nums[i]==key:
                if nums[i+1] in d:
                    d[nums[i+1]]+=1
                else:
                    d[nums[i+1]]=1
        m=-1
        for j in d:
            m=max(m,d[j])
        for key, value in d.items():
            if m == value:
                return key",Easy,14,434,0.0,6,3.0,6.0,31.0,27.0,3.97
1506.0,sort the jumbled numbers,"class Solution:
    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        def getMappedNum(num):
            s = str(num)
            mappedNum = """"
            for c in s:
                mappedNum = mappedNum + str(mapping[int(c)])
            return int(mappedNum)

        sortedNums = []
        for num in nums:
            sortedNums.append((getMappedNum(num), num))
            
        sortedNums.sort(key=lambda x: x[0])
        
        for i, (_, num) in enumerate(sortedNums):
            nums[i] = num
            
        return nums",Medium,18,575,0.0,2,3.0,3.0,31.944444444444443,21.0,4.7250000000000005
1507.0,all ancestors of a node in a directed acyclic graph,"class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        
        result = []
        
        hashmap = collections.defaultdict(set)
        parent = collections.defaultdict(set)
        # indegree = collections.defaultdict(int)
        
        for a, b in edges:
            hashmap[a].add(b)
            parent[b].add(a)
            # indegree[b] += 1
        
        roots = set()
        leafs = set()
        
        for node in range(n):
            if node not in parent:
                roots.add(node)
            
            if node not in hashmap:
                leafs.add(node)
        
        # print(roots)
        # print(leafs)
        
        # ancestors = collections.defaultdict(set)
        
        @cache
        def find_parent(node):
            parents = set()
            if node in parent:
                for p in parent[node]:
                    parents.add(p)
                    parents |= find_parent(p)
            return parents
            
        
        for node in range(n):
            result.append(sorted(list(find_parent(node))))
        
        return result",Medium,42,1159,5.0,6,3.0,7.0,27.59523809523809,26.0,4.576428571428572
1508.0,minimum number of moves to make palindrome,"class Solution:
    @lru_cache(None)
    def minMovesToMakePalindrome(self, s: str) -> int:
        n = len(s)
        if n<=1:
            return 0
        if s[0] == s[-1]:
            return self.minMovesToMakePalindrome(s[1:-1])
        i = 1
        while s[i]!=s[-1]:
            i+=1
        j = n - 2
        while s[j]!=s[0]:
            j-=1
        if i <= n - 1 - j:
            return i + self.minMovesToMakePalindrome(s[:i]+s[i+1:-1])
        else:
            return n - 1 - j + self.minMovesToMakePalindrome(s[1:j]+s[j+1:])",Hard,17,539,0.0,2,3.0,5.0,31.705882352941178,30.0,3.8464705882352943
1510.0,append k integers with minimal sum,"class Solution:
    def minimalKSum(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        result = 0
        
        if nums[0] > k:
            return self.calSum(0, k+1)
        
        if nums[0] != 1:
            k -= (nums[0] - 1)
            result += self.calSum(0, nums[0])
        
        for i in range(n-1):
            numOfCandidates = nums[i+1] - nums[i] -1
            if numOfCandidates >= 1:
                if numOfCandidates >= k:
                    result += self.calSum(nums[i], nums[i] + k +1)
                    k = 0
                    return result

                elif numOfCandidates < k:
                    k -= numOfCandidates
                    result += self.calSum(nums[i], nums[i+1])
        
        if k > 0:
            result += self.calSum(nums[-1], nums[-1] +k+1)
        
        return result
                      
    # calculate the sum between start and end, both exclude
    def calSum(self, start, end):
        return int((end + start) / 2 * (end -start -1))",Medium,32,1050,1.0,4,3.0,7.0,32.8125,41.0,2.566875
1511.0,create binary tree from descriptions,"class Solution:
    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        node_dict = defaultdict(TreeNode)
        ins = defaultdict(int)
        for p, c, isleft in descriptions:
            ins[p] = ins[p]
            ins[c] += 1
            node_dict.setdefault(p, TreeNode(p))
            node_dict.setdefault(c, TreeNode(c))
            if isleft:
                node_dict[p].left = node_dict[c]
            else:
                node_dict[p].right = node_dict[c]
        
        return node_dict[min((indegree, node) for node, indegree in ins.items())[1]]",Medium,14,599,0.0,2,3.0,3.0,42.785714285714285,20.0,3.849285714285714
1512.0,replace non coprime numbers in array,"class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        if len(nums) == 1: return nums
        
        @cache
        def compute_gcd(x, y) -> int:
            while y:
                x, y = y, x % y
            return x

        @cache
        def compute_lcm(x, y) -> int:
            r = (x*y)//compute_gcd(x,y)
            return r
    
        i, j = 0, 1
        while j < len(nums):
            if compute_gcd(min(nums[i],nums[j]), max(nums[i],nums[j])) != 1:
                nums[i]=compute_lcm(min(nums[i],nums[j]), max(nums[i],nums[j]))
                nums.pop(j)
                if i != 0:
                    i-=1
                    j-=1
            else:
                i+=1
                j+=1
        return nums",Hard,26,765,0.0,2,3.0,5.0,29.423076923076923,42.0,2.851923076923077
1513.0,find all k distant indices in an array,"class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        # Time: O(nk) which at the worst case could be O(n^2)
        # Space: O(n) because result will never exceed N values
		res = set()
        for index, num in enumerate(nums):
            if num == key:
                for i in range(max(0, index - k), min(len(nums), index + k + 1)):
                    res.add(i)
        return list(res)",Easy,9,446,2.0,3,3.0,3.0,49.55555555555556,22.0,3.0600000000000005
1514.0,count artifacts that can be extracted,"class Solution:
    def digArtifacts(self, n: int, artifact: List[List[int]], dig: List[List[int]]) -> int:
        dig_set = set()
        for i in dig:
            dig_set.add(tuple(i))
            
        count = 0
        for afact in artifact:
            flag = True
            r1,c1,r2,c2 = afact
            for i in range(r1,r2+1):
                for j in range(c1,c2+1):
                    if (i,j) not in dig_set:
                        flag = False
                        break
                        
            if(flag == True):
                count += 1
                
        return count",Medium,19,615,0.0,4,4.0,9.0,32.36842105263158,30.0,3.6068421052631567
1515.0,maximize the topmost element after k moves,"class Solution:
    def maximumTop(self, nums: List[int], k: int) -> int:
        if len(nums) <= 1 and k &amp; 1: return -1       # Case 1: triggered
        end = min(k-1, len(nums))                    # If k is greater than len(nums), end = len(nums), because Case 2 is triggered, else case 3 is triggered, we still need to find max till k-1
        maxi = max(nums[:end]) if k > 1 else 0       # we calculated the max element based on our end. k > 1 I have given to save from error, beacuse if k <= 1, spliced list will be empty.
        kplusOne = nums[k % len(nums)]               # this is for case 3, finding the k + 1 element, k +1 can give array index out of bound exception, so i did %
        return max(maxi, kplusOne)                   # Case 3, we have to decide either we choose to put the max from removed or (k+1) element",Medium,6,839,5.0,0,5.0,5.0,139.83333333333334,32.0,-5.885000000000002
1516.0,minimum weighted subgraph with the required paths,"class Solution:
  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
    graph,regra = defaultdict(list),defaultdict(list)
    for x,y,d in edges:
      graph[x].append((y,d))
      regra[y].append((x,d))
    for x in graph.keys():
      graph[x].sort(key=lambda p: p[1])
    for x in regra.keys():
      regra[x].sort(key=lambda p: p[1])
    pathfromdest = [float('inf') for _ in range(n)]
    psrcjeden = [float('inf') for _ in range(n)]
    psrcdwa = [float('inf') for _ in range(n)]
    ##
    def expdes(nod,d):
      if d < pathfromdest[nod]:
        pathfromdest[nod] = d
        for som,da in regra[nod]:
          expdes(som,d+da)
          
    
          
    def expsje(nod,d):
      if d < psrcjeden[nod]:
        psrcjeden[nod] = d
        for som,da in graph[nod]:
          expsje(som,d+da)
          
    def expesdwa(nod,d):
      if d < psrcdwa[nod]:
        psrcdwa[nod] = d
        for som,da in graph[nod]:
          expesdwa(som,d+da)
        
    
    expdes(dest,0)
    if pathfromdest[src1] == float('inf') or pathfromdest[src2] == float('inf'): return -1
    expsje(src1,0)
    expesdwa(src2,0)
    ##
    # q = [dest]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in regra[m]:
    #     if pathfromdest[m] + d < pathfromdest[som]:
    #       pathfromdest[som] = pathfromdest[m] + d
    #       q.append(som)
    # ##
    # q = [src1]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in graph[m]:
    #     if psrcjeden[m] + d < psrcjeden[som]:
    #       psrcjeden[som] = psrcjeden[m] + d
    #       q.append(som)
    # ##
    # q = [src2]
    # cu = 0
    # while cu < len(q):
    #   m = q[cu]
    #   cu += 1
    #   for som,d in graph[m]:
    #     if psrcdwa[m] + d < psrcdwa[som]:
    #       psrcdwa[som] = psrcdwa[m] + d
    #       q.append(som)
    ##
    ans = min(pathfromdest[ii]+psrcjeden[ii]+psrcdwa[ii] for ii in range(n))
    if ans == float('inf'): return -1
    else: return ans",Hard,72,2059,32.0,18,2.0,24.0,28.59722222222222,103.0,-2.793750000000001
1517.0,divide array into equal pairs,"class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        return not any(v % 2 for v in Counter(nums).values())",Easy,2,129,0.0,0,2.0,1.0,64.5,5.0,3.575
1518.0,maximize number of subsequences in a string,"class Solution:
    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:
        a, b = pattern[0], pattern[1]
        counter = Counter(text)
        def num_subseq():
            rc = Counter(text) # counter for text[i:]
            ans = 0
            for c in text:
                rc[c] -= 1
                if c == a:
                    ans += rc[b]
            return ans

        return num_subseq() + max(counter[a], counter[b])",Medium,13,452,1.0,2,3.0,3.0,34.76923076923077,23.0,4.310769230769231
1519.0,minimum operations to halve array sum,"class Solution:
def halveArray(self, nums: List[int]) -> int:
    import heapq
    target = sum(nums) / 2
    arr = [-i for i in nums]
    heapq.heapify(arr)
    res = 0
    
    while target > 0: # everything will be negative over here, so we will add the halved value
        n = heapq.heappop(arr) / 2
        target += n
        res += 1
        heapq.heappush(arr,n)
    return res",Medium,13,386,1.0,1,2.0,3.0,29.692307692307693,15.0,5.687692307692308
1520.0,minimum white tiles after covering with carpets,"class Solution:
    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
        
        # get all locations for white
        loc = [i for i in range(len(floor)) if floor[i] == '1']
        if not loc: return 0        
        
        
        @lru_cache(None)
        # calculate maximum white tiles covered
        def dp(i, numCarpets):
            # if no carpets or reached the end of loc
            if numCarpets == 0 or i >= len(loc):
                return 0

            # if remaining caprets could cover till the end of loc
            if loc[i] + numCarpets * carpetLen - 1 >= loc[-1]:
                return len(loc) - i
            
            ans = -float('inf')
            # maximum carpets required to reach the next loc
            required = math.ceil((loc[i+1] - loc[i]) / carpetLen)
            
            
            for k in range(min(required, numCarpets)+1):
                new_i = bisect.bisect(loc, loc[i] + k*carpetLen - 1)
                ans = max(ans, new_i - i + dp(max(i+1, new_i), numCarpets - k))
            return ans

        return len(loc) - dp(0, numCarpets)",Hard,29,1137,5.0,0,3.0,9.0,39.206896551724135,36.0,2.8913793103448286
1521.0,count hills and valleys in an array,"class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        count, new = 0, [nums[0]]
        
        # Create a new array with non-consecutive values
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                new.append(nums[i])

        for i in range(1, len(new)-1):
            count += 1 if (new[i-1] < new[i] > new[i+1] or new[i-1] > new[i] < new[i+1]) else 0

        return count",Easy,12,439,1.0,3,2.0,4.0,36.583333333333336,19.0,4.5475
1522.0,count collisions on a road,"class Solution:
    def countCollisions(self, directions: str) -> int:
        count = 0
        stack = []
        
        for char in directions:
			# if the stack is empty, and the direction is left, we just continue
            if not stack and char == 'L':
                continue
            # otherwise we add the direction in the stack ('S' or 'R') because they might lead to collisions
            elif not stack and char != 'L':
                stack.append(char)
			# stack is not empty
            else:
				# the top element in the stack
                cur = stack[-1]
				# cases that will not lead to collisions
                if char == cur or cur == 'S' and char == 'R' or cur == 'L' and char == 'S' or cur == 'L' and char == 'R':
                    stack.append(char)
				# collision happen but the top of the stack is already 'S' no need to append
                elif cur == 'S' and char == 'L':
                    count += 1
				# collision happen, append a 'S' at the top
                elif cur == 'R' and char == 'S':
                    count += 1
                    stack.pop()
                    stack.append('S')
				# collision happen, append a 'S' at the top
                elif cur == 'R' and char == 'L':
                    count += 2
                    stack.pop()
                    stack.append('S')
        # here, the stack only contains 'R' and 'S'
		# we only need to deal with the 'R' before 'S' case
        n = len(stack)
        i = 0  
        while i < n:
            rs = 1
            if stack[i] == 'S':
                i += 1
            elif stack[i] == 'R':
                if i == n-1:
                    return count                
                elif stack[i] != stack[i+1]:
                    count += 1
                    i += 1     
                else:   
                    while i < n-1 and stack[i] == 'R' and stack[i] == stack[i+1]:
                        rs += 1
                        i += 1
                    if i == n-1:
                        return count
                    else:
                        count += rs
                        i += 1
        return count",Medium,55,2161,10.0,10,4.0,16.0,39.29090909090909,107.0,-4.676181818181819
1523.0,maximum points in an archery competition,"class Solution:
    def __init__(self):
        self.mem = {}  # {(scoring_section,remaining_arrow_count)} = mask
    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:
        (mask,score) = self.dp(numArrows,0,len(aliceArrows)-1,0,aliceArrows)
        # print(""mask:"",mask)
        r = []
        zeroTarget = numArrows
        for i in range(1,len(aliceArrows)):
            if mask &amp; 1<<i :
                zeroTarget -= aliceArrows[i]+1
                r.append(aliceArrows[i]+1)
            else :
                r.append(0)
        r = [zeroTarget] + r
        return r
    def dp(self,numArrows: int, mask , scoring_section  , score ,aliceArrows: List[int]) -> (int,int):
        if numArrows <= 0 :
            return (mask,score)
        if scoring_section <= 0:
            return (mask,score)
        if (scoring_section,numArrows) in self.mem:
            return self.mem[(scoring_section,numArrows)]
        
        score1 = 0
        if numArrows- (aliceArrows[scoring_section]+1) >= 0:
            mask1,score1 = self.dp(numArrows- (aliceArrows[scoring_section]+1) , mask , scoring_section-1 , score , aliceArrows[:-1])
            mask1 |= 1<<scoring_section
            score1 += scoring_section
        else :
            mask1 = mask
        mask2,score2 = self.dp(numArrows , mask , scoring_section-1 , score , aliceArrows[:-1])
        
        if score1 >= score2 :
            self.mem[(scoring_section,numArrows)] = (mask1,score1)
        else :
            self.mem[(scoring_section,numArrows)] = (mask2,score2)

        return self.mem[(scoring_section,numArrows)]",Medium,38,1627,2.0,3,3.0,7.0,42.81578947368421,85.0,-2.6334210526315776
1524.0,find the difference of two arrays,"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        nums1, nums2 = list(set(nums1)), list(set(nums2)) # Converting to set to ensure only unique values remain
        
        new1, new2 = [], [] # New list we'll be adding to
        
        for x in nums1: # Compares first list
            if x not in nums2:
                new1.append(x)
        
        for y in nums2: # Compares second list
            if y not in nums1:
                new2.append(y)
        
        return [new1, new2] # Combines the two",Easy,14,572,5.0,4,3.0,5.0,40.85714285714285,18.0,4.302857142857143
1525.0,minimum deletions to make array beautiful,"class Solution:
    def minDeletion(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums)):
		    # if res % 2 == 0, check even indexes
			# if res % 2 == 1, check odd indexes
            if (i + (res % 2)) % 2 == 0 and i + 1 < len(nums) and nums[i] == nums[i + 1]:
                res += 1
        return res + (len(nums) - res) % 2",Medium,8,359,2.0,2,2.0,4.0,44.875,24.0,3.401249999999999
1526.0,find palindrome with fixed length,"class Solution:
    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:
        def nthPalindrome(n, k):
            half_len = k // 2 - 1 if k % 2 == 0 else k // 2  
            left = str(10 ** half_len + n - 1)
            right = (left if k % 2 == 0 else left[:-1])[::-1]
            res_str = left + right
            return int(res_str) if len(res_str) == intLength else -1
        return [nthPalindrome(query,intLength) for query in queries]",Medium,8,470,0.0,0,3.0,4.0,58.75,26.0,1.932500000000001
1527.0,maximum value of k coins from piles,"class Solution:
    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:
        # sort by the maximum prefix sum
        p = sorted([list(accumulate(x[:k], initial=0)) for x in piles], key=lambda x: -x[-1])
        
        @lru_cache(None)
        def dp(i, k):
            if i == len(p):
                return 0
            ans = 0
            for j in range(min(len(p[i]), k+1)):
                ans = max(ans, p[i][j] + dp(i+1, k-j))
            return ans

        return dp(0, k)",Hard,14,501,1.0,1,3.0,3.0,35.785714285714285,27.0,3.8792857142857136
1528.0,minimum bit flips to convert number,"class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        bstart=bin(start).replace(""0b"","""")
        bgoal=bin(goal).replace(""0b"","""")
      
        diff=len(str(bstart))-len(str(bgoal))
        for i in range(abs(diff)):
            if diff<0:
                bstart='0'+bstart
            elif diff>0:
                bgoal='0'+bgoal
        
        counter=0
        for i in range(len(bstart)):
            if bstart[i]!=bgoal[i]:
                counter+=1
        
        return counter",Easy,17,517,0.0,5,3.0,9.0,30.41176470588235,24.0,4.382941176470589
1529.0,find triangular sum of an array,"class Solution:
    def triangular_sum(self, nums: List[int]) -> int:
        nums1 = nums
        while len(nums1) > 1:
            nums2 = []
            for i in range(len(nums1) - 1):
                nums2 += [(nums1[i] + nums1[i + 1]) % 10]
            nums1 = nums2
        return nums1[0]",Medium,8,295,0.0,2,3.0,2.0,36.875,12.0,5.18125
1530.0,number of ways to select buildings,"class Solution:
    def numberOfWays(self, s: str) -> int:
        def find_subsequence_count(S, T):
            m = len(T)
            n = len(S)
            if m > n:
                return 0
            mat = [[0 for _ in range(n + 1)]
                   for __ in range(m + 1)]
            for i in range(1, m + 1):
                mat[i][0] = 0
            for j in range(n + 1):
                mat[0][j] = 1
            for i in range(1, m + 1):
                for j in range(1, n + 1):
                    if T[i - 1] != S[j - 1]:
                        mat[i][j] = mat[i][j - 1]
                    else:
                        mat[i][j] = (mat[i][j - 1] +
                                     mat[i - 1][j - 1])
            return mat[m][n]
        x = find_subsequence_count(s, '101')
        y = find_subsequence_count(s, '010')
        return x + y",Medium,23,864,0.0,4,4.0,8.0,37.56521739130435,30.0,3.139130434782608
1531.0,sum of scores of built strings,"class Solution:
    def sumScores(self, s: str) -> int:
        n, l, r = len(s), 0, 0
        z = [0] * n
        for i in range(1, n):
            if i <= r:
                z[i] = min(r - i + 1, z[i - l])
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
            if i + z[i] - 1 > r:
                l, r = i, i + z[i] - 1
        return sum(z)+len(s)",Hard,11,393,0.0,4,3.0,4.0,35.72727272727273,29.0,3.464545454545455
1532.0,minimum number of operations to convert time,"class Solution:
    def convertTime(self, current: str, correct: str) -> int:
        count = 0
        
        hour_start = int(current.split("":"")[0])
        hour_end = int(correct.split("":"")[0])
        minute_start = int(current.split("":"")[1])
        minute_end = int(correct.split("":"")[1])
    
        total_start = hour_start * 60 + minute_start
        total_end = hour_end * 60 + minute_end 
        print(total_start,total_end)
        
        while total_start < total_end:
            if abs(total_start - total_end) >= 60 :
                total_start += 60
            elif abs(total_start - total_end) >= 15:
                total_start += 15
            elif abs(total_start - total_end) >= 5 :
                total_start += 5
            elif abs(total_start - total_end) >= 1 :
                total_start += 1
            count += 1
            
        return count",Easy,24,889,0.0,5,3.0,5.0,37.04166666666666,38.0,2.3862500000000004
1533.0,find players with zero or one losses,"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        lose_dict = defaultdict(list)
        players = set()
        answer = [[],[]]
        
        for winner, loser in matches:
            lose_dict[loser].append(winner)
            players.add(winner)
            players.add(loser)
        
        # find the list of all players that have not lost any matches
        for player in players:
            if player not in lose_dict:
                answer[0].append(player)
        
        # answer[1] is a list of all players that have lost exactly one match
        for player in lose_dict.keys():
            if len(lose_dict[player]) == 1:
                answer[1].append(player)
        
        answer[0].sort()
        answer[1].sort()
        
        return answer",Medium,24,821,2.0,5,3.0,5.0,34.208333333333336,18.0,4.72125
1534.0,maximum candies allocated to k children,"class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        if sum(candies) < k:
            return 0
        
        hi = sum(candies) // k                  
        lo = 1                                  # Because sum(candies) >= k, kids can gain at least 1 candy
        
        def can_allo(candies, num, k):          # To determine whether candies can be allocate to at least k piles when pile == num
            count = 0
            for c in candies:
                count += c // num
            return count >= k
        
        while hi > lo:                          # binary search until hi == lo
            mid = (hi + lo) // 2
            if can_allo(candies, mid, k):
                lo = mid + 1
            else:
                hi = mid
        
        if can_allo(candies, hi, k):            # if hi can be allocated: just return hi
            return hi
        else:
            return hi - 1                       # else: it must be hi - 1",Medium,24,996,5.0,1,4.0,6.0,41.5,43.0,1.8649999999999984
1535.0,largest number after digit swaps by parity,"class Solution:
    def largestInteger(self, num: int) -> int:
        arr = [n for n in str(num)]
        n = len(arr)
        
        for i in range(n):
            for j in range(i+1, n):
                if int(arr[i]) % 2 == 0 and int(arr[j]) % 2 == 0 and int(arr[j]) > int(arr[i]):
                    arr[i], arr[j] = arr[j], arr[i]
                
                elif int(arr[i]) % 2 == 1 and int(arr[j]) % 2 == 1 and int(arr[j]) > int(arr[i]):
                    arr[i], arr[j] = arr[j], arr[i]
        
        return int("""".join(arr))",Easy,13,548,0.0,4,3.0,5.0,42.15384615384615,32.0,2.586153846153846
1536.0,minimize result by adding parentheses to expression,"class Solution:
    def minimizeResult(self, expression: str) -> str:
        int1, int2 = expression.split('+')
        arr1, tmp1 = [char for char in int1], [char for char in int1]
        arr2, tmp2 = [char for char in int2], [char for char in int2]
        min_res = int(int1) + int(int2)
        res = '(' + expression + ')'
        first_limit = len(int1)
        sec_limit = len(int2)

        for i in range(0, first_limit):
            for j in range(1, sec_limit + 1):
                if i == 0 and j != sec_limit:
                    cur_res = (int(int1[i:]) + int(int2[:j])) * int(int2[j:])
                elif i != 0 and j == sec_limit:
                    cur_res = int(int1[:i]) * (int(int1[i:]) + int(int2[:j]))
                elif i == 0 and j == sec_limit:
                    continue
                else:
                    cur_res = int(int1[:i]) * (int(int1[i:]) + int(int2[:j])) * int(int2[j:])
                    
                if cur_res < min_res:
                    min_res = cur_res
                    arr1.insert(i, '(')
                    arr2.insert(j, ')')
                    res = """".join(arr1) + '+' + """".join(arr2)
                    arr1 = tmp1[:]
                    arr2 = tmp2[:]
        
        return res",Medium,29,1258,0.0,5,4.0,10.0,43.37931034482759,62.0,-0.6441379310344839
1537.0,maximum product after k increments,"class Solution:
    def maximumProduct(self, nums: List[int], k: int) -> int:
        count=Counter(nums) # Get the frequencies of each element
        a=min(count.keys()) # Start with minimum key
        m=1000000007
        p=1 # To store the answer
        while k:
            c=count[a]
            if c<=k:
                count[a]-=c # Reduce it by the number of times the smallest element is encountered
                count[a+1]+=c # Inrease the count by the same magnitude 
                if count[a]==0: # Check if current numbers count reduces to zero
                    a+=1 # If yes then move onto next minimum number
                k-=c # reduce k
                continue
            if c>k: # if count of the smallest element is greater than the number of operations k then
                count[a]-=k # reduce the count of the smallest number by k 
                count[a+1]+=k # increase the count of smallest_num+1 by k
                k=0 # and reduce k to zero
        for key, val in count.items():
            if val: # if val of keys is greater than 0 then use them in result
                p=p*(key**val)%m #Use modulus to reduce the run time
        return p",Medium,22,1191,14.0,5,4.0,10.0,54.13636363636363,33.0,1.8477272727272729
1538.0,maximum total beauty of the gardens,"class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        totf = 0
        for i,f in enumerate(flowers):
            if f>target:
                flowers[i] = target
            totf += min(f,target)
        flowers.sort(reverse=True)
		
		# if newFlowers can make all garden 'full'
        n = len(flowers)
        if n*target - totf<=newFlowers:
            maxscore = n*full # score if all garden 'full'
            if flowers[-1]<target: # score if all garden but one 'full'
                maxscore = max(maxscore,(n-1)*full+(target-1)*partial) 
            return maxscore
        
		# if newFlowers can not make all garden 'full'
        tofill = 0 # no garden full, n gardens to fill
        level = (totf+newFlowers) // (n-tofill) # try fill all n garden
        while level<flowers[tofill]: # not plausible
            totf -= flowers[tofill] # exclude the next garden
            tofill += 1
            level = (totf+newFlowers) // (n-tofill) # try again
        maxscore = level*partial # score if no garden 'full'
        for i in range(len(flowers)): # (i+1) 'garden full'
            newFlowers -= target - flowers[i] 
            if newFlowers<0: # cannot fill any more garden
                break
            score = (i+1)*full # score from (i+1) 'full' garden
            if tofill==i:
                totf -= flowers[i]
                tofill = i+1
            level = (totf+newFlowers) // (n-tofill) # try fill the rest of the gardens
            while level<flowers[tofill]: # not plausible
                totf -= flowers[tofill] # exclude the next garden
                tofill += 1
                level = (totf+newFlowers) // (n-tofill)
            score = score + level * partial # score from partial gardens
            if score>maxscore:
                maxscore = score
        return maxscore",Hard,41,1902,17.0,8,3.0,15.0,46.39024390243903,61.0,-0.2551219512195128
1539.0,add two integers,"class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2",Easy,2,90,0.0,0,2.0,0.0,45.0,7.0,5.13
1540.0,root equals sum of children,"class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return (root.left.val + root.right.val) == root.val
          

# time O(1)
# space O(1)",Easy,6,171,2.0,0,1.0,0.0,28.5,8.0,6.654999999999999
1541.0,find closest number to zero,"class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        result = nums[0]
        for n in nums:
            if abs(n) < abs(result):
                result = n
            elif n == -result  and n > 0:
                result = n

        return result",Easy,9,276,0.0,3,3.0,3.0,30.666666666666668,16.0,5.280000000000001
1542.0,number of ways to buy pens and pencils,"class Solution:
    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:
        p = total // cost1
        ways = 0
        
        for i in range(p + 1):
            t = total - i * cost1
            ways += (t // cost2) + 1
           
        return ways",Medium,9,281,0.0,1,3.0,1.0,31.22222222222222,14.0,5.550000000000001
1543.0,maximum score of a node sequence,"class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
      
      connection = {}
      
      for source, target in edges:
        if source not in connection: connection[source] = [target]
        else: connection[source].append(target)
          
        if target not in connection: connection[target] = [source]
        else: connection[target].append(source)
          
      res = -1
      
      max_dict = {}
      for key, value in connection.items():
        max1, max2, max3 = -sys.maxsize, -sys.maxsize, -sys.maxsize
        n1, n2, n3 = None, None, None
        for element in value:
          if scores[element] > max1:
            max1, max2, max3 = scores[element], max1, max2
            n1, n2, n3 = element, n1, n2
          elif scores[element] > max2:
            max2, max3 = scores[element], max2
            n2, n3 = element, n2
          elif scores[element] > max3:
            max3 = scores[element]
            n3 = element
        max_dict[key] = []
        if n1 != None: max_dict[key].append(n1)
        if n2 != None: max_dict[key].append(n2)
        if n3 != None: max_dict[key].append(n3)
             
      for source, target in edges:
        base = scores[source] + scores[target]
        
        n_s = max_dict[source]
        n_t = max_dict[target]
        if len(n_s) == 1 or len(n_t) == 1:
          pass
        else:
          new_n_s = [x for x in n_s if x != target]
          new_n_t = [x for x in n_t if x != source]
          if new_n_s[0] != new_n_t[0]:
            res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[0]])
          else:
            if len(new_n_s) > 1:
              res = max(res, base + scores[new_n_s[1]] + scores[new_n_t[0]])
            if len(new_n_t) > 1:
              res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[1]])      
    
      return res",Hard,51,1885,0.0,16,3.0,20.0,36.96078431372549,92.0,-3.666470588235296
1544.0,calculate digit sum of a string,"class Solution(object):
    def digitSum(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: str
        """"""
        while len(s)>k:
            t = """"
            x = 0
            a = 0
            for i in range(len(s)):
                if x==k:
                    x = 1
                    t+=str(a)
                    a = int(s[i])
                else:
                    x+=1
                    a+=int(s[i])
            t+=str(a)
            print(t)
            s = t
        return s",Easy,22,527,0.0,3,4.0,3.0,23.954545454545453,28.0,4.624090909090909
1545.0,minimum rounds to complete all tasks,"lass Solution(object):
    def minimumRounds(self, tasks):
        """"""
        :type tasks: List[int]
        :rtype: int
        """"""
        d = {}
        for i in tasks:
            if i not in d:
                d[i] = 1
            else:
                d[i]+=1
        ans = 0
        for i in d:
            if d[i]<2:
                return -1
            else:
                if d[i]%3==0:
                    ans+=d[i]//3 
                else:
                    ans += d[i]//3 +1
        return ans",Medium,21,512,0.0,4,3.0,5.0,24.38095238095238,25.0,4.885714285714286
1546.0,maximum trailing zeros in a cornered path,"class Solution:
    def maxTrailingZeros(self, grid: List[List[int]]) -> int:
        def check(grid, row_order=1, col_order=1):
            above = [[0, 0] for i in range(len(grid[0]))]
            ans = 0
            for row in grid[::row_order]:
                this_row = [0, 0]
                for i, v in enumerate(row[::col_order]):
                    c2 = c5 = 0
                    while v % 2 == 0:
                        c2 += 1
                        v /= 2
                    while v % 5 == 0:
                        c5 += 1
                        v /= 5
                    this_row[0] += c2
                    this_row[1] += c5
                    ans = max(ans, min(this_row[0] + above[i][0], this_row[1] + above[i][1]))
                    above[i][0] += c2
                    above[i][1] += c5
            return ans
        return max(check(grid, ro, co) for ro in [-1, 1] for co in [-1, 1])",Medium,21,918,0.0,3,5.0,7.0,43.71428571428572,47.0,0.8857142857142861
1547.0,longest path with different adjacent characters,"class Solution(object):
    def longestPath(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: int
        """"""
        self.child = {i:[] for i in range(len(parent))}
        for i in range(1,len(parent)):
            self.child[parent[i]].append(i)
        self.m = 0 
        def ser(i,p):
            if len(self.child[i])==0:
                if p==s[i]:
                    return 0 
                self.m = max(self.m,1)
                return 1
            a = []
            for j in self.child[i]:
                a.append(ser(j,s[i]))
            a.sort()
            x = a[-1]
            y = 0  
            if len(a)>1:
                y = a[-2]
            self.m = max(self.m,x+y+1)
            if s[i]==p:
                return 0 
            return x+1 
        ser(0,"""")
        return self.m",Hard,30,859,0.0,2,3.0,7.0,28.633333333333333,42.0,2.923
1548.0,intersection of multiple arrays,"class Solution:
    def intersection(self, nums: List[List[int]]) -> List[int]:
        return sorted(reduce(lambda x,y: set(x)&amp;set(y), nums))",Easy,2,146,0.0,0,2.0,0.0,73.0,8.0,2.5100000000000007
1549.0,count lattice points inside a circle,"class Solution:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        result = set()
        
        for circle in circles:
            x, y, r = circle
            for i in range(x - r, x + r + 1):
                for j in range(y - r, y + r + 1):
                    if (i - x) * (i - x) + (j - y) * (j - y) <= r * r:
                        result.add((i, j))
                        
        return len(result)",Medium,11,436,0.0,4,4.0,4.0,39.63636363636363,18.0,4.152727272727272
1550.0,count number of rectangles containing each point,"class Solution:
    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
      
      rectangles.sort(key = lambda x : x[0])
      
      for i in range(len(points)):
        points[i] += [i]

      points.sort(key = lambda x : x[0])
      
      data_x = [x[0] for x in rectangles]
      data_y = []
      prev_ind = len(rectangles)
      
      res = [0]*len(points)
      
      for i in range(len(points)-1, -1, -1):
        q_x, q_y, loc = points[i]
        ind = bisect.bisect_left(data_x, q_x)
        for t in range(ind, prev_ind):
          bisect.insort(data_y, rectangles[t][1])
        prev_ind = ind
        res[loc] = len(data_y) - bisect.bisect_left(data_y, q_y)
      
      return res",Medium,24,742,0.0,3,2.0,4.0,30.916666666666668,31.0,3.8175
1551.0,number of flowers in full bloom,"class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:
        fakePerson = [[x, 0, i] for i, x in enumerate(persons)]
        flow = []
        for start, end in flowers:
            flow.append([start, -float('inf')])
            flow.append([end, float('inf')])
        flow += fakePerson
        flow.sort()
        cur = 0
        n = len(persons)
        res = [0] * n
        for item in flow:
            if len(item) == 2:
                if item[1] == -float('inf'):
                    cur += 1
                else:
                    cur -= 1
            else:
                _, _, idx = item
                res[idx] = cur
        return res
		```",Hard,22,715,0.0,4,3.0,5.0,32.5,37.0,2.955
1552.0,count prefixes of a given string,"class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        return sum(1 for word in words if s.startswith(word))",Easy,2,139,0.0,0,2.0,2.0,69.5,7.0,2.925
1553.0,minimum average difference,"class Solution:
    def minimumAverageDifference(self, nums: List[int]) -> int:
      total_sum = sum(nums)
      start = 0
      prefix_sum = []
      for element in nums:
        start += element
        prefix_sum.append(start)
      mini = sys.maxsize
      res = None
      size_t = len(nums)
      for i in range(len(nums)-1):
        diff = abs(floor(prefix_sum[i]/(i+1)) - floor((total_sum - prefix_sum[i])/(size_t - i - 1)))
        if diff < mini:
          mini = diff
          res = i
      last_diff = abs(floor(total_sum/size_t))
      if last_diff < mini: mini = last_diff; res = size_t - 1
      return res",Medium,18,623,0.0,4,2.0,11.0,34.611111111111114,24.0,4.124999999999999
1554.0,count unguarded cells in the grid,"class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
      grid = [[0]*n for _ in range(m)]
      for x, y in guards:
        grid[x][y] = 'G'
      for x, y in walls:
        grid[x][y] = 'W'
        
      grid2 = [[0]*n for _ in range(m)]
      for x, y in guards:
        grid2[x][y] = 'G'
      for x, y in walls:
        grid2[x][y] = 'W'
        
      for i in range(m):
        cache = []
        has_G = False
        for j in range(n):
          if grid[i][j] == 0:
            cache.append(j)
          elif grid[i][j] == 'G':
            if cache:
              for k in cache:
                grid[i][k] = 'O'
              cache = []
            has_G = True
          else:
            if has_G:
              if cache:
                for k in cache:
                  grid[i][k] = 'O'
                  cache = []
              has_G = False
            else:
              cache = []
        if cache:
          if has_G:
            for k in cache:
                grid[i][k] = 'O'
      
      for j in range(n):
        cache = []
        has_G = False
        for i in range(m):
          if grid2[i][j] == 0:
            cache.append(i)
          elif grid2[i][j] == 'G':
            if cache:
              for k in cache:
                grid2[k][j] = 'O'
              cache = []
            has_G = True
          else:
            if has_G:
              if cache:
                for k in cache:
                  grid2[k][j] = 'O'
                  cache = []
              has_G = False
            else:
              cache = []
        if cache:
          if has_G:
            for k in cache:
                grid2[k][j] = 'O'
      
      res = 0
      for i in range(m):
        for j in range(n):
          if grid[i][j] == 0 and grid2[i][j] == 0: res += 1
      return res",Medium,70,1876,0.0,31,3.0,33.0,26.8,96.0,-4.052
1555.0,escape the spreading fire,"class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        lo = 0
        hi = 1000000000
        fire = [[float('inf')] * C for _ in range(R)]
        q = deque()
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 1:
                    fire[r][c] = 0
                    q.appendleft((r, c))
        step = 0
        while q:
            nq = deque()
            while q:
                r, c = q.pop() 
                for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                    rr, cc = r + dr, c + dc
                    if 0 <= rr < R and 0 <= cc < C and grid[rr][cc] == 0 and fire[rr][cc] == float('inf'):
                        nq.appendleft((rr, cc))
                        fire[rr][cc] = min(fire[rr][cc], step + 1)
            step += 1
            q = nq
        def check(mid):
            q = deque([(0, 0)])
            v = {(0, 0): mid} 
            while q:
                r, c = q.pop()
                step = v[r, c] 
                if r == R - 1 and c == C - 1:
                    return True
                for dr, dc in  [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                    rr, cc = dr + r, c + dc
                    if 0 <= rr < R and 0 <= cc < C and grid[rr][cc] == 0 and (rr, cc) not in v and \
                        (step + 1 < fire[rr][cc] or (rr, cc) == (R - 1, C - 1) and step + 1 <= fire[rr][cc] ):
                        q.appendleft((rr, cc))
                        v[rr, cc] = step + 1
            return False
        while lo < hi:
            mid = (lo + hi + 1) // 2
            if check(mid):
                lo = mid
            else:
                hi = mid - 1
        if check(lo):
            return lo 
        return -1",Hard,47,1793,0.0,10,4.0,15.0,38.14893617021277,116.0,-5.87340425531915
1556.0,remove digit from number to maximize result,"class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        res_nums = set()
        pos = 0
        for i in range(number.count(digit)):
            ind = number.index(digit, pos, len(number))
            res = number[:ind] + number[ind+1:]
            if int(res) not in res_nums:
                res_nums.add(int(res))
            pos = ind + 1
        return str(max(res_nums))",Easy,10,404,0.0,2,3.0,2.0,40.4,18.0,4.264
1557.0,minimum consecutive cards to pick up,"class Solution:
    def minimumCardPickup(self, cards: List[int]) -> int:
        dic = defaultdict(int)
        min_num = float('inf')
        
        for i, num in enumerate(cards):
            if num not in dic:
                dic[num] = i
            else:
                min_num = min(min_num, i - dic[num] + 1)
                dic[num] = i
        
        if min_num == float('inf'):
            return -1
        else:
            return min_num",Medium,15,456,0.0,2,3.0,3.0,30.4,20.0,4.964
1558.0,k divisible elements subarrays,"class Solution:
    def countDistinct(self, nums: List[int], k: int, p: int) -> int:
        result = set()
        N = len(nums)
        K = k
        for i in range(N):
            k = K
            for j in range(i,N):
                if k>0:
                    if nums[j] % p == 0:
                        k -= 1
                    s = str(nums[i:j+1])
                    if s not in result:
                        result.add(s)
                elif nums[j] % p != 0:
                    s = str(nums[i:j+1])
                    if s not in result:
                        result.add(s)
                else: 
                    break
        return len(result)",Medium,20,670,0.0,6,4.0,7.0,33.5,32.0,3.185
1559.0,total appeal of a string,"class Solution:
    def appealSum(self, s: str) -> int:
        seen_char_at_idx = defaultdict(int)
        total_appeal = 0
        prev_round_added = 0
        for idx in range(len(s)):
            appeal_supposed_to_add = idx + 1
            this_round_adding = prev_round_added + appeal_supposed_to_add
            if s[idx] in seen_char_at_idx:
                this_round_adding -= seen_char_at_idx[s[idx]] + 1
            
            total_appeal += this_round_adding
            prev_round_added = this_round_adding
            seen_char_at_idx[s[idx]] = idx # refreshing last seen index
        return total_appeal",Hard,14,623,1.0,2,3.0,2.0,44.5,16.0,4.135
1560.0,largest 3 same digit number in string,"class Solution:
  def largestGoodInteger(self, num: str) -> str:
    letter = """"
    
    i = 0
    while i != len(num) :
      j = i + 1
      while j != len(num) and num[i] == num[j]: j += 1
      if j - i > 2 and letter < num[i]        : letter = num[i]
      
      i = j
    
    return letter * 3",Easy,12,302,0.0,3,2.0,3.0,25.166666666666668,21.0,5.335
1561.0,count nodes equal to average of subtree,"class Solution:
    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
        res = 0
        def averageOfSubtreeInner(node):
            nonlocal res
            if not node:
                return (0, 0)
            
            l_cnt, l_sum = averageOfSubtreeInner(node.left)
            r_cnt, r_sum = averageOfSubtreeInner(node.right)
            
            tot_sum = l_sum + r_sum + node.val
            tot_cnt = 1 + l_cnt + r_cnt
            avg = tot_sum//tot_cnt
            if avg == node.val:
                res+=1
            return (tot_cnt, tot_sum)
            
        averageOfSubtreeInner(root)
        return res",Medium,19,647,0.0,0,3.0,2.0,34.05263157894737,22.0,4.555263157894737
1562.0,count number of texts,"class Solution:
    def countTexts(self, pressedKeys: str) -> int:
      res = 0
      
      grid = [0]*(len(pressedKeys)+1)
      
      grid[0] = 1
      
      set1 = {'2', '3', '4', '5', '6', '8'}
      
      for t in range(1,len(grid)):
        target = pressedKeys[t-1]
        res = grid[t-1]
        if target in set1:
          if t >= 2 and pressedKeys[t-2] == target:
            res += grid[t-2]
          if t >= 3 and pressedKeys[t-2] == target and pressedKeys[t-3] == target:
            res += grid[t-3]
        else:
          if t >= 2 and pressedKeys[t-2] ==  target:
            res += grid[t-2]
          if t >= 3 and pressedKeys[t-2] == target and pressedKeys[t-3] == target:
            res += grid[t-3]
          if t >= 4 and pressedKeys[t-2] == target and pressedKeys[t-3] == target and pressedKeys[t-4] == target:
            res += grid[t-4]
            
        grid[t] = res % (10**9 + 7)
      return grid[-1] % (10**9 + 7)",Medium,27,957,0.0,7,2.0,7.0,35.44444444444444,68.0,-0.5299999999999994
1563.0,check if there is a valid parentheses string path,"class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:
      m, n = len(grid), len(grid[0])
      
      if grid[0][0] == ')': return False
      else:
        
        @lru_cache(None)
        def helper(x, y, acc):
          if x == m-1 and y == n-1:
            if grid[x][y] == ')':
              if acc == 1: return True
              else: return False
          else:
            if grid[x][y] == ')':
              if acc == 0: return False
              else:
                if x < m-1:
                  res = helper(x+1, y, acc-1)
                  if res: return True
                if y < n-1:
                  res = helper(x, y+1, acc-1)
                  if res: return True
                return False
            else:
              acc += 1
              if x < m-1:
                res = helper(x+1, y, acc)
                if res: return True
              if y < n-1:
                res = helper(x, y+1, acc)
                if res: return True
              return False
          
        return helper(0, 0, 0)",Hard,34,1059,0.0,4,3.0,14.0,31.147058823529413,70.0,-0.2232352941176465
1564.0,find the k beauty of a number,"class Solution:
    def divisorSubstrings(self, num: int, k: int) -> int:
        num_str = str(num)
        n = len(num_str)
        
        count = 0
        for i in range(n - k + 1):
            sub_num = int(num_str[i:i+k])
            if sub_num == 0 or num % sub_num != 0:
                continue
                
            count += 1
            
        return count",Easy,13,379,0.0,1,3.0,2.0,29.15384615384616,19.0,5.236153846153847
1565.0,number of ways to split array,"class Solution:
    def waysToSplitArray(self, nums: List[int]) -> int:
        running_sum = []
        total = 0
        for i, num in enumerate(nums):
            total += num
            running_sum.append(total)
        
        total = sum(nums)
        splits = 0
        n = len(nums)
        for i in range(n-1):
            if running_sum[i] >= total-running_sum[i]:
                splits += 1
        
        return splits",Medium,15,435,0.0,3,3.0,3.0,29.0,18.0,5.23
1566.0,maximum white tiles covered by a carpet,"class Solution:
    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        if not carpetLen or not tiles: return 0
        def get_next(itl, lf, rt):
            if itl < lf - 1:
                next_itr = lf - 1
            elif itl == lf - 1:
                next_itr = lf
            elif lf <= itl < rt:
                next_itr = rt
            elif itl == rt:
                next_itr = rt + 1
            else:
                next_itr = itl + 1
            return next_itr
        tiles.sort()
        itl = -1
        itr = 0
        iwl = iwr = 0
        nw = 0
        max_w = 0
        max_iter = tiles[-1][1]
        prev_itr = -1
        while itr  < (tiles[-1][1] + 1):
            itl = itr - carpetLen
            njump = itr - prev_itr
            
            if njump == 1:
                while itr > tiles[iwr][1] and iwr < len(tiles) - 1:
                    iwr += 1
                lf, rt = tiles[iwr]
                if lf <= itr <= rt:
                    nw += 1

                next_itr = get_next(itr, lf, rt)
                if itl >= 0:
                    while itl > tiles[iwl][1] and iwl < len(tiles) - 1:
                        iwl += 1
                    lf, rt = tiles[iwl]
                    if lf <= itl <= rt:
                        nw -= 1
                    next_itr2 = get_next(itl, lf, rt) + carpetLen
                else:
                    next_itr2 = math.inf
                prev_itr = itr
                itr = min(next_itr, next_itr2)
            else:
                lf, rt = tiles[iwr]
                if lf <= prev_itr <= rt:
                    nw += itr - prev_itr
                if prev_itr - carpetLen >= 0:
                    lf, rt = tiles[iwl]
                    if lf <= prev_itr - carpetLen <= rt:
                        nw -= itr - prev_itr   
                prev_itr = itr
                itr += 1
            max_w = max(max_w, nw)
        return max_w",Medium,57,1961,0.0,13,4.0,15.0,34.40350877192982,109.0,-5.016315789473683
1567.0,substring with largest variance,"class Solution:
    def largestVariance(self, s: str) -> int:
        counter = Counter(s)
        res = 0
        
        for a, b in permutations(counter, 2):
            count_a, count_b = 0, 0
            remain_b = counter[b]
            for ch in s:
                if ch not in {a, b}:
                    continue
                if ch == a:
                    count_a += 1
                elif ch == b:
                    count_b += 1
                    remain_b -= 1
                # Kadane's Algorithm, modified
                if count_a < count_b and remain_b > 0:
                    count_a, count_b = 0, 0
                if count_b > 0:
                    res = max(res, count_a - count_b) 

        return res",Hard,22,733,1.0,6,4.0,8.0,33.31818181818182,39.0,2.541363636363636
1568.0,find resultant array after removing anagrams,"class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        new = [words[0]]
        for i in range(1, len(words)):
            if Counter(words[i - 1]) == Counter(words[i]):
                continue
            else:
                new.append(words[i])
                
        return new",Easy,9,315,0.0,1,3.0,2.0,35.0,13.0,5.3100000000000005
1569.0,maximum consecutive floors without special floors,"class Solution:
    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:
        aug = [bottom-1] + sorted(special) + [top+1]
        return max(aug[i]-aug[i-1]-1 for i in range(1, len(aug)))",Medium,3,214,0.0,0,2.0,1.0,71.33333333333333,11.0,2.3600000000000003
1570.0,largest combination with bitwise and greater than zero,"class Solution:
    def largestCombination(self, candidates: List[int]) -> int:
        lst, n = [], len(str(bin(max(candidates)))[2:])
        for x in candidates:
            lst.append(str(bin(x))[2:].zfill(n))

        counter = Counter()
        for x in lst:
            for i, y in enumerate(x):
                if y == ""1"":
                    counter[i] += 1
					
        return max(counter.values())",Medium,12,410,0.0,4,3.0,4.0,34.166666666666664,20.0,4.505000000000001
1571.0,percentage of letter in string,"class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        c=0
        for i in letter:
            if i in s:
                c+=s.count(i)
        return c*100//len(s)",Easy,6,194,0.0,2,3.0,2.0,32.333333333333336,11.0,5.69
1572.0,maximum bags with full capacity of rocks,"class Solution:
    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        heap = []
        answer = 0
        n = len(rocks)

        for i in range(n):
            heappush(heap, (
                capacity[i] - rocks[i],
                i
            ))

        while heap:
            remainingCapacity, index  = heappop(heap)
            if remainingCapacity == 0:
                answer += 1

            if 0 < remainingCapacity <= additionalRocks and additionalRocks > 0:
                heappush(heap, (
                    0,
                    index
                ))
                additionalRocks -= remainingCapacity


        return answer",Medium,25,702,0.0,4,3.0,4.0,28.08,31.0,3.9528
1573.0,minimum lines to represent a line chart,"class Solution:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        if len(stockPrices) == 1 :
            return 0
        if len(stockPrices) == 2:
            return 1
        number = 1
        stockPrices.sort()
        for i in range(2, len(stockPrices)):
            if int((stockPrices[i][1]-stockPrices[i-1][1])*(stockPrices[i-1][0]-stockPrices[i-2][0])) !=\
               int((stockPrices[i-1][1]-stockPrices[i-2][1])*(stockPrices[i][0]-stockPrices[i-1][0])):
                number = number + 1
                
        return number
		```",Medium,14,572,0.0,1,3.0,4.0,40.85714285714285,19.0,4.182857142857144
1574.0,sum of total strength of wizards,"class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        ans = 0 
        stack = []
        prefix = list(accumulate(accumulate(strength), initial=0))
        for i, x in enumerate(strength + [0]): 
            while stack and stack[-1][1] >= x: 
                mid = stack.pop()[0]
                lo = stack[-1][0] if stack else -1 
                left = prefix[mid] - prefix[max(lo, 0)]
                right = prefix[i] - prefix[mid]
                ans = (ans + strength[mid]*(right*(mid-lo) - left*(i-mid))) % 1_000_000_007
            stack.append((i, x))
        return ans",Hard,13,608,0.0,2,3.0,3.0,46.76923076923077,22.0,3.290769230769232
1575.0,check if number has equal digit count and digit value,"class Solution:
    def digitCount(self, num: str) -> bool:
        for i in range(len(num)):
            if int(num[i]) != num.count(str(i)):
                return False
        return True",Easy,5,191,0.0,1,3.0,2.0,38.2,8.0,5.522
1576.0,sender with largest word count,"class Solution:
    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
        d,res,s = {},-1,""""
        for i in range(len(senders)):
            sender = senders[i]
            message_count = len(messages[i].split("" ""))
            d[sender] = d.get(sender,0) + message_count
            if d[sender] > res:
                res = d[sender]
                s = sender
            elif d[sender] == res:
                s = max(sender,s)
            
        return s",Medium,13,494,0.0,3,3.0,3.0,38.0,27.0,3.5200000000000005
1577.0,maximum total importance of roads,"class Solution:
    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        dict1={}
        for i in roads:
            if i[0] not in dict1:dict1[i[0]]=1
            else:dict1[i[0]]+=1
            if i[1] not in dict1:dict1[i[1]]=1
            else:dict1[i[1]]+=1
        sorted_dict = {}
        sorted_keys = sorted(dict1, key=dict1.get)  

        for w in sorted_keys:
            sorted_dict[w] = dict1[w]
        
        items = list(sorted_dict.items())
        sorted_dict = {k: v for k, v in reversed(items)}
        
        ans=0
        for i in sorted_dict:
            sorted_dict[i]=n
            n-=1
            
        print(sorted_dict)
        for i in roads:
            hold=sorted_dict[i[0]]+sorted_dict[i[1]]
            ans+=hold
        
        return ans",Medium,27,807,0.0,6,3.0,7.0,29.88888888888889,34.0,3.37
1578.0,rearrange characters to make target string,"class Solution:
   def rearrangeCharacters(self, s: str, target: str) -> int:
       c1=Counter(s)
       c2=Counter(target)
       cnt=0
       while (c2&amp;c1)==c2:
           cnt+=1
           c1=c1-c2
       return (cnt)",Easy,8,225,0.0,1,2.0,1.0,28.125,16.0,5.688750000000001
1579.0,apply discount to prices,"class Solution:
    def discountPrices(self, sentence: str, discount: int) -> str:
        strings = sentence.split(' ')
        result = []
        
        for string in strings:
            if string[0] == '$': tmp = string[1:] tmp.replace('.', '') if tmp.isdigit(): new = (float)(string[1:]) * ((100 - discount) / 100) new = ""$"" + ""{:.2f}"".format(new)
                    result.append(new)
                else:
                    result.append(string)
            else:
                result.append(string)
        
        return "" "".join(result)",Medium,13,555,0.0,2,3.0,4.0,42.69230769230769,24.0,3.457692307692308
1580.0,steps to make array non decreasing,"class Solution:
    def totalSteps(self, nums: List[int]) -> int:
        ans = 0 
        stack = []
        for x in nums: 
            val = 1
            while stack and stack[-1][0] <= x: val = max(val, stack.pop()[1]+1)
            if not stack: val = 0
            stack.append((x, val))
            ans = max(ans, val)
        return ans",Medium,10,345,0.0,3,3.0,3.0,34.5,19.0,4.635000000000001
1582.0,min max game,"class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        
        x = 0 
        while len(nums)>1:
            a = []
            while nums:
                if x:
                    a.append(max(nums[0],nums[1]))
                    nums.pop(0)
                    nums.pop(0)
                    x = 0
                else:
                    a.append(min(nums[0],nums[1]))
                    nums.pop(0)
                    nums.pop(0)
                    x = 1 
            nums = a 
        return nums[0]",Easy,18,531,0.0,3,4.0,3.0,29.5,17.0,5.225
1583.0,partition array such that maximum difference is k,"class Solution:
    def partitionArray(self, nums: List[int], k: int) -> int:
        answer = 0
        nums.sort()

        while nums:
            smallestNumber = nums.pop(0)
            while nums and smallestNumber <= nums[0] and nums[0] - smallestNumber <= k:
                nums.pop(0)

            answer += 1

        return answer",Medium,12,342,0.0,2,2.0,2.0,28.5,16.0,5.595
1584.0,replace elements in an array,"class Solution:
    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
        hashmap = {}

        for i, number in enumerate(nums):
            hashmap[number] = i

        for start, end in operations:
            if start in hashmap:
                nums[hashmap[start]] = end
                hashmap[end] = hashmap[start]

        return nums",Medium,12,379,0.0,3,2.0,3.0,31.58333333333333,16.0,5.2575
1585.0,strong password checker ii,"class Solution:
    def strongPasswordCheckerII(self, S: str) -> bool:
        if len(S)<8:
            return False
        num=0
        upper=0
        lower=0
        spec=0
        char=""!@#$%^&amp;*()-+""
        for i in range(len(S)):
            if i>0 and S[i]==S[i-1]:
                return False
            if S[i].isdigit():
                num+=1
            if S[i].isupper():
                upper+=1
            if S[i].islower():
                lower+=1
            if S[i] in char:
                spec+=1
        if num>0 and upper >0 and lower>0 and spec>0 :
            return True
        return False",Easy,22,626,1.0,5,3.0,8.0,28.454545454545453,31.0,3.8990909090909103
1586.0,successful pairs of spells and potions,"class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        m = len(potions)  
        return [m - bisect.bisect_left(potions, math.ceil(success / spell))
                for spell in spells]",Medium,5,275,0.0,0,3.0,1.0,55.0,11.0,3.77
1587.0,match substring after replacement,"class Solution:
    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
        
#         maintain a map to know which letters can be changed
        d = defaultdict(set)

        for i,j in mappings:
            d[i].add(j)
        
        
        k = len(sub)
        
#         iterate over all possibilities of size len(sub)
        for i in range(len(s)-k+1):
            st = s[i:i+k]
            fl = 0
#          iterate greedily and try if we can replace cur character or not if not we break
            for j in range(k):
                if sub[j] != st[j]: 
                    if st[j] not in d[sub[j]]: 
                        fl = 1
                        break
            if fl ==0: return True
        return False",Hard,23,765,3.0,3,3.0,8.0,33.26086956521739,26.0,4.166521739130435
1588.0,count subarrays with score less than k,"class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        res = 0
        left = 0
        windowSum = 0
        
        for right, num in enumerate(nums):
            windowSum += num
            windowLength = right - left + 1
            while windowSum * windowLength >= k:
                windowSum -= nums[left]
                left += 1
                windowLength -= 1
            
            res += windowLength
        
        return res",Hard,16,479,0.0,2,3.0,2.0,29.9375,21.0,4.905625
1589.0,calculate amount paid in taxes,"class Solution:
    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        
        ans = 0

        n = len(brackets)
        if income <= brackets[0][0]:
            return income * brackets[0][1] * 0.01

        # brackets[k - 1] < income < brackets[k]
        k = 0
        
        for i in range(n):
            if income > brackets[i][0]:
                k += 1

        j = 1
        ans += brackets[0][0] * brackets[0][1] * 0.01
        while j < k:
            ans += (brackets[j][0] - brackets[j - 1][0]) * brackets[j][1] * 0.01
            j += 1

        ans += (income - brackets[j - 1][0]) * brackets[j][1] * 0.01
        
        return ans",Easy,24,682,1.0,3,2.0,4.0,28.416666666666668,26.0,4.5825
1590.0,minimum path cost in a grid,"class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        dic = defaultdict(list)
        lastRow = set(grid[-1])
        
        for i in range(m*n):
            for j in range(n):
                if i in lastRow:
                    continue
                else:
                    # (cost, dest_col)
                    dic[i].append((moveCost[i][j], j))
                    
        dp = [[float('inf')] * n for _ in range(m)]
        
        for i in range(n):
            dp[0][i] = grid[0][i]
        
        for i in range(m-1):
            for j in range(n):
                start = grid[i][j]
                for cost, dest_col in dic[start]:
                    dp[i + 1][dest_col] = min(dp[i + 1][dest_col], dp[i][j] + cost + grid[i + 1][dest_col])
        
        return min(dp[-1])",Medium,26,898,1.0,6,3.0,8.0,34.53846153846154,27.0,3.691538461538461
1591.0,fair distribution of cookies,"class Solution:
    def distributeCookies(self, cookies: List[int], k: int) -> int:
        ans = sum(cookies)
        N = len(cookies)
        total = [0]*k
        
        def backtrack(i, total):
            nonlocal ans
            if i == N:
                ans = min(ans, max(total))
                return
            
            if max(total) >= ans:
                return
            
            for j in range(k):
                total[j] += cookies[i]
                backtrack(i+1, total)
                total[j] -= cookies[i]
        

        backtrack(0, total)
        return ans",Medium,22,600,0.0,1,3.0,3.0,27.27272727272728,26.0,4.705454545454546
1592.0,naming a company,"class Solution:
    def distinctNames(self, ideas: List[str]) -> int:
        seen = set(ideas)
        freq = Counter()
        letters = {x[0] for x in ideas}
        for idea in ideas: 
            for ch in letters: 
                if ch + idea[1:] not in seen: freq[idea[0], ch] += 1 
        ans = 0 
        for idea in ideas: 
            for ch in letters: 
                if ch + idea[1:] not in seen: ans += freq[ch, idea[0]]
        return ans",Hard,12,457,0.0,6,3.0,7.0,38.083333333333336,21.0,3.9325
1593.0,greatest english letter in upper and lower case,"class Solution:
    def greatestLetter(self, s: str) -> str:
        d = {}
        ans = """"
        for i in s:
            if i in d:
                ans = max(ans,i.upper())
            else:
                if i.islower():
                    d[i.upper()] = i 
                else:
                    d[i.lower()] = i 
        return ans",Easy,12,343,0.0,3,4.0,3.0,28.58333333333333,16.0,5.407500000000001
1594.0,sum of numbers with units digit k,"class Solution:
    
    
    def minimumNumbers(self, num: int, k: int) -> int:
        if num==0:
            return 0
        if num<k:
            
            return -1
        nums=[]
        
        while k<=num:
            
            nums.append(k)
            k+=10
        
    
        amount=num
        n=len(nums)

        dp=[[10**9]*(num+1)for _ in range(n)]
        for i in range(n):
            dp[i][0]=0
        if nums[0]<=amount:
            if nums[0]!=0 and amount%nums[0]==0:
                dp[0][nums[0]]=amount//nums[0]
                
            
        for i in range(n):
            for j in range(1,num+1):
                take=10**9
                if nums[i]<=j:
                    take=1+dp[i][j-nums[i]]
                not_take=dp[i-1][j]
                
                dp[i][j]=min(take,not_take)
                ans=dp[i][j]
                    
        if ans!=10**9:
            return ans
        
        return -1",Medium,41,968,0.0,7,3.0,11.0,23.60975609756097,46.0,2.675121951219512
1595.0,longest binary subsequence less than or equal to k,"class Solution:
    def longestSubsequence(self, s: str, k: int) -> int:
        # count all '0' first
        # traverse the s from back to front, try each digit '1'
        
        target = bin(k)[2:]
        result = s.count('0')
        n = len(s)
        cur_sum = 0
        
        for i in range(n-1, -1, -1):
            char = s[i]
            
            if char == '1':
                cur_num = 2 ** ((n-1)-i)
                cur_sum += cur_num
                
                if cur_sum > k:
                    return result
                else:
                    result += 1
        
        return result",Medium,22,627,2.0,2,3.0,3.0,28.5,27.0,4.515
1596.0,selling pieces of wood,"class Solution:
    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
        mp = {(h, w) : p for h, w, p in prices}
        
        @cache
        def fn(m, n): 
            """"""Return max money of a mxn piece of wood.""""""
            if m == 0 or n == 0: return 0
            ans = 0 
            if (m, n) in mp: ans = mp[m, n]
            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))
            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))
            return ans 
        
        return fn(m, n)",Hard,14,590,0.0,1,3.0,7.0,42.142857142857146,43.0,1.6671428571428564
1597.0,count asterisks,"class Solution:
    def countAsterisks(self, s: str) -> int:
        
        result = 0
        
        for i, chunk in enumerate(s.split(""|"")):
            if i % 2 == 0:
                result += chunk.count(""*"")
        
        return result",Easy,9,247,0.0,2,3.0,2.0,27.444444444444443,13.0,5.930000000000001
1598.0,count unreachable pairs of nodes in an undirected graph,"class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        g = collections.defaultdict(list)
        seen = set()
        res = []
        
        # generate an adjacency list from edges
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)
        
        # count nodes in each disjoint graph segments
        def dfs(node):
            if node in seen:
                return
            
            self.count += 1
            seen.add(node)
            for nei in g[node]:
                dfs(nei)
                
            return
        
        for i in range(n):
            self.count = 0
            if i not in seen:
                dfs(i)
                
            res.append(self.count) 
            self.count = 0
                
        # returning sum of product all unique pairs 
        # (a1+a2+a3+...)^2 = (a1^2 + a2^2 + ...) + 2*(a1.a2 + a2.a3 + ...)
        # using above formula we can return the desired result
        return (sum(res)**2 - sum(num**2 for num in res))//2",Medium,34,1062,5.0,2,3.0,7.0,31.23529411764705,21.0,4.988823529411765
1599.0,maximum xor after operations,"class Solution:
    def maximumXOR(self, nums: List[int]) -> int:
        return reduce(lambda x,y:x|y, nums)",Medium,2,109,0.0,0,2.0,0.0,54.5,8.0,4.175
1600.0,number of distinct roll sequences,"class Solution:
    def distinctSequences(self, n: int) -> int:
        MOD = 10**9 + 7
        @cache
        def dfs(i, prev, prev_prev):
            if i >= n:
                return 1
            result = 0
            for dice in range(1, 7):
                if dice == prev or dice == prev_prev:
                    continue
                if dice % 2 == 0 and prev % 2 == 0:
                    continue
                if dice % 3 == 0 and prev % 3 == 0:
                    continue
                result += dfs(i + 1, dice, prev)
            return result % MOD
        return dfs(0, -1, -1)",Hard,17,603,0.0,0,4.0,5.0,35.47058823529412,41.0,2.4676470588235286
1601.0,check if matrix is x matrix,"class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        
        for i in range(n):
            for j in range(n):
                if i == j or i == n - j - 1:
                    if grid[i][j] == 0:
                        return False
                else:
                    if grid[i][j] != 0:
                        return False
                    
        return True",Easy,13,425,0.0,3,4.0,5.0,32.69230769230769,22.0,4.437692307692307
1602.0,count number of ways to place houses,"class Solution:
    def countHousePlacements(self, n: int) -> int:
        mod = 1000000007
        if n==1:
            return 4
      
        
        count_end = 1
        count_space = 1
        
        for i in range(2,n+1):
            prev_end = count_end
            prev_space = count_space
            
            count_space = prev_end + prev_space
            count_end  =prev_space
            
        ways = count_end + count_space
        
        return (ways*ways)%mod",Medium,19,489,0.0,1,3.0,2.0,25.73684210526316,19.0,5.543684210526316
1603.0,maximum score of spliced array,"class Solution:
    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        v1 = v2 = m1 = m2 = 0
        for x1, x2 in zip(nums1, nums2): 
            v1 = max(0, v1+x2-x1)
            v2 = max(0, v2+x1-x2)
            m1 = max(m1, v1)
            m2 = max(m2, v2)
        return max(sum(nums1)+m1, sum(nums2)+m2)",Hard,8,341,0.0,1,3.0,1.0,42.625,23.0,3.62375
1604.0,minimum score after removals on a tree,"class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        tree = [set() for _ in range(n)]
        for e in edges:
            tree[e[0]].add(e[1])
            tree[e[1]].add(e[0])

        def make_tree(i, parent):
            ancestors[i].add(parent)
            for j in ancestors[parent]:
                ancestors[i].add(j)
            tree[i].remove(parent)
            for child in tree[i]:
                make_tree(child, i)
                xor[i] ^= xor[child]

        xor = [nums[i] for i in range(n)]
        ancestors = [set() for _ in range(n)]
        for child in tree[0]:
            make_tree(child, 0)
            xor[0] ^= xor[child]

        ans = 2 ** 31 - 1
        for i in range(1, n - 1):
            for j in range(i + 1, n):
                if i in ancestors[j]:
                    parts = [xor[0] ^ xor[i], xor[i] ^ xor[j], xor[j]]
                elif j in ancestors[i]:
                    parts = [xor[0] ^ xor[j], xor[i], xor[i] ^ xor[j]]
                else:
                    parts = [xor[0] ^ xor[i] ^ xor[j], xor[i], xor[j]]
                ans = min(ans, max(parts) - min(parts))
        return ans",Hard,33,1205,0.0,8,3.0,11.0,36.51515151515152,40.0,2.0536363636363646
1605.0,decode the message,"class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        i = 97
        encMap = {' ': ' '}
        for c in key:
            if c not in encMap:
                encMap[c] = chr(i)
                i += 1
        
        res = []
        for c in message:
            res.append(encMap[c])
        
        return ''.join(res)",Easy,13,353,0.0,3,3.0,3.0,27.15384615384616,16.0,5.596153846153847
1606.0,spiral matrix iv,"class Solution:
    def spiralMatrix(self, rows: int, cols: int, head: Optional[ListNode]) -> List[List[int]]:
        ans = [[-1] * cols for _ in range(rows)]
        rows1, cols1 = rows - 1, cols - 1
        min_layers = min(rows, cols) // 2
        for i in range(min_layers):
            for c in range(i, cols1 - i):
                ans[i][c] = head.val
                head = head.next
                if not head:
                    return ans
            col = cols1 - i
            for r in range(i, rows1 - i):
                ans[r][col] = head.val
                head = head.next
                if not head:
                    return ans
            row = rows1 - i
            for c in range(cols1 - i, i, -1):
                ans[row][c] = head.val
                head = head.next
                if not head:
                    return ans
            for r in range(rows1 - i, i, -1):
                ans[r][i] = head.val
                head = head.next
                if not head:
                    return ans
        if rows <= cols and rows % 2:
            for c in range(min_layers, cols - min_layers):
                ans[min_layers][c] = head.val
                head = head.next
                if not head:
                    return ans
        elif cols % 2:
            for r in range(min_layers, rows - min_layers):
                ans[r][min_layers] = head.val
                head = head.next
                if not head:
                    return ans
        return ans",Medium,40,1511,0.0,9,4.0,16.0,37.775,54.0,0.4202499999999993
1607.0,number of people aware of a secret,"class Solution:
    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        
        '''
        Time: O(n)
        Space: O(n)
        '''
        # record the newly pepole who know the secret on the given day
        dp = [0]*(n+1)
        dp[1] = 1
        share = 0
        MOD = 10**9 + 7
        for i in range(2, n+1):
            # newly people who know the secret today is the sum of days(forget:delay]
            dp[i] = share = (share + dp[i - delay] - dp[i - forget]) % MOD

        # return the sum of days where people not forget the secret yet
        return sum(dp[n-forget+1:]) % MOD",Medium,17,624,4.0,0,2.0,6.0,36.70588235294117,21.0,4.636470588235294
1608.0,number of increasing paths in a grid,"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        '''
        time, space: O(m*n)
        similar to : https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
        '''
        R, C = len(grid), len(grid[0])
        memo = {}
        MOD = 10**9 + 7
        
        def dfs(i, j, R, C, memo):
            if (i, j) in memo:
                return memo[(i,j)]
            
            res = 1
            for di,dj in [(1,0), (0,1), (-1,0), (0,-1)]:
                ni, nj = i+di, j+dj
                if 0<=ni<R and 0<=nj<C and grid[ni][nj] > grid[i][j]:
                    # res = max(res, dfs(ni, nj, R, C, memo))
                    res += dfs(ni, nj, R, C, memo)
            memo[(i, j)] = res % MOD
            return memo[(i, j)]
            
            
        ans = 0
        for i in range(R):
            for j in range(C):
                #ans = max(ans, dfs(i, j, R, C, memo))
                ans += dfs(i, j, R, C, memo) % MOD
                
        return ans % MOD",Hard,30,1028,3.0,3,3.0,5.0,34.266666666666666,71.0,-0.4240000000000012
1609.0,evaluate boolean binary tree,"class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if root.left is None:
            return root.val
        if root.val==2:
            return self.evaluateTree(root.left) or self.evaluateTree(root.right)
        else:
            return self.evaluateTree(root.left) and self.evaluateTree(root.right)",Easy,7,336,0.0,0,3.0,2.0,48.0,11.0,4.4
1610.0,the latest time to catch a bus,"class Solution:
    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        buses = sorted(buses)
        passengers = deque(sorted(passengers))
        res = buses[-1]
        
        s = set(passengers)
        prev = passengers[0]
        
        for i, bus in enumerate(buses):
            cap = capacity
            while cap and passengers and passengers[0] <= bus:
                val = passengers.popleft()
                prev = val
                cap -= 1
                if val-1 not in s:
                    res = val-1
                
            if cap:
                for k in range(bus, prev, -1):
                    if k not in s:
                        res = k
                        break
        
        return res",Medium,24,792,0.0,5,4.0,6.0,33.0,31.0,3.39
1611.0,minimum sum of squared difference,"class Solution:
    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:
        
        nums = [abs(a - b) for a, b in zip(nums1, nums2) if a != b]
        if k1 + k2 >= sum(nums): return 0

        cnt = Counter(nums)
                
        q = []
        for k in cnt:
            heappush(q, -k)        
        
        tot = sum(pow(x, 2) for x in nums)        
        k = k1 + k2
        # ops on largest diff
        while k > 0 and q:
            cur = -heappop(q)
            diff = cur + q[0] if q else cur
            # reduce current diff to next smaller diff
            if diff * cnt[cur] <= k:
                k -= diff * cnt[cur]
                cnt[-q[0]] += cnt[cur]
                tot += (pow(-q[0], 2) - pow(cur, 2)) * cnt[cur] 
            # apply all remaining ops
            else:
                a, b = divmod(k, cnt[cur])
                tot += (pow(cur - a - 1, 2) * b + pow(cur - a, 2) * (cnt[cur] - b)) - pow(cur, 2) * cnt[cur]
                k = 0                   
            
        
        return tot",Medium,30,1080,3.0,3,3.0,15.0,36.0,46.0,1.92
1612.0,subarray with elements greater than varying threshold,"class Solution:
    def validSubarraySize(self, nums: List[int], threshold: int) -> int:
        nums.append(0)
        stack = [(0, -1)]
        for i, v in enumerate(nums):
            while len(stack) > 1 and v <= stack[-1][0]:
                if stack[-1][0] > threshold / (i - 1 - stack[-2][1]):
                    return i - 1 - stack[-2][1]
                stack.pop()
            stack.append((v, i))
        return -1",Hard,10,427,0.0,2,3.0,3.0,42.7,18.0,4.057
1613.0,minimum amount of time to fill cups,"class Solution:
    def fillCups(self, amount: List[int]) -> int:
        amount.sort()
        a = amount[-1]
        b = amount[0] + amount[1]
        if b>a: 
            if (b-a)%2==0:
                return a + (b-a)//2
            else:
                return a + 1 + (b-a)//2
        return a",Easy,10,299,0.0,0,3.0,2.0,29.9,14.0,5.729
1614.0,move pieces to obtain a string,"class Solution:
    def canChange(self, start: str, target: str) -> bool:
        d = {}
        e = {}
        for i in range(len(start)):
            if start[i] not in d:
                d[start[i]] = [i]
                e[start[i]] = i
            else:
                d[start[i]].append(i)
        if ""L"" not in e:
            e[""L""] = -1
            d[""L""] = []
        if ""R"" not in e:
            e[""R""] = -1
            d[""R""] = []
        a = target.count(""L"")
        b = target.count(""R"")
        if a!=len(d[""L""]) or b!=len(d[""R""]):
            return False
        for i in range(len(target)):
            if target[i]==""L"":
                if e[""L""]>=i and ((e[""R""]!=-1 and e[""R""]>e[""L""]) or e[""R""]==-1):
                    if d[""L""]:
                        d[""L""].pop(0)
                        if d[""L""]:
                            e[""L""] = d[""L""][0]
                        else:
                            e[""L""] = -1 
                    else:
                        return False
                else:
                    return False 
            elif target[i]==""R"":
                if e[""R""]<=i and ((e[""L""]!=-1 and (e[""L""]>i)) or e[""L""]==-1):
                    if d[""R""]:
                        d[""R""].pop(0)
                        if d[""R""]:
                            e[""R""] = d[""R""][0]
                        else:
                            e[""R""] = -1 
                    else:
                        False
                else:
                    return False
        return True",Medium,45,1525,0.0,10,5.0,14.0,33.888888888888886,64.0,-0.3499999999999996
1615.0,count the number of ideal arrays,"class Solution:
    def __init__(self):
        self.MOD = 1000000007
        self.memo = {0: 1}
        self.fact = [1 for i in range(10100)]
        
    def inv(self, x):
        if x>1: return self.inv(self.MOD%x)*(self.MOD-self.MOD//x)%self.MOD 
        else: return x
        
    def choose(self, n, k):
        return ((self.fact[n] * self.inv(self.fact[n-k]) ) % self.MOD )* self.inv(self.fact[k]) %self.MOD
    
    def factors(self, x):
        a = []
        i = 2
        while x > 1:
            re = 0
            while x % i == 0:
                re += 1
                x //= i
            if re: a.append(re)
            i += 1
        return a   
    
    def h(self, v):
        if v in self.memo: return self.memo[v]
        self.memo[v] = self.choose(v+self.c, self.c)
        return self.memo[v]
        
    def idealArrays(self, n: int, maxValue: int) -> int:
        s = 0
        self.c = n-1
        
        for i in range(2,10100):
            self.fact[i] = self.fact[i-1] * i % self.MOD

        for i in range(1, maxValue+1):
            cur = 1
            fa = self.factors(i)
            for f in fa: cur = (cur*self.h(f))%self.MOD
            s = (s+cur)%self.MOD
        return s",Hard,42,1217,0.0,2,3.0,9.0,28.976190476190474,52.0,1.8921428571428576
1616.0,maximum number of pairs in array,"class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        answer = [0, 0]
        mydict = defaultdict(int)
        for num in nums:
            mydict[num] += 1
        for key in mydict:
            answer[0] += mydict[key] // 2
            answer[1] += mydict[key] % 2
        return answer",Easy,9,318,0.0,2,3.0,2.0,35.333333333333336,13.0,5.22
1617.0,max sum of a pair with equal sum of digits,"class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        hmap = collections.defaultdict(list)
        
        for n in nums:
            total = sum([int(i) for i in str(n)])
            
            hmap[total] = hmap[total] +[n]
            hmap[total] = sorted(hmap[total], reverse=True)[:2]
        
        result = -1
        for k, v in hmap.items():
            if len(v) == 2:
                result = max(result, sum(v))
        return result",Medium,14,470,0.0,3,3.0,4.0,33.57142857142857,22.0,4.418571428571429
1618.0,query kth smallest trimmed number,"class Solution:
    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:
        A = list(enumerate(nums)) # (1)
        res = []
        for k, t in queries:
            A.sort(key=lambda x: (int(x[1][len(x[1]) - t:]), x[0])) # (2)
            res.append(A[k - 1][0]) # (3)
        return res",Medium,7,330,3.0,1,3.0,1.0,47.142857142857146,15.0,4.137142857142858
1619.0,minimum deletions to make array divisible,"class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        GCD = reduce(lambda x,y: gcd(x,y), numsDivide)
        nums.sort()
        
        for idx, num in enumerate(nums):
            if(GCD % num == 0):
                return idx 
        return -1",Hard,8,294,0.0,0,3.0,2.0,36.75,18.0,4.7125
1620.0,best poker hand,"class Solution:
    def bestHand(self, ranks: List[int], suits: List[str]) -> str:
        r = collections.Counter(ranks)
        s = collections.Counter(suits)
        for i in s:
            if s[i] >= 5:
                return ""Flush""
        for i in r:
            if r[i] >= 3:
                return ""Three of a Kind""
        for i in r:
            if r[i] >= 2:
                return ""Pair""
        return ""High Card""",Easy,13,427,0.0,3,3.0,6.0,32.84615384615385,21.0,4.583846153846155
1621.0,number of zero filled subarrays,"class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        temp = [0] * (len(nums) + 1)
        for index, num in enumerate(nums, start=1):
            if num == 0:
                temp[index] = 1 + temp[index - 1]

        return sum(temp)",Medium,7,263,0.0,2,2.0,2.0,37.57142857142857,15.0,4.878571428571428
1622.0,shortest impossible sequence of rolls,"class Solution:
    def shortestSequence(self, rolls: List[int], k: int) -> int:
        res = 0
        s = set()
        for i in range(len(rolls)):
            num = rolls[i]
            if num not in s:
                s.add(num)
                if len(s) == k:
                    res+=1
                    s = set()
        return res+1",Hard,11,343,0.0,3,3.0,3.0,31.181818181818183,18.0,5.033636363636364
1623.0,first letter to appear twice,"class Solution:
    def repeatedCharacter(self, s: str) -> str:
        l = []
        for i in s:
            if i in l:
                return i
            else:
                l.append(i)",Easy,7,192,0.0,2,3.0,2.0,27.428571428571427,9.0,6.331428571428571
1624.0,equal row and column pairs,"class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        root = {}
        n = len(grid)
        for i in range(n):
            tmp = root
            for j in range(n):
                if grid[i][j] not in tmp:
                    tmp[grid[i][j]] = {}
                tmp = tmp[grid[i][j]]
            if '#' in tmp:
                tmp['#'] += 1
            else:
                tmp['#'] = 1
        
        numPair = 0
        for j in range(n):
            tmp = root
            for i in range(n):
                if grid[i][j] not in tmp:
                    break
                tmp = tmp[grid[i][j]]
            if '#' in tmp:
                numPair += tmp['#']
        
        return numPair",Medium,25,728,5.0,7,4.0,8.0,29.12,25.0,4.4192
1625.0,number of excellent pairs,"class Solution:
    def countExcellentPairs(self, nums: List[int], k: int) -> int:
        freq = Counter(map(int.bit_count, set(nums)))
        return sum(v1*v2 for k1, v1 in freq.items() for k2, v2 in freq.items() if k1+k2 >= k)",Hard,3,230,0.0,0,2.0,3.0,76.66666666666667,13.0,1.6799999999999995
1626.0,make array zero by subtracting equal amounts,"class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        nums.sort()
        count = 0 
        while nums.count(0) != len(nums) : 
            count += 1 
            nums.sort()
            flag, min_num = True, 0
            for i in range(len(nums)) : 
                if (nums[i] != 0) and flag :
                    min_num = nums[i]
                    flag = False 
                nums[i] -= min_num
        return count",Easy,13,453,0.0,3,3.0,3.0,34.84615384615385,18.0,4.703846153846154
1627.0,maximum number of groups entering a competition,"class Solution:
    def maximumGroups(self, grades: List[int]) -> int:
        if len(grades) <= 2 : 
            return 1 
        else : 
            grades.sort()
            dict_group ={}
            group_len = 1 
            i = 0
            end = 0
            while end < len(grades) :
                start, end = i, i + group_len
                # if end >= len(grades) : 
                #     break 
                if group_len != 1 :
                    if (sum(grades[start: end]) > sum(dict_group[group_len - 1])) and (len(grades[start: end]) == (end - start)) :
                        # print(start, end)
                        dict_group[group_len] = grades[start: end] 
                    else : 
                        return len(dict_group)
                else : 
                    dict_group[group_len] = grades[start: end] 
                    
                group_len += 1 
                i = end 
                # print(dict_group)
            return len(dict_group)",Medium,26,1004,4.0,2,4.0,5.0,38.61538461538461,39.0,2.424615384615385
1628.0,find closest node to given two nodes,"class Solution:
    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
        ## RC ##
        ## APPROACH: GRAPH ##
        ## LOGIC ##
        ## 1. Typical Graph problem, just do what the question asks
        ## 2. Watch out for race conditions, a) when no common node b) multiple paths for the same node
        graph = collections.defaultdict(list)
        for u, v in enumerate(edges):
            if v != -1:
                graph[u].append(v)
        
        res = float('inf')
        ans = -1
        visited1 = {}
        def dfs1(node, d):
            nonlocal res
            nonlocal ans
            if node == node2:
                res=min(res, d)
                ans=node
            if node in visited1:
                if visited1[node] > d:
                    visited1[node] = d
                return
            visited1[node] = d
            if node in graph:    
                dfs1(graph[node][0], d +1)
        
        dfs1(node1, 0)
        
        visited2 = {}
        def dfs2(node, d):
            nonlocal res
            nonlocal ans
            if node == node1:
                if res > d:         # if already found in first node, then check for max distance
                    res = d
                    ans=node
            if node in visited2:
                if visited2[node] > d:
                    visited2[node] = d
                return
            visited2[node] = d
            if node in graph:    
                dfs2(graph[node][0], d +1)
        
        dfs2(node2, 0)
        for node in sorted(visited1.keys()):
            if node in visited2:
                if max(visited1[node], visited2[node]) < res:
                    res = max(visited1[node], visited2[node])
                    ans = node
        return ans",Medium,53,1812,6.0,12,4.0,18.0,34.18867924528302,65.0,-0.2969811320754711
1629.0,longest cycle in a graph,"class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        
        ans = -1
        
        def checkLoop(start):
            temp = {}
            count = 0
            while start != -1:
                if start in temp:
                    return count - temp[start]
                elif start in visited:
                    return -1
                
                visited.add(start)
                temp[start] = count
                count += 1
                start = edges[start]
            return -1
                
        visited = set()
        
        for value in edges:
            if value in visited:
                continue
            else:
                ans = max(ans, checkLoop(value))
        
        return ans",Hard,28,763,0.0,1,4.0,5.0,27.25,22.0,5.0475
1630.0,merge similar items,"class Solution:
    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:
        weight = {} # or defaultdict(int)
        values, weights = zip(*items1, *items2)
        for val, wt in zip(values, weights):
            weight[val] = weight.get(val, 0) + wt
        return sorted(weight.items())",Easy,6,340,1.0,1,2.0,1.0,56.66666666666666,16.0,3.160000000000001
1631.0,count number of bad pairs,"class Solution:
    def countBadPairs(self, nums: List[int]) -> int:
        k = len(nums)
        res = k * (k - 1) // 2 # (1)
        c = Counter([i - n for i, n in enumerate(nums)]) # (2) and (3)
        for n in c.values():
            res -= n * (n - 1) // 2 # (4)
        return res",Medium,7,288,3.0,1,2.0,2.0,41.142857142857146,11.0,5.137142857142858
1632.0,task scheduler ii,"class Solution:
    def taskSchedulerII(self, tasks: List[int], space: int) -> int:
        ld={}
        d=0
        for t in tasks:
            ld[t]=0
        for t in tasks:
            if ld[t]==0:
                d+=1
                ld[t]=d
            else:
                nd=ld[t]+space
                ld[t]=max(nd+1,d+1)
                d=ld[t]
        return d",Medium,14,373,0.0,3,3.0,3.0,26.642857142857142,23.0,4.942142857142858
1633.0,minimum replacements to sort the array,"class Solution:
    def minimumReplacement(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        
        def helper(n, to_deal):                 # return (times needed to divide, biggest left-most num)
            if n <= to_deal:
                return (0, n)
            if n % to_deal == 0:                # For example: [9, 3]
                return (n//to_deal - 1, to_deal)
            else:
                times = n // to_deal            # For example: [10, 4], it should at least deivide (n1 // to_deal) times
                x = n // (times+1)              # Since we know 10 must divided into 3 num, the biggest left-most num will be 10//3 = 3
                return (times, x)
                
        to_deal = nums[-1]                      
        res = 0
        i = len(nums) - 2                       # Iterate from the second-last element. 
        
        while i >= 0:
            times, left_most_num = helper(nums[i], to_deal)
            res += times
            to_deal = left_most_num             # Update to_deal to the left_most_num .
            i -= 1
        
        return res",Hard,25,1144,6.0,0,4.0,6.0,45.76,44.0,1.4816000000000005
1634.0,number of arithmetic triplets,"class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        ans = 0 
        seen = set()
        for x in nums: 
            if x-diff in seen and x-2*diff in seen: ans += 1
            seen.add(x)
        return ans",Easy,7,250,0.0,2,3.0,5.0,35.714285714285715,12.0,5.285714285714286
1635.0,reachable nodes with restrictions,"class Solution:
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:
        g = defaultdict(list)
        restrict = set(restricted)
        
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)
            
        seen = set()
        stack = [0]
        res = 0

        while stack:
            node = stack.pop()

            if node not in seen:
                res += 1
                seen.add(node)

            for adj in g[node]:
                if adj not in seen and adj not in restrict:
                    stack.append(adj)
                    
        return res",Medium,24,646,0.0,5,3.0,5.0,26.916666666666668,22.0,4.8975
1636.0,check if there is a valid partition for the array,"class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        dp = [False]*(len(nums)+1)
        dp[-1] = True 
        for i in range(len(nums)-1, -1, -1): 
            if i+1 < len(nums) and dp[i+2] and nums[i] == nums[i+1] \
            or i+2 < len(nums) and dp[i+3] and (nums[i] == nums[i+1] == nums[i+2] or nums[i]+2 == nums[i+1]+1 == nums[i+2]): dp[i] = True
        return dp[0]",Medium,7,403,0.0,1,3.0,2.0,57.57142857142857,29.0,1.6785714285714288
1637.0,longest ideal subsequence,"class Solution:
    def longestIdealString(self, s: str, k: int) -> int:
        
        s = [ord(c) - ord('a') for c in s]
        
        m = 0
        
        hm = {}
        
        for i,v in enumerate(s) :
            
            m = 1
            for h in hm:
                if abs(v - h) <= k:
                    m = max(m, hm[h] +1)
            
            hm[v] = m
        
        return max(hm.values())",Medium,18,424,0.0,3,3.0,4.0,23.55555555555556,20.0,5.5200000000000005
1639.0,node with highest edge score,"class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        edge_cnts = defaultdict(int)
        max_idx, max_val = 0, 0
        
        for inp, out in enumerate(edges):
            edge_cnts[out] += inp
            
        for idx in range(len(edges)):
            if edge_cnts[idx] > max_val:
                max_idx, max_val = idx, edge_cnts[idx]
                
        return max_idx",Medium,12,406,0.0,3,3.0,3.0,33.833333333333336,18.0,4.795000000000001
1640.0,construct smallest number from di string,"class Solution:
    def smallestNumber(self, pattern: str) -> str:
        
        
        l = len(pattern)
        
        sol = """"
        
        visited = set([1,2,3,4,5,6,7,8,9])
        
        def backtrack(cur, i ):
            nonlocal l
            nonlocal sol
            
            if len(cur) == l+1:
                sol = cur
                return True

            for j in visited:
                k = int(cur[-1]) 
                if pattern[i] == 'I' and j <= k:
                    continue
                if pattern[i] == 'D' and j >= k:
                    continue
                
                visited.remove(j)
                if backtrack(cur + str(j), i+1):
                    return True
                visited.add(j)
            
            return False

        for j in visited:
            visited.remove(j)
            if backtrack(str(j), 0):
                return sol
            visited.add(j)",Medium,36,945,0.0,2,3.0,7.0,26.25,42.0,3.1375
1641.0,count special integers,"class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        vals = list(map(int, str(n)))
        
        @cache
        def fn(i, m, on): 
            """"""Return count at index i with mask m and profile flag (True/False)""""""
            ans = 0 
            if i == len(vals): return 1
            for v in range(vals[i] if on else 10 ): 
                if m &amp; 1<<v == 0: 
                    if m or v: ans += fn(i+1, m ^ 1<<v, False)
                    else: ans += fn(i+1, m, False)
            if on and m &amp; 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)
            return ans 
        
        return fn(0, 0, True)-1",Hard,16,654,0.0,2,3.0,6.0,40.875,45.0,1.5212500000000002
1642.0,minimum recolors to get k consecutive black blocks,"class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        start_index = 0
        length = len(blocks)
        res = float(""inf"")
        count = 0
        for i in range(start_index, k):
            if blocks[i] == ""W"":
                count += 1
        res = min(res, count)
        
        for i in range(k, length):
            if blocks[start_index] == ""W"":
                count -= 1
            if blocks[i] == ""W"":
                count += 1
            
            res = min(res, count)
            start_index += 1
        return res",Easy,19,571,0.0,5,3.0,5.0,30.05263157894737,35.0,3.315263157894737
1643.0,time needed to rearrange a binary string,"class Solution:
    def secondsToRemoveOccurrences(self, s: str) -> int:
        
        seconds = 0
        my_list = [*s]
        my_string = s
        
        while '01' in my_string:
            i = 0
            while i < len(my_list) - 1:
                if my_list[i] == '0' and my_list[i + 1] == '1':
                    my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]
                    i += 2
                else:
                    i += 1

            my_string = ''.join(my_list)
            seconds += 1
            
        return seconds",Medium,19,565,0.0,3,3.0,3.0,29.73684210526316,27.0,4.263684210526316
1644.0,shifting letters ii,"class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        ops = [0]*(len(s)+1)
        
        for start, end, direction in shifts:
            ops[start] +=  1 if direction == 1 else -1
            ops[end+1] += -1 if direction == 1 else  1
        
        runningDelta = 0
        w = []
        
        for ind, letter in enumerate(s):
            runningDelta += ops[ind]
            newLetter = chr( (ord(letter) - ord('a') + runningDelta) % 26 + ord('a'))
            w.append(newLetter)
            
        return """".join(w)",Medium,16,572,0.0,2,3.0,7.0,35.75,25.0,3.982500000000001
1645.0,maximum segment sum after removals,"class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        running, sum_before = 0, []
        for num in nums:
            running += num
            sum_before.append(running)
        sum_before.append(0) # [-1]
            
        def get_sum(start, end):
            return sum_before[end] - sum_before[start - 1]
        
        removed, res = [-1, len(nums)], []
        max_seg_sums = [float('-inf'), sum(nums)]
        
        for i in removeQueries:
            ins = bisect_left(removed, i)
            before, after = removed[ins - 1], removed[ins]
            
            to_del = bisect_left(max_seg_sums, get_sum(before + 1, after - 1))
            del max_seg_sums[to_del]
            
            new_l, new_r = get_sum(before + 1, i - 1), get_sum(i + 1, after - 1)
            res.append(max(max_seg_sums[-1], new_l, new_r))
            
            bisect.insort(removed, i)
            bisect.insort(max_seg_sums, new_l)
            bisect.insort(max_seg_sums, new_r)
        
        return res",Hard,28,1072,1.0,1,3.0,10.0,38.285714285714285,39.0,2.4542857142857155
1646.0,minimum hours of training to win a competition,"class Solution:
    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        #Approach: Do a single traversal and for every ith opponent, compare your current energy and exp to opponent
        #and adjust so you always win! How much you have to adjust will be number of hours of training you have to invest
        #before you compete!
        
        #At the end, return answer!
        ans = 0
        
        cenergy = initialEnergy
        cexp = initialExperience
        #n = number of opponents to face!
        n = len(energy)
        for i in range(n):
            if(cenergy <= energy[i]):
                ans += (energy[i] - cenergy + 1)
                cenergy = 1
                #if current player has lower exp, then he needs to make it up for it!
                #difference + 1 wil take his current exp to next exp value from opp so he can win!
                #but also, in doing so, he needs to already be 1 ahead! -> set cexp to opponent's exp + 1!
                #Regardless, since he won, he needs to get ith opponents exp added!
                if(cexp <= experience[i]):
                    ans += (experience[i] - cexp + 1)
                    cexp = experience[i] + 1
                #regardless, current experience only goes up!
                cexp += (experience[i])
                continue
                
                
            else:
                cenergy -= energy[i]
                if(cexp <= experience[i]):
                    ans += (experience[i] - cexp + 1)
                    cexp = experience[i] + 1
                cexp += (experience[i])
                
        
        return ans",Easy,37,1712,10.0,-1,4.0,9.0,46.270270270270274,46.0,1.4556756756756766
1647.0,largest palindromic number,"class Solution:
    def largestPalindromic(self, num: str) -> str:
        
        counter = Counter(num)
        
        l = [(-int(n), c) for n, c in counter.items()]
        heapq.heapify(l)
        
        left, right = [], []
        mid = None

        while l:
            n, c = heapq.heappop(l)
            n = -n 
            
            if c % 2 == 0:
                left = left + [n] * (c // 2)
                right = [n] * (c // 2) + right
            else:
                if c - 1 > 0:
                    heapq.heappush(l, (-n, c - 1))
                if mid is None:
                    mid = n
    
        if mid is None and l:
            mid = -l[0][0]
        
        while right and right[-1] == 0:
            right.pop()

        res = left[:len(right)] + [mid] + right if mid is not None else left[:len(right)] + right
        
        if not res:
            return ""0""

        return ''.join([str(i) for i in res])",Medium,35,950,0.0,7,3.0,11.0,27.142857142857142,40.0,2.9571428571428573
1648.0,amount of time for binary tree to be infected,"class Solution:
    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
		### building the map, see for each node who it touches ###
        queue = [(root, None)]
        mapping = {}
        while (queue):
            curr, parent = queue.pop()
            touches = []
            if (curr.left):
                touches.append(curr.left.val)
                queue.append((curr.left, curr))
            if (curr.right):
                touches.append(curr.right.val)
                queue.append((curr.right, curr))
            if (parent):
                touches.append(parent.val)
            mapping[curr.val] = touches
        
		
		### do a simulation kinda ###
        time = 0
        current_wave = [start]
        next_wave = []
        seen = set()
        seen.add(start)
        
        while (current_wave):
            node_id = current_wave.pop()
            for touch in mapping[node_id]:
                if touch not in seen:
                    next_wave.append(touch)
                    seen.add(touch)
            
            if (len(current_wave) == 0):
                if (len(next_wave) == 0):
                    return time
                else:
                    time += 1
                    current_wave = next_wave
                    next_wave = []
        
        return 0",Medium,41,1330,2.0,8,3.0,10.0,32.4390243902439,41.0,2.4004878048780487
1649.0,find the k sum of an array,"class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        m = sum(x for x in nums if x > 0)
        pq = [(-m, 0)] 
        vals = sorted(abs(x) for x in nums)
        for _ in range(k): 
            x, i = heappop(pq)
            if i < len(vals): 
                heappush(pq, (x+vals[i], i+1))
                if i: heappush(pq, (x-vals[i-1]+vals[i], i+1))
        return -x",Hard,10,395,0.0,3,3.0,6.0,39.5,22.0,3.8850000000000007
1650.0,longest subsequence with limited sum,"class Solution:
    def answerQueries(self, nums: List[int], q: List[int]) -> List[int]:
        nums.sort()
        pref=[]
        pref.append(nums[0])
        for i in nums[1:]:
            pref.append(i+pref[-1])
        
        ans=[]
        for i in q:
            ans.append(bisect.bisect(pref, i))
        
        return ans",Easy,12,335,0.0,2,3.0,2.0,27.916666666666668,13.0,5.8875
1651.0,removing stars from a string,"class Solution:
#Time-Complexity: O(N^2)
#Space-Complexity:O(1)
#Space-Complexity:O(
    def removeStars(self, s: str) -> str:
        #Brute-Force approach: As long as star character appears in string input s, continously simulate!
        #while ""*"" in s:
            #iterate from left to right char by char until you hit star! then update s to subsequence!
            #for i in range(len(s)):
             #   cur_char = s[i]
             #   if(cur_char == '*'):
                    #reupdate s!
              #      s = s[:i-1] + s[i+1:]
               #     break
        
        #return s
        
        #optimized version: Simply traverse linearly using single pointer in linear time
        #by taking advantage of fact that the star char you see when you traverse from L to R is s.t. the last char
        #in built up string will be one char to be removed along with star char per operation!
        
        ans = """"
        
        for i in range(len(s)):
            cur_char = s[i]
            if(cur_char == '*'):
                #pop off last char!
                ans = ans[:len(ans)-1]
                continue
            else:
                ans += cur_char
        
        return ans",Medium,32,1213,17.0,0,3.0,6.0,37.90625,32.0,3.8884375
1652.0,minimum amount of time to collect garbage,"class Solution:
    #If I let n = travel.length and m = garbage.length...
    #Time-Complexity: O(travel.length + garbage.length*10 + 3*garbage.length) -> O(n + m)
    #Space-Complexity: O(3m + (n+1)) ->O(m + n)
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        
        #Approach: First, traverse through garbage array and identify the count as well as the index position of houses
        #each type of garbage is at!
        
        #Utilize 3 hashmaps: one for metal , one for glass , and one for paper!
        #key: index pos -> count: number of garbage at index pos house of that particular type!
        
        metal = {}
        paper = {}
        glass = {}
        
        #need to allocate another array that describes time cost to reach ith index house!
        travel_cost = []
        travel_cost.append(0)
        cur_cost = 0
        
        for e in travel:
            cur_cost += e
            travel_cost.append(cur_cost)
            
        for i in range(len(garbage)):
            for c in garbage[i]:
                if(c == 'M'):
                    if(i not in metal):
                        metal[i] = 1
                    else:
                        metal[i] += 1
                elif(c == 'P'):
                    if(i not in paper):
                        paper[i] = 1
                    else:
                        paper[i] += 1
                else:
                    if(i not in glass):
                        glass[i] = 1
                    else:
                        glass[i] += 1
        
        #once hashmaps are updated, handle 3 types of garbage collection!
        
        #1. Metal
        metal_cost = 0
        pre = 0
        metal_keys = sorted(metal.keys())
        for mk in metal_keys:
            metal_cost += metal[mk]
            metal_cost += (travel_cost[mk] - travel_cost[pre])
            pre = mk
        
        #2. Paper
        paper_cost = 0
        pre2 = 0
        paper_keys = sorted(paper.keys())
        for pk in paper_keys:
            paper_cost += paper[pk]
            paper_cost += (travel_cost[pk] - travel_cost[pre2])
            pre2 = pk
        
        #3. glass
        glass_cost = 0
        pre3 = 0
        glass_keys = sorted(glass.keys())
        for gk in glass_keys:
            glass_cost += glass[gk]
            glass_cost += (travel_cost[gk] - travel_cost[pre3])
            pre3 = gk
        
        return metal_cost + paper_cost + glass_cost",Medium,72,2499,12.0,6,3.0,16.0,34.708333333333336,73.0,-0.4837500000000005
1653.0,build a matrix with conditions,"class Solution:
    def buildMatrix(self, k: int, rowCond: List[List[int]], colCond: List[List[int]]) -> List[List[int]]:
        # topological sort:
        # For rows, in other words ""above"" should be put on the rows with index smaller than ""after""
        # so if we could form an k-length result array with the order restricted by rowCondition
        # then we know we should put the numbers to the rows accordingly 
        
        # For example, as for example 1,
        # if we get [3, 1, 2] as one of the topological sorted result array,
        # we know that 3 should be put in the first row (idx = 0), 1 in the second row (idx = 1), 2 in the third row(idx = 2)
        # so we get the row index for each number in [1, k]
        # We could get the col index similarily 
        
        def topo(cond):
            G = defaultdict(list)
            indegree = [0] * (k + 1)
            # build graph, above_edge -> below_edge, or left -> right
            for a, b in cond:
                G[a].append(b)
                indegree[b] += 1
                
            queue = deque([i for i in range(1, k + 1) if indegree[i] == 0])
            res = []
            while queue:
                cur = queue.popleft()
                res.append(cur)
                for nxt in G[cur]:
                    indegree[nxt] -= 1
                    if indegree[nxt] == 0:
                        queue.append(nxt)
            return res 
                
        rows, cols = topo(rowCond), topo(colCond)
        
        # can not form a solution with exact k value sorted in topological order
        if len(rows) != k or len(cols) != k:
            return []
        
        # build num -> idx mp for easier queries 
        mp1, mp2 = {}, {}
        for i, r in enumerate(rows):
            mp1[r] = i
        
        for i, c in enumerate(cols):
            mp2[c] = i
        
        res = [[0] * k for _ in range(k)]
        for num in range(1, k + 1):
            ri, ci = mp1[num], mp2[num]
            res[ri][ci] = num
        return res",Hard,50,2057,12.0,6,3.0,20.0,41.14,69.0,-0.6625999999999994
1654.0,find subarrays with equal sum,"class Solution:
    def findSubarrays(self, nums: List[int]) -> bool:
        subSum = 0
        p1 = 0
        count = defaultdict(int)
        
        for p2, num in enumerate(nums):
            subSum += num
            ln = p2 - p1 + 1
            if(ln < 2):
                continue
            elif(ln > 2):
                subSum -= nums[p1] 
                p1 += 1
            count[subSum] += 1
            if(count[subSum] == 2):
                return True
            
        return False",Easy,18,504,0.0,-1,3.0,4.0,28.0,23.0,5.06
1655.0,strictly palindromic number,"class Solution:
    def isStrictlyPalindromic(self, n: int) -> bool:
        return False",Medium,2,89,0.0,0,2.0,0.0,44.5,5.0,5.375
1656.0,maximum rows covered by columns,"class Solution:
    def maximumRows(self, mat: List[List[int]], cols: int) -> int:
        m, n = len(mat), len(mat[0])
        masks = []
        for i in range(m): 
            mask = reduce(xor, (1<<j for j in range(n) if mat[i][j]), 0)
            masks.append(mask)
        ans = 0 
        for x in range(1<<n): 
            if x.bit_count() <= cols: 
                ans = max(ans, sum(mask &amp; x == mask for mask in masks))
        return ans",Medium,11,452,0.0,3,3.0,6.0,41.09090909090909,29.0,3.041818181818182
1657.0,maximum number of robots within budget,"class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        ii = rsm = 0
        qq = deque()
        for i, (ct, rc) in enumerate(zip(chargeTimes, runningCosts)): 
            rsm += rc 
            while qq and qq[-1][0] <= ct: qq.pop()
            qq.append((ct, i))
            if chargeTimes[qq[0][1]] + (i - ii + 1) * rsm > budget: 
                if qq[0][1] == ii: qq.popleft()
                rsm -= runningCosts[ii]
                ii += 1
        return len(chargeTimes)-ii",Hard,12,547,0.0,4,3.0,4.0,45.583333333333336,29.0,2.5775
1659.0,number of ways to reach a position after exactly k steps,"class Solution:
    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:
        if abs(startPos - endPos) > k:
            return 0
        
        @cache
        def dp(currentPosition: int = startPos, stepsAvailable: int = k) -> int:
            if stepsAvailable == 0:
                return 1 if currentPosition == endPos else 0
                
            numWays = dp(currentPosition + 1, stepsAvailable - 1) + dp(currentPosition - 1, stepsAvailable - 1)
            return numWays % (10 ** 9 + 7)
        
        return dp()",Medium,13,562,0.0,-1,3.0,3.0,43.23076923076923,28.0,3.189230769230769
1660.0,longest nice subarray,"class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        last = -1
        ror = 0
        for first in range(n):
            if first > last:
                last = first
                ror = nums[first]
            else:
                ror = nums[first]
                for i in range(first + 1, last + 1):
                    ror = ror | nums[i]
            while last+1<=n-1 and (ror &amp; nums[last+1] == 0):
                ror = ror | nums[last+1]
                last = last + 1
            ans = max(ans, last - first + 1)
            # print((first, last), ror, ans)
        return ans",Medium,19,661,1.0,4,3.0,4.0,34.78947368421053,32.0,3.288947368421053
1661.0,meeting rooms iii,"class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        number_of_meetings_in_room = [0] * n
        room_is_available          = [0] * n
        meetings.sort()
        heap = []
        for meeting_start, meeting_end in meetings:
            meeting_length = meeting_end - meeting_start
            while heap and heap[0][0] <= meeting_start:
                end_time, room_number = heapq.heappop(heap)
                # MAKE SURE TO MAKE ROOM AVAILABLE AFTER!!
                room_is_available[room_number] = 0
            if len(heap) < n:
                for room_number, available in enumerate(room_is_available):
                    if available == 0:
                        number_of_meetings_in_room[room_number] += 1
                        room_is_available[room_number] = meeting_start + meeting_length
                        heapq.heappush(heap, (meeting_start + meeting_length, room_number))
                        break
            else:
                end_time, room_number = heapq.heappop(heap)
                heapq.heappush(heap, (end_time + meeting_length, room_number))
                number_of_meetings_in_room[room_number] += 1
        return -max((meetings, -index) for index, meetings in enumerate(number_of_meetings_in_room))[1]",Hard,23,1296,1.0,4,4.0,6.0,56.34782608695652,39.0,0.5886956521739108
1662.0,most frequent even element,"class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        freq = -1
        ans = -1
        for i in sorted(set(nums)):
            if i%2 == 0 and nums.count(i) > freq:
                freq = nums.count(i)
                ans = i
        return ans",Easy,8,272,0.0,2,3.0,2.0,34.0,15.0,5.14
1663.0,optimal partition of string,"class Solution:
    def partitionString(self, s: str) -> int:
        count=1
        word=""""
        for i in s:
            if i in word:
                count+=1
                word=i
            else:
                word+=i
        return count",Medium,10,250,0.0,2,3.0,2.0,25.0,13.0,6.15
1664.0,divide intervals into minimum number of groups,"class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        line = []
        for x, y in intervals: 
            line.append((x, 1))
            line.append((y+1, 0))
        ans = prefix = 0 
        for x, k in sorted(line): 
            if k: prefix += 1
            else: prefix -= 1
            ans = max(ans, prefix)
        return ans",Medium,11,366,0.0,3,3.0,3.0,33.27272727272727,20.0,4.645454545454546
1665.0,longest increasing subsequence ii,"class Solution:
    def lengthOfLIS(self, nums: List[int], k: int) -> int:
        """"""
        """"""
        ##############
        # Range Minimum Query using Segment Tree
        ##############
        def init(tree, value, k, left, right):
            if len(tree)<k+1:
                tree.extend([None] * (k+1-len(tree)))

            if right - left == 1:
                tree[k] = value
                return

            mid = (left + right)//2
            init(tree, value, 2*k, left, mid)
            init(tree, value, 2*k+1, mid, right)
            tree[k] = max(tree[2*k], tree[2*k+1])

        def update(tree, value, pos, k, left, right):
            if right - left == 1: # only 1 elements
                tree[k] = value
                return

            mid = (left + right)//2
            if pos<mid:
                update(tree, value, pos, 2*k, left, mid)
            else:
                update(tree, value, pos, 2*k+1, mid, right)
            tree[k] = max(tree[2*k], tree[2*k+1])

        def query(tree, l, r, k, left, right):
            if l>=r:
                return None
            elif l<=left and right<=r:
                return tree[k]

            mid = (left + right)//2
            v1 = query(tree, l, min(mid, r), 2*k, left, mid)
            v2 = query(tree, max(l, mid), r, 2*k+1, mid, right)
            v = [v for v in [v1, v2] if v is not None]
            ret = None if len(v) == 0 else max(v)
            return ret
        ##############
        
        n = len(nums)
        # print(nums, k)
        # print(len(nums), max(nums), k)

        segt = []
        sizet = max(nums) + 1
        # init(segt, float(""-inf""), 1, 0, sizet)
        segt = [float(""-inf"")] * (4 * sizet)
        
        dp = [1] * n
        update(segt, dp[0], nums[0], 1, 0, sizet)
        
        for i in range(1, n):
            dpj = query(segt, nums[i]-k, nums[i], 1, 0, sizet)
            if dpj is None:
                dp[i] = 1
            else:
                dp[i] = max(dpj + 1, 1)
            update(segt, dp[i], nums[i], 1, 0, sizet)
            pass
        
        ans = max(dp)
        # print(""ans:"", ans)
        # print(""="" * 20)
        return ans
    
# print = lambda *a, **aa: ()",Hard,72,2229,11.0,3,3.0,11.0,30.95833333333333,134.0,-6.106250000000003
1666.0,count days spent together,"class Solution:
    def countDaysTogether(self, aa: str, la: str, ab: str, lb: str) -> int:

        aa = aa.split('-')
        la = la.split('-')
        ab = ab.split('-')
        lb = lb.split('-')
        
        start1 = date(2013,int(aa[0]),int(aa[1]))
        end1 = date(2013,int(la[0]),int(la[1]))
        start2 = date(2013,int(ab[0]),int(ab[1]))
        end2 = date(2013,int(lb[0]),int(lb[1]))
        
        overlaps = start1 <= end2 and end1 >= start2
        if not overlaps:
            return 0
        return abs(max(start1, start2)-min(end1, end2)).days +1",Easy,16,577,0.0,0,2.0,1.0,36.0625,35.0,3.1343749999999995
1667.0,maximum matching of players with trainers,"class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort(reverse=True)
        trainers.sort(reverse=True)
        tot = 0
        while trainers and players:
            if trainers[-1] >= players[-1]:
                tot += 1
                players.pop()
            trainers.pop()
        
        return tot",Medium,11,379,0.0,2,3.0,2.0,34.45454545454545,15.0,5.09909090909091
1668.0,smallest subarrays with maximum bitwise or,"class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n=len(nums)
        lastVal=[0 for i in range(32)]
        ans=[0 for i in range(n)]
        for i in range(n-1,-1,-1):
            maxVal=0
            for j in range(32):
                if nums[i]&amp;(1<<j):
                    lastVal[31-j]=0
                else:
                    lastVal[31-j]=lastVal[31-j]+1 if i<n-1 else -float('inf')
                maxVal=max(maxVal,lastVal[31-j])
            ans[i]=max(ans[i],maxVal)+1
        return ans",Medium,14,542,0.0,3,3.0,6.0,38.71428571428572,24.0,3.755714285714285
1669.0,minimum money required before transactions,"class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        ans = val = 0 
        for cost, cashback in transactions: 
            ans += max(0, cost - cashback)
            val = max(val, min(cost, cashback))
        return ans + val",Hard,6,265,0.0,1,3.0,1.0,44.16666666666666,14.0,4.385000000000001
1670.0,smallest even multiple,"class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        return n if n % 2 == 0 else 2 * n",Easy,2,108,0.0,0,2.0,1.0,54.0,8.0,4.220000000000001
1671.0,length of the longest alphabetical continuous substring,"class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        cnt = 1
        res = 0
        
        for i in range(1, len(s)):
            if ord(s[i]) - ord(s[i-1]) == 1:
                cnt += 1
                res = max(res, cnt)
            else:
                cnt = 1
                    
        return max(res, cnt)",Medium,12,346,0.0,2,3.0,2.0,28.83333333333333,19.0,5.205
1672.0,reverse odd levels of binary tree,"class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        
        def reverseLevel(nodes: List[Optional[TreeNode]]) -> None:
            for i in range(len(nodes) // 2):
                nodes[i].val, nodes[~i].val = nodes[~i].val, nodes[i].val
        
        levels = defaultdict(list)
        nodeQueue = [(root, 0)]
        while nodeQueue:
            node, level = nodeQueue.pop()
            if level % 2 == 1:
                levels[level].append(node)
            for child in [node.left, node.right]:
                if child is not None:
                    nodeQueue.append((child, level + 1))
        
        for level in levels.values():
            reverseLevel(level)
            
        return root",Medium,20,764,0.0,6,3.0,6.0,38.2,27.0,3.322
1673.0,sum of prefix scores of strings,"class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        cnter = defaultdict(int)
        res = []
        
        #Adding all prefixes to counter
        for word in words:
            for idx in range(1, len(word) + 1):
                cnter[word[:idx]] += 1
        
        #Adding up occurrences
        for word in words:
            cnt = 0
            for idx in range(1, len(word) + 1):
                cnt += cnter[word[:idx]]
                    
            res.append(cnt)
                    
        return res",Hard,18,555,2.0,4,3.0,4.0,30.83333333333333,18.0,5.085
1674.0,sort the people,"class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        return [n for _, n in sorted((-h, n) for h, n in zip(heights, names))]",Easy,2,171,0.0,0,2.0,2.0,85.5,11.0,1.0850000000000009
1675.0,longest subarray with maximum bitwise and,"class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        mx=max(nums)
        ans=0
        v=0
        for i in range(len(nums)):
            if nums[i]==mx:
                v+=1
                ans=max(ans,v)
            else:
                v=0
        return ans",Medium,11,289,0.0,2,3.0,2.0,26.27272727272728,18.0,5.535454545454545
1676.0,find all good indices,"class Solution:
    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        n=len(nums)
        left=[False for i in range(n)]
        right=[False for i in range(n)]
        ls,rs=-1,n
        for i in range(1,n):
            if i>=k:
                if i-ls>k:
                    left[i]=True
            if nums[i]>nums[i-1]:
                ls=i-1
        for j in range(n-2,-1,-1):
            if j<n-k:
                if rs-j>k:
                    right[j]=True
            if nums[j]>nums[j+1]:
                rs=j+1
        ans=[]
        for i in range(n):
            if left[i] and right[i]:
                ans.append(i)
        return ans",Medium,22,668,0.0,10,3.0,12.0,30.363636363636363,38.0,2.6872727272727275
1677.0,number of good paths,"class Solution:    
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
        n = len(vals)
        
        nodes = {}
        for i in range(n):
            nodes[vals[i]] = nodes.get(vals[i], set([]))
            nodes[vals[i]].add(i)
        # print(nodes)
        
        adj = [set([]) for _ in range(n)]
        for ai, bi in edges:
            adj[ai].add(bi)
            adj[bi].add(ai)
        # print(adj)
        
        def bfs(s, chk): 
            ret = [s]
            q = [s]
            chk[s] = True
            while len(q)>0:
                u = q.pop(0)
                for v in adj[u]:
                    if chk[v]==False and vals[s]>=vals[v]:
                        q.append(v)
                        chk[v] = True
                        if vals[v]==vals[s]:
                            ret.append(v)
            return ret
        
        keys = sorted(nodes.keys(), key = lambda x: x)

        chk = [False] * n
        ans = len(vals)
        for k in keys:
            qq = nodes[k]

            print(""++ "", k, len(qq))
            sys.stdout.flush()
            
            while len(qq)>0:
                v = qq.pop()
                ret = bfs(v, chk)
                nr = len(ret)
                ans = ans + (nr * (nr-1)) // 2
                for t in ret:
                    qq.discard(t)
            
        return ans

print = lambda *a, **aa: ()",Hard,50,1424,2.0,8,3.0,10.0,28.48,56.0,1.2568
1678.0,remove letter to equalize frequency,"class Solution:
    def equalFrequency(self, word: str) -> bool:
        
        c = Counter(word)
        
        m = c.values()
        
        for l in c:
            c[l] -= 1
            
            s = set(c.values())
            if 0 in s:
                s.remove(0)
            if  len(s) == 1:
                return True
            
            c[l] += 1
        
        return False",Easy,18,400,0.0,2,3.0,3.0,22.22222222222222,16.0,6.1
1679.0,bitwise xor of all pairings,"class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        n=len(nums1)
        m=len(nums2)
        ans=0
        if(m%2==0):
            if(n%2==0):
                return 0
            else:
                ans=nums2[0]
                for i in range(1,m):
                    ans^=nums2[i]
                return ans
        else:
            if(n%2==0):
                ans=nums1[0]
                for i in range(1,n):
                    ans^=nums1[i]
                return ans
            else:
                ans=nums1[0]
                for i in range(1,n):
                    ans^=nums1[i]
                for i in range(m):
                    ans^=nums2[i]
                return ans",Medium,25,733,0.0,1,4.0,7.0,29.32,39.0,3.1612
1680.0,number of pairs satisfying inequality,"class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        ans = 0
        n = len(nums1)
        nums = [nums1[i] - nums2[i] for i in range(n)]
        vis = []
        for i in range(n - 1, -1, -1):
            if not vis:
                vis.append(nums[i] + diff)
            else:
                pos = bisect.bisect_left(vis, nums[i])
                ans += len(vis) - pos
                bisect.insort(vis, nums[i] + diff)
        return ans",Hard,13,496,0.0,2,3.0,6.0,38.15384615384615,22.0,4.066153846153847
1681.0,number of common factors,"class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        GCD = gcd(a, b)
        
        commonFactors = 1
        for i in range(2, floor(GCD) + 1):
            if GCD % i == 0:
                commonFactors += 1
                
        return commonFactors",Easy,9,279,0.0,2,3.0,2.0,31.0,17.0,5.21
1682.0,maximum sum of an hourglass,"class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        m = len(grid); n = len(grid[0])
        
        def hourglassSum(i: int, j: int) -> int:
            return sum(grid[i - 1][j - 1:j + 2]) + grid[i][j] + sum(grid[i + 1][j - 1:j + 2])
        
        maxSum = 0
        for i, j in product(range(1, m - 1), range(1, n - 1)):
            maxSum = max(maxSum, hourglassSum(i, j))
            
        return maxSum",Medium,11,438,0.0,0,3.0,1.0,39.81818181818182,23.0,3.936363636363637
1683.0,minimize xor,"class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:        
        bits2 = bin(num2)[2:].count(""1"")
        bin1 = bin(num1)[2:]

        if len(bin1) <= bits2:
            return (1 << bits2) - 1
        
        ans = 0
        for i in range(len(bin1)):
            if bin1[i] == ""1"":
                ans |= 1 << (len(bin1) - i - 1)
                bits2 -= 1
            if bits2 == 0:
                return ans
        
        for i in range(len(bin1)):
            if bin1[~i] == ""0"":
                ans |= 1 << i
                bits2 -= 1
            if bits2 == 0:
                return ans",Medium,21,624,0.0,5,3.0,7.0,29.714285714285715,43.0,2.5457142857142863
1684.0,maximum deletions on a string,"class Solution:
    def deleteString(self, s: str) -> int:
        n = len(s)

        if len(set(s)) == 1:
            return n
        
        @cache
        def dp(i: int = 0) -> int:
            if i == n - 1:
                return 1
            maxOperations = 0
            for l in range(1, (n - i) // 2 + 1):
                if s[i : i + l] == s[i + l:i + 2 * l]:
                    maxOperations = max(maxOperations, dp(i + l))
            return maxOperations + 1
        
        return dp()",Hard,17,505,0.0,1,3.0,4.0,29.705882352941178,29.0,4.186470588235294
1686.0,find the original array of prefix xor,"class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        ans = [pref[0]]
        mx = pref[0]
        for i in range(1,len(pref)):
            a = pref[i]^mx 
            ans.append(a)
            mx = mx^a
        return ans",Medium,8,247,0.0,1,3.0,1.0,30.875,11.0,5.8812500000000005
1687.0,using a robot to print the lexicographically smallest string,"class Solution:
    def robotWithString(self, s: str) -> str:
        t= []
        res = []
		#counter would tell if there is any smaller character on the right
        counter = [0]*26
        for char in s:
            counter[ord(char)-97] += 1
        for idx, char in enumerate(s):
            t.append(char)
            counter[ord(char)-97] -= 1

            while len(t) != 0:
                    value = ord(t[-1])-97
                    ifc = False
                    for i in range(value):
                        if counter[i] > 0:
                            ifc = True
                            break
                    if ifc:
                        break
                    res.append(t[-1])
                    t.pop()

        return """".join(res)",Medium,24,771,1.0,4,4.0,10.0,32.125,22.0,4.468749999999999
1688.0,paths in matrix whose sum is divisible by k,"class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        import copy
        hm = defaultdict(list)
        
        m, n = len(grid), len(grid[0])
        
        def dfs(r, c):
            if r >= len(grid) or c >= len(grid[0]):
                return []
            if r == m - 1 and c == n - 1:
                hm[(r, c)] = {grid[r][c] : 1}
                return
            if (r, c) not in hm:
                dfs(r + 1, c)
                dfs(r, c + 1)
                it = defaultdict(int)
                if (r + 1, c) in hm:
                    for i in hm[(r + 1, c)]:
                        it[(grid[r][c] + i) % k] += hm[(r + 1, c)][i]
                if (r, c + 1) in hm:
                    for i in hm[(r, c + 1)]:
                        it[(grid[r][c] + i) % k] += hm[(r, c + 1)][i]
                hm[(r, c)] = it
            return
        dfs(0, 0)
        res = 0
        for i in hm[(0, 0)]:
            if i % k == 0:
                res += hm[(0, 0)][i]
                res %= (10 ** 9 + 7)
        return res",Hard,31,1071,0.0,6,4.0,9.0,34.54838709677419,58.0,0.4906451612903222
1689.0,number of valid clock times,"class Solution:
    def countTime(self, time: str) -> int:
        if '?' not in time: return 1
        hh,mm=time.split(':')
        tH,th=hh
        tM,tm=mm
        answ=0
        d='0123456789'
        for H in d:
            for h in d:
                for M in d:
                    for m in d:
                        Hh=int(H+h)
                        Mm=int(M+m)
                        if Hh<24 and Mm<60:
                            if H!=tH!='?' or h!=th!='?' or M!=tM!='?' or m!=tm!='?': continue
                            answ+=1
                            
        return answ",Easy,18,596,0.0,5,4.0,7.0,33.111111111111114,34.0,3.079999999999999
1690.0,range product queries of powers,"class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        def min_arr(x):
            k = bin(x)[2:]
            k = k[::-1]
            ans = []
            for i in range(0, len(k)):
                if (k[i] == '1'):
                    ans.append(2**i)
            return ans
        nums = min_arr(n)
        prod = [1]
        for i in range(len(nums)):
            k = (prod[-1]*nums[i])
            prod.append(k)
        res = []
        for i in range(len(queries)):
            b = prod[queries[i][1]+1]
            a = prod[queries[i][0]]
            res.append((b//a))
            res[i] = res[i]%(10**9 + 7)
        return res",Medium,21,682,0.0,3,3.0,4.0,32.476190476190474,29.0,3.8171428571428576
1691.0,minimize maximum of array,"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        n = len(nums)
        pr = [0]
        for i in range(n):
            pr.append(pr[-1] + nums[i])
            
        dp = [0] * n
        dp[0] = nums[0]
        
        for i in range(1, n):
            if nums[i] < dp[i - 1]:
                dp[i] = dp[i - 1]
            else:
                dp[i] = max(dp[i - 1], math.ceil(pr[i + 1] / (i + 1)))
        return dp[-1]",Medium,15,457,0.0,3,3.0,3.0,30.466666666666665,18.0,5.098000000000001
1692.0,create components with same value,"class Solution:
    def getFactors(self, x):
        factors = []
        for i in range(1, int(sqrt(x)) + 1):
            if x % i != 0: continue
            factors.append(i)
            if x // i != i: factors.append(x // i)
        return factors

    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        graph = defaultdict(list)
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        self.cntRemainZero = 0
        def dfs(u, p, sumPerComponent): # return remain of the subtree with root `u`
            remain = nums[u]
            for v in graph[u]:
                if v == p: continue
                remain += dfs(v, u, sumPerComponent)
                
            remain %= sumPerComponent
            if remain == 0:
                self.cntRemainZero += 1
                
            return remain
        
        def isGood(sumPerComponent, expectedNumOfComponents):
            self.cntRemainZero = 0
            dfs(0, -1, sumPerComponent)
            return self.cntRemainZero == expectedNumOfComponents
        
        sumAllNodes, maxNum = sum(nums), max(nums)
        for sumPerComponent in sorted(self.getFactors(sumAllNodes)):
            if sumPerComponent < maxNum: continue  # at least maxNum
            expectedNumOfComponents = sumAllNodes // sumPerComponent
            if isGood(sumPerComponent, expectedNumOfComponents):
                return expectedNumOfComponents - 1 # Need to cut `numOfComponent - 1` edges to make `numOfComponent` connected component
            
        return 0",Hard,41,1616,3.0,2,3.0,10.0,39.41463414634146,56.0,0.6726829268292676
1693.0,largest positive integer that exists with its negative,"class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums.sort()
        i = len(nums) - 1
        
        while i >= 0:
            tmp = nums[i]
            if -tmp in nums:
                return tmp
            else:
                i -= 1

        return -1",Easy,12,282,0.0,1,3.0,2.0,23.5,13.0,6.345
1694.0,count number of distinct integers after reverse operations,"class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        tmp = []
        
        for num in nums:
            tmp.append(int(str(num)[::-1]))
        
        return len(set(nums+tmp))",Medium,7,214,0.0,1,2.0,1.0,30.571428571428573,9.0,6.168571428571429
1695.0,sum of number and its reverse,"class Solution:
    def sumOfNumberAndReverse(self, total: int) -> bool:
        for num in range(total // 2, total + 1):
            if num + int(str(num)[::-1]) == total:
                return True
            
        return False",Medium,6,234,0.0,1,3.0,2.0,39.0,13.0,4.950000000000001
1696.0,count subarrays with fixed bounds,"class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        i =  0 # left index
        j = 0  # right index
        ans = 0
        
        minn = [] # store the indices of minK in a window which have no element less than minK and greater than maxK 
        maxx = [] # store the indices of maxK in a window which have no element less than minK and greater than maxK
        
        while j<len(nums):
            if nums[j]==minK:
                minn.append(j)
            if nums[j]==maxK:
                maxx.append(j)

            if nums[j]<minK or nums[j]>maxK: # conflict
                a,b = 0,0 # indices of minn and maxx array
                while a<len(minn) and b<len(maxx):
                    m = max(minn[a],maxx[b])  # max index which should keep in subbarray necessarily
                    ans+=j-m                  # add how many subarray can create such that they start from nums[i]
                    if nums[i]==minK:
                        a+=1
                    if nums[i]==maxK:
                        b+=1
                    i+=1 
                # there is a conflict on indix j so clear minn and maxx array    
                minn.clear()
                maxx.clear()
                
                i = j+1 # set left pointer to j+1 (searching for new window which can start from j+1)
                
            j+=1        
                
        # after reaching j on last indix check if there is a window which is already created       
        a,b = 0,0
        while a<len(minn) and b<len(maxx):
            m = max(minn[a],maxx[b])
            ans+=j-m

            if nums[i]==minK:
                a+=1
            if nums[i]==maxK:
                b+=1
             
            i+=1        
                        
        return ans",Hard,46,1832,11.0,10,4.0,12.0,39.82608695652174,69.0,-0.8843478260869571
1697.0,determine if two events have conflict,"class Solution:
    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        if event1[1][0:2]==event2[0][0:2]:
            if event1[1][3:5]>=event2[0][3:5]:
                return True
            else:
                return False
        else:
            if event1[1][0:2]<event2[0][0:2] or event2[1][0:2]<event1[0][0:2]:
                return False
            elif event1[1][0:2]>event2[0][0:2]:
                return True",Easy,11,452,0.0,1,3.0,4.0,41.09090909090909,31.0,2.961818181818182
1698.0,number of subarrays with gcd equal to k,"class Solution:
    def subarrayGCD(self, nums: List[int], k: int) -> int:
        def gcd(n1, n2):
            if n2==0:
                return n1
            return gcd(n2, n1%n2)
        
        ans = 0
        n = len(nums)
        for i in range(n):
            curr_gcd = 0
            for j in range(i, n):
                curr_gcd = gcd(curr_gcd, nums[j])
                if  curr_gcd == k:
                    ans += 1
        
        return ans",Medium,16,456,0.0,2,3.0,4.0,28.5,27.0,4.435
1699.0,minimum cost to make array equal,"class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        nums, cost = zip(*sorted(zip(nums, cost)))
        total = sum(cost)
        prefix = 0 
        for i, x in enumerate(cost): 
            prefix += x
            if prefix > total//2: break 
        return sum(c*abs(x-nums[i]) for x, c in zip(nums, cost))",Hard,8,344,0.0,1,3.0,3.0,43.0,19.0,3.990000000000001
1700.0,minimum number of operations to make arrays similar,"class Solution:
    def makeSimilar(self, nums: List[int], target: List[int]) -> int:
        ne = sorted(x for x in nums if not x&amp;1)
        no = sorted(x for x in nums if x&amp;1)
        te = sorted(x for x in target if not x&amp;1)
        to = sorted(x for x in target if x&amp;1)
        return (sum(abs(x-y) for x, y in zip(ne, te)) + sum(abs(x-y) for x, y in zip(no, to)))//4",Hard,6,387,0.0,0,2.0,10.0,64.5,15.0,2.575
1701.0,odd string difference,"class Solution:
    def oddString(self, words: List[str]) -> str:
        a=""abcdefghijklmnopqrstuvwxyz""
        l=[]
        for i in range(0,len(words)):
            w=words[i]
            ans=[]
            for j in range(1,len(w)):
                s=a.index(w[j])-a.index(w[j-1])
                ans.append(s)

            l.append(ans)
        for i in l:
            if l.count(i)==1:
                return words[l.index(i)]",Easy,14,431,0.0,4,3.0,4.0,30.785714285714285,19.0,4.909285714285715
1702.0,words within two edits of dictionary,"class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        
        n = len(queries[0])
        ans = []
        
        for i in range(len(queries)):
            for j in range(len(dictionary)):
                count = 0
                for k in range(n):
                    if(dictionary[j][k] != queries[i][k]):
                        count += 1
                    if(count > 2):
                        break
                if(count <= 2):
                    ans.append(queries[i])
                    break
        return ans",Medium,17,585,0.0,1,4.0,6.0,34.411764705882355,21.0,4.502941176470588
1703.0,destroy sequential targets,"class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:
        hmap=defaultdict(list)
        for i in nums:
            if i%space in hmap:
                occ,val=hmap[i%space]
                hmap[i%space]=[occ+1,min(val,i)]
            else:
                hmap[i%space]=[1,i]
        value=-float('inf')
        ans=-1
        for i,j in hmap.items():
            if j[0]>value:
                value=j[0]
                ans=j[1]
            if j[0]==value:
                ans=min(ans,j[1])
        return ans",Medium,17,544,0.0,5,3.0,5.0,32.0,32.0,3.4400000000000004
1704.0,next greater element iv,"class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        st1,st2=[],[]
        heapify(st2)
        ans=[-1 for i in range(len(nums))]
        for i in range(len(nums)):
            while st2 and nums[-st2[0]]<nums[i]:
                ans[-heappop(st2)]=nums[i]
            while st1 and nums[st1[-1]]<nums[i]:
                heappush(st2,-st1.pop())
            st1.append(i)
        return ans",Hard,11,429,0.0,3,3.0,5.0,39.0,16.0,4.530000000000001
1705.0,average value of even numbers that are divisible by three,"class Solution:
    def averageValue(self, nums: List[int]) -> int:
        sum, count = 0,0
        for n in nums:
            if n % 3 == 0 and n % 2 == 0:
                sum += n
                count += 1
        if count == 0: return 0
        return int(sum/count)",Easy,8,271,0.0,2,3.0,3.0,33.875,22.0,4.45125
1706.0,most popular video creator,"class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
        total_views = {}
        first_max_view = {}
        
        for i in range(len(creators)):
            total_views[creators[i]] = total_views.get(creators[i], 0)+views[i]
            
            if creators[i] in first_max_view:
                if views[i] > views[first_max_view[creators[i]]]: #update value with highest view id
                    first_max_view[creators[i]] = i
                elif views[i] == views[first_max_view[creators[i]]]: #if views of some video are equal update with lexicographically smallest id.
                    if ids[i] < ids[first_max_view[creators[i]]]:
                        first_max_view[creators[i]] = i
            else:
                first_max_view[creators[i]] = i
        
        max_views = max(total_views.values())
        ans = []
        
        for name in total_views:
            if total_views[name] == max_views: #select most popular video creators
                ans.append([name, ids[first_max_view[name]]])
                
        return ans",Medium,24,1145,3.0,7,3.0,8.0,47.708333333333336,35.0,1.7262500000000005
1707.0,minimum addition to make integer beautiful,"class Solution:
    def makeIntegerBeautiful(self, n: int, target: int) -> int:
        
		#function to get sum of digits
        def sumofc(num):
            s = 0
            while num != 0:
                s += num % 10
                num = int(num/10)
            return s
        
        sumc = sumofc(n)
        ans = 0
        tmpn = n
        multp = 1
		#keep making last digit zero till sum of digits is less than target
        while sumc > target:
            lastn = tmpn % 10
            tmpn = int(tmpn/10) + 1
            ans = ans + multp * (10 - lastn)
            sumc = sumofc(tmpn)
            multp = multp * 10
         
        return ans",Medium,23,664,2.0,1,3.0,3.0,28.869565217391305,24.0,4.841739130434783
1708.0,height of binary tree after subtree removal queries,"class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        depth = {}
        height = {0 : 0}
        
        def fn(node, d): 
            if not node: return 0 
            depth[node.val] = d
            height[node.val] = 1 + max(fn(node.left, d+1), fn(node.right, d+1))
            return height[node.val]
        
        h = fn(root, 0)
        level = [[0, 0] for _ in range(h)]
        for k, v in depth.items(): 
            if height[k] >= height[level[v][0]]: level[v] = [k, level[v][0]]
            elif height[k] > height[level[v][1]]: level[v][1] = k
        ans = []
        for q in queries: 
            d = depth[q]
            if q == level[d][0]: ans.append(h-1-height[q]+height[level[d][1]])
            else: ans.append(h-1)
        return ans",Hard,21,819,0.0,4,3.0,7.0,39.0,40.0,2.0700000000000003
1709.0,apply operations to an array,"class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        ans = []
        for i, x in enumerate(nums): 
            if i+1 < len(nums) and nums[i] == nums[i+1]: 
                nums[i] *= 2
                nums[i+1] = 0 
            if nums[i]: ans.append(nums[i])
        return ans + [0]*(len(nums)-len(ans))",Easy,8,339,0.0,3,3.0,3.0,42.375,16.0,4.22625
1710.0,maximum sum of distinct subarrays with length k,"class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        left, right = 0,0
        max_sum = 0
        n = len(nums)
        seen = {}
        current_sum = 0
        while right<n:
            seen[nums[right]] = seen.get(nums[right], 0)+1
            current_sum += nums[right]
            if right-left+1 == k:
                if len(seen) == k:
                    max_sum = max(max_sum, current_sum)
                if seen[nums[left]]>1:
                    seen[nums[left]]-=1
                else:
                    del seen[nums[left]]
                current_sum-=nums[left]
                left+=1
            right+=1
        
        return max_sum",Medium,21,696,0.0,4,4.0,4.0,33.142857142857146,36.0,2.937142857142856
1711.0,total cost to hire k workers,"class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        n = len(costs)
        first = []
        last = []
        res = 0
        l = 0
        r = len(costs) - 1
        for i in range(candidates):
            heapq.heappush(first, costs[l])
            heapq.heappush(last, costs[r])
            l += 1
            r -= 1
            if l + 1 > r:
                break
        for i in range(k):
            if not last or (first and first[0] <= last[0]):
                res += heapq.heappop(first)
                if l <= r:
                    heapq.heappush(first, costs[l])
                    l += 1
            elif not first or (last and last[0] < first[0]):
                res += heapq.heappop(last)
                if r >= l:
                    heapq.heappush(last, costs[r])
                    r -= 1
        return res

class Solution {
    public long totalCost(int[] costs, int k, int candidates) {
        int n  = costs.length;
        Queue<Integer> first = new PriorityQueue<>();
        Queue<Integer> last = new PriorityQueue<>();
        long res = 0;
        int l = 0;
        int r = n - 1;
        for (int i = 0; i < candidates; i ++) {
            first.offer(costs[l]);
            last.offer(costs[r]);
            l ++;
            r --;
            if (l + 1 > r) {
                break;
            }
        }
        for (int i = 0; i < k; i ++) {
            if (last.isEmpty() || (!first.isEmpty() &amp;&amp; first.peek() <= last.peek())) {
                res += (long)first.poll();
                if (l <= r) {
                    first.offer(costs[l]);
                    l ++;
                }
            } else if (first.isEmpty() || (!last.isEmpty() &amp;&amp; last.peek() < first.peek())) {
                res += (long)last.poll();
                if (r >= l) {
                    last.offer(costs[r]);
                    r --;
                }
            }
        }
        return res;
    }
}",Medium,62,1999,0.0,4,3.0,14.0,32.24193548387097,70.0,-0.3217741935483875
1712.0,minimum total distance traveled,"class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        
        @cache
        def dfs(i, j, k):
            if j == 0: #no robot available
                return 0
            if i == 0: #no factory available
                return float('inf')
            if k == 0: #the ith factory has 0 spot to use
                if i == 1: #if there'ls only one factory left
                    return float('inf')
                return dfs(i - 1, j, factory[i - 2][1]) #since the ith factory has no spot, we have to not use it

            
            result1 = dfs(i - 1, j, factory[i - 2][1]) if i >= 2 else float('inf') #condition 1: don't use the ith factory
            result2 = dfs(i, j - 1, k - 1) + abs(robot[j - 1] - factory[i - 1][0])#condition 2: use the ith factory
            result = min(result1, result2)
            return result
                
        
        
        m, n = len(robot), len(factory)
        robot.sort()
        factory.sort()
        result = dfs(n, m, factory[n - 1][1])
        return result",Hard,26,1084,7.0,0,3.0,6.0,41.69230769230769,47.0,1.6476923076923082
1713.0,number of distinct averages,"class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        
        ans = set()
        nums.sort()
        queue = deque(nums)
        
        while queue:
            low = queue.popleft()
            high = queue.pop()
            ans.add((low+high)/2)
        
        return len(ans)",Easy,12,310,0.0,1,3.0,1.0,25.83333333333333,10.0,6.4350000000000005
1714.0,count ways to build good strings,"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        dp = [0]*(high+1)
        dp[zero] += 1
        dp[one] += 1
        mod = (10**9)+7
        for i in range(min(zero,one)+1,high+1):
            if i-zero>=0:
                dp[i]+=dp[i-zero]
            if i-one>=0:
                dp[i]+=dp[i-one]
        s = 0
        for i in range(low,high+1):
            s+=dp[i]
        return s%mod",Medium,14,447,0.0,4,3.0,4.0,31.928571428571427,30.0,3.706428571428572
1715.0,most profitable path in a tree,"class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        graph = defaultdict(list)
        
        for edge in edges:
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])
        
        def bob_dfs(curr_node, prev_node, count):
            if curr_node == 0:
                return count
            if prev_node != None and len(graph[curr_node]) == 1 and curr_node != 0:
                return -1
            
            for node in graph[curr_node]:
                if node == prev_node:
                    continue
                res = bob_dfs(node, curr_node, count + 1)
                if res != -1:
                    if count < (res + 1) // 2:
                        amount[curr_node] = 0
                    if res % 2 == 0 and res // 2 == count:
                        amount[curr_node] /= 2
                    return res
            return -1  
        
        bob_dfs(bob, None, 0)
        leafs_res = []
        
        def sum_dfs(curr_node, curr_sum, prev_node):
            if len(graph[curr_node]) == 1 and curr_node != 0:
                leafs_res.append(curr_sum + amount[curr_node])
            
            for node in graph[curr_node]:
                if node == prev_node:
                    continue
                sum_dfs(node, curr_sum + amount[curr_node], curr_node)
        
        sum_dfs(0, 0, None)
        
        res = max(leafs_res)
        if res % 1 == 0:
            return int(res)
        else:
            return res",Medium,44,1565,0.0,5,4.0,12.0,35.56818181818182,71.0,-0.8411363636363642
1716.0,split message based on limit,"class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        best = math.inf
        def check(x):
            avail = 0
            start = 1
            while start <= x:
                next_start = start * 10
                suffix = f""<{start}/{x}>""
                if len(suffix) > limit:
                    return False
                avail += (min(next_start - 1, x) - start + 1) * (limit - len(suffix))
                start = next_start
            last_suffix = f""<{x}/{x}>""
            return avail >= n >= avail - (limit - len(last_suffix))
        
        for n_part in range(1, n + 1):
            if check(n_part):
                break
        else:
            return []
        
        ans = []
        start = 0
        for i in range(1, n_part + 1):
            suffix = f""<{i}/{n_part}>""
            next_start = start + limit - len(suffix)
            ans.append(message[start:next_start] + suffix)
            start = next_start
        return ans",Hard,30,1030,0.0,1,3.0,5.0,34.333333333333336,45.0,2.170000000000001
1717.0,convert the temperature,"class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        return [celsius + 273.15, celsius * 1.80 + 32.00]",Easy,2,138,0.0,0,2.0,0.0,69.0,6.0,3.0699999999999994
1718.0,number of subarrays with lcm equal to k,"class Solution:
    def subarrayLCM(self, nums: List[int], k: int) -> int:
        num_subarray = 0
        n = len(nums)
        for i in range(n):
            lcm = nums[i]
            for j in range(i, n):
                lcm = math.lcm(lcm, nums[j])
                if lcm > k:
                    break
                else:
                    num_subarray += (lcm == k)
        return num_subarray",Medium,12,404,0.0,2,4.0,3.0,33.666666666666664,22.0,4.409999999999999
1719.0,minimum number of operations to sort a binary tree by level,"class Solution:
    def countswaps(self, arr):
        count = 0
        temp = sorted(arr)
        h = {}
        
        for i in range(len(arr)):
            h[arr[i]] = i
        
        for i in range(len(arr)):
            if arr[i] != temp[i]:
                count += 1
                
                # swap to correct place
                j = h[temp[i]]
                
                h[arr[i]], h[arr[j]] = j, i
                arr[i], arr[j] = arr[j], arr[i]
        
        return count
        
    
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        q = collections.deque()
        q.append(root)
        ans = 0
        
        while q:
            size = len(q)
            level = []
            for _ in range(size):
                temp = q.popleft()
                level.append(temp.val)
                
                if temp.left:
                    q.append(temp.left)
                if temp.right:
                    q.append(temp.right)

            ans += self.countswaps(level)
            
        return ans",Medium,41,1074,1.0,6,3.0,7.0,26.195121951219512,33.0,3.8424390243902433
1720.0,maximum number of non overlapping palindrome substrings,"class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n = len(s)
        vals = [1]*n
        for i in range(2*n-1): 
            lo, hi = i//2, (i+1)//2
            while 0 <= lo <= hi < n and s[lo] == s[hi]: 
                if vals[lo] < k: vals[lo] = max(vals[lo], hi-lo+1)
                lo -= 1
                hi += 1
        dp = [0]*(n+1)
        for i in range(n-1, -1, -1): 
            dp[i] = dp[i+1]
            if vals[i] >= k: dp[i] = max(dp[i], 1+dp[i+vals[i]])
        return dp[0]",Hard,14,523,0.0,5,3.0,5.0,37.35714285714285,38.0,2.357857142857143
1721.0,number of unequal triplets in array,"class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:
                        res += 1
        return res



class Solution {
    public int unequalTriplets(int[] nums) {
        int n = nums.length;
        int res = 0;
        for (int i = 0; i < n - 2; i ++) {
            for (int j = i + 1; j < n - 1; j ++) {
                for (int k = j + 1; k < n; k ++) {
                    if (nums[i] != nums[j] &amp;&amp; nums[i] != nums[k] &amp;&amp; nums[j] != nums[k]) {
                        res ++;
                    }
                }
            }
        }
        return res;
    }
}",Easy,28,854,0.0,3,3.0,8.0,30.5,28.0,4.095000000000001
1723.0,minimum fuel cost to report to the capital,"class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        d = defaultdict(list)
        q = deque([])
        c = Counter()
        c_acc = Counter()
        
        for x, y in roads:
            d[x].append(y)
            d[y].append(x)
            c[x] += 1
            c[y] += 1        
        
        for k, v in c.items():
            if v == 1 and k!=0:
                q.append(k)
                c_acc[k] += 1
                        
        res = 0        
        while q:
            node = q.popleft()
            p = c_acc[node]                                    
            res += ceil(p/seats)            
            for nei in d[node]:
                c_acc[nei] += p
                c[nei] -= 1
                
                if c[nei] == 1 and nei != 0:
                    c_acc[nei] += 1
                    q.append(nei)
        return res",Medium,30,910,0.0,6,4.0,6.0,30.33333333333333,37.0,2.97
1724.0,number of beautiful partitions,"class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        s=list(s)
        l0=len(s)
        prime={'2', '3', '5', '7'}
        for i in range(l0):
            s[i]=s[i] in prime
        if not s[0]:
            return 0
        if s[-1]:
            return 0
        p=10**9+7
        stops=[0]
        for i in range(l0-1):
            if (not s[i]) and s[i+1]:
                stops.append(i+1)
        l1=len(stops)

        def bp(i, k):
            if l0-stops[i]<k*minLength:
                return 0
            if k==1:
                return 1                    
            i1=i+1
            while i1<l1 and stops[i1]<stops[i]+minLength:
                i1+=1
            return sm[i1]%p

        for j in range(1, k+1):
            table=[bp(i, j) for i in range(l1)]
            sm=[]
            tmp=0
            for t in table:
                sm.append(tmp)
                tmp+=t
            sm.append(tmp)
            for i in range(l1+1):
                sm[i]=tmp-sm[i]
        
        return table[0]",Hard,39,1066,0.0,6,3.0,13.0,27.33333333333333,47.0,2.3
,Calculate factorial,"def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n-1)",Intermediate,4,79,,1,,,,,0.8
,Calculate factorial,"def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n-1)",Intermediate,4,79,,1,,,,,0.8
