Unnamed: 0,Answer,num_of_lines,code_length,comments,cyclomatic_complexity,num_of_indents,loop_count,line_length,identifiers,readability
0.0,"class Solution {
 public:
  vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < nums.size(); ++i) {
      if (const auto it = numToIndex.find(target - nums[i]);
          it != cend(numToIndex))
        return {it->second, i};
      numToIndex[nums[i]] = i;
    }

    throw;
  }
};",8,347,0.0,1.0,4.0,2.0,43.375,8.0,4.99625
1.0,"class Solution {
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* curr = &dummy;
    int carry = 0;

    while (l1 || l2 || carry) {
      if (l1 != nullptr) {
        carry += l1->val;
        l1 = l1->next;
      }
      if (l2 != nullptr) {
        carry += l2->val;
        l2 = l2->next;
      }
      curr->next = new ListNode(carry % 10);
      carry /= 10;
      curr = curr->next;
    }

    return dummy.next;
  }
};",12,479,0.0,3.0,5.0,3.0,39.91666666666666,2.0,5.7275
2.0,"class Solution {
 public:
  int lengthOfLongestSubstring(string s) {
    int ans = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      ++count[s[r]];
      while (count[s[r]] > 1)
        --count[s[l++]];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",9,303,0.0,2.0,3.0,2.0,33.666666666666664,6.0,6.07
3.0,"class Solution {
 public:
  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    const int n1 = nums1.size();
    const int n2 = nums2.size();
    if (n1 > n2)
      return findMedianSortedArrays(nums2, nums1);

    int l = 0;
    int r = n1;

    while (l <= r) {
      const int partition1 = (l + r) / 2;
      const int partition2 = (n1 + n2 + 1) / 2 - partition1;
      const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1[partition1 - 1];
      const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2[partition2 - 1];
      const int minRight1 = partition1 == n1 ? INT_MAX : nums1[partition1];
      const int minRight2 = partition2 == n2 ? INT_MAX : nums2[partition2];
      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1)
        return (n1 + n2) % 2 == 0
                   ? (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5
                   : max(maxLeft1, maxLeft2);
      else if (maxLeft1 > minRight2)
        r = partition1 - 1;
      else
        l = partition1 + 1;
    }

    throw;
  }
};",16,1046,0.0,4.0,3.0,4.0,65.375,22.0,1.49625
4.0,"class Solution {
 public:
  string longestPalindrome(string s) {
    if (s.empty())
      return """";

    // [start, end] indices of the longest palindrome in s
    pair<int, int> indices{0, 0};

    for (int i = 0; i < s.length(); ++i) {
      const auto [l1, r1] = extend(s, i, i);
      if (r1 - l1 > indices.second - indices.first)
        indices = {l1, r1};
      if (i + 1 < s.length() && s[i] == s[i + 1]) {
        const auto [l2, r2] = extend(s, i, i + 1);
        if (r2 - l2 > indices.second - indices.first)
          indices = {l2, r2};
      }
    }

    return s.substr(indices.first, indices.second - indices.first + 1);
  }

 private:
  // Returns [start, end] indices of the longest palindrome extended from
  // s[i..j]
  pair<int, int> extend(const string& s, int i, int j) {
    for (; i >= 0 && j < s.length(); --i, ++j)
      if (s[i] != s[j])
        break;
    return {i + 1, j - 1};
  }
};",14,916,3.0,4.0,9.0,7.0,65.42857142857143,14.0,2.0514285714285707
5.0,"class Solution {
 public:
  string convert(string s, int numRows) {
    string ans;
    vector<vector<char>> rows(numRows);
    int k = 0;
    int direction = (numRows == 1) - 1;

    for (const char c : s) {
      rows[k].push_back(c);
      if (k == 0 || k == numRows - 1)
        direction *= -1;
      k += direction;
    }

    for (const vector<char>& row : rows)
      for (const char c : row)
        ans += c;

    return ans;
  }
};",10,442,0.0,4.0,3.0,4.0,44.2,14.0,4.202
6.0,"class Solution {
 public:
  int reverse(int x) {
    long ans = 0;

    while (x) {
      ans = ans * 10 + x % 10;
      x /= 10;
    }

    return (ans < INT_MIN || ans > INT_MAX) ? 0 : ans;
  }
};",5,198,0.0,1.0,3.0,1.0,39.6,3.0,5.896000000000001
7.0,"class Solution {
 public:
  int myAtoi(string s) {
    trim(s);
    if (s.empty())
      return 0;

    const int sign = s[0] == '-' ? -1 : 1;
    if (s[0] == '+' || s[0] == '-')
      s = s.substr(1);

    long num = 0;

    for (const char c : s) {
      if (!isdigit(c))
        break;
      num = num * 10 + (c - '0');
      if (sign * num < INT_MIN)
        return INT_MIN;
      if (sign * num > INT_MAX)
        return INT_MAX;
    }

    return sign * num;
  }

 private:
  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};",13,595,0.0,2.0,4.0,6.0,45.76923076923077,9.0,4.620769230769231
8.0,"class Solution {
 public:
  bool isPalindrome(int x) {
    if (x < 0)
      return false;

    long reversed = 0;
    int y = x;

    while (y) {
      reversed = reversed * 10 + y % 10;
      y /= 10;
    }

    return reversed == x;
  }
};",7,241,0.0,1.0,3.0,2.0,34.42857142857143,4.0,6.261428571428571
9.0,"class Solution {
 public:
  bool isMatch(string s, string p) {
    const int m = s.length();
    const int n = p.length();
    // dp[i][j] := true if s[0..i) matches p[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    auto isMatch = [&](int i, int j) -> bool {
      return j >= 0 && p[j] == '.' || s[i] == p[j];
    };

    for (int j = 0; j < p.length(); ++j)
      if (p[j] == '*' && dp[0][j - 1])
        dp[0][j + 1] = true;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (p[j] == '*') {
          const bool noRepeat = dp[i + 1][j - 1];  // Min index of '*' is 1
          const bool doRepeat = isMatch(i, j - 1) && dp[i][j + 1];
          dp[i + 1][j + 1] = noRepeat || doRepeat;
        } else if (isMatch(i, j)) {
          dp[i + 1][j + 1] = dp[i][j];
        }

    return dp[m][n];
  }
};",19,870,2.0,7.0,5.0,7.0,45.78947368421053,20.0,3.238947368421053
10.0,"class Solution {
 public:
  int maxArea(vector<int>& height) {
    int ans = 0;
    int l = 0;
    int r = height.size() - 1;

    while (l < r) {
      const int minHeight = min(height[l], height[r]);
      ans = max(ans, minHeight * (r - l));
      if (height[l] < height[r])
        ++l;
      else
        --r;
    }

    return ans;
  }
};",9,344,0.0,3.0,3.0,2.0,38.22222222222222,8.0,5.4
11.0,"class Solution {
 public:
  string intToRoman(int num) {
    const vector<pair<int, string>> valueSymbols{
        {1000, ""M""}, {900, ""CM""}, {500, ""D""}, {400, ""CD""}, {100, ""C""},
        {90, ""XC""},  {50, ""L""},   {40, ""XL""}, {10, ""X""},   {9, ""IX""},
        {5, ""V""},    {4, ""IV""},   {1, ""I""}};
    string ans;

    for (const auto& [value, symbol] : valueSymbols) {
      if (num == 0)
        break;
      while (num >= value) {
        num -= value;
        ans += symbol;
      }
    }

    return ans;
  }
};",7,511,0.0,2.0,18.0,3.0,73.0,8.0,1.4300000000000015
12.0,"class Solution {
 public:
  int romanToInt(string s) {
    int ans = 0;
    vector<int> roman(128);

    roman['I'] = 1;
    roman['V'] = 5;
    roman['X'] = 10;
    roman['L'] = 50;
    roman['C'] = 100;
    roman['D'] = 500;
    roman['M'] = 1000;

    for (int i = 0; i + 1 < s.length(); ++i)
      if (roman[s[i]] < roman[s[i + 1]])
        ans -= roman[s[i]];
      else
        ans += roman[s[i]];

    return ans + roman[s.back()];
  }
};",15,445,0.0,3.0,2.0,2.0,29.666666666666668,6.0,6.43
13.0,"class Solution {
 public:
  string longestCommonPrefix(vector<string>& strs) {
    if (strs.empty())
      return """";

    for (int i = 0; i < strs[0].length(); ++i)
      for (int j = 1; j < strs.size(); ++j)
        if (i == strs[j].length() || strs[j][i] != strs[0][i])
          return strs[0].substr(0, i);

    return strs[0];
  }
};",8,339,0.0,2.0,2.0,4.0,42.375,5.0,5.44625
14.0,"class Solution {
 public:
  vector<vector<int>> threeSum(vector<int>& nums) {
    if (nums.size() < 3)
      return {};

    vector<vector<int>> ans;

    sort(begin(nums), end(nums));

    for (int i = 0; i + 2 < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      // Choose nums[i] as the first num in the triplet,
      // and search the remaining nums in [i + 1, n - 1]
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r) {
        const int sum = nums[i] + nums[l] + nums[r];
        if (sum == 0) {
          ans.push_back({nums[i], nums[l++], nums[r--]});
          while (l < r && nums[l] == nums[l - 1])
            ++l;
          while (l < r && nums[r] == nums[r + 1])
            --r;
        } else if (sum < 0) {
          ++l;
        } else {
          --r;
        }
      }
    }

    return ans;
  }
};",16,876,2.0,8.0,9.0,8.0,54.75,9.0,3.2325
15.0,"class Solution {
 public:
  int threeSumClosest(vector<int>& nums, int target) {
    int ans = nums[0] + nums[1] + nums[2];

    sort(begin(nums), end(nums));

    for (int i = 0; i + 2 < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      // Choose nums[i] as the first num in the triplet,
      // and search the remaining nums in [i + 1, n - 1]
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r) {
        const int sum = nums[i] + nums[l] + nums[r];
        if (sum == target)
          return sum;
        if (abs(sum - target) < abs(ans - target))
          ans = sum;
        if (sum < target)
          ++l;
        else
          --r;
      }
    }

    return ans;
  }
};",14,737,2.0,5.0,4.0,6.0,52.642857142857146,10.0,3.802142857142857
16.0,"class Solution {
 public:
  vector<string> letterCombinations(string digits) {
    if (digits.empty())
      return {};

    vector<string> ans;

    dfs(digits, 0, """", ans);
    return ans;
  }

 private:
  const vector<string> digitToLetters{"""",    """",    ""abc"",  ""def"", ""ghi"",
                                      ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};

  void dfs(const string& digits, int i, string&& path, vector<string>& ans) {
    if (i == digits.length()) {
      ans.push_back(path);
      return;
    }

    for (const char letter : digitToLetters[digits[i] - '0']) {
      path.push_back(letter);
      dfs(digits, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",11,687,0.0,1.0,7.0,3.0,62.45454545454545,14.0,2.49909090909091
17.0,"class Solution {
 public:
  vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> ans;
    vector<int> path;
    sort(begin(nums), end(nums));
    nSum(nums, 4, target, 0, nums.size() - 1, path, ans);
    return ans;
  }

 private:
  // In [l, r], find n numbers add up to the target
  void nSum(const vector<int>& nums, long n, long target, int l, int r,
            vector<int>& path, vector<vector<int>>& ans) {
    if (r - l + 1 < n || target < nums[l] * n || target > nums[r] * n)
      return;
    if (n == 2) {
      // Similar to the sub procedure in 15. 3Sum
      while (l < r) {
        const int sum = nums[l] + nums[r];
        if (sum == target) {
          path.push_back(nums[l]);
          path.push_back(nums[r]);
          ans.push_back(path);
          path.pop_back();
          path.pop_back();
          ++l;
          --r;
          while (l < r && nums[l] == nums[l - 1])
            ++l;
          while (l < r && nums[r] == nums[r + 1])
            --r;
        } else if (sum < target) {
          ++l;
        } else {
          --r;
        }
      }
      return;
    }

    for (int i = l; i <= r; ++i) {
      if (i > l && nums[i] == nums[i - 1])
        continue;
      path.push_back(nums[i]);
      nSum(nums, n - 1, target - nums[i], i + 1, r, path, ans);
      path.pop_back();
    }
  }
};",26,1359,2.0,8.0,9.0,9.0,52.26923076923077,16.0,2.755769230769232
18.0,"class Solution {
 public:
  ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (n--)
      fast = fast->next;
    if (fast == nullptr)
      return head->next;

    while (fast->next) {
      slow = slow->next;
      fast = fast->next;
    }
    slow->next = slow->next->next;

    return head;
  }
};",9,367,0.0,2.0,3.0,3.0,40.77777777777778,2.0,5.83
19.0,"class Solution {
 public:
  bool isValid(string s) {
    stack<char> stack;

    for (const char c : s)
      if (c == '(')
        stack.push(')');
      else if (c == '{')
        stack.push('}');
      else if (c == '[')
        stack.push(']');
      else if (stack.empty() || pop(stack) != c)
        return false;

    return stack.empty();
  }

 private:
  int pop(stack<char>& stack) {
    const int c = stack.top();
    stack.pop();
    return c;
  }
};",10,462,0.0,6.0,4.0,5.0,46.2,10.0,4.241999999999999
20.0,"class Solution {
 public:
  ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2)
      return list1 ? list1 : list2;
    if (list1->val > list2->val)
      swap(list1, list2);
    list1->next = mergeTwoLists(list1->next, list2);
    return list1;
  }
};",5,286,0.0,1.0,2.0,2.0,57.2,1.0,4.572000000000001
21.0,"class Solution {
 public:
  vector<string> generateParenthesis(int n) {
    vector<string> ans;
    dfs(n, n, """", ans);
    return ans;
  }

 private:
  void dfs(int l, int r, string&& path, vector<string>& ans) {
    if (l == 0 && r == 0) {
      ans.push_back(path);
      return;
    }

    if (l > 0) {
      path.push_back('(');
      dfs(l - 1, r, move(path), ans);
      path.pop_back();
    }
    if (l < r) {
      path.push_back(')');
      dfs(l, r - 1, move(path), ans);
      path.pop_back();
    }
  }
};",12,518,0.0,2.0,6.0,3.0,43.16666666666666,9.0,4.734999999999999
22.0,"class Solution {
 public:
  ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode dummy(0);
    ListNode* curr = &dummy;
    auto compare = [](ListNode* a, ListNode* b) { return a->val > b->val; };
    priority_queue<ListNode*, vector<ListNode*>, decltype(compare)> minHeap(
        compare);

    for (ListNode* list : lists)
      if (list != nullptr)
        minHeap.push(list);

    while (!minHeap.empty()) {
      ListNode* minNode = minHeap.top();
      minHeap.pop();
      if (minNode->next)
        minHeap.push(minNode->next);
      curr->next = minNode;
      curr = curr->next;
    }

    return dummy.next;
  }
};",13,636,0.0,3.0,4.0,4.0,48.92307692307692,1.0,5.0769230769230775
23.0,"class Solution {
 public:
  ListNode* swapPairs(ListNode* head) {
    const int length = getLength(head);
    ListNode dummy(0, head);
    ListNode* prev = &dummy;
    ListNode* curr = head;

    for (int i = 0; i < length / 2; ++i) {
      ListNode* next = curr->next;
      curr->next = next->next;
      next->next = prev->next;
      prev->next = next;
      prev = curr;
      curr = curr->next;
    }

    return dummy.next;
  }

 private:
  int getLength(ListNode* head) {
    int length = 0;
    for (ListNode* curr = head; curr; curr = curr->next)
      ++length;
    return length;
  }
};",19,598,0.0,1.0,4.0,2.0,31.473684210526315,6.0,6.267368421052632
24.0,"class Solution {
 public:
  ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr)
      return nullptr;

    ListNode* tail = head;

    for (int i = 0; i < k; ++i) {
      if (tail == nullptr)  // Less than k nodes, do nothing
        return head;
      tail = tail->next;
    }

    ListNode* newHead = reverse(head, tail);
    head->next = reverseKGroup(tail, k);
    return newHead;
  }

 private:
  // Reverses [head, tail)
  ListNode* reverse(ListNode* head, ListNode* tail) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr != tail) {
      ListNode* next = curr->next;
      curr->next = prev;
      prev = curr;
      curr = next;
    }

    return prev;
  }
};",17,716,2.0,1.0,5.0,4.0,42.11764705882353,3.0,5.629411764705883
25.0,"class Solution {
 public:
  int removeDuplicates(vector<int>& nums) {
    int i = 0;

    for (const int num : nums)
      if (i < 1 || num > nums[i - 1])
        nums[i++] = num;

    return i;
  }
};",4,201,0.0,2.0,2.0,2.0,50.25,6.0,4.637499999999999
26.0,"class Solution {
 public:
  int removeElement(vector<int>& nums, int val) {
    int i = 0;

    for (const int num : nums)
      if (num != val)
        nums[i++] = num;

    return i;
  }
};",4,191,0.0,2.0,2.0,2.0,47.75,7.0,4.7625
27.0,"class Solution {
 public:
  int strStr(string haystack, string needle) {
    const int m = haystack.length();
    const int n = needle.length();

    for (int i = 0; i < m - n + 1; i++)
      if (haystack.substr(i, n) == needle)
        return i;

    return -1;
  }
};",7,269,0.0,1.0,2.0,2.0,38.42857142857143,9.0,5.461428571428572
28.0,"class Solution {
 public:
  int divide(int dividend, int divisor) {
    // -2^{31} / -1 = 2^31 -> overflow so return 2^31 - 1
    if (dividend == INT_MIN && divisor == -1)
      return INT_MAX;

    const int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;
    long ans = 0;
    long dvd = labs(dividend);
    long dvs = labs(divisor);

    while (dvd >= dvs) {
      long k = 1;
      while (k * 2 * dvs <= dvd)
        k *= 2;
      dvd -= k * dvs;
      ans += k;
    }

    return sign * ans;
  }
};",11,499,1.0,1.0,4.0,3.0,45.36363636363637,6.0,5.057272727272727
29.0,"class Solution {
 public:
  vector<int> findSubstring(string s, vector<string>& words) {
    if (s.empty() || words.empty())
      return {};

    const int k = words.size();
    const int n = words[0].length();
    vector<int> ans;
    unordered_map<string, int> count;

    for (const string& word : words)
      ++count[word];

    for (int i = 0; i < s.length() - k * n + 1; ++i) {
      unordered_map<string, int> seen;
      int j;
      for (j = 0; j < k; ++j) {
        const string& word = s.substr(i + j * n, n);
        if (++seen[word] > count[word])
          break;
      }
      if (j == k)
        ans.push_back(i);
    }

    return ans;
  }
};",17,661,0.0,4.0,5.0,6.0,38.88235294117647,19.0,4.060588235294118
30.0,"class Solution {
 public:
  void nextPermutation(vector<int>& nums) {
    const int n = nums.size();

    // From back to front, find the first num < nums[i + 1]
    int i;
    for (i = n - 2; i >= 0; --i)
      if (nums[i] < nums[i + 1])
        break;

    // From back to front, find the first num > nums[i], swap it with nums[i]
    if (i >= 0)
      for (int j = n - 1; j > i; --j)
        if (nums[j] > nums[i]) {
          swap(nums[i], nums[j]);
          break;
        }

    // Reverse nums[i + 1..n - 1]
    reverse(nums, i + 1, n - 1);
  }

 private:
  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};",12,672,3.0,5.0,4.0,6.0,56.0,11.0,3.4399999999999995
31.0,"class Solution {
 public:
  int longestValidParentheses(string s) {
    const string s2 = "")"" + s;
    // dp[i] := Length of longest valid parentheses substring of s2[1..i]
    vector<int> dp(s2.length());

    for (int i = 1; i < s2.length(); ++i)
      if (s2[i] == ')' && s2[i - dp[i - 1] - 1] == '(')
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;

    return *max_element(begin(dp), end(dp));
  }
};",7,412,1.0,2.0,2.0,2.0,58.85714285714285,7.0,3.802857142857144
32.0,"class Solution {
 public:
  int search(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return m;
      if (nums[l] <= nums[m]) {  // nums[l..m] are sorted
        if (nums[l] <= target && target < nums[m])
          r = m - 1;
        else
          l = m + 1;
      } else {  // nums[m..n - 1] are sorted
        if (nums[m] < target && target <= nums[r])
          l = m + 1;
        else
          r = m - 1;
      }
    }

    return -1;
  }
};",10,569,2.0,7.0,5.0,5.0,56.9,8.0,3.439000000000001
33.0,"class Solution {
 public:
  vector<int> searchRange(vector<int>& nums, int target) {
    const int l = lower_bound(begin(nums), end(nums), target) - begin(nums);
    if (l == nums.size() || nums[l] != target)
      return {-1, -1};
    const int r = upper_bound(begin(nums), end(nums), target) - begin(nums) - 1;
    return {l, r};
  }
};",5,338,0.0,0.0,4.0,1.0,67.6,8.0,2.8760000000000003
34.0,"class Solution {
 public:
  int searchInsert(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size();

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return m;
      if (nums[m] < target)
        l = m + 1;
      else
        r = m;
    }

    return l;
  }
};",8,319,0.0,3.0,3.0,3.0,39.875,8.0,5.251250000000001
35.0,"class Solution {
 public:
  bool isValidSudoku(vector<vector<char>>& board) {
    unordered_set<string> seen;

    for (int i = 0; i < 9; ++i)
      for (int j = 0; j < 9; ++j) {
        if (board[i][j] == '.')
          continue;
        const string c(1, board[i][j]);
        if (!seen.insert(c + ""@row"" + to_string(i)).second ||
            !seen.insert(c + ""@col"" + to_string(j)).second ||
            !seen.insert(c + ""@box"" + to_string(i / 3) + to_string(j / 3))
                 .second)
          return false;
      }

    return true;
  }
};",10,552,0.0,2.0,3.0,4.0,55.2,8.0,3.932
36.0,"class Solution {
 public:
  void solveSudoku(vector<vector<char>>& board) {
    solve(board, 0);
  }

 private:
  bool solve(vector<vector<char>>& board, int s) {
    if (s == 81)
      return true;

    const int i = s / 9;
    const int j = s % 9;

    if (board[i][j] != '.')
      return solve(board, s + 1);

    for (char c = '1'; c <= '9'; ++c)
      if (isValid(board, i, j, c)) {
        board[i][j] = c;
        if (solve(board, s + 1))
          return true;
        board[i][j] = '.';
      }

    return false;
  }

  bool isValid(vector<vector<char>>& board, int row, int col, char c) {
    for (int i = 0; i < 9; ++i)
      if (board[i][col] == c || board[row][i] == c ||
          board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)
        return false;
    return true;
  }
};",16,800,0.0,2.0,5.0,7.0,50.0,17.0,3.38
37.0,"class Solution {
 public:
  string countAndSay(int n) {
    string ans = ""1"";

    while (--n) {
      string next;
      for (int i = 0; i < ans.length(); ++i) {
        int count = 1;
        while (i + 1 < ans.length() && ans[i] == ans[i + 1]) {
          ++count;
          ++i;
        }
        next += to_string(count) + ans[i];
      }
      ans = move(next);
    }

    return ans;
  }
};",11,397,0.0,3.0,5.0,3.0,36.09090909090909,7.0,5.571818181818181
38.0,"class Solution {
 public:
  vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    vector<vector<int>> ans;
    sort(begin(candidates), end(candidates));
    dfs(candidates, 0, target, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& A, int s, int target, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (target < 0)
      return;
    if (target == 0) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i < A.size(); ++i) {
      path.push_back(A[i]);
      dfs(A, i, target - A[i], move(path), ans);
      path.pop_back();
    }
  }
};",13,618,0.0,1.0,6.0,3.0,47.53846153846154,13.0,4.001538461538462
39.0,"class Solution {
 public:
  vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
    vector<vector<int>> ans;
    sort(begin(candidates), end(candidates));
    dfs(candidates, 0, target, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& A, int s, int target, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (target < 0)
      return;
    if (target == 0) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i < A.size(); ++i) {
      if (i > s && A[i] == A[i - 1])
        continue;
      path.push_back(A[i]);
      dfs(A, i + 1, target - A[i], move(path), ans);
      path.pop_back();
    }
  }
};",14,678,0.0,1.0,6.0,4.0,48.42857142857143,13.0,3.921428571428572
40.0,"class Solution {
 public:
  int firstMissingPositive(vector<int>& nums) {
    const int n = nums.size();

    // Correct slot:
    // nums[i] = i + 1
    // nums[i] - 1 = i
    // nums[nums[i] - 1] = nums[i]
    for (int i = 0; i < n; ++i)
      while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])
        swap(nums[i], nums[nums[i] - 1]);

    for (int i = 0; i < n; ++i)
      if (nums[i] != i + 1)
        return i + 1;

    return n + 1;
  }
};",9,464,4.0,3.0,2.0,4.0,51.55555555555556,7.0,4.5200000000000005
41.0,"class Solution {
 public:
  int trap(vector<int>& height) {
    const int n = height.size();
    int ans = 0;
    vector<int> l(n);  // l[i] := max(height[0..i])
    vector<int> r(n);  // r[i] := max(height[i..n))

    for (int i = 0; i < n; ++i)
      l[i] = i == 0 ? height[i] : max(height[i], l[i - 1]);

    for (int i = n - 1; i >= 0; --i)
      r[i] = i == n - 1 ? height[i] : max(height[i], r[i + 1]);

    for (int i = 0; i < n; ++i)
      ans += min(l[i], r[i]) - height[i];

    return ans;
  }
};",15,507,2.0,3.0,2.0,3.0,33.8,11.0,5.638000000000001
42.0,"class Solution {
 public:
  string multiply(string num1, string num2) {
    string s(num1.length() + num2.length(), '0');

    for (int i = num1.length() - 1; i >= 0; --i)
      for (int j = num2.length() - 1; j >= 0; --j) {
        const int mult = (num1[i] - '0') * (num2[j] - '0');
        const int sum = mult + (s[i + j + 1] - '0');
        s[i + j] += sum / 10;
        s[i + j + 1] = '0' + sum % 10;
      }

    const int i = s.find_first_not_of('0');
    return i == -1 ? ""0"" : s.substr(i);
  }
};",12,506,0.0,2.0,3.0,2.0,42.16666666666666,13.0,4.605
43.0,"class Solution {
 public:
  bool isMatch(string s, string p) {
    const int m = s.length();
    const int n = p.length();
    // dp[i][j] := true if s[0..i) matches p[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    auto isMatch = [&](int i, int j) -> bool {
      return j >= 0 && p[j] == '?' || s[i] == p[j];
    };

    for (int j = 0; j < p.length(); ++j)
      if (p[j] == '*')
        dp[0][j + 1] = dp[0][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (p[j] == '*') {
          const bool matchEmpty = dp[i + 1][j];
          const bool matchSome = dp[i][j + 1];
          dp[i + 1][j + 1] = matchEmpty || matchSome;
        } else if (isMatch(i, j)) {
          dp[i + 1][j + 1] = dp[i][j];
        }

    return dp[m][n];
  }
};",19,813,1.0,7.0,5.0,7.0,42.78947368421053,20.0,3.468947368421053
44.0,"class Solution {
 public:
  int jump(vector<int>& nums) {
    int ans = 0;
    int end = 0;
    int farthest = 0;

    // Implicit BFS
    for (int i = 0; i < nums.size() - 1; ++i) {
      farthest = max(farthest, i + nums[i]);
      if (farthest >= nums.size() - 1) {
        ++ans;
        break;
      }
      if (i == end) {    // Visited all the items on the current level
        ++ans;           // Increment the level
        end = farthest;  // Make the queue size for the next level
      }
    }

    return ans;
  }
};",12,530,4.0,3.0,5.0,4.0,44.16666666666666,7.0,5.005000000000001
45.0,"class Solution {
 public:
  vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> ans;

    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() == nums.size()) {
      ans.push_back(path);
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};",14,629,0.0,1.0,6.0,3.0,44.92857142857143,12.0,4.336428571428571
46.0,"class Solution {
 public:
  vector<vector<int>> permuteUnique(vector<int>& nums) {
    vector<vector<int>> ans;
    sort(begin(nums), end(nums));
    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() == nums.size()) {
      ans.push_back(path);
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};",16,745,0.0,1.0,6.0,4.0,46.5625,12.0,4.189375
47.0,"class Solution {
 public:
  void rotate(vector<vector<int>>& matrix) {
    reverse(begin(matrix), end(matrix));
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = i + 1; j < matrix.size(); ++j)
        swap(matrix[i][j], matrix[j][i]);
  }
};",7,254,0.0,3.0,2.0,2.0,36.285714285714285,5.0,5.934285714285714
48.0,"class Solution {
 public:
  vector<vector<string>> groupAnagrams(vector<string>& strs) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> keyToAnagrams;

    for (const string& str : strs) {
      string key = str;
      sort(begin(key), end(key));
      keyToAnagrams[key].push_back(str);
    }

    for (const auto& [_, anagrams] : keyToAnagrams)
      ans.push_back(anagrams);

    return ans;
  }
};",8,428,0.0,2.0,3.0,2.0,53.5,10.0,3.8850000000000007
49.0,"class Solution {
 public:
  double myPow(double x, long n) {
    if (n == 0)
      return 1;
    if (n < 0)
      return 1 / myPow(x, -n);
    if (n & 1)
      return x * myPow(x, n - 1);
    return myPow(x * x, n / 2);
  }
};",5,226,0.0,0.0,2.0,3.0,45.2,3.0,5.512
50.0,"class Solution {
 public:
  vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> ans;
    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),
        vector<string>(n, string(n, '.')), ans);
    return ans;
  }

 private:
  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,
           vector<bool>&& diag2, vector<string>&& board,
           vector<vector<string>>& ans) {
    if (i == n) {
      ans.push_back(board);
      return;
    }

    for (int j = 0; j < n; ++j) {
      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])
        continue;
      board[i][j] = 'Q';
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;
      dfs(n, i + 1, move(cols), move(diag1), move(diag2), move(board), ans);
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;
      board[i][j] = '.';
    }
  }
};",14,871,0.0,1.0,5.0,3.0,62.21428571428572,18.0,2.2407142857142865
51.0,"class Solution {
 public:
  int totalNQueens(int n) {
    int ans = 0;
    dfs(n, 0, vector<bool>(n), vector<bool>(2 * n - 1), vector<bool>(2 * n - 1),
        ans);
    return ans;
  }

 private:
  void dfs(int n, int i, vector<bool>&& cols, vector<bool>&& diag1,
           vector<bool>&& diag2, int& ans) {
    if (i == n) {
      ++ans;
      return;
    }

    for (int j = 0; j < n; ++j) {
      if (cols[j] || diag1[i + j] || diag2[j - i + n - 1])
        continue;
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = true;
      dfs(n, i + 1, move(cols), move(diag1), move(diag2), ans);
      cols[j] = diag1[i + j] = diag2[j - i + n - 1] = false;
    }
  }
};",12,670,0.0,1.0,5.0,3.0,55.833333333333336,15.0,3.115
52.0,"class Solution {
 public:
  int maxSubArray(vector<int>& nums) {
    // dp[i] := max sum subarray ending w/ i
    vector<int> dp(nums.size());

    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); ++i)
      dp[i] = max(nums[i], dp[i - 1] + nums[i]);

    return *max_element(begin(dp), end(dp));
  }
};",7,308,1.0,1.0,2.0,1.0,44.0,5.0,5.4
53.0,"class Solution {
 public:
  vector<int> spiralOrder(vector<vector<int>>& matrix) {
    if (matrix.empty())
      return {};

    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<int> ans;
    int r1 = 0;
    int c1 = 0;
    int r2 = m - 1;
    int c2 = n - 1;

    // Repeatedly add matrix[r1..r2][c1..c2] to ans
    while (ans.size() < m * n) {
      for (int j = c1; j <= c2 && ans.size() < m * n; ++j)
        ans.push_back(matrix[r1][j]);
      for (int i = r1 + 1; i <= r2 - 1 && ans.size() < m * n; ++i)
        ans.push_back(matrix[i][c2]);
      for (int j = c2; j >= c1 && ans.size() < m * n; --j)
        ans.push_back(matrix[r2][j]);
      for (int i = r2 - 1; i >= r1 + 1 && ans.size() < m * n; --i)
        ans.push_back(matrix[i][c1]);
      ++r1, ++c1, --r2, --c2;
    }

    return ans;
  }
};",23,836,1.0,5.0,4.0,6.0,36.34782608695652,16.0,4.6286956521739135
54.0,"class Solution {
 public:
  bool canJump(vector<int>& nums) {
    int i = 0;

    for (int reach = 0; i < nums.size() && i <= reach; ++i)
      reach = max(reach, i + nums[i]);

    return i == nums.size();
  }
};",6,213,0.0,1.0,2.0,1.0,35.5,5.0,6.125
55.0,"class Solution {
 public:
  vector<vector<int>> merge(vector<vector<int>>& intervals) {
    vector<vector<int>> ans;

    sort(begin(intervals), end(intervals));

    for (const vector<int>& interval : intervals)
      if (ans.empty() || ans.back()[1] < interval[0])
        ans.push_back(interval);
      else
        ans.back()[1] = max(ans.back()[1], interval[1]);

    return ans;
  }
};",6,391,0.0,3.0,2.0,2.0,65.16666666666667,6.0,3.2350000000000003
56.0,"class Solution {
 public:
  vector<vector<int>> insert(vector<vector<int>>& intervals,
                             vector<int>& newInterval) {
    const int n = intervals.size();
    vector<vector<int>> ans;
    int i = 0;

    while (i < n && intervals[i][1] < newInterval[0])
      ans.push_back(intervals[i++]);

    // Merge overlapping intervals
    while (i < n && intervals[i][0] <= newInterval[1]) {
      newInterval[0] = min(newInterval[0], intervals[i][0]);
      newInterval[1] = max(newInterval[1], intervals[i][1]);
      ++i;
    }

    ans.push_back(newInterval);

    while (i < n)
      ans.push_back(intervals[i++]);

    return ans;
  }
};",11,660,1.0,3.0,3.0,3.0,60.0,8.0,3.4800000000000013
57.0,"class Solution {
 public:
  int lengthOfLastWord(string s) {
    int i = s.length() - 1;

    while (i >= 0 && s[i] == ' ')
      --i;
    const int lastIndex = i;
    while (i >= 0 && s[i] != ' ')
      --i;

    return lastIndex - i;
  }
};",6,242,0.0,2.0,2.0,2.0,40.333333333333336,6.0,5.529999999999999
58.0,"class Solution {
 public:
  vector<vector<int>> generateMatrix(int n) {
    vector<vector<int>> ans(n, vector<int>(n));
    int count = 1;

    for (int min = 0; min < n / 2; ++min) {
      const int max = n - min - 1;
      for (int i = min; i < max; ++i)
        ans[min][i] = count++;
      for (int i = min; i < max; ++i)
        ans[i][max] = count++;
      for (int i = max; i > min; --i)
        ans[max][i] = count++;
      for (int i = max; i > min; --i)
        ans[i][min] = count++;
    }

    if (n & 1)
      ans[n / 2][n / 2] = count;

    return ans;
  }
};",20,573,0.0,6.0,3.0,6.0,28.65,13.0,5.5815
59.0,"class Solution {
 public:
  string getPermutation(int n, int k) {
    string ans;
    vector<int> nums(n);
    vector<int> fact(n + 1, 1);  // fact[i] := i!

    iota(begin(nums), end(nums), 1);

    for (int i = 2; i <= n; ++i)
      fact[i] = fact[i - 1] * i;

    --k;  // 0-indexed

    for (int i = n - 1; i >= 0; --i) {
      const int j = k / fact[i];
      k %= fact[i];
      ans += to_string(nums[j]);
      nums.erase(begin(nums) + j);
    }

    return ans;
  }
};",16,476,2.0,2.0,3.0,2.0,29.75,11.0,6.0025
60.0,"class Solution {
 public:
  ListNode* rotateRight(ListNode* head, int k) {
    if (!head || !head->next || k == 0)
      return head;

    ListNode* tail;
    int length = 1;
    for (tail = head; tail->next; tail = tail->next)
      ++length;
    tail->next = head;  // Circle the list

    const int t = length - k % length;
    for (int i = 0; i < t; ++i)
      tail = tail->next;
    ListNode* newHead = tail->next;
    tail->next = nullptr;

    return newHead;
  }
};",15,473,1.0,2.0,2.0,3.0,31.53333333333333,6.0,6.362
61.0,"class Solution {
 public:
  int uniquePaths(int m, int n) {
    // dp[i][j] := unique paths from (0, 0) to (i, j)
    vector<vector<int>> dp(m, vector<int>(n, 1));

    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

    return dp[m - 1][n - 1];
  }
};",8,315,1.0,2.0,2.0,2.0,39.375,8.0,5.45625
62.0,"class Solution {
 public:
  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    const int m = obstacleGrid.size();
    const int n = obstacleGrid[0].size();
    // dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1)
    vector<vector<long>> dp(m + 1, vector<long>(n + 1, 0));
    dp[0][1] = 1;  // Can also set dp[1][0] = 1

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (!obstacleGrid[i - 1][j - 1])
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

    return dp[m][n];
  }
};",11,533,2.0,3.0,2.0,3.0,48.45454545454545,9.0,4.5190909090909095
63.0,"class Solution {
 public:
  int minPathSum(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i > 0 && j > 0)
          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);
        else if (i > 0)
          grid[i][0] += grid[i - 1][0];
        else if (j > 0)
          grid[0][j] += grid[0][j - 1];

    return grid[m - 1][n - 1];
  }
};",11,459,0.0,7.0,2.0,5.0,41.72727272727273,9.0,4.804545454545455
64.0,"class Solution {
 public:
  bool isNumber(string s) {
    trim(s);
    if (s.empty())
      return false;

    bool seenNum = false;
    bool seenDot = false;
    bool seenE = false;

    for (int i = 0; i < s.length(); ++i) {
      switch (s[i]) {
        case '.':
          if (seenDot || seenE)
            return false;
          seenDot = true;
          break;
        case 'e':
        case 'E':
          if (seenE || !seenNum)
            return false;
          seenE = true;
          seenNum = false;
          break;
        case '+':
        case '-':
          if (i > 0 && s[i - 1] != 'e')
            return false;
          seenNum = false;
          break;
        default:
          if (!isdigit(s[i]))
            return false;
          seenNum = true;
      }
    }

    return seenNum;
  }

 private:
  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};",23,941,0.0,4.0,5.0,6.0,40.91304347826087,9.0,4.877826086956522
65.0,"class Solution {
 public:
  vector<int> plusOne(vector<int>& digits) {
    for (int i = digits.size() - 1; i >= 0; --i) {
      if (digits[i] < 9) {
        ++digits[i];
        return digits;
      }
      digits[i] = 0;
    }

    digits.insert(begin(digits), 1);
    return digits;
  }
};",8,291,0.0,1.0,4.0,2.0,36.375,4.0,6.026250000000001
66.0,"class Solution {
 public:
  string addBinary(string a, string b) {
    string ans;
    int carry = 0;
    int i = a.length() - 1;
    int j = b.length() - 1;

    while (i >= 0 || j >= 0 || carry) {
      if (i >= 0)
        carry += a[i--] - '0';
      if (j >= 0)
        carry += b[j--] - '0';
      ans += carry % 2 + '0';
      carry /= 2;
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};",11,409,0.0,3.0,3.0,3.0,37.18181818181818,8.0,5.493636363636364
67.0,"class Solution {
 public:
  vector<string> fullJustify(vector<string>& words, size_t maxWidth) {
    vector<string> ans;
    vector<string> row;
    size_t rowLetters = 0;

    for (const string& word : words) {
      // If we put the word in this row, it'll exceed the maxWidth,
      // So we cannot put the word to this row and have to pad spaces to
      // Each word in this row
      if (rowLetters + row.size() + word.length() > maxWidth) {
        const int spaces = maxWidth - rowLetters;
        if (row.size() == 1) {
          // Pad all spaces after row[0]
          for (int i = 0; i < spaces; ++i)
            row[0] += "" "";
        } else {
          // Evenly pad spaces to each word (expect the last one) in this row
          for (int i = 0; i < spaces; ++i)
            row[i % (row.size() - 1)] += "" "";
        }
        ans.push_back(join(row, """"));
        row.clear();
        rowLetters = 0;
      }
      row.push_back(word);
      rowLetters += word.length();
    }
    ans.push_back(ljust(join(row, "" ""), maxWidth));

    return ans;
  }

 private:
  string join(const vector<string>& words, const string& s) {
    string joined;
    for (int i = 0; i < words.size(); ++i) {
      joined += words[i];
      if (i != words.size() - 1)
        joined += s;
    }
    return joined;
  }

  string ljust(string s, int width) {
    for (int i = 0; i < s.length() - width; ++i)
      s += "" "";
    return s;
  }
};",28,1436,5.0,7.0,9.0,10.0,51.285714285714285,22.0,2.4242857142857144
68.0,"class Solution {
 public:
  int mySqrt(int x) {
    unsigned l = 1;
    unsigned r = x + 1u;

    while (l < r) {
      const unsigned m = (l + r) / 2;
      if (m > x / m)
        r = m;
      else
        l = m + 1;
    }

    // l: smallest number s.t. l * l > x
    return l - 1;
  }
};",7,290,1.0,3.0,3.0,2.0,41.42857142857143,4.0,5.551428571428572
69.0,"class Solution {
 public:
  int climbStairs(int n) {
    // dp[i] := # of distinct ways to climb to i-th stair
    vector<int> dp(n + 1);
    dp[0] = 1;
    dp[1] = 1;

    for (int i = 2; i <= n; ++i)
      dp[i] = dp[i - 1] + dp[i - 2];

    return dp[n];
  }
};",8,264,1.0,1.0,2.0,1.0,33.0,5.0,6.390000000000001
70.0,"class Solution {
 public:
  string simplifyPath(string path) {
    string ans;
    istringstream iss(path);
    vector<string> stack;

    for (string dir; getline(iss, dir, '/');) {
      if (dir.empty() || dir == ""."")
        continue;
      if (dir == "".."") {
        if (!stack.empty())
          stack.pop_back();
      } else {
        stack.push_back(dir);
      }
    }

    for (const string& s : stack)
      ans += ""/"" + s;

    return ans.empty() ? ""/"" : ans;
  }
};",11,478,0.0,5.0,5.0,6.0,43.45454545454545,8.0,4.689090909090909
71.0,"class Solution {
 public:
  int minDistance(string word1, string word2) {
    const int m = word1.length();
    const int n = word2.length();
    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      dp[i][0] = i;

    for (int j = 1; j <= n; ++j)
      dp[0][j] = j;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (word1[i - 1] == word2[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;

    return dp[m][n];
  }
};",17,651,1.0,6.0,3.0,5.0,38.294117647058826,14.0,4.653529411764706
72.0,"class Solution {
 public:
  void setZeroes(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    bool shouldFillFirstRow = false;
    bool shouldFillFirstCol = false;

    for (int j = 0; j < n; ++j)
      if (matrix[0][j] == 0) {
        shouldFillFirstRow = true;
        break;
      }

    for (int i = 0; i < m; ++i)
      if (matrix[i][0] == 0) {
        shouldFillFirstCol = true;
        break;
      }

    // Store the information in the 1st row/col
    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (matrix[i][j] == 0) {
          matrix[i][0] = 0;
          matrix[0][j] = 0;
        }

    // Fill 0s for the matrix except the 1st row/col
    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (matrix[i][0] == 0 || matrix[0][j] == 0)
          matrix[i][j] = 0;

    // Fill 0s for the 1st row if needed
    if (shouldFillFirstRow)
      for (int j = 0; j < n; ++j)
        matrix[0][j] = 0;

    // Fill 0s for the 1st col if needed
    if (shouldFillFirstCol)
      for (int i = 0; i < m; ++i)
        matrix[i][0] = 0;
  }
};",30,1141,4.0,18.0,5.0,20.0,38.03333333333333,17.0,3.657000000000001
73.0,"class Solution {
 public:
  bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.empty())
      return false;

    const int m = matrix.size();
    const int n = matrix[0].size();
    int l = 0;
    int r = m * n;

    while (l < r) {
      const int mid = (l + r) / 2;
      const int i = mid / n;
      const int j = mid % n;
      if (matrix[i][j] == target)
        return true;
      if (matrix[i][j] < target)
        l = mid + 1;
      else
        r = mid;
    }

    return false;
  }
};",13,519,0.0,3.0,3.0,4.0,39.92307692307692,16.0,4.446923076923078
74.0,"class Solution {
 public:
  void sortColors(vector<int>& nums) {
    int zero = -1;
    int one = -1;
    int two = -1;

    for (const int num : nums)
      if (num == 0) {
        nums[++two] = 2;
        nums[++one] = 1;
        nums[++zero] = 0;
      } else if (num == 1) {
        nums[++two] = 2;
        nums[++one] = 1;
      } else {
        nums[++two] = 2;
      }
  }
};",10,383,0.0,6.0,5.0,3.0,38.3,8.0,5.093
75.0,"class Solution {
 public:
  string minWindow(string s, string t) {
    vector<int> count(128);
    int required = t.length();
    int bestLeft = -1;
    int minLength = s.length() + 1;

    for (const char c : t)
      ++count[c];

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (--count[s[r]] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 < minLength) {
          bestLeft = l;
          minLength = r - l + 1;
        }
        if (++count[s[l++]] > 0)
          ++required;
      }
    }

    return bestLeft == -1 ? """" : s.substr(bestLeft, minLength);
  }
};",13,606,0.0,6.0,5.0,6.0,46.61538461538461,11.0,4.044615384615385
76.0,"class Solution {
 public:
  vector<vector<int>> combine(int n, int k) {
    vector<vector<int>> ans;
    dfs(n, k, 1, {}, ans);
    return ans;
  }

 private:
  void dfs(int n, int k, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (path.size() == k) {
      ans.push_back(path);
      return;
    }

    for (int i = s; i <= n; ++i) {
      path.push_back(i);
      dfs(n, k, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",11,451,0.0,1.0,6.0,2.0,41.0,12.0,4.69
77.0,"class Solution {
 public:
  vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> ans;
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    ans.push_back(path);

    for (int i = s; i < nums.size(); ++i) {
      path.push_back(nums[i]);
      dfs(nums, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",10,443,0.0,1.0,5.0,1.0,44.3,11.0,4.553000000000001
78.0,"class Solution {
 public:
  bool exist(vector<vector<char>>& board, string word) {
    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j)
        if (dfs(board, word, i, j, 0))
          return true;
    return false;
  }

 private:
  bool dfs(vector<vector<char>>& board, const string& word, int i, int j,
           int s) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return false;
    if (board[i][j] != word[s] || board[i][j] == '*')
      return false;
    if (s == word.length() - 1)
      return true;

    const char cache = board[i][j];
    board[i][j] = '*';
    const bool isExist = dfs(board, word, i + 1, j, s + 1) ||
                         dfs(board, word, i - 1, j, s + 1) ||
                         dfs(board, word, i, j + 1, s + 1) ||
                         dfs(board, word, i, j - 1, s + 1);
    board[i][j] = cache;

    return isExist;
  }
};",15,935,0.0,1.0,3.0,6.0,62.333333333333336,17.0,2.45
79.0,"class Solution {
 public:
  int removeDuplicates(vector<int>& nums) {
    int i = 0;

    for (const int num : nums)
      if (i < 2 || num > nums[i - 2])
        nums[i++] = num;

    return i;
  }
};",4,201,0.0,2.0,2.0,2.0,50.25,6.0,4.637499999999999
80.0,"class Solution {
 public:
  bool search(vector<int>& nums, int target) {
    int l = 0;
    int r = nums.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (nums[m] == target)
        return true;
      if (nums[l] == nums[m] && nums[m] == nums[r]) {
        ++l;
        --r;
      } else if (nums[l] <= nums[m]) {  // nums[l..m] are sorted
        if (nums[l] <= target && target < nums[m])
          r = m - 1;
        else
          l = m + 1;
      } else {  // nums[m..n - 1] are sorted
        if (nums[m] < target && target <= nums[r])
          l = m + 1;
        else
          r = m - 1;
      }
    }

    return false;
  }
};",12,663,2.0,9.0,6.0,6.0,55.25,8.0,3.4075
81.0,"class Solution {
 public:
  ListNode* deleteDuplicates(ListNode* head) {
    ListNode dummy(0, head);
    ListNode* prev = &dummy;

    while (head) {
      while (head->next && head->val == head->next->val)
        head = head->next;
      if (prev->next == head)
        prev = prev->next;
      else
        prev->next = head->next;
      head = head->next;
    }

    return dummy.next;
  }
};",8,397,0.0,4.0,3.0,3.0,49.625,1.0,5.013750000000001
82.0,"class Solution {
 public:
  ListNode* deleteDuplicates(ListNode* head) {
    ListNode* curr = head;

    while (curr) {
      while (curr->next && curr->val == curr->next->val)
        curr->next = curr->next->next;
      curr = curr->next;
    }

    return head;
  }
};",5,271,0.0,2.0,3.0,2.0,54.2,1.0,4.722
83.0,"class Solution {
 public:
  int largestRectangleArea(vector<int>& heights) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i <= heights.size(); ++i) {
      while (!stack.empty() &&
             (i == heights.size() || heights[stack.top()] > heights[i])) {
        const int h = heights[stack.top()];
        stack.pop();
        const int w = stack.empty() ? i : i - stack.top() - 1;
        ans = max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
};",11,488,0.0,2.0,4.0,2.0,44.36363636363637,10.0,4.647272727272727
84.0,"class Solution {
 public:
  int maximalRectangle(vector<vector<char>>& matrix) {
    if (matrix.empty())
      return 0;

    int ans = 0;
    vector<int> hist(matrix[0].size());

    for (const vector<char>& row : matrix) {
      for (int i = 0; i < row.size(); ++i)
        hist[i] = row[i] == '0' ? 0 : hist[i] + 1;
      ans = max(ans, largestRectangleArea(hist));
    }

    return ans;
  }

 private:
  int largestRectangleArea(const vector<int>& heights) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i <= heights.size(); ++i) {
      while (!stack.empty() &&
             (i == heights.size() || heights[stack.top()] > heights[i])) {
        const int h = heights[stack.top()];
        stack.pop();
        const int w = stack.empty() ? i : i - stack.top() - 1;
        ans = max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
};",19,875,0.0,3.0,6.0,5.0,46.05263157894737,18.0,3.5152631578947373
85.0,"class Solution {
 public:
  ListNode* partition(ListNode* head, int x) {
    ListNode beforeHead(0);
    ListNode afterHead(0);
    ListNode* before = &beforeHead;
    ListNode* after = &afterHead;

    for (; head; head = head->next)
      if (head->val < x) {
        before->next = head;
        before = head;
      } else {
        after->next = head;
        after = head;
      }

    after->next = nullptr;
    before->next = afterHead.next;

    return beforeHead.next;
  };
};",15,486,0.0,3.0,4.0,9.0,32.4,2.0,6.464
86.0,"class Solution {
 public:
  bool isScramble(string s1, string s2) {
    if (s1 == s2)
      return true;
    const string hashKey = s1 + '+' + s2;
    if (const auto it = memo.find(hashKey); it != cend(memo))
      return it->second;

    vector<int> count(128);

    for (int i = 0; i < s1.length(); ++i) {
      ++count[s1[i]];
      --count[s2[i]];
    }

    if (any_of(begin(count), end(count), [](int c) { return c != 0; }))
      return memo[hashKey] = false;

    for (int i = 1; i < s1.length(); ++i) {
      if (isScramble(s1.substr(0, i), s2.substr(0, i)) &&
          isScramble(s1.substr(i), s2.substr(i)))
        return memo[hashKey] = true;
      if (isScramble(s1.substr(0, i), s2.substr(s2.length() - i)) &&
          isScramble(s1.substr(i), s2.substr(0, s2.length() - i)))
        return memo[hashKey] = true;
    }

    return memo[hashKey] = false;
  }

 private:
  unordered_map<string, bool> memo;
};",18,924,0.0,1.0,5.0,7.0,51.333333333333336,13.0,3.7200000000000006
87.0,"class Solution {
 public:
  void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1;      // nums1's index (actual nums)
    int j = n - 1;      // nums2's index
    int k = m + n - 1;  // nums1's index (next filled position)

    while (j >= 0)
      if (i >= 0 && nums1[i] > nums2[j])
        nums1[k--] = nums1[i--];
      else
        nums1[k--] = nums2[j--];
  }
};",6,399,3.0,4.0,2.0,2.0,66.5,9.0,2.875
88.0,"class Solution {
 public:
  vector<int> grayCode(int n) {
    vector<int> ans{0};

    for (int i = 0; i < n; ++i)
      for (int j = ans.size() - 1; j >= 0; --j)
        ans.push_back(ans[j] | 1 << i);

    return ans;
  }
};",8,226,0.0,2.0,3.0,2.0,28.25,6.0,6.557499999999999
89.0,"class Solution {
 public:
  vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    vector<vector<int>> ans;
    sort(begin(nums), end(nums));
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    ans.push_back(path);

    for (int i = s; i < nums.size(); ++i) {
      if (i > s && nums[i] == nums[i - 1])
        continue;
      path.push_back(nums[i]);
      dfs(nums, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",12,545,0.0,1.0,5.0,2.0,45.41666666666666,11.0,4.452500000000001
90.0,"class Solution {
 public:
  int numDecodings(string s) {
    const int n = s.length();
    // dp[i] := # of ways to decode s[i..n)
    vector<int> dp(n + 1);
    dp[n] = 1;  // """"
    dp[n - 1] = isValid(s[n - 1]);

    for (int i = n - 2; i >= 0; --i) {
      if (isValid(s[i]))
        dp[i] += dp[i + 1];
      if (isValid(s[i], s[i + 1]))
        dp[i] += dp[i + 2];
    }

    return dp[0];
  }

 private:
  bool isValid(char c) {
    return c != '0';
  }

  bool isValid(char c1, char c2) {
    return c1 == '1' || c1 == '2' && c2 < '7';
  }
};",12,550,2.0,1.0,5.0,3.0,45.833333333333336,12.0,4.3950000000000005
91.0,"class Solution {
 public:
  ListNode* reverseBetween(ListNode* head, int left, int right) {
    if (left == 1)
      return reverseN(head, right);

    head->next = reverseBetween(head->next, left - 1, right - 1);

    return head;
  }

 private:
  ListNode* reverseN(ListNode* head, int n) {
    if (n == 1)
      return head;

    ListNode* newHead = reverseN(head->next, n - 1);
    ListNode* headNext = head->next;
    head->next = headNext->next;
    headNext->next = head;

    return newHead;
  }
};",10,506,0.0,-1.0,3.0,2.0,50.6,4.0,4.925999999999999
92.0,"class Solution {
 public:
  vector<string> restoreIpAddresses(const string& s) {
    vector<string> ans;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, vector<string>&& path,
           vector<string>& ans) {
    if (path.size() == 4 && start == s.length()) {
      ans.push_back(path[0] + ""."" + path[1] + ""."" + path[2] + ""."" + path[3]);
      return;
    }
    if (path.size() == 4 || start == s.length())
      return;

    for (int length = 1; length <= 3; ++length) {
      if (start + length > s.length())
        return;  // Out of bound
      if (length > 1 && s[start] == '0')
        return;  // Leading '0'
      const string& num = s.substr(start, length);
      if (stoi(num) > 255)
        return;
      path.push_back(num);
      dfs(s, start + length, move(path), ans);
      path.pop_back();
    }
  }
};",16,867,2.0,1.0,6.0,6.0,54.1875,14.0,3.383125
93.0,"class Solution {
 public:
  vector<int> inorderTraversal(TreeNode* root) {
    vector<int> ans;
    stack<TreeNode*> stack;

    while (root || !stack.empty()) {
      while (root) {
        stack.push(root);
        root = root->left;
      }
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      root = root->right;
    }

    return ans;
  }
};",9,370,0.0,2.0,4.0,2.0,41.11111111111112,3.0,5.64
94.0,"class Solution {
 public:
  vector<TreeNode*> generateTrees(int n) {
    if (n == 0)
      return {};
    return generateTrees(1, n);
  }

 private:
  vector<TreeNode*> generateTrees(int min, int max) {
    if (min > max)
      return {nullptr};

    vector<TreeNode*> ans;

    for (int i = min; i <= max; ++i)
      for (TreeNode* left : generateTrees(min, i - 1))
        for (TreeNode* right : generateTrees(i + 1, max)) {
          ans.push_back(new TreeNode(i));
          ans.back()->left = left;
          ans.back()->right = right;
        }

    return ans;
  }
};",11,574,0.0,2.0,6.0,5.0,52.18181818181818,5.0,4.323636363636363
95.0,"class Solution {
 public:
  int numTrees(int n) {
    // G[i] := # of unique BST's that store values 1..i
    vector<int> G(n + 1);
    G[0] = 1;
    G[1] = 1;

    for (int i = 2; i <= n; ++i)
      for (int j = 0; j < i; ++j)
        G[i] += G[j] * G[i - j - 1];

    return G[n];
  }
};",10,289,1.0,2.0,2.0,2.0,28.9,6.0,6.599
96.0,"class Solution {
 public:
  bool isInterleave(string s1, string s2, string s3) {
    const int m = s1.length();
    const int n = s2.length();
    if (m + n != s3.length())
      return false;

    // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of
    //             s1[0..i) and s2[0..j)
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;

    for (int i = 1; i <= m; ++i)
      dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];

    for (int j = 1; j <= n; ++j)
      dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1] ||
                   dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];

    return dp[m][n];
  }
};",18,793,2.0,5.0,2.0,7.0,44.05555555555556,15.0,4.195
97.0,"class Solution {
 public:
  bool isValidBST(TreeNode* root) {
    return isValidBST(root, nullptr, nullptr);
  }

 private:
  bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
    if (root == nullptr)
      return true;
    if (minNode && root->val <= minNode->val)
      return false;
    if (maxNode && root->val >= maxNode->val)
      return false;

    return isValidBST(root->left, minNode, root) &&
           isValidBST(root->right, root, maxNode);
  }
};",6,484,0.0,-1.0,3.0,3.0,80.66666666666667,3.0,2.3200000000000003
98.0,"class Solution {
 public:
  void recoverTree(TreeNode* root) {
    inorder(root);
    swap(x, y);
  }

 private:
  TreeNode* pred = nullptr;
  TreeNode* x = nullptr;  // 1st wrong node
  TreeNode* y = nullptr;  // 2nd wrond node

  void inorder(TreeNode* root) {
    if (root == nullptr)
      return;

    inorder(root->left);

    if (pred && root->val < pred->val) {
      y = root;
      if (x == nullptr)
        x = pred;
      else
        return;
    }
    pred = root;

    inorder(root->right);
  }

  void swap(TreeNode* x, TreeNode* y) {
    const int temp = x->val;
    x->val = y->val;
    y->val = temp;
  }
};",16,625,2.0,3.0,5.0,3.0,39.0625,6.0,5.484375000000001
99.0,"class Solution {
 public:
  bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;
    return p->val == q->val &&              //
           isSameTree(p->left, q->left) &&  //
           isSameTree(p->right, q->right);
  }
};",3,254,2.0,0.0,2.0,1.0,84.66666666666667,2.0,2.14
100.0,"class Solution {
 public:
  bool isSymmetric(TreeNode* root) {
    return isSymmetric(root, root);
  }

 private:
  bool isSymmetric(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;

    return p->val == q->val &&                //
           isSymmetric(p->left, q->right) &&  //
           isSymmetric(p->right, q->left);
  }
};",4,348,2.0,-1.0,3.0,1.0,87.0,3.0,1.83
101.0,"class Solution {
 public:
  vector<vector<int>> levelOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(currLevel);
    }

    return ans;
  }
};",14,554,0.0,4.0,7.0,5.0,39.57142857142857,5.0,5.2785714285714285
102.0,"class Solution {
 public:
  vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    deque<TreeNode*> q{{root}};
    bool isLeftToRight = true;

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz)
        if (isLeftToRight) {
          TreeNode* node = q.front();
          q.pop_front();
          currLevel.push_back(node->val);
          if (node->left)
            q.push_back(node->left);
          if (node->right)
            q.push_back(node->right);
        } else {
          TreeNode* node = q.back();
          q.pop_back();
          currLevel.push_back(node->val);
          if (node->right)
            q.push_front(node->right);
          if (node->left)
            q.push_front(node->left);
        }
      ans.push_back(currLevel);
      isLeftToRight = !isLeftToRight;
    }

    return ans;
  }
};",21,938,0.0,8.0,8.0,8.0,44.66666666666666,6.0,4.42
103.0,"class Solution {
 public:
  int maxDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
  }
};",3,171,0.0,0.0,2.0,1.0,57.0,2.0,4.55
104.0,"class Solution {
 public:
  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    unordered_map<int, int> inToIndex;

    for (int i = 0; i < inorder.size(); ++i)
      inToIndex[inorder[i]] = i;

    return build(preorder, 0, preorder.size() - 1, inorder, 0,
                 inorder.size() - 1, inToIndex);
  }

 private:
  TreeNode* build(const vector<int>& preorder, int preStart, int preEnd,
                  const vector<int>& inorder, int inStart, int inEnd,
                  const unordered_map<int, int>& inToIndex) {
    if (preStart > preEnd)
      return nullptr;

    const int rootVal = preorder[preStart];
    const int rootInIndex = inToIndex.at(rootVal);
    const int leftSize = rootInIndex - inStart;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(preorder, preStart + 1, preStart + leftSize, inorder,
                       inStart, rootInIndex - 1, inToIndex);
    root->right = build(preorder, preStart + leftSize + 1, preEnd, inorder,
                        rootInIndex + 1, inEnd, inToIndex);
    return root;
  }
};",14,1081,0.0,0.0,3.0,2.0,77.21428571428571,23.0,0.5707142857142866
105.0,"class Solution {
 public:
  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    unordered_map<int, int> inToIndex;

    for (int i = 0; i < inorder.size(); ++i)
      inToIndex[inorder[i]] = i;

    return build(inorder, 0, inorder.size() - 1, postorder, 0,
                 postorder.size() - 1, inToIndex);
  }

 private:
  TreeNode* build(const vector<int>& inorder, int inStart, int inEnd,
                  const vector<int>& postorder, int postStart, int postEnd,
                  const unordered_map<int, int>& inToIndex) {
    if (inStart > inEnd)
      return nullptr;

    const int rootVal = postorder[postEnd];
    const int rootInIndex = inToIndex.at(rootVal);
    const int leftSize = rootInIndex - inStart;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(inorder, inStart, rootInIndex - 1, postorder, postStart,
                       postStart + leftSize - 1, inToIndex);
    root->right = build(inorder, rootInIndex + 1, inEnd, postorder,
                        postStart + leftSize, postEnd - 1, inToIndex);
    return root;
  }
};",14,1091,0.0,0.0,3.0,2.0,77.92857142857143,23.0,0.5064285714285717
106.0,"class Solution {
 public:
  vector<vector<int>> levelOrderBottom(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(currLevel);
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};",15,595,0.0,4.0,7.0,5.0,39.66666666666666,5.0,5.27
107.0,"class Solution {
 public:
  TreeNode* sortedArrayToBST(vector<int>& nums) {
    return build(nums, 0, nums.size() - 1);
  }

 private:
  TreeNode* build(const vector<int>& nums, int l, int r) {
    if (l > r)
      return nullptr;
    const int m = (l + r) / 2;
    return new TreeNode(nums[m], build(nums, l, m - 1), build(nums, m + 1, r));
  }
};",5,348,0.0,-1.0,3.0,1.0,69.6,8.0,2.8160000000000007
108.0,"class Solution {
 public:
  TreeNode* sortedListToBST(ListNode* head) {
    if (head == nullptr)
      return nullptr;
    if (!head->next)
      return new TreeNode(head->val);

    ListNode* mid = findMid(head);
    TreeNode* root = new TreeNode(mid->val);
    root->left = sortedListToBST(head);
    root->right = sortedListToBST(mid->next);

    return root;
  }

 private:
  ListNode* findMid(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      prev = slow;
      slow = slow->next;
      fast = fast->next->next;
    }
    prev->next = nullptr;

    return slow;
  }
};",16,665,0.0,0.0,4.0,3.0,41.5625,1.0,5.9193750000000005
109.0,"class Solution {
 public:
  bool isBalanced(TreeNode* root) {
    if (root == nullptr)
      return true;
    return abs(maxDepth(root->left) - maxDepth(root->right)) <= 1 &&
           isBalanced(root->left) && isBalanced(root->right);
  }

 private:
  int maxDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
  }
};",5,397,0.0,-1.0,3.0,2.0,79.4,3.0,2.434
110.0,"class Solution {
 public:
  int minDepth(TreeNode* root) {
    if (root == nullptr)
      return 0;
    if (root->left == nullptr)
      return minDepth(root->right) + 1;
    if (root->right == nullptr)
      return minDepth(root->left) + 1;
    return min(minDepth(root->left), minDepth(root->right)) + 1;
  }
};",5,313,0.0,0.0,2.0,3.0,62.6,2.0,4.045999999999999
111.0,"class Solution {
 public:
  bool hasPathSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return false;
    if (root->val == sum && root->left == nullptr && root->right == nullptr)
      return true;
    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
  }
};",4,325,0.0,0.0,2.0,2.0,81.25,3.0,2.2675
112.0,"class Solution {
 public:
  vector<vector<int>> pathSum(TreeNode* root, int sum) {
    vector<vector<int>> ans;
    dfs(root, sum, {}, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int sum, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (root == nullptr)
      return;
    if (root->val == sum && root->left == nullptr && root->right == nullptr) {
      path.push_back(root->val);
      ans.push_back(path);
      path.pop_back();
      return;
    }

    path.push_back(root->val);
    dfs(root->left, sum - root->val, move(path), ans);
    dfs(root->right, sum - root->val, move(path), ans);
    path.pop_back();
  }
};",13,658,0.0,0.0,5.0,2.0,50.61538461538461,8.0,4.344615384615385
113.0,"class Solution {
 public:
  void flatten(TreeNode* root) {
    if (root == nullptr)
      return;

    flatten(root->left);
    flatten(root->right);

    TreeNode* const left = root->left;    // Flattened left
    TreeNode* const right = root->right;  // Flattened right

    root->left = nullptr;
    root->right = left;

    // Connect the original right subtree
    // To the end of new right subtree
    TreeNode* rightmost = root;
    while (rightmost->right)
      rightmost = rightmost->right;
    rightmost->right = right;
  }
};",11,538,4.0,2.0,2.0,2.0,48.90909090909091,4.0,5.118181818181818
114.0,"class Solution {
 public:
  int numDistinct(string s, string t) {
    const int m = s.length();
    const int n = t.length();
    vector<vector<unsigned long>> dp(m + 1, vector<unsigned long>(n + 1));

    for (int i = 0; i <= m; ++i)
      dp[i][0] = 1;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s[i - 1] == t[j - 1])
          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j];

    return dp[m][n];
  }
};",14,488,0.0,5.0,2.0,4.0,34.857142857142854,11.0,5.342857142857143
115.0,"class Solution {
 public:
  Node* connect(Node* root) {
    if (root == nullptr)
      return nullptr;
    connectTwoNodes(root->left, root->right);
    return root;
  }

 private:
  void connectTwoNodes(Node* p, Node* q) {
    if (p == nullptr)
      return;
    p->next = q;
    connectTwoNodes(p->left, p->right);
    connectTwoNodes(q->left, q->right);
    connectTwoNodes(p->right, q->left);
  }
};",9,403,0.0,0.0,3.0,2.0,44.77777777777778,2.0,5.59
116.0,"class Solution {
 public:
  Node* connect(Node* root) {
    Node* node = root;  // The node just above current needling

    while (node) {
      Node dummy(0);  // Dummy node before needling
      // Needle children of node
      for (Node* needle = &dummy; node; node = node->next) {
        if (node->left) {  // Needle left child
          needle->next = node->left;
          needle = needle->next;
        }
        if (node->right) {  // Needle right child
          needle->next = node->right;
          needle = needle->next;
        }
      }
      node = dummy.next;  // Move node to the next level
    }

    return root;
  }
};",11,640,6.0,4.0,6.0,5.0,58.18181818181818,1.0,4.303636363636364
117.0,"class Solution {
 public:
  vector<vector<int>> generate(int numRows) {
    vector<vector<int>> ans;

    for (int i = 0; i < numRows; ++i)
      ans.push_back(vector<int>(i + 1, 1));

    for (int i = 2; i < numRows; ++i)
      for (int j = 1; j < ans[i].size() - 1; ++j)
        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];

    return ans;
  }
};",11,351,0.0,3.0,2.0,3.0,31.90909090909091,8.0,6.028181818181817
118.0,"class Solution {
 public:
  vector<int> getRow(int rowIndex) {
    vector<int> ans(rowIndex + 1, 1);

    for (int i = 2; i < rowIndex + 1; ++i)
      for (int j = 1; j < i; ++j)
        ans[i - j] += ans[i - j - 1];

    return ans;
  }
};",8,240,0.0,2.0,2.0,2.0,30.0,6.0,6.46
119.0,"class Solution {
 public:
  int minimumTotal(vector<vector<int>>& triangle) {
    for (int i = triangle.size() - 2; i >= 0; --i)
      for (int j = 0; j <= i; ++j)
        triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);
    return triangle[0][0];
  }
};",7,272,0.0,2.0,2.0,2.0,38.85714285714285,5.0,5.762857142857143
120.0,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sellOne = 0;
    int holdOne = INT_MIN;

    for (const int price : prices) {
      sellOne = max(sellOne, holdOne + price);
      holdOne = max(holdOne, -price);
    }

    return sellOne;
  }
};",6,269,0.0,1.0,3.0,1.0,44.833333333333336,7.0,5.025
121.0,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sell = 0;
    int hold = INT_MIN;

    for (const int price : prices) {
      sell = max(sell, hold + price);
      hold = max(hold, sell - price);
    }

    return sell;
  }
};",6,251,0.0,1.0,3.0,1.0,41.833333333333336,7.0,5.295000000000001
122.0,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sellTwo = 0;
    int holdTwo = INT_MIN;
    int sellOne = 0;
    int holdOne = INT_MIN;

    for (const int price : prices) {
      sellTwo = max(sellTwo, holdTwo + price);
      holdTwo = max(holdTwo, sellOne - price);
      sellOne = max(sellOne, holdOne + price);
      holdOne = max(holdOne, -price);
    }

    return sellTwo;
  }
};",10,411,0.0,1.0,3.0,1.0,41.1,9.0,5.1610000000000005
123.0,"class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int ans = INT_MIN;
    maxPathSumDownFrom(root, ans);
    return ans;
  }

 private:
  // root->val + 0/1 of its subtrees
  int maxPathSumDownFrom(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = max(0, maxPathSumDownFrom(root->left, ans));
    const int r = max(0, maxPathSumDownFrom(root->right, ans));
    ans = max(ans, root->val + l + r);
    return root->val + max(l, r);
  }
};",9,488,1.0,-1.0,3.0,1.0,54.22222222222222,9.0,4.14
124.0,"class Solution {
 public:
  bool isPalindrome(string s) {
    int l = 0;
    int r = s.length() - 1;

    while (l < r) {
      while (l < r && !isalnum(s[l]))
        ++l;
      while (l < r && !isalnum(s[r]))
        --r;
      if (tolower(s[l]) != tolower(s[r]))
        return false;
      ++l;
      --r;
    }

    return true;
  }
};",9,340,0.0,3.0,3.0,4.0,37.77777777777778,5.0,5.74
125.0,"class Solution {
 public:
  vector<vector<string>> findLadders(string beginWord, string endWord,
                                     vector<string>& wordList) {
    unordered_set<string> wordSet{begin(wordList), end(wordList)};
    if (!wordSet.count(endWord))
      return {};

    // {""hit"": [""hot""], ""hot"": [""dot"", ""lot""], ...}
    unordered_map<string, vector<string>> graph;

    // Build graph from beginWord -> endWord
    if (!bfs(beginWord, endWord, wordSet, graph))
      return {};

    vector<vector<string>> ans;
    dfs(graph, beginWord, endWord, {beginWord}, ans);
    return ans;
  }

 private:
  bool bfs(const string& beginWord, const string& endWord,
           unordered_set<string>& wordSet,
           unordered_map<string, vector<string>>& graph) {
    unordered_set<string> currentLevelWords{beginWord};

    while (!currentLevelWords.empty()) {
      for (const string& word : currentLevelWords)
        wordSet.erase(word);
      unordered_set<string> nextLevelWords;
      bool reachEndWord = false;
      for (const string& parent : currentLevelWords) {
        vector<string> children;
        getChildren(parent, wordSet, children);
        for (const string& child : children) {
          if (wordSet.count(child)) {
            nextLevelWords.insert(child);
            graph[parent].push_back(child);
          }
          if (child == endWord)
            reachEndWord = true;
        }
      }
      if (reachEndWord)
        return true;
      currentLevelWords = move(nextLevelWords);
    }

    return false;
  }

  void getChildren(const string& parent, const unordered_set<string>& wordSet,
                   vector<string>& children) {
    string s(parent);

    for (int i = 0; i < s.length(); ++i) {
      const char cache = s[i];
      for (char c = 'a'; c <= 'z'; ++c) {
        if (c == cache)
          continue;
        s[i] = c;  // Now is `child`
        if (wordSet.count(s))
          children.push_back(s);
      }
      s[i] = cache;
    }
  }

  void dfs(const unordered_map<string, vector<string>>& graph,
           const string& word, const string& endWord, vector<string>&& path,
           vector<vector<string>>& ans) {
    if (word == endWord) {
      ans.push_back(path);
      return;
    }
    if (!graph.count(word))
      return;

    for (const string& child : graph.at(word)) {
      path.push_back(child);
      dfs(graph, child, endWord, move(path), ans);
      path.pop_back();
    }
  }
};",36,2464,3.0,9.0,19.0,16.0,68.44444444444444,50.0,-2.7200000000000024
126.0,"class Solution {
 public:
  int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
    unordered_set<string> wordSet(begin(wordList), end(wordList));
    if (!wordSet.count(endWord))
      return 0;

    int ans = 0;
    queue<string> q{{beginWord}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int i = 0; i < word.length(); ++i) {
          const char cache = word[i];
          for (char c = 'a'; c <= 'z'; ++c) {
            word[i] = c;
            if (word == endWord)
              return ans + 1;
            if (wordSet.count(word)) {
              q.push(word);
              wordSet.erase(word);
            }
          }
          word[i] = cache;
        }
      }
    }

    return 0;
  }
};",21,832,0.0,5.0,9.0,7.0,39.61904761904762,14.0,4.194285714285714
127.0,"class Solution {
 public:
  int longestConsecutive(vector<int>& nums) {
    int ans = 0;
    unordered_set<int> seen{begin(nums), end(nums)};

    for (int num : nums) {
      // Num is the start of a sequence
      if (seen.count(num - 1))
        continue;
      int length = 1;
      while (seen.count(++num))
        ++length;
      ans = max(ans, length);
    }

    return ans;
  }
};",8,390,1.0,2.0,4.0,3.0,48.75,7.0,4.592499999999999
128.0,"class Solution {
 public:
  int sumNumbers(TreeNode* root) {
    int ans = 0;
    dfs(root, 0, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int path, int& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      ans += path * 10 + root->val;
      return;
    }

    dfs(root->left, path * 10 + root->val, ans);
    dfs(root->right, path * 10 + root->val, ans);
  }
};",9,441,0.0,0.0,4.0,2.0,49.0,6.0,4.75
129.0,"class Solution {
 public:
  void solve(vector<vector<char>>& board) {
    if (board.empty())
      return;

    const int m = board.size();
    const int n = board[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (board[i][j] == 'O') {
            q.emplace(i, j);
            board[i][j] = '*';
          }

    // Mark grids that stretch from four sides with '*'
    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (board[x][y] != 'O')
          continue;
        q.emplace(x, y);
        board[x][y] = '*';
      }
    }

    for (vector<char>& row : board)
      for (char& c : row)
        if (c == '*')
          c = 'O';
        else if (c == 'O')
          c = 'X';
  }
};",24,1061,1.0,12.0,6.0,13.0,44.208333333333336,21.0,2.88125
130.0,"class Solution {
 public:
  vector<vector<string>> partition(string s) {
    vector<vector<string>> ans;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, vector<string>&& path,
           vector<vector<string>>& ans) {
    if (start == s.length()) {
      ans.push_back(path);
      return;
    }

    for (int i = start; i < s.length(); ++i)
      if (isPalindrome(s, start, i)) {
        path.push_back(s.substr(start, i - start + 1));
        dfs(s, i + 1, move(path), ans);
        path.pop_back();
      }
  }

  bool isPalindrome(const string& s, int l, int r) {
    while (l < r)
      if (s[l++] != s[r--])
        return false;
    return true;
  }
};",13,705,0.0,2.0,7.0,5.0,54.23076923076923,16.0,2.979230769230768
131.0,"class Solution {
 public:
  int minCut(string s) {
    const int n = s.length();
    // isPalindrome[i][j] := true if s[i..j] is a palindrome
    vector<vector<bool>> isPalindrome(n, vector<bool>(n, true));
    // dp[i] := min cuts needed for a palindrome partitioning of s[0..i]
    vector<int> dp(n, n);

    for (int l = 2; l <= n; ++l)
      for (int i = 0, j = l - 1; j < n; ++i, ++j)
        isPalindrome[i][j] = s[i] == s[j] && isPalindrome[i + 1][j - 1];

    for (int i = 0; i < n; ++i) {
      if (isPalindrome[0][i]) {
        dp[i] = 0;
        continue;
      }

      // Try all possible partitions
      for (int j = 0; j < i; ++j)
        if (isPalindrome[j + 1][i])
          dp[i] = min(dp[i], dp[j] + 1);
    }

    return dp.back();
  }
};",17,759,3.0,7.0,4.0,8.0,44.64705882352941,12.0,4.241764705882352
132.0,"class Solution {
 public:
  Node* cloneGraph(Node* node) {
    if (node == nullptr)
      return nullptr;

    queue<Node*> q{{node}};
    unordered_map<Node*, Node*> map{{node, new Node(node->val)}};

    while (!q.empty()) {
      Node* u = q.front();
      q.pop();
      for (Node* v : u->neighbors) {
        if (!map.count(v)) {
          map[v] = new Node(v->val);
          q.push(v);
        }
        map[u]->neighbors.push_back(map[v]);
      }
    }

    return map[node];
  }
};",10,491,0.0,3.0,9.0,4.0,49.1,1.0,4.761000000000001
133.0,"class Solution {
 public:
  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    const int gasses = accumulate(begin(gas), end(gas), 0);
    const int costs = accumulate(begin(cost), end(cost), 0);
    if (gasses - costs < 0)
      return -1;

    int ans = 0;
    int sum = 0;

    // Try to start from each index
    for (int i = 0; i < gas.size(); ++i) {
      sum += gas[i] - cost[i];
      if (sum < 0) {
        sum = 0;
        ans = i + 1;  // Start from next index
      }
    }

    return ans;
  }
};",12,524,2.0,2.0,4.0,3.0,43.66666666666666,11.0,4.69
134.0,"class Solution {
 public:
  int candy(vector<int>& ratings) {
    const int n = ratings.size();
    int ans = 0;
    vector<int> l(n, 1);
    vector<int> r(n, 1);

    for (int i = 1; i < n; ++i)
      if (ratings[i] > ratings[i - 1])
        l[i] = l[i - 1] + 1;

    for (int i = n - 2; i >= 0; --i)
      if (ratings[i] > ratings[i + 1])
        r[i] = r[i + 1] + 1;

    for (int i = 0; i < n; ++i)
      ans += max(l[i], r[i]);

    return ans;
  }
};",15,456,0.0,5.0,2.0,5.0,30.4,11.0,5.744
135.0,"class Solution {
 public:
  int singleNumber(vector<int>& nums) {
    int ans = 0;

    for (const int num : nums)
      ans ^= num;

    return ans;
  }
};",4,156,0.0,1.0,2.0,1.0,39.0,6.0,5.710000000000001
136.0,"class Solution {
 public:
  int singleNumber(vector<int>& nums) {
    int ans = 0;

    for (int i = 0; i < 32; ++i) {
      int sum = 0;
      for (const int num : nums)
        sum += num >> i & 1;
      sum %= 3;
      ans |= sum << i;
    }

    return ans;
  }
};",9,268,0.0,2.0,3.0,2.0,29.77777777777778,8.0,6.219999999999999
137.0,"class Solution {
 public:
  Node* copyRandomList(Node* head) {
    if (head == nullptr)
      return nullptr;
    if (const auto it = map.find(head); it != cend(map))
      return it->second;

    Node* newNode = new Node(head->val);
    map[head] = newNode;
    newNode->next = copyRandomList(head->next);
    newNode->random = copyRandomList(head->random);
    return newNode;
  }

 private:
  unordered_map<Node*, Node*> map;
};",10,431,0.0,0.0,2.0,2.0,43.1,2.0,5.801
138.0,"class Solution {
 public:
  bool wordBreak(string s, vector<string>& wordDict) {
    return wordBreak(s, {begin(wordDict), end(wordDict)}, {});
  }

 private:
  bool wordBreak(const string& s, const unordered_set<string>&& wordSet,
                 unordered_map<string, bool>&& memo) {
    if (wordSet.count(s))
      return true;
    if (const auto it = memo.find(s); it != cend(memo))
      return it->second;

    // 1 <= prefix.length() < s.length()
    for (int i = 1; i < s.length(); ++i) {
      const string& prefix = s.substr(0, i);
      const string& suffix = s.substr(i);
      if (wordSet.count(prefix) && wordBreak(suffix, move(wordSet), move(memo)))
        return memo[s] = true;
    }

    return memo[s] = false;
  }
};",11,738,1.0,0.0,6.0,4.0,67.0909090909091,17.0,1.9418181818181808
139.0,"class Solution {
 public:
  vector<string> wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> wordSet{begin(wordDict), end(wordDict)};
    unordered_map<string, vector<string>> memo;
    return wordBreak(s, wordSet, memo);
  }

 private:
  vector<string> wordBreak(const string& s,
                           const unordered_set<string>& wordSet,
                           unordered_map<string, vector<string>>& memo) {
    if (const auto it = memo.find(s); it != cend(memo))
      return it->second;

    vector<string> ans;

    // 1 <= prefix.length() < s.length()
    for (int i = 1; i < s.length(); ++i) {
      const string& prefix = s.substr(0, i);
      const string& suffix = s.substr(i);
      if (wordSet.count(prefix))
        for (const string& word : wordBreak(suffix, wordSet, memo))
          ans.push_back(prefix + "" "" + word);
    }

    // Contains whole string, so don't add any space
    if (wordSet.count(s))
      ans.push_back(s);

    return memo[s] = ans;
  }
};",14,1012,2.0,3.0,5.0,5.0,72.28571428571429,24.0,0.694285714285714
140.0,"class Solution {
 public:
  bool hasCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
      if (slow == fast)
        return true;
    }

    return false;
  }
};",7,280,0.0,1.0,3.0,2.0,40.0,2.0,5.96
141.0,"class Solution {
 public:
  ListNode* detectCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
      if (slow == fast) {
        slow = head;
        while (slow != fast) {
          slow = slow->next;
          fast = fast->next;
        }
        return slow;
      }
    }

    return nullptr;
  }
};",10,420,0.0,2.0,5.0,3.0,42.0,1.0,5.7
142.0,"class Solution {
 public:
  void reorderList(ListNode* head) {
    if (!head || !head->next)
      return;

    ListNode* mid = findMid(head);
    ListNode* reversed = reverse(mid);
    merge(head, reversed);
  }

 private:
  ListNode* findMid(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      prev = slow;
      slow = slow->next;
      fast = fast->next->next;
    }
    prev->next = nullptr;

    return slow;
  }

  ListNode* reverse(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;

    while (curr) {
      ListNode* next = curr->next;
      curr->next = prev;
      prev = curr;
      curr = next;
    }

    return prev;
  }

  void merge(ListNode* l1, ListNode* l2) {
    while (l2) {
      ListNode* next = l1->next;
      l1->next = l2;
      l1 = l2;
      l2 = next;
    }
  }
};",24,910,0.0,2.0,8.0,4.0,37.91666666666666,3.0,5.687500000000001
143.0,"class Solution {
 public:
  vector<int> preorderTraversal(TreeNode* root) {
    vector<int> ans;
    preorder(root, ans);
    return ans;
  }

 private:
  void preorder(TreeNode* root, vector<int>& ans) {
    if (root == nullptr)
      return;

    ans.push_back(root->val);
    preorder(root->left, ans);
    preorder(root->right, ans);
  }
};",8,344,0.0,0.0,3.0,1.0,43.0,5.0,5.450000000000001
144.0,"class Solution {
 public:
  vector<int> postorderTraversal(TreeNode* root) {
    vector<int> ans;
    postorder(root, ans);
    return ans;
  }

 private:
  void postorder(TreeNode* root, vector<int>& ans) {
    if (root == nullptr)
      return;

    postorder(root->left, ans);
    postorder(root->right, ans);
    ans.push_back(root->val);
  }
};",8,349,0.0,0.0,3.0,1.0,43.625,5.0,5.393750000000001
145.0,"class Solution {
 public:
  ListNode* insertionSortList(ListNode* head) {
    ListNode dummy(0);
    ListNode* prev = &dummy;  // The last (largest) of the sorted list

    while (head) {                  // Current inserting node
      ListNode* next = head->next;  // Cache next inserting node
      if (prev->val >= head->val)   // `prev` >= current inserting node
        prev = &dummy;              // Move `prev` to the front
      while (prev->next && prev->next->val < head->val)
        prev = prev->next;
      head->next = prev->next;
      prev->next = head;
      head = next;  // Update current inserting node
    }

    return dummy.next;
  }
};",10,660,6.0,3.0,3.0,3.0,66.0,1.0,3.8400000000000016
146.0,"class Solution {
 public:
  ListNode* sortList(ListNode* head) {
    const int length = getLength(head);
    ListNode dummy(0, head);

    for (int k = 1; k < length; k *= 2) {
      ListNode* curr = dummy.next;
      ListNode* tail = &dummy;
      while (curr) {
        ListNode* l = curr;
        ListNode* r = split(l, k);
        curr = split(r, k);
        auto [mergedHead, mergedTail] = merge(l, r);
        tail->next = mergedHead;
        tail = mergedTail;
      }
    }

    return dummy.next;
  }

 private:
  int getLength(ListNode* head) {
    int length = 0;
    for (ListNode* curr = head; curr; curr = curr->next)
      ++length;
    return length;
  }

  ListNode* split(ListNode* head, int k) {
    while (--k && head)
      head = head->next;
    ListNode* rest = head ? head->next : nullptr;
    if (head != nullptr)
      head->next = nullptr;
    return rest;
  }

  pair<ListNode*, ListNode*> merge(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* tail = &dummy;

    while (l1 && l2) {
      if (l1->val > l2->val)
        swap(l1, l2);
      tail->next = l1;
      l1 = l1->next;
      tail = tail->next;
    }
    tail->next = l1 ? l1 : l2;
    while (tail->next)
      tail = tail->next;

    return {dummy.next, tail};
  }
};",32,1273,0.0,5.0,9.0,8.0,39.78125,7.0,4.8796875
147.0,"class Solution {
 public:
  int maxPoints(vector<vector<int>>& points) {
    int ans = 0;

    for (int i = 0; i < points.size(); ++i) {
      unordered_map<pair<int, int>, int, pairHash> slopeCount;
      const vector<int> p1{points[i]};
      int samePoints = 1;
      int maxPoints = 0;  // Maximum number of points with the same slope
      for (int j = i + 1; j < points.size(); ++j) {
        const vector<int> p2{points[j]};
        if (p1 == p2)
          ++samePoints;
        else
          maxPoints = max(maxPoints, ++slopeCount[getSlope(p1, p2)]);
      }
      ans = max(ans, samePoints + maxPoints);
    }

    return ans;
  }

 private:
  pair<int, int> getSlope(const vector<int>& p, const vector<int>& q) {
    const int dx = p[0] - q[0];
    const int dy = p[1] - q[1];
    if (dx == 0)
      return {0, p[0]};
    if (dy == 0)
      return {p[1], 0};
    const int d = __gcd(dx, dy);
    return {dx / d, dy / d};
  }

  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",23,1059,1.0,2.0,12.0,5.0,46.04347826086956,32.0,1.8560869565217395
148.0,"class Solution {
 public:
  int evalRPN(vector<string>& tokens) {
    stack<long> stack;
    const unordered_map<string, function<long(long, long)>> op{
        {""+"", plus<long>()},
        {""-"", minus<long>()},
        {""*"", multiplies<long>()},
        {""/"", divides<long>()}};

    for (const string& token : tokens)
      if (op.count(token)) {
        const long b = stack.top();
        stack.pop();
        const long a = stack.top();
        stack.pop();
        stack.push(op.at(token)(a, b));
      } else {
        stack.push(stoi(token));
      }

    return stack.top();
  }
};",10,590,0.0,3.0,9.0,2.0,59.0,9.0,3.0700000000000003
149.0,"class Solution {
 public:
  string reverseWords(string s) {
    reverse(begin(s), end(s));          // Reverse the whole string
    reverseWords(s, s.length());        // Reverse each word
    return cleanSpaces(s, s.length());  // Clean up spaces
  }

 private:
  void reverseWords(string& s, int n) {
    int i = 0;
    int j = 0;

    while (i < n) {
      while (i < j || i < n && s[i] == ' ')  // Skip spaces
        ++i;
      while (j < i || j < n && s[j] != ' ')  // Skip non spaces
        ++j;
      reverse(begin(s) + i, begin(s) + j);  // Reverse the word
    }
  }

  // Trim leading, trailing, and middle spaces
  string cleanSpaces(string& s, int n) {
    int i = 0;
    int j = 0;

    while (j < n) {
      while (j < n && s[j] == ' ')  // Skip spaces
        ++j;
      while (j < n && s[j] != ' ')  // Keep non spaces
        s[i++] = s[j++];
      while (j < n && s[j] == ' ')  // Skip spaces
        ++j;
      if (j < n)  // Keep only one space
        s[i++] = ' ';
    }

    return s.substr(0, i);
  }
};",16,1029,11.0,7.0,6.0,8.0,64.3125,14.0,2.471875
150.0,"class Solution {
 public:
  int maxProduct(vector<int>& nums) {
    int ans = nums[0];
    int dpMin = nums[0];  // Min so far
    int dpMax = nums[0];  // Max so far

    for (int i = 1; i < nums.size(); ++i) {
      const int num = nums[i];
      const int prevMin = dpMin;  // dpMin[i - 1]
      const int prevMax = dpMax;  // dpMax[i - 1]
      if (num < 0) {
        dpMin = min(prevMax * num, num);
        dpMax = max(prevMin * num, num);
      } else {
        dpMin = min(prevMin * num, num);
        dpMax = max(prevMax * num, num);
      }
      ans = max(ans, dpMax);
    }

    return ans;
  }
};",15,609,4.0,3.0,5.0,2.0,40.6,13.0,4.726000000000001
151.0,"class Solution {
 public:
  int findMin(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] < nums[r])
        r = m;
      else
        l = m + 1;
    }

    return nums[l];
  }
};",7,266,0.0,3.0,3.0,2.0,38.0,7.0,5.5200000000000005
152.0,"class Solution {
 public:
  int findMin(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] == nums[r])
        --r;
      else if (nums[m] < nums[r])
        r = m;
      else
        l = m + 1;
    }

    return nums[l];
  }
};",8,314,0.0,5.0,3.0,3.0,39.25,7.0,5.2875000000000005
153.0,"class MinStack {
 public:
  void push(int x) {
    if (stack.empty())
      stack.emplace(x, x);
    else
      stack.emplace(x, min(x, stack.top().second));
  }

  void pop() {
    stack.pop();
  }

  int top() {
    return stack.top().first;
  }

  int getMin() {
    return stack.top().second;
  }

 private:
  stack<pair<int, int>> stack;  // {x, min}
};",7,358,1.0,1.0,6.0,1.0,51.142857142857146,8.0,4.217142857142857
154.0,"class Solution {
 public:
  TreeNode* upsideDownBinaryTree(TreeNode* root) {
    if (root == nullptr || root->left == nullptr)
      return root;

    TreeNode* newRoot = upsideDownBinaryTree(root->left);
    root->left->left = root->right;  // 2's left = 3 (root's right)
    root->left->right = root;        // 2's right = 1 (root)
    root->left = nullptr;
    root->right = nullptr;
    return newRoot;
  }
};",8,413,2.0,0.0,2.0,1.0,51.625,1.0,5.21375
155.0,"/**
 * The read4 API is defined in the parent class Reader4.
 *     int read4(char *buf4);
 */

class Solution {
 public:
  /**
   * @param buf Destination buffer
   * @param n   Number of characters to read
   * @return    The number of actual characters read
   */
  int read(char* buf, int n) {
    char* buf4 = new char[4];
    int i4 = 0;  // buf4's index
    int n4 = 0;  // buf4's size
    int i = 0;   // buf's index

    while (i < n) {
      if (i4 == n4) {      // All characters in buf4 are consumed
        i4 = 0;            // Reset buf4's index
        n4 = read4(buf4);  // Read 4 (or less) chars from file to buf4
        if (n4 == 0)       // Reach the EOF
          return i;
      }
      buf[i++] = buf4[i4++];
    }

    return i;
  }
};",11,760,9.0,1.0,4.0,3.0,69.0909090909091,12.0,2.6418181818181825
156.0,"/**
 * The read4 API is defined in the parent class Reader4.
 *     int read4(char *buf4);
 */

class Solution {
 public:
  /**
   * @param buf Destination buffer
   * @param n   Number of characters to read
   * @return    The number of actual characters read
   */
  int read(char* buf, int n) {
    int i = 0;  // buf's index

    while (i < n) {
      if (i4 == n4) {      // All characters in buf4 are consumed
        i4 = 0;            // Reset buf4's index
        n4 = read4(buf4);  // Read 4 (or less) chars from file to buf4
        if (n4 == 0)       // Reach the EOF
          return i;
      }
      buf[i++] = buf4[i4++];
    }

    return i;
  }

 private:
  char* buf4 = new char[4];
  int i4 = 0;  // buf4's index
  int n4 = 0;  // buf4's size
};",11,764,9.0,1.0,4.0,3.0,69.45454545454545,12.0,2.6090909090909093
157.0,"class Solution {
 public:
  int lengthOfLongestSubstringTwoDistinct(string s) {
    int ans = 0;
    int distinct = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r]] == 1)
        ++distinct;
      while (distinct == 3)
        if (--count[s[l++]] == 0)
          --distinct;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",10,394,0.0,4.0,3.0,4.0,39.4,7.0,5.3340000000000005
158.0,"class Solution {
 public:
  ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    ListNode* a = headA;
    ListNode* b = headB;

    while (a != b) {
      a = a ? a->next : headB;
      b = b ? b->next : headA;
    }

    return a;
  }
};",6,255,0.0,1.0,3.0,1.0,42.5,1.0,5.835000000000001
159.0,"class Solution {
 public:
  bool isOneEditDistance(string s, string t) {
    const int m = s.length();
    const int n = t.length();
    if (m > n)  // Make sure len(s) <= len(t)
      return isOneEditDistance(t, s);

    for (int i = 0; i < m; ++i)
      if (s[i] != t[i]) {
        if (m == n)
          return s.substr(i + 1) == t.substr(i + 1);  // Replace s[i] with t[i]
        return s.substr(i) == t.substr(i + 1);        // Delete t[i]
      }

    return m + 1 == n;  // Delete t[-1]
  }
};",9,500,4.0,1.0,3.0,4.0,55.55555555555556,9.0,4.0200000000000005
160.0,"class Solution {
 public:
  int findPeakElement(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (nums[m] >= nums[m + 1])
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",7,273,0.0,3.0,3.0,2.0,39.0,7.0,5.430000000000001
161.0,"class Solution {
 public:
  vector<string> findMissingRanges(vector<int>& nums, int lower, int upper) {
    if (nums.empty())
      return {getRange(lower, upper)};

    vector<string> ans;

    if (nums.front() > lower)
      ans.push_back(getRange(lower, nums.front() - 1));

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] > nums[i - 1] + 1)
        ans.push_back(getRange(nums[i - 1] + 1, nums[i] - 1));

    if (nums.back() < upper)
      ans.push_back(getRange(nums.back() + 1, upper));

    return ans;
  }

 private:
  string getRange(int lo, int hi) {
    if (lo == hi)
      return to_string(lo);
    return to_string(lo) + ""->"" + to_string(hi);
  }
};",11,674,0.0,3.0,4.0,6.0,61.27272727272727,10.0,3.065454545454545
162.0,"struct Bucket {
  int min;
  int max;
};

class Solution {
 public:
  int maximumGap(vector<int>& nums) {
    if (nums.size() < 2)
      return 0;

    const int mini = *min_element(begin(nums), end(nums));
    const int maxi = *max_element(begin(nums), end(nums));
    if (mini == maxi)
      return 0;

    const int gap = ceil((maxi - mini) / (double)(nums.size() - 1));
    const int bucketSize = (maxi - mini) / gap + 1;
    vector<Bucket> buckets(bucketSize, {INT_MAX, INT_MIN});

    for (const int num : nums) {
      const int i = (num - mini) / gap;
      buckets[i].min = min(buckets[i].min, num);
      buckets[i].max = max(buckets[i].max, num);
    }

    int ans = 0;
    int prevMax = mini;

    for (const Bucket& bucket : buckets) {
      if (bucket.min == INT_MAX)
        continue;  // Empty bucket
      ans = max(ans, bucket.min - prevMax);
      prevMax = bucket.max;
    }

    return ans;
  }
};",20,919,1.0,2.0,6.0,5.0,45.95,22.0,3.224499999999999
163.0,"class Solution {
 public:
  int compareVersion(string version1, string version2) {
    istringstream iss1(version1);
    istringstream iss2(version2);
    int v1;
    int v2;
    char dotChar;

    while (bool(iss1 >> v1) + bool(iss2 >> v2)) {
      if (v1 < v2)
        return -1;
      if (v1 > v2)
        return 1;
      iss1 >> dotChar;
      iss2 >> dotChar;
      v1 = 0;
      v2 = 0;
    }

    return 0;
  };
};",14,421,0.0,1.0,3.0,3.0,30.071428571428573,9.0,6.1535714285714285
164.0,"class Solution {
 public:
  string fractionToDecimal(int numerator, int denominator) {
    if (numerator == 0)
      return ""0"";

    string ans;

    if (numerator < 0 ^ denominator < 0)
      ans += ""-"";

    long n = labs(numerator);
    long d = labs(denominator);
    ans += to_string(n / d);

    if (n % d == 0)
      return ans;

    ans += '.';
    unordered_map<int, int> seen;

    for (long r = n % d; r; r %= d) {
      if (const auto it = seen.find(r); it != cend(seen)) {
        ans.insert(it->second, 1, '(');
        ans += ')';
        break;
      }
      seen[r] = ans.size();
      r *= 10;
      ans += to_string(r / d);
    }

    return ans;
  }
};",20,673,0.0,2.0,4.0,5.0,33.65,8.0,5.8115
165.0,"class Solution {
 public:
  vector<int> twoSum(vector<int>& numbers, int target) {
    int l = 0;
    int r = numbers.size() - 1;

    while (numbers[l] + numbers[r] != target)
      if (numbers[l] + numbers[r] < target)
        ++l;
      else
        --r;

    return {l + 1, r + 1};
  }
};",6,292,0.0,3.0,3.0,2.0,48.66666666666666,6.0,4.66
166.0,"class Solution {
 public:
  string convertToTitle(int n) {
    return n == 0 ? """"
                  : convertToTitle((n - 1) / 26) + (char)('A' + ((n - 1) % 26));
  }
};",2,169,0.0,0.0,2.0,0.0,84.5,4.0,1.8750000000000016
167.0,"class Solution {
 public:
  int majorityElement(vector<int>& nums) {
    int ans;
    int count = 0;

    for (const int num : nums) {
      if (count == 0)
        ans = num;
      count += num == ans ? 1 : -1;
    }

    return ans;
  }
};",6,241,0.0,2.0,3.0,2.0,40.16666666666666,7.0,5.385000000000001
168.0,"class TwoSum {
 public:
  void add(int number) {
    ++count[number];
  }

  bool find(int value) {
    for (const auto& [key, freq] : count) {
      const int remain = value - key;
      if (key == remain && freq > 1)
        return true;
      if (key != remain && count.count(remain))
        return true;
    }

    return false;
  }

 private:
  unordered_map<int, int> count;
};",7,384,0.0,1.0,4.0,3.0,54.85714285714285,10.0,3.7628571428571433
169.0,"class Solution {
 public:
  int titleToNumber(string s) {
    return accumulate(begin(s), end(s), 0,
                      [](int a, int b) { return a * 26 + (b - 'A' + 1); });
  }
};",3,183,0.0,-1.0,3.0,0.0,61.0,5.0,3.89
170.0,"class Solution {
 public:
  int trailingZeroes(int n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
  }
};",2,117,0.0,0.0,2.0,0.0,58.5,3.0,4.315
171.0,"class Solution {
 public:
  int calculateMinimumHP(vector<vector<int>>& dungeon) {
    const int m = dungeon.size();
    const int n = dungeon[0].size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
    dp[m][n - 1] = 1;
    dp[m - 1][n] = 1;

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
        dp[i][j] = max(dp[i][j], 1);
      }

    return dp[0][0];
  }
};",13,482,0.0,2.0,3.0,2.0,37.07692307692308,11.0,5.263076923076923
172.0,"class Solution {
 public:
  string largestNumber(vector<int>& nums) {
    string ans;

    sort(begin(nums), end(nums), [](int a, int b) {
      return to_string(a) + to_string(b) > to_string(b) + to_string(a);
    });

    for (const int num : nums)
      ans += to_string(num);

    return ans[0] == '0' ? ""0"" : ans;
  }
};",6,325,0.0,0.0,3.0,1.0,54.16666666666666,8.0,4.1450000000000005
173.0,"class Solution {
 public:
  void reverseWords(vector<char>& s) {
    reverse(begin(s), end(s));  // Reverse the whole string
    reverseWords(s, s.size());  // Reverse each word
  }

 private:
  void reverseWords(vector<char>& s, int n) {
    int i = 0;
    int j = 0;

    while (i < n) {
      while (i < j || i < n && s[i] == ' ')  // Skip spaces
        ++i;
      while (j < i || j < n && s[j] != ' ')  // Skip non spaces
        ++j;
      reverse(begin(s) + i, begin(s) + j);  // Reverse the word
    }
  }
};",8,516,5.0,4.0,4.0,3.0,64.5,9.0,3.015
174.0,"class Solution {
 public:
  vector<string> findRepeatedDnaSequences(string s) {
    unordered_set<string> ans;
    unordered_set<string_view> seen;
    const string_view sv(s);

    for (int i = 0; i + 10 <= s.length(); ++i) {
      if (seen.count(sv.substr(i, 10)))
        ans.insert(s.substr(i, 10));
      seen.insert(sv.substr(i, 10));
    }

    return {begin(ans), end(ans)};
  }
};",9,389,0.0,2.0,4.0,2.0,43.22222222222222,6.0,5.15
175.0,"class Solution {
 public:
  int maxProfit(int k, vector<int>& prices) {
    if (k >= prices.size() / 2) {
      int sell = 0;
      int hold = INT_MIN;

      for (const int price : prices) {
        sell = max(sell, hold + price);
        hold = max(hold, sell - price);
      }

      return sell;
    }

    vector<int> sell(k + 1);
    vector<int> hold(k + 1, INT_MIN);

    for (const int price : prices)
      for (int i = k; i > 0; --i) {
        sell[i] = max(sell[i], hold[i] + price);
        hold[i] = max(hold[i], sell[i - 1] - price);
      }

    return sell[k];
  }
};",13,583,0.0,3.0,5.0,4.0,44.84615384615385,13.0,4.183846153846154
176.0,"class Solution {
 public:
  void rotate(vector<int>& nums, int k) {
    k %= nums.size();
    reverse(nums, 0, nums.size() - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.size() - 1);
  }

 private:
  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};",6,320,0.0,2.0,3.0,1.0,53.333333333333336,8.0,4.1000000000000005
177.0,"class Solution {
 public:
  uint32_t reverseBits(uint32_t n) {
    uint32_t ans = 0;

    for (int i = 0; i < 32; ++i)
      if (n >> i & 1)
        ans |= 1 << 31 - i;

    return ans;
  }
};",6,192,0.0,2.0,2.0,2.0,32.0,2.0,6.68
178.0,"class Solution {
 public:
  int hammingWeight(uint32_t n) {
    int ans = 0;

    for (int i = 0; i < 32; ++i)
      if ((n >> i) & 1)
        ++ans;

    return ans;
  }
};",6,173,0.0,2.0,2.0,2.0,28.83333333333333,4.0,6.765000000000001
179.0,"class Solution {
 public:
  int rob(vector<int>& nums) {
    if (nums.empty())
      return 0;
    if (nums.size() == 1)
      return nums[0];

    // dp[i] := max money of robbing nums[0..i]
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);

    for (int i = 2; i < nums.size(); ++i)
      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);

    return dp.back();
  }
};",10,404,1.0,1.0,2.0,3.0,40.4,5.0,5.724000000000001
180.0,"class Solution {
 public:
  vector<int> rightSideView(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      const int size = q.size();
      for (int i = 0; i < size; ++i) {
        TreeNode* node = q.front();
        q.pop();
        if (i == size - 1)
          ans.push_back(node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
    }

    return ans;
  }
};",13,529,0.0,5.0,7.0,6.0,40.69230769230769,6.0,5.017692307692308
181.0,"class Solution {
 public:
  int numIslands(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = 0;

    auto bfs = [&](int r, int c) {
      queue<pair<int, int>> q{{{r, c}}};
      grid[r][c] = '2';  // Mark '2' as visited
      while (!q.empty()) {
        const auto [i, j] = q.front();
        q.pop();
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (grid[x][y] != '1')
            continue;
          q.emplace(x, y);
          grid[x][y] = '2';  // Mark '2' as visited
        }
      }
    };

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == '1') {
          bfs(i, j);
          ++ans;
        }

    return ans;
  }
};",25,925,2.0,5.0,10.0,7.0,37.0,22.0,3.65
182.0,"class Solution {
 public:
  int rangeBitwiseAnd(int m, int n) {
    int shiftBits = 0;

    while (m != n) {
      m >>= 1;
      n >>= 1;
      ++shiftBits;
    }

    return m << shiftBits;
  }
};",6,198,0.0,1.0,3.0,4.0,33.0,5.0,6.29
183.0,"class Solution {
 public:
  bool isHappy(int n) {
    int slow = squaredSum(n);
    int fast = squaredSum(squaredSum(n));

    while (slow != fast) {
      slow = squaredSum(slow);
      fast = squaredSum(squaredSum(fast));
    }

    return slow == 1;
  }

 private:
  int squaredSum(int n) {
    int sum = 0;
    while (n) {
      sum += pow(n % 10, 2);
      n /= 10;
    }
    return sum;
  };
};",11,400,0.0,1.0,5.0,2.0,36.36363636363637,8.0,5.567272727272727
184.0,"class Solution {
 public:
  ListNode* removeElements(ListNode* head, int val) {
    ListNode dummy(0, head);
    ListNode* prev = &dummy;

    for (; head; head = head->next)
      if (head->val != val) {
        prev->next = head;
        prev = prev->next;
      }
    prev->next = nullptr;  // In case the last val == val

    return dummy.next;
  }
};",9,355,1.0,3.0,3.0,2.0,39.44444444444444,2.0,5.93
185.0,"class Solution {
 public:
  int countPrimes(int n) {
    if (n <= 2)
      return 0;
    const vector<bool> isPrime = sieveEratosthenes(n);
    return count(begin(isPrime), end(isPrime), true);
  }

 private:
  vector<bool> sieveEratosthenes(int n) {
    vector<bool> isPrime(n, true);
    isPrime[0] = false;
    isPrime[1] = false;
    for (int i = 2; i * i < n; ++i)
      if (isPrime[i])
        for (int j = i * i; j < n; j += i)
          isPrime[j] = false;
    return isPrime;
  }
};",13,491,0.0,2.0,3.0,4.0,37.76923076923077,10.0,5.300769230769231
186.0,"class Solution {
 public:
  bool isIsomorphic(string s, string t) {
    vector<int> charToIndex_s(128);
    vector<int> charToIndex_t(128);

    for (int i = 0; i < s.length(); ++i) {
      if (charToIndex_s[s[i]] != charToIndex_t[t[i]])
        return false;
      charToIndex_s[s[i]] = i + 1;
      charToIndex_t[t[i]] = i + 1;
    }

    return true;
  }
};",9,360,0.0,1.0,3.0,2.0,40.0,7.0,5.460000000000001
187.0,"class Solution {
 public:
  ListNode* reverseList(ListNode* head) {
    if (!head || !head->next)
      return head;

    ListNode* newHead = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newHead;
  }
};",6,248,0.0,0.0,2.0,1.0,41.333333333333336,1.0,6.06
188.0,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> graph(numCourses);
    vector<State> state(numCourses);

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[1];
      const int v = prerequisite[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < numCourses; ++i)
      if (hasCycle(graph, i, state))
        return false;

    return true;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state) {
    if (state[u] == State::kVisiting)
      return true;
    if (state[u] == State::kVisited)
      return false;

    state[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, state))
        return true;
    state[u] = State::kVisited;

    return false;
  }
};",17,908,0.0,2.0,5.0,7.0,53.41176470588236,19.0,2.8729411764705883
189.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool search(const string& word) {
    shared_ptr<TrieNode> node = find(word);
    return node && node->isWord;
  }

  bool startsWith(const string& prefix) {
    return find(prefix) != nullptr;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  shared_ptr<TrieNode> find(const string& prefix) {
    shared_ptr<TrieNode> node = root;
    for (const char c : prefix) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return nullptr;
      node = node->children[i];
    }
    return node;
  }
};",18,980,0.0,1.0,9.0,4.0,54.44444444444444,22.0,2.3000000000000007
190.0,"class Solution {
 public:
  int minSubArrayLen(int s, vector<int>& nums) {
    int ans = INT_MAX;
    int sum = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      sum += nums[r];
      while (sum >= s) {
        ans = min(ans, r - l + 1);
        sum -= nums[l++];
      }
    }

    return ans < INT_MAX ? ans : 0;
  }
};",9,332,0.0,2.0,4.0,2.0,36.888888888888886,7.0,5.62
191.0,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int> ans;
    vector<vector<int>> graph(numCourses);
    vector<State> state(numCourses);

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[1];
      const int v = prerequisite[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < numCourses; ++i)
      if (hasCycle(graph, i, state, ans))
        return {};

    reverse(begin(ans), end(ans));
    return ans;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state,
                vector<int>& ans) {
    if (state[u] == State::kVisiting)
      return true;
    if (state[u] == State::kVisited)
      return false;

    state[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, state, ans))
        return true;
    state[u] = State::kVisited;
    ans.push_back(u);

    return false;
  }
};",20,1033,0.0,2.0,6.0,7.0,51.65,21.0,2.7715
192.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class WordDictionary {
 public:
  void addWord(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool search(const string& word) {
    return dfs(word, 0, root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  bool dfs(const string& word, int s, shared_ptr<TrieNode> node) {
    if (s == word.length())
      return node->isWord;
    if (word[s] != '.') {
      shared_ptr<TrieNode> next = node->children[word[s] - 'a'];
      return next ? dfs(word, s + 1, next) : false;
    }

    // word[s] == '.' -> search all 26 children
    for (int i = 0; i < 26; ++i)
      if (node->children[i] && dfs(word, s + 1, node->children[i]))
        return true;

    return false;
  }
};",18,1051,1.0,2.0,8.0,6.0,58.388888888888886,18.0,2.385
193.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    vector<string> ans;

    for (const string& word : words)
      insert(word);

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j)
        dfs(board, i, j, root, ans);

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  void dfs(vector<vector<char>>& board, int i, int j, shared_ptr<TrieNode> node,
           vector<string>& ans) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return;
    if (board[i][j] == '*')
      return;

    const char c = board[i][j];
    shared_ptr<TrieNode> child = node->children[c - 'a'];
    if (child == nullptr)
      return;
    if (child->word != nullptr) {
      ans.push_back(*child->word);
      child->word = nullptr;
    }

    board[i][j] = '*';
    dfs(board, i + 1, j, child, ans);
    dfs(board, i - 1, j, child, ans);
    dfs(board, i, j + 1, child, ans);
    dfs(board, i, j - 1, child, ans);
    board[i][j] = c;
  }
};",31,1505,0.0,6.0,8.0,9.0,48.54838709677419,26.0,2.1906451612903224
194.0,"class Solution {
 public:
  int rob(vector<int>& nums) {
    if (nums.empty())
      return 0;
    if (nums.size() == 1)
      return nums[0];

    auto rob = [&](int l, int r) {
      int prev1 = 0;  // dp[i - 1]
      int prev2 = 0;  // dp[i - 2]

      for (int i = l; i <= r; ++i) {
        const int dp = max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = dp;
      }

      return prev1;
    };

    return max(rob(0, nums.size() - 2), rob(1, nums.size() - 1));
  }
};",13,491,2.0,0.0,4.0,3.0,37.76923076923077,10.0,5.440769230769231
195.0,"class Solution {
 public:
  string shortestPalindrome(string s) {
    string t = s;
    reverse(begin(t), end(t));

    const string_view sv_s(s);
    const string_view sv_t(t);

    for (int i = 0; i < s.length(); ++i)
      if (sv_s.substr(0, s.length() - i) == sv_t.substr(i))
        return t.substr(0, i) + s;

    return t + s;
  }
};",9,340,0.0,1.0,2.0,2.0,37.77777777777778,7.0,5.720000000000001
196.0,"class Solution {
 public:
  int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int num : nums) {
      minHeap.push(num);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    return minHeap.top();
  }
};",5,283,0.0,2.0,3.0,2.0,56.6,8.0,3.806
197.0,"class Solution {
 public:
  vector<vector<int>> combinationSum3(int k, int n) {
    vector<vector<int>> ans;
    dfs(k, n, 1, {}, ans);
    return ans;
  }

 private:
  void dfs(int k, int n, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (k == 0 && n == 0) {
      ans.push_back(path);
      return;
    }
    if (k == 0 || n <= 0)
      return;

    for (int i = s; i <= 9; ++i) {
      path.push_back(i);
      dfs(k - 1, n - i, i + 1, move(path), ans);
      path.pop_back();
    }
  }
};",12,507,0.0,1.0,6.0,3.0,42.25,12.0,4.577500000000001
198.0,"class Solution {
 public:
  bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> seen;

    for (const int num : nums)
      if (!seen.insert(num).second)
        return true;

    return false;
  }
};",4,215,0.0,1.0,2.0,2.0,53.75,6.0,4.3825
199.0,"class Solution {
 public:
  vector<vector<int>> getSkyline(const vector<vector<int>>& buildings) {
    const int n = buildings.size();
    if (n == 0)
      return {};
    if (n == 1) {
      const int left = buildings[0][0];
      const int right = buildings[0][1];
      const int height = buildings[0][2];
      return {{left, height}, {right, 0}};
    }

    const vector<vector<int>> left =
        getSkyline({begin(buildings), begin(buildings) + n / 2});
    const vector<vector<int>> right =
        getSkyline({begin(buildings) + n / 2, end(buildings)});
    return merge(left, right);
  }

 private:
  vector<vector<int>> merge(const vector<vector<int>>& left,
                            const vector<vector<int>>& right) {
    vector<vector<int>> ans;
    int i = 0;  // left's index
    int j = 0;  // right's index
    int leftY = 0;
    int rightY = 0;

    while (i < left.size() && j < right.size())
      // Choose the point with smaller x
      if (left[i][0] < right[j][0]) {
        leftY = left[i][1];  // Update the ongoing leftY
        addPoint(ans, left[i][0], max(left[i++][1], rightY));
      } else {
        rightY = right[j][1];  // Update the ongoing rightY
        addPoint(ans, right[j][0], max(right[j++][1], leftY));
      }

    while (i < left.size())
      addPoint(ans, left[i][0], left[i++][1]);

    while (j < right.size())
      addPoint(ans, right[j][0], right[j++][1]);

    return ans;
  }

  void addPoint(vector<vector<int>>& ans, int x, int y) {
    if (!ans.empty() && ans.back()[0] == x) {
      ans.back()[1] = y;
      return;
    }
    if (!ans.empty() && ans.back()[1] == y)
      return;
    ans.push_back({x, y});
  }
};",26,1678,5.0,4.0,15.0,8.0,64.53846153846153,30.0,0.2515384615384608
200.0,"class Solution {
 public:
  bool containsNearbyDuplicate(vector<int>& nums, int k) {
    unordered_set<int> seen;

    for (int i = 0; i < nums.size(); ++i) {
      if (!seen.insert(nums[i]).second)
        return true;
      if (i >= k)
        seen.erase(nums[i - k]);
    }

    return false;
  }
};",7,302,0.0,2.0,3.0,3.0,43.142857142857146,6.0,5.217142857142857
201.0,"class Solution {
 public:
  bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff,
                                     int valueDiff) {
    set<long> window;

    for (int i = 0; i < nums.size(); ++i) {
      if (const auto it =
              window.lower_bound(static_cast<long>(nums[i]) - valueDiff);
          it != cend(window) && *it - nums[i] <= valueDiff)
        return true;
      window.insert(nums[i]);
      if (i >= indexDiff)
        window.erase(nums[i - indexDiff]);
    }

    return false;
  }
};",9,529,0.0,2.0,3.0,9.0,58.77777777777778,7.0,3.71
202.0,"class Solution {
 public:
  int maximalSquare(vector<vector<char>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    int maxLength = 0;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (i == 0 || j == 0 || matrix[i][j] == '0')
          dp[i][j] = matrix[i][j] == '1' ? 1 : 0;
        else
          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
        maxLength = max(maxLength, dp[i][j]);
      }

    return maxLength * maxLength;
  }
};",13,575,0.0,4.0,4.0,3.0,44.23076923076923,12.0,4.339230769230769
203.0,"class Solution {
 public:
  int countNodes(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
  }
};",3,173,0.0,0.0,2.0,1.0,57.66666666666666,2.0,4.49
204.0,"class Solution {
 public:
  int computeArea(long A, long B, long C, long D,  //
                  long E, long F, long G, long H) {
    const long x = max(A, E) < min(C, G) ? (min(C, G) - max(A, E)) : 0;
    const long y = max(B, F) < min(D, H) ? (min(D, H) - max(B, F)) : 0;
    return (C - A) * (D - B) + (G - E) * (H - F) - x * y;
  }
};",4,340,1.0,0.0,2.0,0.0,85.0,4.0,1.870000000000001
205.0,"class Solution {
 public:
  int calculate(string s) {
    int ans = 0;
    int num = 0;
    int sign = 1;
    stack<int> stack{{sign}};  // Stack.top(): current env's sign

    for (const char c : s)
      if (isdigit(c))
        num = num * 10 + (c - '0');
      else if (c == '(')
        stack.push(sign);
      else if (c == ')')
        stack.pop();
      else if (c == '+' || c == '-') {
        ans += sign * num;
        sign = (c == '+' ? 1 : -1) * stack.top();
        num = 0;
      }

    return ans + sign * num;
  }
};",12,532,1.0,8.0,5.0,5.0,44.333333333333336,9.0,4.369999999999999
206.0,"class MyStack {
 public:
  void push(int x) {
    q.push(x);
    for (int i = 0; i < q.size() - 1; ++i) {
      q.push(q.front());
      q.pop();
    }
  }

  int pop() {
    const int val = q.front();
    q.pop();
    return val;
  }

  int top() {
    return q.front();
  }

  bool empty() {
    return q.empty();
  }

 private:
  queue<int> q;
};",12,349,0.0,-1.0,6.0,1.0,29.08333333333333,10.0,6.0825000000000005
207.0,"class Solution {
 public:
  TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr)
      return nullptr;

    TreeNode* const left = root->left;
    TreeNode* const right = root->right;
    root->left = invertTree(right);
    root->right = invertTree(left);
    return root;
  }
};",7,290,0.0,0.0,2.0,1.0,41.42857142857143,3.0,5.851428571428571
208.0,"class Solution {
 public:
  int calculate(string s) {
    stack<int> nums;
    stack<char> ops;

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c)) {
        int num = c - '0';
        while (i + 1 < s.length() && isdigit(s[i + 1])) {
          num = num * 10 + (s[i + 1] - '0');
          ++i;
        }
        nums.push(num);
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        while (!ops.empty() && compare(ops.top(), c))
          nums.push(calculate(pop(ops), pop(nums), pop(nums)));
        ops.push(c);
      }
    }

    while (!ops.empty())
      nums.push(calculate(pop(ops), pop(nums), pop(nums)));

    return nums.top();
  }

 private:
  int calculate(char op, int b, int a) {
    switch (op) {
      case '+':
        return a + b;
      case '-':
        return a - b;
      case '*':
        return a * b;
      case '/':
        return a / b;
    }
    throw;
  }

  // Returns true if priority(op1) >= priority(op2)
  bool compare(char op1, char op2) {
    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';
  }

  char pop(stack<char>& ops) {
    const char op = ops.top();
    ops.pop();
    return op;
  }

  int pop(stack<int>& nums) {
    const int num = nums.top();
    nums.pop();
    return num;
  }
};",26,1302,1.0,5.0,11.0,7.0,50.07692307692308,24.0,2.1730769230769225
209.0,"class Solution {
 public:
  vector<string> summaryRanges(vector<int>& nums) {
    vector<string> ans;

    for (int i = 0; i < nums.size(); ++i) {
      const int begin = nums[i];
      while (i + 1 < nums.size() && nums[i] == nums[i + 1] - 1)
        ++i;
      const int end = nums[i];
      if (begin == end)
        ans.push_back(to_string(begin));
      else
        ans.push_back(to_string(begin) + ""->"" + to_string(end));
    }

    return ans;
  }
};",10,458,0.0,4.0,3.0,3.0,45.8,9.0,4.558
210.0,"class Solution {
 public:
  vector<int> majorityElement(vector<int>& nums) {
    vector<int> ans;
    int candidate1 = 0;
    int candidate2 = 1;   // Any number different from candidate1
    int countSoFar1 = 0;  // # of candidate1 so far
    int countSoFar2 = 0;  // # of candidate2 so far

    for (const int num : nums)
      if (num == candidate1) {
        ++countSoFar1;
      } else if (num == candidate2) {
        ++countSoFar2;
      } else if (countSoFar1 == 0) {  // Assign new candidate
        candidate1 = num;
        ++countSoFar1;
      } else if (countSoFar2 == 0) {  // Assign new candidate
        candidate2 = num;
        ++countSoFar2;
      } else {  // Meet a new number, so pair out previous counts
        --countSoFar1;
        --countSoFar2;
      }

    const int count1 = count(begin(nums), end(nums), candidate1);
    const int count2 = count(begin(nums), end(nums), candidate2);

    if (count1 > nums.size() / 3)
      ans.push_back(candidate1);
    if (count2 > nums.size() / 3)
      ans.push_back(candidate2);
    return ans;
  }
};",19,1071,6.0,11.0,7.0,8.0,56.36842105263158,14.0,2.6868421052631577
211.0,"class Solution {
 public:
  int kthSmallest(TreeNode* root, int k) {
    const int leftCount = countNodes(root->left);

    if (leftCount == k - 1)
      return root->val;
    if (leftCount >= k)
      return kthSmallest(root->left, k);
    return kthSmallest(root->right, k - 1 - leftCount);  // LeftCount < k
  }

 private:
  int countNodes(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
  }
};",7,473,1.0,-1.0,3.0,3.0,67.57142857142857,6.0,3.2385714285714293
212.0,"class Solution {
 public:
  bool isPowerOfTwo(int n) {
    return n < 0 ? false : __builtin_popcountll(n) == 1;
  }
};",2,118,0.0,0.0,2.0,0.0,59.0,3.0,4.2700000000000005
213.0,"class Solution {
 public:
  int countDigitOne(int n) {
    int ans = 0;

    for (long pow10 = 1; pow10 <= n; pow10 *= 10) {
      const long divisor = pow10 * 10;
      const int quotient = n / divisor;
      const int remainder = n % divisor;
      if (quotient > 0)
        ans += quotient * pow10;
      if (remainder >= pow10)
        ans += min(remainder - pow10 + 1, pow10);
    }

    return ans;
  }
};",10,411,0.0,3.0,3.0,3.0,41.1,9.0,5.041
214.0,"class Solution {
 public:
  bool isPalindrome(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
    }

    if (fast != nullptr)
      slow = slow->next;
    slow = reverseList(slow);

    while (slow) {
      if (slow->val != head->val)
        return false;
      slow = slow->next;
      head = head->next;
    }

    return true;
  }

 private:
  ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;

    while (head) {
      ListNode* next = head->next;
      head->next = prev;
      prev = head;
      head = next;
    }

    return prev;
  }
};",17,680,0.0,3.0,6.0,5.0,40.0,2.0,5.66
215.0,"class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root->val > max(p->val, q->val))
      return lowestCommonAncestor(root->left, p, q);
    if (root->val < min(p->val, q->val))
      return lowestCommonAncestor(root->right, p, q);
    return root;
  }
};",4,315,0.0,0.0,2.0,2.0,78.75,1.0,2.692500000000001
216.0,"class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr || root == p || root == q)
      return root;

    TreeNode* l = lowestCommonAncestor(root->left, p, q);
    TreeNode* r = lowestCommonAncestor(root->right, p, q);

    if (l && r)
      return root;
    return l ? l : r;
  }
};",6,355,0.0,0.0,2.0,2.0,59.16666666666666,1.0,4.455000000000001
217.0,"class Solution {
 public:
  void deleteNode(ListNode* node) {
    node->val = node->next->val;
    node->next = node->next->next;
  }
};",3,136,0.0,1.0,2.0,0.0,45.333333333333336,2.0,5.54
218.0,"class Solution {
 public:
  vector<int> productExceptSelf(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);        // Can also use nums as the ans array
    vector<int> prefix(n, 1);  // Prefix product
    vector<int> suffix(n, 1);  // Suffix product

    for (int i = 1; i < n; ++i)
      prefix[i] = prefix[i - 1] * nums[i - 1];

    for (int i = n - 2; i >= 0; --i)
      suffix[i] = suffix[i + 1] * nums[i + 1];

    for (int i = 0; i < n; ++i)
      ans[i] = prefix[i] * suffix[i];

    return ans;
  }
};",15,536,3.0,3.0,2.0,3.0,35.733333333333334,11.0,5.504
219.0,"class Solution {
 public:
  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> ans;
    deque<int> q;  // Max queue

    for (int i = 0; i < nums.size(); ++i) {
      while (!q.empty() && q.back() < nums[i])
        q.pop_back();
      q.push_back(nums[i]);
      if (i >= k && nums[i - k] == q.front())  // Out of bound
        q.pop_front();
      if (i >= k - 1)
        ans.push_back(q.front());
    }

    return ans;
  }
};",10,451,2.0,4.0,3.0,4.0,45.1,7.0,4.901
220.0,"class Solution {
 public:
  bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int r = 0;
    int c = matrix[0].size() - 1;

    while (r < matrix.size() && c >= 0) {
      if (matrix[r][c] == target)
        return true;
      if (matrix[r][c] > target)
        --c;
      else
        ++r;
    }

    return false;
  }
};",7,337,0.0,3.0,3.0,3.0,48.142857142857146,6.0,4.707142857142857
221.0,"class Solution {
 public:
  vector<int> diffWaysToCompute(string expression) {
    return ways(expression, {});
  }

 private:
  vector<int> ways(const string& s, unordered_map<string, vector<int>>&& memo) {
    if (const auto it = memo.find(s); it != cend(memo))
      return it->second;

    vector<int> ans;

    for (int i = 0; i < s.length(); ++i)
      if (ispunct(s[i]))
        for (const int a : ways(s.substr(0, i), move(memo)))
          for (const int b : ways(s.substr(i + 1), move(memo)))
            if (s[i] == '+')
              ans.push_back(a + b);
            else if (s[i] == '-')
              ans.push_back(a - b);
            else
              ans.push_back(a * b);

    return memo[s] = (ans.empty() ? vector<int>{stoi(s)} : ans);
  }
};",11,763,0.0,7.0,5.0,8.0,69.36363636363636,16.0,1.4372727272727277
222.0,"class Solution {
 public:
  bool isAnagram(string s, string t) {
    if (s.length() != t.length())
      return false;

    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (const char c : t)
      if (--count[c] < 0)
        return false;

    return true;
  }
};",6,294,0.0,2.0,2.0,4.0,49.0,9.0,4.449999999999999
223.0,"class Solution {
 public:
  int shortestDistance(vector<string>& wordsDict, string word1, string word2) {
    int ans = wordsDict.size();
    int index1 = -1;  // wordsDict[index1] == word1
    int index2 = -1;  // wordsDict[index2] == word2

    for (int i = 0; i < wordsDict.size(); ++i) {
      if (wordsDict[i] == word1) {
        index1 = i;
        if (index2 != -1)
          ans = min(ans, index1 - index2);
      }
      if (wordsDict[i] == word2) {
        index2 = i;
        if (index1 != -1)
          ans = min(ans, index2 - index1);
      }
    }

    return ans;
  }
};",11,585,2.0,5.0,5.0,5.0,53.18181818181818,9.0,3.793636363636364
224.0,"class Solution {
 public:
  int shortestWordDistance(vector<string>& words, string word1, string word2) {
    const bool isSame = word1 == word2;
    int ans = INT_MAX;
    // If word1 == word2, index1 is the newest index
    int index1 = words.size();
    // If word1 == word2, index2 is the previous index
    int index2 = -words.size();

    for (int i = 0; i < words.size(); ++i) {
      if (words[i] == word1) {
        if (isSame)
          index2 = index1;
        index1 = i;
      } else if (words[i] == word2) {
        index2 = i;
      }
      ans = min(ans, abs(index1 - index2));
    }

    return ans;
  }
};",12,623,2.0,5.0,5.0,6.0,51.91666666666666,11.0,3.707500000000002
225.0,"class Solution {
 public:
  bool isStrobogrammatic(string num) {
    const vector<char> rotated{'0', '1', 'x', 'x', 'x',
                               'x', '9', 'x', '8', '6'};
    int l = 0;
    int r = num.length() - 1;

    while (l <= r)
      if (num[l++] != rotated[num[r--] - '0'])
        return false;

    return true;
  }
};",6,336,0.0,1.0,3.0,2.0,56.0,7.0,4.0200000000000005
226.0,"class Solution {
 public:
  vector<string> findStrobogrammatic(int n) {
    return helper(n, n);
  }

 private:
  vector<string> helper(int n, int k) {
    if (n == 0)
      return {""""};
    if (n == 1)
      return {""0"", ""1"", ""8""};

    vector<string> ans;

    for (const string& inner : helper(n - 2, k)) {
      if (n < k)
        ans.push_back(""0"" + inner + ""0"");
      ans.push_back(""1"" + inner + ""1"");
      ans.push_back(""6"" + inner + ""9"");
      ans.push_back(""8"" + inner + ""8"");
      ans.push_back(""9"" + inner + ""6"");
    }

    return ans;
  }
};",11,558,0.0,1.0,6.0,4.0,50.72727272727273,9.0,4.114545454545454
227.0,"class Solution {
 public:
  int strobogrammaticInRange(string low, string high) {
    int ans = 0;

    for (int n = low.length(); n <= high.length(); ++n) {
      string s(n, ' ');
      dfs(low, high, s, 0, n - 1, ans);
    }

    return ans;
  }

 private:
  const vector<pair<char, char>> pairs{
      {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};

  void dfs(const string& low, const string& high, string& s, int l, int r,
           int& ans) {
    if (l > r) {
      if (s.length() == low.length() && s < low)
        return;
      if (s.length() == high.length() && s > high)
        return;
      ++ans;
      return;
    }

    for (const auto& [leftDigit, rightDigit] : pairs) {
      if (l == r && leftDigit != rightDigit)
        continue;
      s[l] = leftDigit;
      s[r] = rightDigit;
      if (s.length() > 1 && s[0] == '0')
        continue;
      dfs(low, high, s, l + 1, r - 1, ans);
    }
  }
};",17,932,0.0,2.0,12.0,7.0,54.8235294117647,20.0,2.225882352941177
228.0,"class Solution {
 public:
  vector<vector<string>> groupStrings(vector<string>& strings) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> keyToStrings;

    for (const string& s : strings)
      keyToStrings[getKey(s)].push_back(s);

    for (const auto& [_, strings] : keyToStrings)
      ans.push_back(strings);

    return ans;
  }

 private:
  // ""abc"" -> ""11"" because diff(a, b) = 1 and diff(b, c) = 1
  string getKey(const string& s) {
    string key;

    for (int i = 1; i < s.length(); ++i) {
      const int diff = (s[i] - s[i - 1] + 26) % 26;
      key += to_string(diff) + "","";
    }

    return key;
  }
};",12,646,1.0,2.0,4.0,7.0,53.833333333333336,16.0,3.2349999999999994
229.0,"class Solution {
 public:
  int countUnivalSubtrees(TreeNode* root) {
    int ans = 0;
    isUnival(root, INT_MAX, ans);
    return ans;
  }

 private:
  bool isUnival(TreeNode* root, int val, int& ans) {
    if (root == nullptr)
      return true;

    if (isUnival(root->left, root->val, ans) &
        isUnival(root->right, root->val, ans)) {
      ++ans;
      return root->val == val;
    }

    return false;
  }
};",8,421,0.0,-1.0,4.0,2.0,52.625,6.0,4.48375
230.0,"class Vector2D {
 public:
  Vector2D(vector<vector<int>>& vec) {
    for (const vector<int>& A : vec)
      for (const int a : A)
        this->vec.push_back(a);
  }

  int next() {
    return vec[i++];
  }

  bool hasNext() {
    return i < vec.size();
  }

 private:
  vector<int> vec;
  int i = 0;
};",6,303,0.0,1.0,4.0,2.0,50.5,10.0,4.155
231.0,"class Solution {
 public:
  bool canAttendMeetings(vector<vector<int>>& intervals) {
    sort(begin(intervals), end(intervals));

    for (int i = 1; i < intervals.size(); ++i)
      if (intervals[i - 1][1] > intervals[i][0])
        return false;

    return true;
  }
};",6,272,0.0,1.0,2.0,2.0,45.333333333333336,4.0,5.34
232.0,"class Solution {
 public:
  int minMeetingRooms(vector<vector<int>>& intervals) {
    sort(begin(intervals), end(intervals));

    // Store end times of each room.
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const vector<int>& interval : intervals) {
      // No overlap, we can reuse the same room.
      if (!minHeap.empty() && interval[0] >= minHeap.top())
        minHeap.pop();
      minHeap.push(interval[1]);
    }

    return minHeap.size();
  }
};",6,479,2.0,2.0,3.0,2.0,79.83333333333333,7.0,1.895000000000001
233.0,"class Solution {
 public:
  vector<vector<int>> getFactors(int n) {
    vector<vector<int>> ans;
    dfs(n, 2, {}, ans);  // The smallest factor is 2
    return ans;
  }

 private:
  void dfs(int n, int s, vector<int>&& path, vector<vector<int>>& ans) {
    if (n <= 1) {
      if (path.size() > 1)
        ans.push_back(path);
      return;
    }

    for (int i = s; i <= n; ++i)
      if (n % i == 0) {
        path.push_back(i);
        dfs(n / i, i, move(path), ans);
        path.pop_back();
      }
  }
};",11,512,1.0,3.0,6.0,4.0,46.54545454545455,10.0,4.310909090909091
234.0,"class Solution {
 public:
  bool verifyPreorder(vector<int>& preorder) {
    int i = 0;
    dfs(preorder, i, INT_MIN, INT_MAX);
    return i == preorder.size();
  }

 private:
  void dfs(const vector<int>& preorder, int& i, int min, int max) {
    if (i == preorder.size())
      return;
    if (preorder[i] < min || preorder[i] > max)
      return;

    const int val = preorder[i++];
    dfs(preorder, i, min, val);
    dfs(preorder, i, val, max);
  }
};",9,456,0.0,0.0,3.0,3.0,50.66666666666666,12.0,4.0600000000000005
235.0,"class Solution {
 public:
  int minCost(vector<vector<int>>& costs) {
    for (int i = 1; i < costs.size(); ++i) {
      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);
      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);
      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);
    }

    return *min_element(begin(costs.back()), end(costs.back()));
  }
};",7,373,0.0,1.0,3.0,1.0,53.285714285714285,4.0,4.564285714285715
236.0,"class Solution {
 public:
  vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> ans;
    dfs(root, {}, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, vector<string>&& path, vector<string>& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      ans.push_back(join(path) + to_string(root->val));
      return;
    }

    path.push_back(to_string(root->val) + ""->"");
    dfs(root->left, move(path), ans);
    dfs(root->right, move(path), ans);
    path.pop_back();
  }

  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  }
};",14,696,0.0,0.0,6.0,3.0,49.71428571428572,12.0,3.965714285714285
237.0,"class Solution {
 public:
  int addDigits(int num) {
    return 1 + (num - 1) % 9;
  }
};",2,89,0.0,0.0,2.0,0.0,44.5,3.0,5.575
238.0,"class Solution {
 public:
  int threeSumSmaller(vector<int>& nums, int target) {
    if (nums.size() < 3)
      return 0;

    int ans = 0;

    sort(begin(nums), end(nums));

    for (int i = 0; i + 2 < nums.size(); ++i) {
      int l = i + 1;
      int r = nums.size() - 1;
      while (l < r)
        if (nums[i] + nums[l] + nums[r] < target) {
          // (nums[i], nums[l], nums[r])
          // (nums[i], nums[l], nums[r - 1])
          // ...,
          // (nums[i], nums[l], nums[l + 1])
          ans += r - l;
          ++l;
        } else {
          --r;
        }
    }

    return ans;
  }
};",12,607,4.0,4.0,5.0,4.0,50.583333333333336,8.0,4.2675
239.0,"class Solution {
 public:
  vector<int> singleNumber(vector<int>& nums) {
    const int xors = accumulate(begin(nums), end(nums), 0, bit_xor<>());
    const int lowbit = xors & -xors;
    vector<int> ans(2);

    // Seperate nums into two groups by the lowbit
    for (const int num : nums)
      if (num & lowbit)
        ans[0] ^= num;
      else
        ans[1] ^= num;

    return ans;
  }
};",7,395,1.0,3.0,2.0,2.0,56.42857142857143,10.0,3.661428571428572
240.0,"class Solution {
 public:
  bool validTree(int n, vector<vector<int>>& edges) {
    if (n == 0 || edges.size() != n - 1)
      return false;

    vector<vector<int>> graph(n);
    queue<int> q{{0}};
    unordered_set<int> seen{{0}};

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u])
        if (!seen.count(v)) {
          q.push(v);
          seen.insert(v);
        }
    }

    return seen.size() == n;
  }
};",14,636,0.0,4.0,9.0,5.0,45.42857142857143,17.0,3.4314285714285706
241.0,"class Solution {
 public:
  bool isUgly(int n) {
    if (n == 0)
      return false;

    for (const int prime : {2, 3, 5})
      while (n % prime == 0)
        n /= prime;

    return n == 1;
  }
};",4,199,0.0,2.0,3.0,3.0,49.75,5.0,4.7225
242.0,"class Solution {
 public:
  int nthUglyNumber(int n) {
    vector<int> uglyNums{1};
    int i2 = 0;
    int i3 = 0;
    int i5 = 0;

    while (uglyNums.size() < n) {
      const int next2 = uglyNums[i2] * 2;
      const int next3 = uglyNums[i3] * 3;
      const int next5 = uglyNums[i5] * 5;
      const int next = min({next2, next3, next5});
      if (next == next2)
        ++i2;
      if (next == next3)
        ++i3;
      if (next == next5)
        ++i5;
      uglyNums.push_back(next);
    }

    return uglyNums.back();
  }
};",14,534,0.0,4.0,5.0,4.0,38.142857142857146,15.0,4.527142857142857
243.0,"class Solution {
 public:
  int minCostII(vector<vector<int>>& costs) {
    int prevIndex = -1;  // The previous minimum index
    int prevMin1 = 0;    // Minimum cost so far
    int prevMin2 = 0;    // 2nd minimum cost so far

    for (const vector<int>& cost : costs) {  // O(n)
      int index = -1;  // The painted index s.t. achieve the minimum cost after
                       // Painting current house
      int min1 = INT_MAX;  // The minimum cost after painting current house
      int min2 = INT_MAX;  // The 2nd minimum cost after painting current house
      for (int i = 0; i < cost.size(); ++i) {  // O(k)
        const int theCost = cost[i] + (i == prevIndex ? prevMin2 : prevMin1);
        if (theCost < min1) {
          index = i;
          min2 = min1;
          min1 = theCost;
        } else if (theCost < min2) {  // Min1 <= theCost < min2
          min2 = theCost;
        }
      }
      prevIndex = index;
      prevMin1 = min1;
      prevMin2 = min2;
    }

    return prevMin1;
  }
};",18,1012,10.0,5.0,6.0,4.0,56.22222222222222,14.0,3.28
244.0,"class Solution {
 public:
  bool canPermutePalindrome(string s) {
    unordered_set<char> seen;

    for (const char c : s)
      if (!seen.insert(c).second)
        seen.erase(c);

    return seen.size() <= 1;
  }
};",4,217,0.0,2.0,2.0,2.0,54.25,6.0,4.2775
245.0,"class Solution {
 public:
  vector<string> generatePalindromes(string s) {
    int odd = 0;
    unordered_map<char, int> count;

    // Get character occurrence
    for (const char c : s)
      ++count[c];

    // Count odd one
    for (const auto& [_, value] : count)
      if (value & 1)
        ++odd;

    // can't form any palindrome
    if (odd > 1)
      return {};

    vector<string> ans;
    vector<char> candidates;
    string mid;

    // Get mid and candidates characters
    for (const auto& [key, value] : count) {
      if (value & 1)
        mid += key;
      for (int i = 0; i < value / 2; ++i)
        candidates.push_back(key);
    }

    // Backtracking to generate our ans (strings)
    dfs(candidates, mid, vector<bool>(candidates.size()), """", ans);
    return ans;
  }

 private:
  // Generate all unique palindromes from candidates
  void dfs(const vector<char>& candidates, const string& mid,
           vector<bool>&& used, string&& path, vector<string>& ans) {
    if (path.length() == candidates.size()) {
      string secondHalf = path;
      reverse(begin(secondHalf), end(secondHalf));
      ans.push_back(path + mid + secondHalf);
      return;
    }

    for (int i = 0; i < candidates.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(candidates[i]);
      dfs(candidates, mid, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }
};",28,1535,6.0,7.0,7.0,12.0,54.82142857142857,25.0,1.9660714285714285
246.0,"class Solution {
 public:
  int missingNumber(vector<int>& nums) {
    int ans = nums.size();

    for (int i = 0; i < nums.size(); ++i)
      ans ^= i ^ nums[i];

    return ans;
  }
};",6,186,0.0,1.0,2.0,1.0,31.0,5.0,6.529999999999999
247.0,"class Solution {
 public:
  string alienOrder(vector<string>& words) {
    unordered_map<char, unordered_set<char>> graph;
    vector<int> inDegree(26);
    buildGraph(graph, words, inDegree);
    return topology(graph, inDegree);
  }

 private:
  void buildGraph(unordered_map<char, unordered_set<char>>& graph,
                  const vector<string>& words, vector<int>& inDegree) {
    // Create node for each character in each word
    for (const string& word : words)
      for (const char c : word)
        if (!graph.count(c))
          graph[c] = unordered_set<char>();

    for (int i = 1; i < words.size(); ++i) {
      const string& first = words[i - 1];
      const string& second = words[i];
      const int length = min(first.length(), second.length());
      for (int j = 0; j < length; ++j) {
        const char u = first[j];
        const char v = second[j];
        if (u != v) {
          if (!graph[u].count(v)) {
            graph[u].insert(v);
            ++inDegree[v - 'a'];
          }
          break;  // Later characters' order are meaningless
        }
        // First = ""ab"", second = ""a"" -> invalid
        if (j == length - 1 && first.length() > second.length()) {
          graph.clear();
          return;
        }
      }
    }
  }

  string topology(unordered_map<char, unordered_set<char>>& graph,
                  vector<int>& inDegree) {
    string s;
    queue<char> q;

    for (const auto& [c, _] : graph)
      if (inDegree[c - 'a'] == 0)
        q.push(c);

    while (!q.empty()) {
      const char u = q.front();
      q.pop();
      s += u;
      for (const char v : graph[u])
        if (--inDegree[v - 'a'] == 0)
          q.push(v);
    }

    // Words = [""z"", ""x"", ""y"", ""x""]
    return s.length() == graph.size() ? s : """";
  }
};",28,1783,4.0,11.0,10.0,14.0,63.67857142857143,40.0,-0.8310714285714287
248.0,"class Solution {
 public:
  int closestValue(TreeNode* root, double target) {
    // If target < root->val, search left subtree
    if (target < root->val && root->left) {
      const int left = closestValue(root->left, target);
      if (abs(left - target) < abs(root->val - target))
        return left;
    }

    // If target > root->val, search right subtree
    if (target > root->val && root->right) {
      const int right = closestValue(root->right, target);
      if (abs(right - target) < abs(root->val - target))
        return right;
    }

    return root->val;
  }
};",6,582,2.0,2.0,4.0,6.0,97.0,7.0,0.2900000000000009
249.0,"class Codec {
 public:
  // Encodes a list of strings to a single string.
  string encode(vector<string>& strs) {
    string encoded;

    for (const string& s : strs)
      encoded += to_string(s.length()) + '/' + s;

    return encoded;
  }

  // Decodes a single string to a list of strings.
  vector<string> decode(string s) {
    vector<string> decoded;

    for (int i = 0; i < s.length();) {
      const int slash = s.find('/', i);
      const int length = stoi(s.substr(i, slash - i));
      i = slash + length + 1;
      decoded.push_back(s.substr(slash + 1, i - slash - 1));
    }

    return decoded;
  }
};",12,618,2.0,1.0,4.0,2.0,51.5,16.0,3.545000000000001
250.0,"class Solution {
 public:
  vector<int> closestKValues(TreeNode* root, double target, int k) {
    deque<int> q;

    inorder(root, q);

    while (q.size() > k)
      if (abs(q.front() - target) > abs(q.back() - target))
        q.pop_front();
      else
        q.pop_back();

    return {begin(q), end(q)};
  }

 private:
  void inorder(TreeNode* root, deque<int>& q) {
    if (root == nullptr)
      return;

    inorder(root->left, q);
    q.push_back(root->val);
    inorder(root->right, q);
  }
};",10,504,0.0,3.0,4.0,3.0,50.4,7.0,4.344
251.0,"class Solution {
 public:
  string numberToWords(int num) {
    if (num == 0)
      return ""Zero"";
    return helper(num);
  }

 private:
  const vector<string> belowTwenty{
      """",        ""One"",     ""Two"",       ""Three"",    ""Four"",
      ""Five"",    ""Six"",     ""Seven"",     ""Eight"",    ""Nine"",
      ""Ten"",     ""Eleven"",  ""Twelve"",    ""Thirteen"", ""Fourteen"",
      ""Fifteen"", ""Sixteen"", ""Seventeen"", ""Eighteen"", ""Nineteen""};
  const vector<string> tens{"""",      """",      ""Twenty"",  ""Thirty"", ""Forty"",
                            ""Fifty"", ""Sixty"", ""Seventy"", ""Eighty"", ""Ninety""};

  string helper(int num) {
    string s;

    if (num < 20)
      s = belowTwenty.at(num);
    else if (num < 100)
      s = tens.at(num / 10) + "" "" + belowTwenty.at(num % 10);
    else if (num < 1000)
      s = helper(num / 100) + "" Hundred "" + helper(num % 100);
    else if (num < 1000000)
      s = helper(num / 1000) + "" Thousand "" + helper(num % 1000);
    else if (num < 1000000000)
      s = helper(num / 1000000) + "" Million "" + helper(num % 1000000);
    else
      s = helper(num / 1000000000) + "" Billion "" + helper(num % 1000000000);

    trim(s);
    return s;
  }

  void trim(string& s) {
    s.erase(0, s.find_first_not_of(' '));
    s.erase(s.find_last_not_of(' ') + 1);
  }
};",16,1277,0.0,9.0,6.0,9.0,79.8125,12.0,0.7168750000000017
252.0,"class Solution {
 public:
  int hIndex(vector<int>& citations) {
    const int n = citations.size();
    int accumulate = 0;
    vector<int> count(n + 1);

    for (const int citation : citations)
      ++count[min(citation, n)];

    // To find the largeset h-index, loop from back to front
    // I is the candidate h-index
    for (int i = n; i >= 0; --i) {
      accumulate += count[i];
      if (accumulate >= i)
        return i;
    }

    throw;
  }
};",10,460,2.0,2.0,3.0,3.0,46.0,10.0,4.640000000000001
253.0,"class Solution {
 public:
  int hIndex(vector<int>& citations) {
    const int n = citations.size();
    int l = 0;
    int r = n;

    while (l < r) {
      const int m = (l + r) / 2;
      if (citations[m] >= n - m)
        r = m;
      else
        l = m + 1;
    }

    return n - l;
  }
};",8,294,0.0,3.0,3.0,2.0,36.75,9.0,5.432500000000001
254.0,"class Solution {
 public:
  int numWays(int n, int k) {
    if (n == 0)
      return 0;
    if (n == 1)
      return k;
    if (n == 2)
      return k * k;

    // dp[i] := # of ways to paint n posts with k colors
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = k;
    dp[2] = k * k;

    for (int i = 3; i <= n; ++i)
      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1);

    return dp[n];
  }
};",12,398,1.0,1.0,2.0,4.0,33.166666666666664,6.0,6.275
255.0,"class Solution {
 public:
  int findCelebrity(int n) {
    int candidate = 0;

    // Everyone knows the celebrity
    for (int i = 1; i < n; ++i)
      if (knows(candidate, i))
        candidate = i;

    // Candidate knows nobody and everyone knows the celebrity
    for (int i = 0; i < n; ++i) {
      if (i < candidate && knows(candidate, i) || !knows(i, candidate))
        return -1;
      if (i > candidate && !knows(i, candidate))
        return -1;
    }

    return candidate;
  }
};",10,493,2.0,3.0,3.0,5.0,49.3,6.0,4.683000000000002
256.0,"bool isBadVersion(int version);

class Solution {
 public:
  int firstBadVersion(int n) {
    int l = 1;
    int r = n;

    while (l < r) {
      const int m = l + (r - l) / 2;
      if (isBadVersion(m))
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",8,277,0.0,3.0,3.0,2.0,34.625,9.0,5.62375
257.0,"class Solution {
 public:
  int numSquares(int n) {
    vector<int> dp(n + 1, n);  // 1^2 x n

    dp[0] = 0;  // No way
    dp[1] = 1;  // 1^2

    for (int i = 2; i <= n; ++i)
      for (int j = 1; j * j <= i; ++j)
        dp[i] = min(dp[i], dp[i - j * j] + 1);

    return dp[n];
  }
};",10,289,3.0,2.0,2.0,2.0,28.9,6.0,6.679
258.0,"class Solution {
 public:
  void wiggleSort(vector<int>& nums) {
    // 1. if i is even, then nums[i] <= nums[i - 1]
    // 2. if i is odd, then nums[i] >= nums[i - 1]
    for (int i = 1; i < nums.size(); ++i)
      if ((!(i & 1) && nums[i] > nums[i - 1]) ||
          ((i & 1) && nums[i] < nums[i - 1]))
        swap(nums[i], nums[i - 1]);
  }
};",4,347,2.0,5.0,2.0,4.0,86.75,4.0,1.4525000000000006
259.0,"class Solution {
 public:
  vector<string> addOperators(string num, int target) {
    vector<string> ans;
    dfs(num, target, 0, 0, 0, {}, ans);
    return ans;
  }

 private:
  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  }

  // Start index, prev value, current evaluated value
  void dfs(const string& num, int target, int start, long prev, long eval,
           vector<string>&& path, vector<string>& ans) {
    if (start == num.length()) {
      if (eval == target)
        ans.push_back(join(path));
      return;
    }

    for (int i = start; i < num.length(); ++i) {
      if (i > start && num[start] == '0')
        return;
      const string& s = num.substr(start, i - start + 1);
      const long curr = stol(s);
      if (start == 0) {
        path.push_back(s);
        dfs(num, target, i + 1, curr, curr, move(path), ans);
        path.pop_back();
      } else {
        for (const string& op : {""+"", ""-"", ""*""}) {
          path.push_back(op + s);
          if (op == ""+"")
            dfs(num, target, i + 1, curr, eval + curr, move(path), ans);
          else if (op == ""-"")
            dfs(num, target, i + 1, -curr, eval - curr, move(path), ans);
          else
            dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr,
                move(path), ans);
          path.pop_back();
        }
      }
    }
  }
};",22,1437,1.0,9.0,11.0,9.0,65.31818181818181,24.0,0.5613636363636374
260.0,"class Solution {
 public:
  void moveZeroes(vector<int>& nums) {
    int i = 0;
    for (const int num : nums)
      if (num != 0)
        nums[i++] = num;

    while (i < nums.size())
      nums[i++] = 0;
  }
};",4,212,0.0,4.0,2.0,3.0,53.0,6.0,4.2700000000000005
261.0,"class PeekingIterator : public Iterator {
 public:
  PeekingIterator(const vector<int>& nums) : Iterator(nums) {}

  // Returns the next element in the iteration without advancing the iterator.
  int peek() {
    // Iterator(*this) makes a copy of current iterator, then call next on the
    // Copied iterator to get the next value without affecting current iterator
    return Iterator(*this).next();
  }

  // hasNext() and next() should behave the same as in the Iterator interface.
  // Override them if needed.
  int next() {
    return Iterator::next();
  }

  bool hasNext() const {
    return Iterator::hasNext();
  }
};",4,629,5.0,-1.0,5.0,1.0,157.25,7.0,-4.8925
262.0,"class Solution {
 public:
  TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
    if (root == nullptr)
      return nullptr;
    if (root->val <= p->val)
      return inorderSuccessor(root->right, p);

    TreeNode* left = inorderSuccessor(root->left, p);
    return left ? left : root;
  }
};",5,301,0.0,0.0,2.0,2.0,60.2,1.0,4.362
263.0,"class Solution {
 public:
  void wallsAndGates(vector<vector<int>>& rooms) {
    const int m = rooms.size();
    const int n = rooms[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (rooms[i][j] == 0)
          q.emplace(i, j);

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (rooms[x][y] != INT_MAX)
          continue;
        rooms[x][y] = rooms[i][j] + 1;
        q.emplace(x, y);
      }
    }
  }
};",20,737,0.0,6.0,5.0,7.0,36.85,19.0,4.1235
264.0,"class Solution {
 public:
  int findDuplicate(vector<int>& nums) {
    int slow = nums[nums[0]];
    int fast = nums[nums[nums[0]]];

    while (slow != fast) {
      slow = nums[slow];
      fast = nums[nums[fast]];
    }

    slow = nums[0];

    while (slow != fast) {
      slow = nums[slow];
      fast = nums[fast];
    }

    return slow;
  }
};",9,352,0.0,2.0,4.0,2.0,39.11111111111112,5.0,5.62
265.0,"class Solution {
 public:
  void gameOfLife(vector<vector<int>>& board) {
    const int m = board.size();
    const int n = board[0].size();

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        int ones = 0;
        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)
          for (int y = max(0, j - 1); y < min(n, j + 2); ++y)
            ones += board[x][y] & 1;
        // Any live cell with 2 or 3 live neighbors
        // lives on to the next generation
        if (board[i][j] == 1 && (ones == 3 || ones == 4))
          board[i][j] |= 0b10;
        // Any dead cell with exactly 3 live neighbors
        // becomes a live cell, as if by reproduction
        if (board[i][j] == 0 && ones == 3)
          board[i][j] |= 0b10;
      }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        board[i][j] >>= 1;
  }
};",20,866,4.0,10.0,3.0,10.0,43.3,14.0,4.083000000000001
266.0,"class Solution {
 public:
  bool wordPattern(string pattern, string str) {
    const int n = pattern.length();
    istringstream iss(str);
    vector<int> charToIndex(128);
    unordered_map<string, int> stringToIndex;

    int i = 0;
    for (string word; iss >> word; ++i) {
      if (i == n)  // Out of bound
        return false;
      if (charToIndex[pattern[i]] != stringToIndex[word])
        return false;
      charToIndex[pattern[i]] = i + 1;
      stringToIndex[word] = i + 1;
    }

    return i == n;
  }
};",13,520,1.0,1.0,3.0,3.0,40.0,11.0,5.100000000000001
267.0,"class Solution {
 public:
  bool wordPatternMatch(string pattern, string s) {
    return isMatch(pattern, 0, s, 0, unordered_map<char, string>(),
                   unordered_set<string>());
  }

 private:
  bool isMatch(const string& pattern, int i, const string& s, int j,
               unordered_map<char, string>&& charToString,
               unordered_set<string>&& seen) {
    if (i == pattern.length() && j == s.length())
      return true;
    if (i == pattern.length() || j == s.length())
      return false;

    const char c = pattern[i];

    if (const auto it = charToString.find(c); it != cend(charToString)) {
      const string& t = it->second;
      // Check if we can match t w/ s[j:]
      if (s.substr(j).find(t) == string::npos)
        return false;

      // If can match, so continue match the rest
      return isMatch(pattern, i + 1, s, j + t.length(), move(charToString),
                     move(seen));
    }

    for (int k = j; k < s.length(); ++k) {
      const string& t = s.substr(j, k - j + 1);

      // This string is already mapped by other character
      if (seen.count(t))
        continue;

      charToString[c] = t;
      seen.insert(t);

      if (isMatch(pattern, i + 1, s, k + 1, move(charToString), move(seen)))
        return true;

      // Backtracking
      charToString.erase(c);
      seen.erase(t);
    }

    return false;
  }
};",19,1388,4.0,0.0,5.0,9.0,73.05263157894737,27.0,0.5852631578947367
268.0,"class Solution {
 public:
  bool canWinNim(int n) {
    return n % 4 != 0;
  }
};",2,81,0.0,0.0,2.0,0.0,40.5,3.0,5.935
269.0,"class Solution {
 public:
  vector<string> generatePossibleNextMoves(string currentState) {
    vector<string> ans;

    for (int i = 0; i + 1 < currentState.length(); ++i)
      if (currentState[i] == '+' && currentState[i + 1] == '+')
        ans.push_back(currentState.substr(0, i) + ""--"" +
                      currentState.substr(i + 2));

    return ans;
  }
};",6,368,0.0,2.0,2.0,2.0,61.333333333333336,5.0,3.74
270.0,"class Solution {
 public:
  bool canWin(string currentState) {
    const auto it = memo.find(currentState);
    if (it == cend(memo))
      return it->second;

    // If any of currentState[i:i + 2] == ""++"" and your friend can't win after
    // Changing currentState[i:i + 2] to ""--"" (or ""-""), then you can win
    for (int i = 0; i + 1 < currentState.length(); ++i)
      if (currentState[i] == '+' && currentState[i + 1] == '+' &&
          !canWin(currentState.substr(0, i) + '-' + currentState.substr(i + 2)))
        return memo[currentState] = true;

    return memo[currentState] = false;
  }

 private:
  unordered_map<string, bool> memo;
};",8,650,2.0,1.0,2.0,4.0,81.25,7.0,1.887500000000001
271.0,"class MedianFinder {
 public:
  void addNum(int num) {
    if (maxHeap.empty() || num <= maxHeap.top())
      maxHeap.push(num);
    else
      minHeap.push(num);

    // Balance two heaps s.t.
    // |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1
    if (maxHeap.size() < minHeap.size())
      maxHeap.push(minHeap.top()), minHeap.pop();
    else if (maxHeap.size() - minHeap.size() > 1)
      minHeap.push(maxHeap.top()), maxHeap.pop();
  }

  double findMedian() {
    if (maxHeap.size() == minHeap.size())
      return (maxHeap.top() + minHeap.top()) / 2.0;
    return maxHeap.top();
  }

 private:
  priority_queue<int> maxHeap;
  priority_queue<int, vector<int>, greater<>> minHeap;
};",9,698,2.0,5.0,3.0,4.0,77.55555555555556,7.0,1.92
272.0,"class Solution {
 public:
  int minTotalDistance(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<int> I;  // I indices s.t. grid[i][j] == 1
    vector<int> J;  // J indices s.t. grid[i][j] == 1

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j])
          I.push_back(i);

    for (int j = 0; j < n; ++j)
      for (int i = 0; i < m; ++i)
        if (grid[i][j])
          J.push_back(j);

    // Sum(i - median(I)) + sum(j - median(J))
    return minTotalDistance(I) + minTotalDistance(J);
  }

 private:
  int minTotalDistance(const vector<int>& grid) {
    int sum = 0;
    int i = 0;
    int j = grid.size() - 1;

    while (i < j)
      sum += grid[j--] - grid[i++];

    return sum;
  }
};",21,791,3.0,6.0,3.0,7.0,37.66666666666666,19.0,4.29
273.0,"class Codec {
 public:
  // Encodes a tree to a single string.
  string serialize(TreeNode* root) {
    if (root == nullptr)
      return """";

    string s;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      TreeNode* node = q.front();
      q.pop();
      if (node != nullptr) {
        s += to_string(node->val) + "" "";
        q.push(node->left);
        q.push(node->right);
      } else {
        s += ""n "";
      }
    }

    return s;
  }

  // Decodes your encoded data to tree.
  TreeNode* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    string word;
    iss >> word;
    TreeNode* root = new TreeNode(stoi(word));
    queue<TreeNode*> q{{root}};

    while (iss >> word) {
      TreeNode* node = q.front();
      q.pop();
      if (word != ""n"") {
        node->left = new TreeNode(stoi(word));
        q.push(node->left);
      }
      iss >> word;
      if (word != ""n"") {
        node->right = new TreeNode(stoi(word));
        q.push(node->right);
      }
    }

    return root;
  }
};",25,1068,2.0,5.0,13.0,7.0,42.72,6.0,4.5552
274.0,"class Solution {
 public:
  int longestConsecutive(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return dfs(root, root->val, 0, 0);
  }

 private:
  int dfs(TreeNode* root, int target, int length, int maxLength) {
    if (root == nullptr)
      return maxLength;
    if (root->val == target)
      maxLength = max(maxLength, ++length);
    else
      length = 1;
    return max(dfs(root->left, root->val + 1, length, maxLength),
               dfs(root->right, root->val + 1, length, maxLength));
  }
};",7,520,0.0,1.0,3.0,3.0,74.28571428571429,6.0,2.474285714285714
275.0,"class Solution {
 public:
  string getHint(string secret, string guess) {
    int A = 0;
    int B = 0;
    vector<int> count1(10);
    vector<int> count2(10);

    for (int i = 0; i < secret.length(); ++i)
      if (secret[i] == guess[i])
        ++A;
      else {
        ++count1[secret[i] - '0'];
        ++count2[guess[i] - '0'];
      }

    for (int i = 0; i < 10; ++i)
      B += min(count1[i], count2[i]);

    return to_string(A) + ""A"" + to_string(B) + ""B"";
  }
};",14,474,0.0,4.0,3.0,3.0,33.857142857142854,10.0,5.532857142857143
276.0,"class Solution {
 public:
  int lengthOfLIS(vector<int>& nums) {
    if (nums.empty())
      return 0;

    // dp[i] := Length of LIS ending at nums[i]
    vector<int> dp(nums.size(), 1);

    for (int i = 1; i < nums.size(); ++i)
      for (int j = 0; j < i; ++j)
        if (nums[j] < nums[i])
          dp[i] = max(dp[i], dp[j] + 1);

    return *max_element(begin(dp), end(dp));
  }
};",9,389,1.0,3.0,2.0,4.0,43.22222222222222,6.0,5.25
277.0,"class Solution {
 public:
  vector<string> removeInvalidParentheses(string s) {
    vector<string> ans;
    const auto [l, r] = getLeftAndRightCounts(s);
    dfs(s, 0, l, r, ans);
    return ans;
  }

 private:
  // Similar to 921. Minimum Add to Make Parentheses Valid
  // Returns how many '(' and ')' need to be deleted
  pair<int, int> getLeftAndRightCounts(const string& s) {
    int l = 0;
    int r = 0;

    for (const char c : s)
      if (c == '(')
        ++l;
      else if (c == ')') {
        if (l == 0)
          ++r;
        else
          --l;
      }

    return {l, r};
  }

  void dfs(const string& s, int start, int l, int r, vector<string>& ans) {
    if (l == 0 && r == 0 && isValid(s)) {
      ans.push_back(s);
      return;
    }

    for (int i = start; i < s.length(); ++i) {
      if (i > start && s[i] == s[i - 1])
        continue;
      if (l > 0 && s[i] == '(')  // Delete s[i]
        dfs(s.substr(0, i) + s.substr(i + 1), i, l - 1, r, ans);
      if (r > 0 && s[i] == ')')  // Delete s[i]
        dfs(s.substr(0, i) + s.substr(i + 1), i, l, r - 1, ans);
    }
  }

  bool isValid(const string& s) {
    int count = 0;  // # of '(' - # of ')'

    for (const char c : s) {
      if (c == '(')
        ++count;
      else if (c == ')')
        --count;
      if (count < 0)
        return false;
    }

    return true;  // Count == 0
  }
};",23,1375,6.0,11.0,10.0,13.0,59.78260869565217,27.0,0.8995652173913058
278.0,"class Solution {
 public:
  int minArea(vector<vector<char>>& image, int x, int y) {
    const int m = image.size();
    const int n = image[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    vector<int> topLeft{x, y};
    vector<int> bottomRight{x, y};
    queue<pair<int, int>> q{{{x, y}}};
    image[x][y] = '2';  // Visited

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int r = i + dirs[k];
        const int c = j + dirs[k + 1];
        if (r < 0 || r == m || c < 0 || c == n)
          continue;
        if (image[r][c] != '1')
          continue;
        topLeft[0] = min(topLeft[0], r);
        topLeft[1] = min(topLeft[1], c);
        bottomRight[0] = max(bottomRight[0], r);
        bottomRight[1] = max(bottomRight[1], c);
        q.emplace(r, c);
        image[r][c] = '2';
      }
    }

    const int width = bottomRight[1] - topLeft[1] + 1;
    const int height = bottomRight[0] - topLeft[0] + 1;
    return width * height;
  }
};",25,1035,1.0,2.0,10.0,4.0,41.4,25.0,3.094000000000001
279.0,"class NumArray {
 public:
  NumArray(vector<int>& nums) : prefix(nums.size() + 1) {
    partial_sum(begin(nums), end(nums), begin(prefix) + 1);
  }

  int sumRange(int left, int right) {
    return prefix[right + 1] - prefix[left];
  }

 private:
  vector<int> prefix;
};",4,271,0.0,0.0,3.0,0.0,67.75,6.0,3.1225000000000005
280.0,"class NumMatrix {
 public:
  NumMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty())
      return;

    const int m = matrix.size();
    const int n = matrix[0].size();
    // prefix[i][j] := sum of matrix[0..i)[0..j)
    prefix.resize(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            matrix[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];
  }

  int sumRegion(int row1, int col1, int row2, int col2) {
    return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1] -
           prefix[row2 + 1][col1] + prefix[row1][col1];
  }

 private:
  vector<vector<int>> prefix;
};",12,681,1.0,2.0,3.0,3.0,56.75,15.0,3.1325000000000003
281.0,"class UnionFind {
 public:
  vector<int> id;

  UnionFind(int n) : id(n, -1), rank(n) {}

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> rank;
};

class Solution {
 public:
  vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
    const vector<int> dirs{0, 1, 0, -1, 0};
    vector<int> ans;
    vector<vector<bool>> seen(m, vector<bool>(n));
    UnionFind uf(m * n);
    int count = 0;

    for (const vector<int>& p : positions) {
      const int i = p[0];
      const int j = p[1];
      if (seen[i][j]) {
        ans.push_back(count);
        continue;
      }
      seen[i][j] = true;
      const int id = getId(i, j, n);
      uf.id[id] = id;
      ++count;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        const int neighborId = getId(x, y, n);
        if (uf.id[neighborId] == -1)  // Water
          continue;
        const int currentRoot = uf.find(id);
        const int neighborRoot = uf.find(neighborId);
        if (currentRoot != neighborRoot) {
          uf.unionByRank(currentRoot, neighborRoot);
          --count;
        }
      }
      ans.push_back(count);
    }

    return ans;
  }

 private:
  int getId(int i, int j, int n) {
    return i * n + j;
  }
};",39,1676,1.0,5.0,15.0,9.0,42.97435897435897,47.0,0.2723076923076899
282.0,"class Solution {
 public:
  bool isAdditiveNumber(string num) {
    const int n = num.length();

    // num[0..i] = firstNum
    for (int i = 0; i < n / 2; ++i) {
      if (i > 0 && num[0] == '0')
        return false;
      const long firstNum = stol(num.substr(0, i + 1));
      // num[i + 1..j] = secondNum
      // Len(thirdNum) >= max(len(firstNum), len(secondNum))
      for (int j = i + 1; max(i, j - i) < n - j; ++j) {
        if (j > i + 1 && num[i + 1] == '0')
          break;
        const long secondNum = stol(num.substr(i + 1, j - i));
        if (dfs(num, firstNum, secondNum, j + 1))
          return true;
      }
    }

    return false;
  }

 private:
  bool dfs(const string& num, long firstNum, long secondNum, long s) {
    if (s == num.length())
      return true;

    const long thirdNum = firstNum + secondNum;
    const string& thirdNumStr = to_string(thirdNum);
    return num.find(thirdNumStr, s) == s &&
           dfs(num, secondNum, thirdNum, s + thirdNumStr.length());
  }
};",16,1009,3.0,1.0,5.0,6.0,63.0625,15.0,2.5843750000000005
283.0,"class FenwickTree {
 public:
  FenwickTree(int m, int n) : sums(m + 1, vector<int>(n + 1)) {}

  void update(int row, int col, int delta) {
    for (int i = row; i < sums.size(); i += i & -i)
      for (int j = col; j < sums[0].size(); j += j & -j)
        sums[i][j] += delta;
  }

  int get(int row, int col) {
    int sum = 0;
    for (int i = row; i > 0; i -= i & -i)
      for (int j = col; j > 0; j -= j & -j)
        sum += sums[i][j];
    return sum;
  }

 private:
  vector<vector<int>> sums;
};

class NumMatrix {
 public:
  NumMatrix(vector<vector<int>>& matrix)
      : matrix(matrix), tree(matrix.size(), matrix[0].size()) {
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = 0; j < matrix[0].size(); ++j)
        tree.update(i + 1, j + 1, matrix[i][j]);
  }

  void update(int row, int col, int val) {
    tree.update(row + 1, col + 1, val - matrix[row][col]);
    matrix[row][col] = val;
  }

  int sumRegion(int row1, int col1, int row2, int col2) {
    return tree.get(row2 + 1, col2 + 1) - tree.get(row1, col2 + 1) -
           tree.get(row2 + 1, col1) + tree.get(row1, col1);
  }

 private:
  vector<vector<int>> matrix;
  FenwickTree tree;
};",25,1174,0.0,5.0,8.0,6.0,46.96,31.0,1.8935999999999995
284.0,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
    int sell = 0;
    int hold = INT_MIN;
    int prev = 0;

    for (const int price : prices) {
      const int cache = sell;
      sell = max(sell, hold + price);
      hold = max(hold, prev - price);
      prev = cache;
    }

    return sell;
  }
};",9,319,0.0,1.0,3.0,1.0,35.44444444444444,10.0,5.570000000000001
285.0,"class Solution {
 public:
  vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
    if (n == 1 || edges.empty())
      return {0};

    vector<int> ans;
    unordered_map<int, unordered_set<int>> graph;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].insert(v);
      graph[v].insert(u);
    }

    for (const auto& [label, children] : graph)
      if (children.size() == 1)
        ans.push_back(label);

    while (n > 2) {
      n -= ans.size();
      vector<int> nextLeaves;
      for (const int leaf : ans) {
        const int u = *begin(graph[leaf]);
        graph[u].erase(leaf);
        if (graph[u].size() == 1)
          nextLeaves.push_back(u);
      }
      ans = nextLeaves;
    }

    return ans;
  }
};",16,803,0.0,6.0,6.0,7.0,50.1875,19.0,2.863125
286.0,"class Solution {
 public:
  vector<vector<int>> multiply(vector<vector<int>>& mat1,
                               vector<vector<int>>& mat2) {
    const int m = mat1.size();
    const int n = mat2.size();
    const int l = mat2[0].size();
    vector<vector<int>> ans(m, vector<int>(l));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < l; ++j)
        for (int k = 0; k < n; ++k)
          ans[i][j] += mat1[i][k] * mat2[k][j];

    return ans;
  }
};",13,462,0.0,3.0,2.0,3.0,35.53846153846154,15.0,5.001538461538462
287.0,"class Solution {
 public:
  int maxCoins(vector<int>& nums) {
    const int n = nums.size();

    nums.insert(begin(nums), 1);
    nums.insert(end(nums), 1);

    // dp[i][j] := maxCoins(nums[i..j])
    dp.resize(n + 2, vector<int>(n + 2));
    return maxCoins(nums, 1, n);
  }

 private:
  vector<vector<int>> dp;

  int maxCoins(vector<int>& nums, int i, int j) {
    if (i > j)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    for (int k = i; k <= j; ++k)
      dp[i][j] = max(dp[i][j],                                              //
                     maxCoins(nums, i, k - 1) + maxCoins(nums, k + 1, j) +  //
                         nums[i - 1] * nums[k] * nums[j + 1]);

    return dp[i][j];
  }
};",13,725,3.0,0.0,3.0,3.0,55.76923076923077,12.0,3.720769230769231
288.0,"class Solution {
 public:
  int nthSuperUglyNumber(int n, vector<int>& primes) {
    const int k = primes.size();
    vector<int> indices(k);
    vector<int> uglyNums{1};

    while (uglyNums.size() < n) {
      vector<int> nexts(k);
      for (int i = 0; i < k; ++i)
        nexts[i] = uglyNums[indices[i]] * primes[i];
      const int next = *min_element(begin(nexts), end(nexts));
      for (int i = 0; i < k; ++i)
        if (next == nexts[i])
          ++indices[i];
      uglyNums.push_back(next);
    }

    return uglyNums.back();
  }
};",14,545,0.0,4.0,4.0,4.0,38.92857142857143,13.0,4.716428571428571
289.0,"class Solution {
 public:
  vector<vector<int>> verticalOrder(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> range(2);
    getRange(root, range, 0);  // Get the leftmost and rightmost x index

    vector<vector<int>> ans(range[1] - range[0] + 1);
    queue<pair<TreeNode*, int>> q{{{root, -range[0]}}};  // (TreeNode, x)

    while (!q.empty()) {
      const auto [node, x] = q.front();
      q.pop();
      ans[x].push_back(node->val);
      if (node->left)
        q.emplace(node->left, x - 1);
      if (node->right)
        q.emplace(node->right, x + 1);
    }

    return ans;
  }

 private:
  void getRange(TreeNode* root, vector<int>& range, int x) {
    if (root == nullptr)
      return;

    range[0] = min(range[0], x);
    range[1] = max(range[1], x);

    getRange(root->left, range, x - 1);
    getRange(root->right, range, x + 1);
  }
};",17,882,2.0,3.0,8.0,5.0,51.88235294117647,9.0,3.85058823529412
290.0,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  vector<int> countSmaller(vector<int>& nums) {
    vector<int> ans(nums.size());
    unordered_map<int, int> ranks;
    getRanks(nums, ranks);
    FenwickTree tree(ranks.size());

    for (int i = nums.size() - 1; i >= 0; --i) {
      const int num = nums[i];
      ans[i] = tree.get(ranks[num] - 1);
      tree.update(ranks[num], 1);
    }

    return ans;
  }

 private:
  void getRanks(const vector<int>& nums, unordered_map<int, int>& ranks) {
    set<int> sorted(begin(nums), end(nums));
    int rank = 0;
    for (const int num : sorted)
      ranks[num] = ++rank;
  }
};",23,1020,0.0,2.0,11.0,4.0,44.34782608695652,30.0,2.2286956521739123
291.0,"class Solution {
 public:
  string removeDuplicateLetters(string s) {
    string ans;
    vector<int> count(128);
    vector<bool> used(128);

    for (const char c : s)
      ++count[c];

    for (const char c : s) {
      --count[c];
      if (used[c])
        continue;
      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {
        used[ans.back()] = false;
        ans.pop_back();
      }
      used[c] = true;
      ans.push_back(c);
    }

    return ans;
  }
};",12,486,0.0,3.0,4.0,4.0,40.5,10.0,4.9350000000000005
292.0,"class Solution {
 public:
  int shortestDistance(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const int nBuildings = getBuildingCount(grid);
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = INT_MAX;
    // dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1)
    vector<vector<int>> dist(m, vector<int>(n));
    // reachCount[i][j] := # of buildings (1) grid[i][j] (0) can reach
    vector<vector<int>> reachCount(m, vector<int>(n));

    auto bfs = [&](int row, int col) -> bool {
      queue<pair<int, int>> q{{{row, col}}};
      vector<vector<bool>> seen(m, vector<bool>(n));
      seen[row][col] = true;
      int depth = 0;
      int seenBuildings = 1;

      while (!q.empty()) {
        ++depth;
        for (int sz = q.size(); sz > 0; --sz) {
          const auto [i, j] = q.front();
          q.pop();
          for (int k = 0; k < 4; ++k) {
            const int x = i + dirs[k];
            const int y = j + dirs[k + 1];
            if (x < 0 || x == m || y < 0 || y == n)
              continue;
            if (seen[x][y])
              continue;
            seen[x][y] = true;
            if (!grid[x][y]) {
              dist[x][y] += depth;
              ++reachCount[x][y];
              q.emplace(x, y);
            } else if (grid[x][y] == 1) {
              ++seenBuildings;
            }
          }
        }
      }

      return seenBuildings == nBuildings;
    };

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)  // Bfs from this building
          if (!bfs(i, j))
            return -1;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (reachCount[i][j] == nBuildings)
          ans = min(ans, dist[i][j]);

    return ans == INT_MAX ? -1 : ans;
  }

 private:
  int getBuildingCount(vector<vector<int>>& grid) {
    return accumulate(begin(grid), end(grid), 0, [](int s, vector<int>& row) {
      return s + count(begin(row), end(row), 1);
    });
  }
};",44,2043,3.0,9.0,14.0,14.0,46.43181818181818,40.0,0.5611363636363613
293.0,"class Solution {
 public:
  int maxProduct(vector<string>& words) {
    size_t ans = 0;
    vector<int> masks;

    for (const string& word : words)
      masks.push_back(getMask(word));

    for (int i = 0; i < words.size(); ++i)
      for (int j = 0; j < i; ++j)
        if ((masks[i] & masks[j]) == 0)
          ans = max(ans, words[i].length() * words[j].length());

    return ans;
  }

 private:
  int getMask(const string& word) {
    int mask = 0;
    for (const char c : word)
      mask |= 1 << c - 'a';
    return mask;
  }
};",13,537,0.0,4.0,3.0,5.0,41.30769230769231,14.0,4.462307692307692
294.0,"class Solution {
 public:
  int bulbSwitch(int n) {
    // K-th bulb only be switched when k % i == 0.
    // So we can reiterate the problem:
    // To find # of number <= n that have odd factors.
    // Obviously, only square numbers have odd factor(s).
    // E.g. n = 10, only 1, 4, and 9 are square numbers that <= 10
    return sqrt(n);
  }
};",2,349,5.0,0.0,2.0,0.0,174.5,3.0,-5.925000000000001
295.0,"class Solution {
 public:
  vector<string> generateAbbreviations(string word) {
    vector<string> ans;
    dfs(word, 0, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& word, int i, int count, vector<string>&& path,
           vector<string>& ans) {
    if (i == word.length()) {
      ans.push_back(join(path) + getCountString(count));
      return;
    }

    // Abbreviate word[i]
    dfs(word, i + 1, count + 1, move(path), ans);
    // Keep word[i], so consume the count as a string
    path.push_back(getCountString(count) + word[i]);
    dfs(word, i + 1, 0, move(path), ans);  // Reset count to 0
    path.pop_back();
  }

  string getCountString(int count) {
    return count > 0 ? to_string(count) : """";
  }

  string join(const vector<string>& path) {
    string joined;
    for (const string& s : path)
      joined += s;
    return joined;
  };
};",15,880,3.0,-1.0,7.0,2.0,58.66666666666666,20.0,2.4800000000000004
296.0,"class Solution {
 public:
  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
    vector<int> ans;

    for (int k1 = 0; k1 <= k; ++k1) {
      const int k2 = k - k1;
      if (k1 > nums1.size() || k2 > nums2.size())
        continue;
      ans = max(ans, maxNumber(maxNumber(nums1, k1), maxNumber(nums2, k2)));
    }

    return ans;
  }

 private:
  vector<int> maxNumber(const vector<int>& nums, int k) {
    if (k == 0)
      return {};

    vector<int> ans;
    int toPop = nums.size() - k;

    for (const int num : nums) {
      while (!ans.empty() && ans.back() < num && toPop-- > 0)
        ans.pop_back();
      ans.push_back(num);
    }

    return {begin(ans), begin(ans) + k};
  }

 private:
  vector<int> maxNumber(const vector<int>& nums1, const vector<int>& nums2) {
    vector<int> ans;

    auto s1 = cbegin(nums1);
    auto s2 = cbegin(nums2);

    while (s1 != cend(nums1) || s2 != cend(nums2))
      if (lexicographical_compare(s1, cend(nums1), s2, cend(nums2)))
        ans.push_back(*s2++);
      else
        ans.push_back(*s1++);

    return ans;
  }
};",20,1099,0.0,4.0,8.0,7.0,54.95,23.0,2.0344999999999995
297.0,"class Solution {
 public:
  int coinChange(vector<int>& coins, int amount) {
    // dp[i] := fewest # of coins to make up i
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;

    for (const int coin : coins)
      for (int i = coin; i <= amount; ++i)
        dp[i] = min(dp[i], dp[i - coin] + 1);

    return dp[amount] == amount + 1 ? -1 : dp[amount];
  }
};",7,368,1.0,2.0,2.0,2.0,52.57142857142857,8.0,4.268571428571429
298.0,"class Solution {
 public:
  int countComponents(int n, vector<vector<int>>& edges) {
    int ans = 0;
    vector<vector<int>> graph(n);
    unordered_set<int> seen;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i)
      if (!seen.count(i)) {
        bfs(graph, i, seen);
        ++ans;
      }

    return ans;
  }

 private:
  void bfs(const vector<vector<int>>& graph, int node,
           unordered_set<int>& seen) {
    queue<int> q{{node}};
    seen.insert(node);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      for (const int v : graph[u])
        if (!seen.count(v)) {
          q.push(v);
          seen.insert(v);
        }
    }
  }
};",19,826,0.0,6.0,9.0,6.0,43.47368421052632,24.0,2.787368421052632
299.0,"class Solution {
 public:
  void wiggleSort(vector<int>& nums) {
    const int n = nums.size();
    const auto it = begin(nums) + n / 2;
    nth_element(begin(nums), it, end(nums));
    const int median = *it;

// Index-rewiring
#define A(i) nums[(1 + 2 * i) % (n | 1)]

    for (int i = 0, j = 0, k = n - 1; i <= k;)
      if (A(i) > median)
        swap(A(i++), A(j++));
      else if (A(i) < median)
        swap(A(i), A(k--));
      else
        ++i;
  }
};",10,461,1.0,6.0,2.0,3.0,46.1,9.0,4.510999999999999
300.0,"class Solution {
 public:
  int maxSubArrayLen(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      const int target = prefix - k;
      if (const auto it = prefixToIndex.find(target); it != cend(prefixToIndex))
        ans = max(ans, i - it->second);
      if (!prefixToIndex.count(prefix))
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};",12,496,0.0,3.0,5.0,3.0,41.333333333333336,12.0,4.6000000000000005
301.0,"class Solution {
 public:
  bool isPowerOfThree(int n) {
    return n > 0 && static_cast<int>(pow(3, 19)) % n == 0;
  }
};",2,122,0.0,0.0,2.0,0.0,61.0,4.0,3.9899999999999993
302.0,"class Solution {
 public:
  int countRangeSum(vector<int>& nums, int lower, int upper) {
    const int n = nums.size();
    int ans = 0;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + nums[i]);

    mergeSort(prefix, 0, n, lower, upper, ans);
    return ans;
  }

 private:
  void mergeSort(vector<long>& prefix, int l, int r, int lower, int upper,
                 int& ans) {
    if (l >= r)
      return;

    const int m = (l + r) / 2;
    mergeSort(prefix, l, m, lower, upper, ans);
    mergeSort(prefix, m + 1, r, lower, upper, ans);
    merge(prefix, l, m, r, lower, upper, ans);
  }

  void merge(vector<long>& prefix, int l, int m, int r, int lower, int upper,
             int& ans) {
    int lo = m + 1;  // 1st index s.t. prefix[lo] - prefix[i] >= lower
    int hi = m + 1;  // 1st index s.t. prefix[hi] - prefix[i] > upper

    // For each index i in range [l, m], add hi - lo to ans
    for (int i = l; i <= m; ++i) {
      while (lo <= r && prefix[lo] - prefix[i] < lower)
        ++lo;
      while (hi <= r && prefix[hi] - prefix[i] <= upper)
        ++hi;
      ans += hi - lo;
    }

    vector<long> sorted(r - l + 1);
    int k = 0;      // sorted's index
    int i = l;      // left's index
    int j = m + 1;  // right's index

    while (i <= m && j <= r)
      if (prefix[i] < prefix[j])
        sorted[k++] = prefix[i++];
      else
        sorted[k++] = prefix[j++];

    // Put possible remaining left part to the sorted array
    while (i <= m)
      sorted[k++] = prefix[i++];

    // Put possible remaining right part to the sorted array
    while (j <= r)
      sorted[k++] = prefix[j++];

    copy(begin(sorted), end(sorted), begin(prefix) + l);
  }
};",30,1737,8.0,9.0,6.0,10.0,57.9,30.0,1.2090000000000032
303.0,"class Solution {
 public:
  ListNode* oddEvenList(ListNode* head) {
    ListNode oddHead(0);
    ListNode evenHead(0);
    ListNode* odd = &oddHead;
    ListNode* even = &evenHead;

    for (int isOdd = 0; head; head = head->next)
      if (isOdd ^= 1) {
        odd->next = head;
        odd = odd->next;
      } else {
        even->next = head;
        even = even->next;
      }

    odd->next = evenHead.next;
    even->next = nullptr;
    return oddHead.next;
  }
};",14,472,0.0,3.0,4.0,2.0,33.714285714285715,2.0,6.345714285714285
304.0,"class Solution {
 public:
  int longestIncreasingPath(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;
    vector<vector<int>> memo(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        ans = max(ans, dfs(matrix, i, j, INT_MIN, memo));

    return ans;
  }

 private:
  // memo[i][j] := the LIP starting from matrix[i][j]
  int dfs(const vector<vector<int>>& matrix, int i, int j, int prev,
          vector<vector<int>>& memo) {
    if (i < 0 || i == matrix.size() || j < 0 || j == matrix[0].size())
      return 0;
    if (matrix[i][j] <= prev)
      return 0;
    int& ans = memo[i][j];
    if (ans > 0)
      return ans;

    const int curr = matrix[i][j];
    return ans = 1 + max({dfs(matrix, i + 1, j, curr, memo),
                          dfs(matrix, i - 1, j, curr, memo),
                          dfs(matrix, i, j + 1, curr, memo),
                          dfs(matrix, i, j - 1, curr, memo)});
  }
};",17,1022,1.0,1.0,4.0,5.0,60.11764705882353,22.0,2.129411764705883
305.0,"class Solution {
 public:
  int minPatches(vector<int>& nums, int n) {
    int ans = 0;
    int i = 0;      // Point to nums
    long miss = 1;  // Min sum in [1, n] we might miss

    while (miss <= n)
      if (i < nums.size() && nums[i] <= miss) {
        miss += nums[i++];
      } else {
        // Greedily add miss itself to increase the range
        // From [1, miss) to [1, 2 * miss)
        miss += miss;
        ++ans;
      }

    return ans;
  }
};",8,462,4.0,3.0,4.0,2.0,57.75,6.0,3.942500000000001
306.0,"class Solution {
 public:
  bool isValidSerialization(string preorder) {
    int degree = 1;  // OutDegree (children) - inDegree (parent)
    istringstream iss(preorder);

    for (string node; getline(iss, node, ',');) {
      if (--degree < 0)
        return false;
      if (node != ""#"")
        degree += 2;
    }

    return degree == 0;
  }
};",8,349,1.0,2.0,3.0,3.0,43.625,5.0,5.313750000000001
307.0,"class Solution {
 public:
  vector<string> findItinerary(vector<vector<string>>& tickets) {
    vector<string> ans;
    unordered_map<string, multiset<string>> graph;

    for (const vector<string>& ticket : tickets)
      graph[ticket[0]].insert(ticket[1]);

    dfs(graph, ""JFK"", ans);
    reverse(begin(ans), end(ans));
    return ans;
  }

 private:
  void dfs(unordered_map<string, multiset<string>>& graph, const string& u,
           vector<string>& ans) {
    while (graph.count(u) && !graph[u].empty()) {
      const string v = *begin(graph[u]);
      graph[u].erase(begin(graph[u]));
      dfs(graph, v, ans);
    }
    ans.push_back(u);
  }
};",11,654,0.0,2.0,4.0,2.0,59.45454545454545,16.0,2.6890909090909085
308.0,"struct T {
  int min;   // Min value in the subtree
  int max;   // Max value in the subtree
  int size;  // Total size of the subtree
};

class Solution {
 public:
  int largestBSTSubtree(TreeNode* root) {
    return dfs(root).size;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {INT_MAX, INT_MIN, 0};

    T l = dfs(root->left);
    T r = dfs(root->right);

    if (l.max < root->val && root->val < r.min)
      return {min(l.min, root->val), max(r.max, root->val),
              1 + l.size + r.size};

    // Mark as invalid one, but still record the size of children
    // Returns (-INF, INF) because any node won't > INT and < -INF
    return {INT_MIN, INT_MAX, max(l.size, r.size)};
  }
};",11,729,5.0,-1.0,7.0,2.0,66.27272727272727,6.0,3.2754545454545454
309.0,"class Solution {
 public:
  bool increasingTriplet(vector<int>& nums) {
    int first = INT_MAX;
    int second = INT_MAX;

    for (const int num : nums)
      if (num <= first)
        first = num;
      else if (num <= second)  // First < num <= second
        second = num;
      else
        return true;  // First < second < num (third)

    return false;
  }
};",7,368,2.0,4.0,2.0,3.0,52.57142857142857,7.0,4.288571428571428
310.0,"class Solution {
 public:
  bool isSelfCrossing(vector<int>& x) {
    if (x.size() <= 3)
      return false;

    for (int i = 3; i < x.size(); ++i) {
      if (x[i - 2] <= x[i] && x[i - 1] <= x[i - 3])
        return true;
      if (i >= 4 && x[i - 1] == x[i - 3] && x[i - 2] <= x[i] + x[i - 4])
        return true;
      if (i >= 5 && x[i - 4] <= x[i - 2] && x[i - 2] <= x[i] + x[i - 4] &&
          x[i - 1] <= x[i - 3] && x[i - 3] <= x[i - 1] + x[i - 5])
        return true;
    }

    return false;
  }
};",8,512,0.0,1.0,3.0,5.0,64.0,4.0,3.6000000000000005
311.0,"class Solution {
 public:
  vector<vector<int>> palindromePairs(vector<string>& words) {
    vector<vector<int>> ans;
    unordered_map<string, int> map;  // {reversed word: its index}

    for (int i = 0; i < words.size(); ++i) {
      string word = words[i];
      reverse(begin(word), end(word));
      map[word] = i;
    }

    for (int i = 0; i < words.size(); ++i) {
      const string& word = words[i];
      // Special case to prevent duplicate calculation
      if (const auto it = map.find("""");
          it != cend(map) && it->second != i && isPalindrome(word))
        ans.push_back({i, it->second});
      for (int j = 1; j <= word.length(); ++j) {
        const string& l = word.substr(0, j);
        const string& r = word.substr(j);
        if (const auto it = map.find(l);
            it != cend(map) && it->second != i && isPalindrome(r))
          ans.push_back({i, it->second});
        if (const auto it = map.find(r);
            it != cend(map) && it->second != i && isPalindrome(l))
          ans.push_back({it->second, i});
      }
    }

    return ans;
  }

 private:
  bool isPalindrome(const string& word) {
    int l = 0;
    int r = word.length() - 1;
    while (l < r)
      if (word[l++] != word[r--])
        return false;
    return true;
  }
};",26,1280,2.0,7.0,10.0,8.0,49.23076923076923,24.0,2.229230769230769
312.0,"struct T {
  int robRoot;
  int notRobRoot;
};

class Solution {
 public:
  int rob(TreeNode* root) {
    const auto& [robRoot, notRobRoot] = robOrNotRob(root);
    return max(robRoot, notRobRoot);
  }

 private:
  T robOrNotRob(TreeNode* root) {
    if (root == nullptr)
      return {0, 0};
    const T l = robOrNotRob(root->left);
    const T r = robOrNotRob(root->right);
    return {root->val + l.notRobRoot + r.notRobRoot,
            max(l.robRoot, l.notRobRoot) + max(r.robRoot, r.notRobRoot)};
  }
};",10,509,0.0,-1.0,6.0,1.0,50.9,8.0,4.319
313.0,"class Solution {
 public:
  vector<int> countBits(int n) {
    // Let f(i) := i's # of 1's in bitmask
    // f(i) = f(i / 2) + i % 2
    vector<int> ans(n + 1);

    for (int i = 1; i <= n; ++i)
      ans[i] = ans[i / 2] + (i & 1);

    return ans;
  }
};",6,255,2.0,1.0,2.0,1.0,42.5,5.0,5.575000000000001
314.0,"class Solution {
 public:
  int depthSum(vector<NestedInteger>& nestedList) {
    int ans = 0;
    int depth = 0;
    queue<NestedInteger> q;

    addIntegers(q, nestedList);

    while (!q.empty()) {
      ++depth;
      for (int sz = q.size(); sz > 0; --sz) {
        const NestedInteger ni = q.front();
        q.pop();
        if (ni.isInteger())
          ans += ni.getInteger() * depth;
        else
          addIntegers(q, ni.getList());
      }
    }

    return ans;
  }

 private:
  void addIntegers(queue<NestedInteger>& q,
                   const vector<NestedInteger>& nestedList) {
    for (const NestedInteger& ni : nestedList)
      q.push(ni);
  }
};",14,669,0.0,5.0,5.0,4.0,47.785714285714285,9.0,4.199285714285715
315.0,"class Solution {
 public:
  int lengthOfLongestSubstringKDistinct(string s, int k) {
    int ans = 0;
    int distinct = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r]] == 1)
        ++distinct;
      while (distinct == k + 1)
        if (--count[s[l++]] == 0)
          --distinct;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",10,403,0.0,4.0,3.0,4.0,40.3,8.0,5.1530000000000005
316.0,"class NestedIterator {
 public:
  NestedIterator(vector<NestedInteger>& nestedList) {
    addInteger(nestedList);
  }

  int next() {
    const int num = q.front();
    q.pop();
    return num;
  }

  bool hasNext() {
    return !q.empty();
  }

 private:
  queue<int> q;

  void addInteger(const vector<NestedInteger>& nestedList) {
    for (const NestedInteger& ni : nestedList)
      if (ni.isInteger())
        q.push(ni.getInteger());
      else
        addInteger(ni.getList());
  }
};",9,491,0.0,2.0,5.0,2.0,54.55555555555556,9.0,3.77
317.0,"class Solution {
 public:
  bool isPowerOfFour(int n) {
    // Why (4^n - 1) % 3 == 0?
    // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are
    // Three consecutive numbers; among one of them, there must be a multiple
    // Of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.
    // Therefore, 4^n - 1 is a multiple of 3.
    return n > 0 && __builtin_popcountll(n) == 1 && (n - 1) % 3 == 0;
  }
};",3,432,5.0,0.0,2.0,1.0,144.0,3.0,-3.18
318.0,"class Solution {
 public:
  int integerBreak(int n) {
    // If an optimal product contains a factor f >= 4, then we can replace it
    // With 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,
    // We never need a factor >= 4, meaning we only need factors 1, 2, and 3
    // (and 1 is wasteful).
    // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.
    if (n == 2)  // 1 * 1
      return 1;
    if (n == 3)  // 1 * 2
      return 2;

    int ans = 1;

    while (n > 4) {
      n -= 3;
      ans *= 3;
    }
    ans *= n;

    return ans;
  }
};",8,591,7.0,1.0,3.0,4.0,73.875,4.0,2.991250000000001
319.0,"class Solution {
 public:
  void reverseString(vector<char>& s) {
    int l = 0;
    int r = s.size() - 1;

    while (l < r)
      swap(s[l++], s[r--]);
  }
};",4,160,0.0,2.0,2.0,1.0,40.0,5.0,5.66
320.0,"class Solution {
 public:
  string reverseVowels(string s) {
    const unordered_set<char> vowels{'a', 'e', 'i', 'o', 'u',
                                     'A', 'E', 'I', 'O', 'U'};
    int l = 0;
    int r = s.length() - 1;

    while (l < r) {
      while (l < r && !vowels.count(s[l]))
        ++l;
      while (l < r && !vowels.count(s[r]))
        --r;
      swap(s[l++], s[r--]);
    }

    return s;
  }
};",8,417,0.0,3.0,4.0,3.0,52.125,7.0,4.18875
321.0,"class MovingAverage {
 public:
  MovingAverage(int size) : size(size) {}

  double next(int val) {
    if (q.size() == size)
      sum -= q.front(), q.pop();
    sum += val;
    q.push(val);
    return sum / q.size();
  }

 private:
  int size;
  double sum = 0;
  queue<int> q;
};",8,281,0.0,1.0,3.0,1.0,35.125,7.0,5.898750000000001
322.0,"struct T {
  int num;
  int freq;
  T(int num, int freq) : num(num), freq(freq) {}
};

class Solution {
 public:
  vector<int> topKFrequent(vector<int>& nums, int k) {
    const int n = nums.size();
    vector<int> ans;
    unordered_map<int, int> count;
    auto compare = [](const T& a, const T& b) { return a.freq > b.freq; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count) {
      minHeap.emplace(num, freq);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    while (!minHeap.empty())
      ans.push_back(minHeap.top().num), minHeap.pop();

    return ans;
  }
};",15,698,0.0,3.0,6.0,4.0,46.53333333333333,19.0,3.372
323.0,"class TicTacToe {
 public:
  TicTacToe(int n) : n(n), rows(n), cols(n) {}

  /**
   * Player {player} makes a move at ({row}, {col}).
   *
   * @param row    The row of the board.
   * @param col    The column of the board.
   * @param player The player, can be either 1 or 2.
   * @return The current winning condition, can be either:
   *         0: No one wins.
   *         1: Player 1 wins.
   *         2: Player 2 wins.
   */
  int move(int row, int col, int player) {
    const int toAdd = player == 1 ? 1 : -1;
    const int target = player == 1 ? n : -n;

    if (row == col) {
      diag += toAdd;
      if (diag == target)
        return player;
    }

    if (row + col == n - 1) {
      antiDiag += toAdd;
      if (antiDiag == target)
        return player;
    }

    rows[row] += toAdd;
    if (rows[row] == target)
      return player;

    cols[col] += toAdd;
    if (cols[col] == target)
      return player;

    return 0;
  }

 private:
  const int n;
  // Record count('X') - count('O')
  vector<int> rows;
  vector<int> cols;
  int diag = 0;
  int antiDiag = 0;
};",17,1088,2.0,1.0,8.0,6.0,64.0,16.0,2.1800000000000006
324.0,"class Solution {
 public:
  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    vector<int> ans;
    unordered_set<int> set{begin(nums1), end(nums1)};

    for (const int num : nums2)
      if (set.erase(num))
        ans.push_back(num);

    return ans;
  }
};",5,280,0.0,2.0,3.0,2.0,56.0,8.0,3.86
325.0,"class Solution {
 public:
  vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() > nums2.size())
      return intersect(nums2, nums1);

    vector<int> ans;
    unordered_map<int, int> count;

    for (const int num : nums1)
      ++count[num];

    for (const int num : nums2)
      if (const auto it = count.find(num);
          it != cend(count) && it->second-- > 0)
        ans.push_back(num);

    return ans;
  }
};",8,453,0.0,3.0,2.0,4.0,56.625,12.0,3.4037500000000005
326.0,"class Solution {
 public:
  int numberOfPatterns(int m, int n) {
    int ans = 0;
    vector<vector<int>> across(10, vector<int>(10));
    vector<bool> seen(10);

    across[1][3] = across[3][1] = 2;
    across[1][7] = across[7][1] = 4;
    across[3][9] = across[9][3] = 6;
    across[7][9] = across[9][7] = 8;
    across[1][9] = across[9][1] = across[2][8] = across[8][2] = across[3][7] =
        across[7][3] = across[4][6] = across[6][4] = 5;

    ans += dfs(m, n, 1, 1, seen, across) * 4;  // 1, 3, 7, 9 are symmetric
    ans += dfs(m, n, 2, 1, seen, across) * 4;  // 2, 4, 6, 8 are symmetric
    ans += dfs(m, n, 5, 1, seen, across);      // 5
    return ans;
  }

 private:
  int dfs(int m, int n, int u, int depth, vector<bool>& seen,
          const vector<vector<int>>& across) {
    if (depth > n)
      return 0;

    seen[u] = true;
    int ans = depth >= m ? 1 : 0;

    for (int v = 1; v <= 9; ++v) {
      if (v == u || seen[v])
        continue;
      const int acrossed = across[u][v];
      if (acrossed == 0 || seen[acrossed])
        ans += dfs(m, n, v, depth + 1, seen, across);
    }

    seen[u] = false;
    return ans;
  }
};",23,1150,3.0,1.0,4.0,4.0,50.0,20.0,3.3200000000000003
327.0,"class SummaryRanges {
 public:
  void addNum(int val) {
    if (map.count(val))
      return;

    const int lo = lowerKey(val);
    const int hi = higherKey(val);

    // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}
    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {
      map[lo][1] = map[hi][1];
      map.erase(hi);
      // {lo, map[lo][1]} + val = {lo, val}
      // (prevent adding duplicate entry by using '>=' instead of '==')
    } else if (lo >= 0 && map[lo][1] + 1 >= val) {
      map[lo][1] = max(map[lo][1], val);
    } else if (hi >= 0 && val + 1 == hi) {
      // Val + {hi, map[hi][1]} = {val, map[hi][1]}
      map[val] = {val, map[hi][1]};
      map.erase(hi);
    } else {
      map[val] = {val, val};
    }
  }

  vector<vector<int>> getIntervals() {
    vector<vector<int>> intervals;
    for (const auto& [_, interval] : map)
      intervals.push_back(interval);
    return intervals;
  }

 private:
  map<int, vector<int>> map;  // {start: {start, end}}

  // Maximum in map < key
  int lowerKey(int key) {
    auto it = map.lower_bound(key);  // Minimum in map >= key
    if (it == begin(map))
      return -1;
    return (--it)->first;
  }

  // Minimum in map > key
  int higherKey(int key) {
    const auto it = map.upper_bound(key);  // Minimum in map > key
    if (it == cend(map))
      return -1;
    return it->first;
  }
};",20,1394,9.0,5.0,20.0,7.0,69.7,17.0,0.8869999999999987
328.0,"class SnakeGame {
 public:
  /** Initialize your data structure here.
     @param width - screen width
     @param height - screen height
     @param food - A list of food positions
     E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the
     second is at [1,0]. */
  SnakeGame(int width, int height, vector<vector<int>>& food)
      : width(width), height(height), food(food) {
    lookup.insert(getId(0, 0));
    body.push_back(getId(0, 0));
  }

  /** Moves the snake.
      @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down
      @return The game's score after the move. Return -1 if game over.
      Game over when snake crosses the screen boundary or bites its body. */
  int move(string direction) {
    // Old head's position
    int i = body.front() / width;
    int j = body.front() % width;

    // Update head's position and check if out of bound
    if (direction == ""U"" && --i < 0)
      return -1;
    if (direction == ""L"" && --j < 0)
      return -1;
    if (direction == ""R"" && ++j == width)
      return -1;
    if (direction == ""D"" && ++i == height)
      return -1;

    const int newHead = getId(i, j);

    // Case 1: eat food and increase size by 1
    if (k < food.size() && i == food[k][0] && j == food[k][1]) {
      lookup.insert(newHead);
      body.push_front(newHead);
      ++k;
      return ++score;
    }

    // Case 2: new head != old tail and eat body!
    if (newHead != body.back() && lookup.count(newHead))
      return -1;

    // Case 3: normal case
    // Remove old tail first (important), then add new head
    // Because new head may be in old tail's position
    lookup.erase(body.back());
    lookup.insert(newHead);
    body.pop_back();
    body.push_front(newHead);

    return score;
  }

 private:
  int width;
  int height;
  int score = 0;
  int k = 0;  // food's index
  vector<vector<int>> food;
  unordered_set<int> lookup;
  deque<int> body;  // snake's body

  int getId(int i, int j) {
    return i * width + j;
  }
};",28,2016,11.0,1.0,5.0,8.0,72.0,20.0,1.599999999999998
329.0,"class Solution {
 public:
  int maxEnvelopes(vector<vector<int>>& envelopes) {
    sort(begin(envelopes), end(envelopes), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];
    });

    // Same as 300. Longest Increasing Subsequence
    int ans = 0;
    vector<int> dp(envelopes.size());

    for (const vector<int>& e : envelopes) {
      int l = 0;
      int r = ans;
      while (l < r) {
        const int m = (l + r) / 2;
        if (dp[m] >= e[1])
          r = m;
        else
          l = m + 1;
      }
      dp[l] = e[1];
      if (l == ans)
        ++ans;
    }

    return ans;
  }
};",13,636,1.0,4.0,5.0,4.0,48.92307692307692,13.0,3.796923076923077
330.0,"struct Tweet {
  int id;
  int time;
  Tweet* next = nullptr;
  Tweet(int id, int time) : id(id), time(time) {}
};

struct User {
  int id;
  unordered_set<int> followeeIds;
  Tweet* tweetHead = nullptr;

  User() {}

  User(int id) : id(id) {
    follow(id);  // Follow himself
  }

  void follow(int followeeId) {
    followeeIds.insert(followeeId);
  }

  void unfollow(int followeeId) {
    followeeIds.erase(followeeId);
  }

  void post(int tweetId, int time) {
    Tweet* oldTweetHead = tweetHead;
    tweetHead = new Tweet(tweetId, time);
    tweetHead->next = oldTweetHead;
  }
};

class Twitter {
 public:
  /** Compose a new tweet. */
  void postTweet(int userId, int tweetId) {
    if (!users.count(userId))
      users[userId] = User(userId);
    users[userId].post(tweetId, time++);
  }

  /**
   * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in
   * the news feed must be posted by users who the user followed or by the user
   * herself. Tweets must be ordered from most recent to least recent.
   */
  vector<int> getNewsFeed(int userId) {
    if (!users.count(userId))
      return {};

    vector<int> newsFeed;

    auto compare = [](const Tweet* a, const Tweet* b) {
      return a->time < b->time;
    };
    priority_queue<Tweet*, vector<Tweet*>, decltype(compare)> maxHeap(compare);

    for (const int followeeId : users[userId].followeeIds) {
      Tweet* tweetHead = users[followeeId].tweetHead;
      if (tweetHead != nullptr)
        maxHeap.push(tweetHead);
    }

    int count = 0;
    while (!maxHeap.empty() && count++ < 10) {
      Tweet* tweet = maxHeap.top();
      maxHeap.pop();
      newsFeed.push_back(tweet->id);
      if (tweet->next)
        maxHeap.push(tweet->next);
    }

    return newsFeed;
  }

  /**
   * Follower follows a followee.
   * If the operation is invalid, it should be a no-op.
   */
  void follow(int followerId, int followeeId) {
    if (followerId == followeeId)
      return;
    if (!users.count(followerId))
      users[followerId] = User(followerId);
    if (!users.count(followeeId))
      users[followeeId] = User(followeeId);
    users[followerId].follow(followeeId);
  }

  /**
   * Follower unfollows a followee.
   * If the operation is invalid, it should be a no-op.
   */
  void unfollow(int followerId, int followeeId) {
    if (followerId == followeeId)
      return;
    if (const auto it = users.find(followerId);
        it != cend(users) && users.count(followeeId))
      it->second.unfollow(followeeId);
  }

 private:
  int time = 0;
  unordered_map<int, User> users;  // {userId: User}
};",39,2605,6.0,7.0,18.0,13.0,66.7948717948718,37.0,-0.9715384615384616
331.0,"class Solution {
 public:
  bool isReflected(vector<vector<int>>& points) {
    int minX = INT_MAX;
    int maxX = INT_MIN;
    unordered_set<pair<int, int>, pairHash> seen;

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      minX = min(minX, x);
      maxX = max(maxX, x);
      seen.insert({x, y});
    }

    const int sum = minX + maxX;
    // (leftX + rightX) / 2 = (minX + maxX) / 2
    //  leftX = minX + maxX - rightX
    // RightX = minX + maxX - leftX

    for (const vector<int>& p : points)
      if (!seen.count({sum - p[0], p[1]}))
        return false;

    return true;
  }

 private:
  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",14,771,3.0,1.0,7.0,3.0,55.07142857142857,22.0,2.483571428571429
332.0,"class Solution {
 public:
  int countNumbersWithUniqueDigits(int n) {
    if (n == 0)
      return 1;

    int ans = 10;
    int uniqueDigits = 9;

    for (int availableNum = 9; n > 1 && availableNum > 0; --n, --availableNum) {
      uniqueDigits *= availableNum;
      ans += uniqueDigits;
    }

    return ans;
  }
};",9,321,0.0,1.0,3.0,2.0,35.666666666666664,6.0,5.95
333.0,"class Solution {
 public:
  string rearrangeString(string s, int k) {
    const int n = s.length();
    string ans;
    vector<int> count(128);
    vector<int> valid(128);  // valid[i] := the leftmost index char i can appear

    for (const char c : s)
      ++count[c];

    for (int i = 0; i < n; ++i) {
      const char c = getBestLetter(count, valid, i);
      if (c == '*')
        return """";
      ans += c;
      --count[c];
      valid[c] = i + k;
    }

    return ans;
  }

  // Returns the letter that has most count and also valid
 private:
  char getBestLetter(const vector<int>& count, const vector<int>& valid,
                     int index) {
    int maxCount = -1;
    char bestLetter = '*';

    for (char c = 'a'; c <= 'z'; ++c)
      if (count[c] > 0 && count[c] > maxCount && index >= valid[c]) {
        bestLetter = c;
        maxCount = count[c];
      }

    return bestLetter;
  }
};",21,910,2.0,3.0,5.0,5.0,43.333333333333336,24.0,3.3
334.0,"class Solution {
 public:
  vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {
    const int n = nums.size();
    const bool upward = a > 0;
    vector<int> ans(n);
    vector<int> quad;

    for (const int num : nums)
      quad.push_back(f(num, a, b, c));

    int i = upward ? n - 1 : 0;
    for (int l = 0, r = n - 1; l <= r;)
      if (upward)  // Maximum in both ends
        ans[i--] = quad[l] > quad[r] ? quad[l++] : quad[r--];
      else  // Minimum in both ends
        ans[i++] = quad[l] < quad[r] ? quad[l++] : quad[r--];

    return ans;
  }

 private:
  // The concavity of f only depends on a's sign
  int f(int x, int a, int b, int c) {
    return (a * x + b) * x + c;
  }
};",13,715,3.0,3.0,3.0,4.0,55.0,21.0,2.71
335.0,"class Solution {
 public:
  int maxKilledEnemies(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int enemyCount = 0;
    // dp[i][j] := max enemies grid[i][j] can kill
    vector<vector<int>> dp(m, vector<int>(n));

    auto update = [&](int i, int j) {
      if (grid[i][j] == '0')
        dp[i][j] += enemyCount;
      else if (grid[i][j] == 'E')
        ++enemyCount;
      else  // grid[i][j] == 'W'
        enemyCount = 0;
    };

    // Extend four directions, if meet 'W', need to start over from 0
    for (int i = 0; i < m; ++i) {
      enemyCount = 0;
      for (int j = 0; j < n; ++j)
        update(i, j);
      enemyCount = 0;
      for (int j = n - 1; j >= 0; --j)
        update(i, j);
    }

    for (int j = 0; j < n; ++j) {
      enemyCount = 0;
      for (int i = 0; i < m; ++i)
        update(i, j);
      enemyCount = 0;
      for (int i = m - 1; i >= 0; --i)
        update(i, j);
    }

    return accumulate(begin(dp), end(dp), 0,
                      [](int subtotal, const vector<int>& row) {
      return max(subtotal, *max_element(begin(row), end(row)));
    });
  }
};",31,1149,3.0,10.0,6.0,9.0,37.064516129032256,21.0,3.724193548387097
336.0,"class Solution {
 public:
  int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = INT_MIN;

    for (int baseCol = 0; baseCol < n; ++baseCol) {
      // sums[i] := sum(matrix[i][baseCol..j])
      vector<int> sums(m, 0);
      for (int j = baseCol; j < n; ++j) {
        for (int i = 0; i < m; ++i)
          sums[i] += matrix[i][j];
        // Find the max subarray no more than k
        set<int> accumulate{0};
        int prefix = 0;
        for (const int sum : sums) {
          prefix += sum;
          if (const auto it = accumulate.lower_bound(prefix - k);
              it != cend(accumulate))
            ans = max(ans, prefix - *it);
          accumulate.insert(prefix);
        }
      }
    }

    return ans;
  }
};",19,817,2.0,5.0,6.0,5.0,43.0,18.0,3.75
337.0,"class Solution {
 public:
  int depthSumInverse(vector<NestedInteger>& nestedList) {
    int ans = 0;
    int prevSum = 0;
    queue<NestedInteger> q{{begin(nestedList), end(nestedList)}};

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const NestedInteger ni = q.front();
        q.pop();
        if (ni.isInteger())
          prevSum += ni.getInteger();
        else {
          for (const NestedInteger nextNi : ni.getList())
            q.push(nextNi);
        }
      }
      ans += prevSum;
    }

    return ans;
  }
};",12,558,0.0,5.0,7.0,4.0,46.5,7.0,4.3950000000000005
338.0,"class Solution {
 public:
  bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    return targetCapacity == 0 ||
           jug1Capacity + jug2Capacity >= targetCapacity &&
               targetCapacity % __gcd(jug1Capacity, jug2Capacity) == 0;
  }
};",2,279,0.0,0.0,2.0,0.0,139.5,5.0,-3.174999999999999
339.0,"class Solution {
 public:
  vector<vector<int>> findLeaves(TreeNode* root) {
    vector<vector<int>> ans;

    depth(root, ans);
    return ans;
  }

 private:
  // Depth of root (0-indexed)
  int depth(TreeNode* root, vector<vector<int>>& ans) {
    if (root == nullptr)
      return -1;

    const int l = depth(root->left, ans);
    const int r = depth(root->right, ans);
    const int h = 1 + max(l, r);
    if (ans.size() == h)  // Meet leaf
      ans.push_back({});

    ans[h].push_back(root->val);
    return h;
  }
};",11,526,2.0,0.0,4.0,2.0,47.81818181818182,11.0,4.436363636363636
340.0,"class Solution {
 public:
  bool isPerfectSquare(int num) {
    long l = 1;
    long r = num;

    while (l < r) {
      const long m = (l + r) / 2;
      if (m >= num / m)
        r = m;
      else
        l = m + 1;
    }

    return l * l == num;
  }
};",7,256,0.0,3.0,3.0,2.0,36.57142857142857,4.0,5.948571428571429
341.0,"class Solution {
 public:
  vector<int> largestDivisibleSubset(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans;
    // sizeEndsAt[i] := largest size ends at nums[i]
    vector<int> sizeEndsAt(n, 1);
    // prevIndex[i] := the best index s.t.
    // 1. nums[i] % nums[prevIndex[i]] == 0 and
    // 2. can increase the size of the subset
    vector<int> prevIndex(n, -1);
    int maxSize = 0;  // Max size of the subset
    int index = -1;   // Track the best ending index

    sort(begin(nums), end(nums));

    // Fix max ending num in the subset first
    for (int i = 0; i < n; ++i) {
      for (int j = i - 1; j >= 0; --j)
        if (nums[i] % nums[j] == 0 && sizeEndsAt[i] < sizeEndsAt[j] + 1) {
          sizeEndsAt[i] = sizeEndsAt[j] + 1;
          prevIndex[i] = j;
        }
      // Find a new subset that has a bigger size
      if (maxSize < sizeEndsAt[i]) {
        maxSize = sizeEndsAt[i];
        index = i;  // Update the best ending index
      }
    }

    // Loop from back to front
    while (index != -1) {
      ans.push_back(nums[index]);
      index = prevIndex[index];
    }

    return ans;
  }
};",19,1147,10.0,5.0,6.0,5.0,60.36842105263158,12.0,3.1068421052631576
342.0,"class Solution {
 public:
  ListNode* plusOne(ListNode* head) {
    if (head == nullptr)
      return new ListNode(1);
    if (addOne(head) == 1)
      return new ListNode(1, head);
    return head;
  }

 private:
  int addOne(ListNode* node) {
    const int carry = node->next ? addOne(node->next) : 1;
    const int sum = node->val + carry;
    node->val = sum % 10;
    return sum / 10;
  }
};",8,396,0.0,-1.0,3.0,2.0,49.5,6.0,4.825
343.0,"class Solution {
 public:
  vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {
    vector<int> ans(length);
    int prefix = 0;

    for (const vector<int>& update : updates) {
      const int startIndex = update[0];
      const int endIndex = update[1];
      const int inc = update[2];
      ans[startIndex] += inc;
      if (endIndex + 1 < length)
        ans[endIndex + 1] -= inc;
    }

    for (int i = 0; i < length; ++i) {
      prefix += ans[i];
      ans[i] = prefix;
    }

    return ans;
  }
};",13,529,0.0,3.0,4.0,4.0,40.69230769230769,15.0,4.417692307692308
344.0,"class Solution {
 public:
  int getSum(unsigned a, unsigned b) {
    while (b) {                      // Still have carry bits
      const unsigned carry = a & b;  // Record carry bits
      a ^= b;                        // ^ works like + w/o handling carry bits
      b = carry << 1;
    }
    return a;
  }
};",5,312,3.0,1.0,3.0,1.0,62.4,3.0,3.964000000000001
345.0,"class Solution {
 public:
  int superPow(int a, vector<int>& b) {
    constexpr int k = 1337;
    int ans = 1;

    auto powMod = [&](int x, int y) {  // X^y % k
      int pow = 1;
      while (y--)
        pow = (pow * x) % k;
      return pow;
    };

    a %= k;
    for (const int i : b)
      ans = powMod(ans, 10) * powMod(a, i) % k;

    return ans;
  }
};",10,363,1.0,1.0,3.0,2.0,36.3,11.0,5.433000000000002
346.0,"struct T {
  int i;
  int j;
  int sum;  // nums1[i] + nums2[j]
  T(int i, int j, int sum) : i(i), j(j), sum(sum) {}
};

class Solution {
 public:
  vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2,
                                     int k) {
    vector<vector<int>> ans;
    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < nums1.size(); ++i)
      minHeap.emplace(i, 0, nums1[i] + nums2[0]);

    while (!minHeap.empty() && ans.size() < k) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      ans.push_back({nums1[i], nums2[j]});
      if (j + 1 < nums2.size())
        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);
    }

    return ans;
  }
};",17,825,1.0,2.0,7.0,3.0,48.52941176470589,17.0,3.432352941176471
347.0,"/**
 * Forward declaration of guess API.
 * (The problem description is not clear, so I translate it into follows.)
 *
 * @param traget num
 *        guess num
 *
 * @return -1 if guess num >  target num
 *          0 if guess num == target num
 *          1 if guess num <  target num
 */

class Solution {
 public:
  int guessNumber(int n) {
    int l = 1;
    int r = n;

    // Find the first guess num that >= target num
    while (l < r) {
      const int m = l + (r - l) / 2;
      if (guess(m) <= 0)  // -1, 0
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",7,590,3.0,5.0,3.0,6.0,84.28571428571429,7.0,1.3542857142857123
348.0,"class Solution {
 public:
  int getMoneyAmount(int n) {
    // dp[i][j] := min money you need to guarantee a win of picking i..j
    dp.resize(n + 1, vector<int>(n + 1, INT_MAX));
    return getMoneyAmount(1, n);
  }

 private:
  vector<vector<int>> dp;

  int getMoneyAmount(int i, int j) {
    if (i >= j)
      return 0;
    if (dp[i][j] != INT_MAX)
      return dp[i][j];

    for (int k = i; k <= j; ++k)
      dp[i][j] =
          min(dp[i][j],
              max(getMoneyAmount(i, k - 1), getMoneyAmount(k + 1, j)) + k);

    return dp[i][j];
  }
};",10,555,1.0,0.0,3.0,3.0,55.5,9.0,3.965
349.0,"class Solution {
 public:
  int wiggleMaxLength(vector<int>& nums) {
    int increasing = 1;
    int decreasing = 1;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] > nums[i - 1])
        increasing = decreasing + 1;
      else if (nums[i] < nums[i - 1])
        decreasing = increasing + 1;

    return max(increasing, decreasing);
  }
};",8,352,0.0,4.0,2.0,3.0,44.0,6.0,5.079999999999999
350.0,"class Solution {
 public:
  int combinationSum4(vector<int>& nums, int target) {
    vector<unsigned long long> dp(target + 1);
    dp[0] = 1;

    for (int i = 1; i <= target; ++i)
      for (const int num : nums)
        if (i >= num)
          dp[i] += dp[i - num];

    return dp[target];
  }
};",7,299,0.0,3.0,2.0,3.0,42.71428571428572,7.0,5.155714285714286
351.0,"struct T {
  int i;
  int j;
  int num;  // matrix[i][j]
  T(int i, int j, int num) : i(i), j(j), num(num) {}
};

class Solution {
 public:
  int kthSmallest(vector<vector<int>>& matrix, int k) {
    auto compare = [&](const T& a, const T& b) { return a.num > b.num; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < matrix.size(); ++i)
      minHeap.emplace(i, 0, matrix[i][0]);

    while (k-- > 1) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      if (j + 1 < matrix[0].size())
        minHeap.emplace(i, j + 1, matrix[i][j + 1]);
    }

    return minHeap.top().num;
  }
};",15,657,1.0,2.0,6.0,3.0,43.8,15.0,4.117999999999999
352.0,"class PhoneDirectory {
 public:
  /** Initialize your data structure here
      @param maxNumbers - The maximum numbers that can be stored in the phone
     directory. */
  PhoneDirectory(int maxNumbers) : next(maxNumbers) {
    for (int i = 0; i < maxNumbers - 1; ++i)
      next[i] = i + 1;
    next.back() = 0;
  }

  /** Provide a number which is not assigned to anyone.
      @return - Return an available number. Return -1 if none is available. */
  int get() {
    if (next[number] == -1)
      return -1;

    const int ans = number;
    number = next[number];
    next[ans] = -1;  // Mark as used
    return ans;
  }

  /** Check if a number is available or not. */
  bool check(int number) {
    return next[number] != -1;
  }

  /** Recycle or release a number. */
  void release(int number) {
    if (next[number] != -1)
      return;

    next[number] = this->number;
    this->number = number;
  }

 private:
  int number = 0;    // Current possible available number
  vector<int> next;  // Next available number
};",16,1029,7.0,1.0,5.0,5.0,64.3125,12.0,2.9318750000000007
353.0,"class RandomizedSet {
 public:
  /** Inserts a value to the set. Returns true if the set did not already
   * contain the specified element. */
  bool insert(int val) {
    if (valToIndex.count(val))
      return false;

    valToIndex[val] = vals.size();
    vals.push_back(val);
    return true;
  }

  /** Removes a value from the set. Returns true if the set contained the
   * specified element. */
  bool remove(int val) {
    if (!valToIndex.count(val))
      return false;

    const int index = valToIndex[val];
    // Following two lines order are important when vals.size() == 1
    valToIndex[vals.back()] = index;
    valToIndex.erase(val);
    vals[index] = vals.back();
    vals.pop_back();
    return true;
  }

  /** Get a random element from the set. */
  int getRandom() {
    const int index = rand() % vals.size();
    return vals[index];
  }

 private:
  unordered_map<int, int> valToIndex;  // {val: index in vals}
  vector<int> vals;
};",16,960,5.0,0.0,5.0,6.0,60.0,13.0,3.200000000000001
354.0,"struct Item {
  int val;
  int indexInMap;
  Item(int val, int indexInMap) : val(val), indexInMap(indexInMap) {}
};

class RandomizedCollection {
 public:
  /** Inserts a value to the collection. Returns true if the collection did not
   * already contain the specified element. */
  bool insert(int val) {
    valToIndices[val].push_back(items.size());
    items.emplace_back(val, valToIndices[val].size() - 1);
    return valToIndices[val].size() == 1;
  }

  /** Removes a value from the collection. Returns true if the collection
   * contained the specified element. */
  bool remove(int val) {
    if (!valToIndices.count(val))
      return false;

    const int index = valToIndices[val].back();
    valToIndices[items.back().val][items.back().indexInMap] = index;
    valToIndices[val].pop_back();
    if (valToIndices[val].empty())
      valToIndices.erase(val);
    items[index] = items.back();
    items.pop_back();
    return true;
  }

  /** Get a random element from the collection. */
  int getRandom() {
    const int index = rand() % items.size();
    return items[index].val;
  }

 private:
  unordered_map<int, vector<int>> valToIndices;
  vector<Item> items;
};",19,1181,3.0,1.0,6.0,6.0,62.1578947368421,17.0,2.405789473684212
355.0,"class Solution {
 public:
  /** @param head The linked list's head.
      Note that the head is guaranteed to be not null, so it contains at least
     one node. */
  Solution(ListNode* head) : head(head) {}

  /** Returns a random node's value. */
  int getRandom() {
    int ans = -1;
    int i = 1;

    for (ListNode* curr = head; curr; curr = curr->next, ++i)
      if (rand() % i == 0)
        ans = curr->val;

    return ans;
  }

 private:
  ListNode* head;
};",8,469,2.0,2.0,3.0,2.0,58.625,4.0,4.10375
356.0,"class Solution {
 public:
  bool canConstruct(string ransomNote, string magazine) {
    vector<int> count(128);

    for (const char c : magazine)
      ++count[c];

    for (const char c : ransomNote)
      if (--count[c] < 0)
        return false;

    return true;
  }
};",5,274,0.0,2.0,2.0,3.0,54.8,9.0,3.928
357.0,"class Solution {
 public:
  Solution(vector<int>& nums) : nums(move(nums)) {}

  /** Resets the array to its original configuration and return it. */
  vector<int> reset() {
    return nums;
  }

  /** Returns a random shuffling of the array. */
  vector<int> shuffle() {
    vector<int> A(nums);
    for (int i = A.size() - 1; i > 0; --i) {
      const int j = rand() % (i + 1);
      swap(A[i], A[j]);
    }
    return A;
  }

 private:
  vector<int> nums;
};",9,461,2.0,-1.0,5.0,1.0,51.22222222222222,9.0,4.33
358.0,"class Solution {
 public:
  NestedInteger deserialize(string s) {
    if (s[0] != '[')
      return NestedInteger(stoi(s));

    stack<NestedInteger> stack;
    int start;  // the start index of num

    for (int i = 0; i < s.length(); ++i) {
      switch (s[i]) {
        case '[':
          stack.push(NestedInteger());
          start = i + 1;
          break;
        case ',':
          if (i > start) {
            const int num = stoi(s.substr(start, i));
            stack.top().add(NestedInteger(num));
          }
          start = i + 1;
          break;
        case ']':
          NestedInteger popped = stack.top();
          stack.pop();
          if (i > start) {
            const int num = stoi(s.substr(start, i));
            popped.add(NestedInteger(num));
          }
          if (stack.empty())
            return popped;
          else
            stack.top().add(popped);
          start = i + 1;
          break;
      }
    }

    throw;
  }
};",22,972,1.0,5.0,6.0,5.0,44.18181818181818,8.0,4.603636363636364
359.0,"class Solution {
 public:
  vector<int> lexicalOrder(int n) {
    vector<int> ans;
    int curr = 1;

    while (ans.size() < n) {
      ans.push_back(curr);
      if (curr * 10 <= n) {
        curr *= 10;
      } else {
        while (curr % 10 == 9 || curr == n)
          curr /= 10;
        ++curr;
      }
    }

    return ans;
  }
};",8,340,0.0,4.0,5.0,3.0,42.5,5.0,5.135000000000001
360.0,"class Solution {
 public:
  int firstUniqChar(string s) {
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (int i = 0; i < s.length(); ++i)
      if (count[s[i]] == 1)
        return i;

    return -1;
  }
};",7,242,0.0,2.0,2.0,3.0,34.57142857142857,7.0,5.948571428571428
361.0,"struct T {
  int depth;
  size_t length;
  T(int depth, size_t length) : depth(depth), length(length) {}
};

class Solution {
 public:
  int lengthLongestPath(string input) {
    size_t ans = 0;
    stack<T> stack{{{-1, 0}}};  // Placeholder
    istringstream iss(input);

    for (string token; getline(iss, token, '\n');) {
      const int depth =
          count_if(begin(token), end(token), [](char c) { return c == '\t'; });
      token.erase(remove(begin(token), end(token), '\t'), end(token));
      while (depth <= stack.top().depth)
        stack.pop();
      if (isFile(token))
        ans = max(ans, stack.top().length + token.length());
      else  // Directory + '/'
        stack.emplace(depth, stack.top().length + token.length() + 1);
    }

    return ans;
  }

 private:
  bool isFile(const string& token) {
    return token.find('.') != string::npos;
  }
};",17,876,2.0,2.0,10.0,4.0,51.52941176470589,14.0,3.3223529411764705
362.0,"class Solution {
 public:
  char findTheDifference(string s, string t) {
    char ans = 0;

    for (const char c : s)
      ans ^= c;

    for (const char c : t)
      ans ^= c;

    return ans;
  }
};",5,202,0.0,2.0,2.0,3.0,40.4,9.0,5.224
363.0,"class Solution {
 public:
  int lastRemaining(int n) {
    return n == 1 ? 1 : 2 * (1 + n / 2 - lastRemaining(n / 2));
  }
};",2,125,0.0,0.0,2.0,0.0,62.5,3.0,3.955
364.0,"class Solution {
 public:
  bool isRectangleCover(vector<vector<int>>& rectangles) {
    int area = 0;
    int x1 = INT_MAX;
    int y1 = INT_MAX;
    int x2 = INT_MIN;
    int y2 = INT_MIN;
    unordered_set<string> corners;

    for (const vector<int>& r : rectangles) {
      area += (r[2] - r[0]) * (r[3] - r[1]);
      x1 = min(x1, r[0]);
      y1 = min(y1, r[1]);
      x2 = max(x2, r[2]);
      y2 = max(y2, r[3]);

      // Four points of current rectangle
      const vector<string> points{to_string(r[0]) + "" "" + to_string(r[1]),
                                  to_string(r[0]) + "" "" + to_string(r[3]),
                                  to_string(r[2]) + "" "" + to_string(r[1]),
                                  to_string(r[2]) + "" "" + to_string(r[3])};
      for (const string& point : points)
        if (!corners.insert(point).second)
          corners.erase(point);
    }

    if (corners.size() != 4)
      return false;
    if (!corners.count(to_string(x1) + "" "" + to_string(y1)) ||
        !corners.count(to_string(x1) + "" "" + to_string(y2)) ||
        !corners.count(to_string(x2) + "" "" + to_string(y1)) ||
        !corners.count(to_string(x2) + "" "" + to_string(y2)))
      return false;

    return area == (x2 - x1) * (y2 - y1);
  }
};",17,1257,1.0,3.0,4.0,5.0,73.94117647058823,15.0,1.4652941176470584
365.0,"class Solution {
 public:
  bool isSubsequence(string s, string t) {
    if (s.empty())
      return true;

    int i = 0;
    for (const char c : t)
      if (s[i] == c && ++i == s.length())
        return true;

    return false;
  }
};",5,238,0.0,1.0,2.0,3.0,47.6,7.0,4.836
366.0,"class Solution {
 public:
  bool validUtf8(vector<int>& data) {
    int leftToCheck = 0;

    for (const int d : data)
      if (leftToCheck == 0) {
        if ((d >> 3) == 0b11110)
          leftToCheck = 3;
        else if ((d >> 4) == 0b1110)
          leftToCheck = 2;
        else if ((d >> 5) == 0b110)
          leftToCheck = 1;
        else if ((d >> 7) == 0b0)
          leftToCheck = 0;
        else
          return false;
      } else {
        if ((d >> 6) != 0b10)
          return false;
        --leftToCheck;
      }

    return leftToCheck == 0;
  }
};",10,570,0.0,10.0,4.0,7.0,57.0,6.0,3.43
367.0,"class Solution {
 public:
  string decodeString(string s) {
    stack<pair<string, int>> stack;  // (prevStr, repeatCount)
    string currStr;
    int currNum = 0;

    for (const char c : s)
      if (isdigit(c)) {
        currNum = currNum * 10 + (c - '0');
      } else {
        if (c == '[') {
          stack.emplace(currStr, currNum);
          currStr = """";
          currNum = 0;
        } else if (c == ']') {
          const auto [prevStr, n] = stack.top();
          stack.pop();
          currStr = prevStr + getRepeatedStr(currStr, n);
        } else {
          currStr += c;
        }
      }

    return currStr;
  }

 private:
  // S * n times
  string getRepeatedStr(const string& s, int n) {
    string repeat;
    while (n--)
      repeat += s;
    return repeat;
  }
};",16,791,2.0,7.0,8.0,5.0,49.4375,15.0,3.230625
368.0,"class Solution {
 public:
  int longestSubstring(string s, int k) {
    int ans = 0;

    for (int n = 1; n <= 26; ++n)
      ans = max(ans, longestSubstringWithNUniqueCharacters(s, k, n));

    return ans;
  }

 private:
  int longestSubstringWithNUniqueCharacters(const string& s, int k, int n) {
    int ans = 0;
    int uniqueChars = 0;  // # of unique chars in window
    int noLessThanK = 0;  // # of chars >= k in window
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (count[s[r]] == 0)
        ++uniqueChars;
      if (++count[s[r]] == k)
        ++noLessThanK;
      while (uniqueChars > n) {
        if (count[s[l]] == k)
          --noLessThanK;
        if (--count[s[l]] == 0)
          --uniqueChars;
        ++l;
      }
      if (noLessThanK == n)  // Unique chars also == n
        ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",19,895,3.0,7.0,5.0,8.0,47.10526315789474,16.0,3.560526315789474
369.0,"class Solution {
 public:
  int maxRotateFunction(vector<int>& nums) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    int f = 0;

    // Calculate F(0) first
    for (int i = 0; i < nums.size(); ++i)
      f += i * nums[i];

    int ans = f;

    for (int i = nums.size() - 1; i > 0; --i) {
      f += sum - nums.size() * nums[i];
      ans = max(ans, f);
    }

    return ans;
  }
};",12,401,1.0,2.0,3.0,2.0,33.416666666666664,9.0,5.8325000000000005
370.0,"class Solution {
 public:
  int integerReplacement(long n) {
    int ans = 0;

    for (; n > 1; ++ans)
      if ((n & 1) == 0)  // Ends w/ 0
        n >>= 1;
      else if (n == 3 || ((n >> 1) & 1) == 0)  // N = 3 or ends w/ 01
        --n;
      else  // Ends w/ 11
        ++n;

    return ans;
  }
};",8,304,3.0,5.0,2.0,3.0,38.0,3.0,5.98
371.0,"class Solution {
 public:
  Solution(vector<int>& nums) : nums(move(nums)) {}

  int pick(int target) {
    int ans = -1;
    int range = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == target && rand() % ++range == 0)
        ans = i;

    return ans;
  }

 private:
  vector<int> nums;
};",8,309,0.0,2.0,3.0,2.0,38.625,8.0,5.42375
372.0,"class Solution {
 public:
  vector<double> calcEquation(vector<vector<string>>& equations,
                              vector<double>& values,
                              vector<vector<string>>& queries) {
    vector<double> ans;
    // graph[A][B] := A / B
    unordered_map<string, unordered_map<string, double>> graph;

    for (int i = 0; i < equations.size(); ++i) {
      const string& A = equations[i][0];
      const string& B = equations[i][1];
      graph[A][B] = values[i];
      graph[B][A] = 1 / values[i];
    }

    for (const vector<string>& query : queries) {
      const string& A = query[0];
      const string& C = query[1];
      if (!graph.count(A) || !graph.count(C))
        ans.push_back(-1);
      else
        ans.push_back(divide(graph, A, C, unordered_set<string>()));
    }

    return ans;
  }

 private:
  // Returns A / C
  double divide(
      const unordered_map<string, unordered_map<string, double>>& graph,
      const string& A, const string& C, unordered_set<string>&& seen) {
    if (A == C)
      return 1.0;

    seen.insert(A);

    // Value := A / B
    for (const auto& [B, value] : graph.at(A)) {
      if (seen.count(B))
        continue;
      const double res = divide(graph, B, C, move(seen));  // B / C
      if (res > 0)                                         // Valid result
        return value * res;  // A / C = (A / B) * (B / C)
    }

    return -1;  // Invalid result
  }
};",20,1439,7.0,4.0,6.0,7.0,71.95,34.0,-0.1955000000000009
373.0,"class Solution {
 public:
  int findNthDigit(int n) {
    int digitSize = 1;
    int startNum = 1;
    long count = 9;

    while (digitSize * count < n) {
      n -= digitSize * count;
      ++digitSize;
      startNum *= 10;
      count *= 10;
    }

    const int targetNum = startNum + (n - 1) / digitSize;
    const int index = (n - 1) % digitSize;
    return to_string(targetNum)[index] - '0';
  }
};",11,406,0.0,1.0,3.0,1.0,36.90909090909091,9.0,5.538181818181819
374.0,"class Solution {
 public:
  vector<string> readBinaryWatch(int num) {
    vector<string> ans;
    dfs(num, 0, 0, 0, ans);
    return ans;
  }

 private:
  const vector<int> hours{1, 2, 4, 8};
  const vector<int> minutes{1, 2, 4, 8, 16, 32};

  void dfs(int n, int s, int h, int m, vector<string>& ans) {
    if (n == 0) {
      string time = to_string(h) + "":"" + (m < 10 ? ""0"" : """") + to_string(m);
      ans.push_back(time);
      return;
    }

    for (int i = s; i < hours.size() + minutes.size(); ++i)
      if (i < 4 && h + hours[i] < 12)
        dfs(n - 1, i + 1, h + hours[i], m, ans);
      else if (i >= 4 && m + minutes[i - 4] < 60)
        dfs(n - 1, i + 1, h, m + minutes[i - 4], ans);
  }
};",13,705,0.0,4.0,6.0,4.0,54.23076923076923,16.0,2.919230769230768
375.0,"class Solution {
 public:
  string removeKdigits(string num, int k) {
    if (num.length() == k)
      return ""0"";

    string ans;
    vector<char> stack;

    for (int i = 0; i < num.length(); ++i) {
      while (k > 0 && !stack.empty() && stack.back() > num[i]) {
        stack.pop_back();
        --k;
      }
      stack.push_back(num[i]);
    }

    while (k-- > 0)
      stack.pop_back();

    for (const char c : stack) {
      if (c == '0' && ans.empty())
        continue;
      ans += c;
    }

    return ans.empty() ? ""0"" : ans;
  }
};",13,548,0.0,4.0,5.0,6.0,42.15384615384615,9.0,4.766153846153846
376.0,"class Solution {
 public:
  bool canCross(vector<int>& stones) {
    const int n = stones.size();
    // dp[i][j] := true if a frog can make a size j jump to stones[i]
    vector<vector<bool>> dp(n, vector<bool>(n + 1));
    dp[0][0] = true;

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const int k = stones[i] - stones[j];
        if (k > n)
          continue;
        for (const int x : {k - 1, k, k + 1})
          if (0 <= x && x <= n)
            dp[i][k] = dp[i][k] || dp[j][x];
      }

    return any_of(begin(dp.back()), end(dp.back()),
                  [](bool val) { return val; });
  }
};",13,634,1.0,4.0,5.0,6.0,48.76923076923077,14.0,3.7107692307692313
377.0,"class Solution {
 public:
  int sumOfLeftLeaves(TreeNode* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;

    if (root->left) {
      if (root->left->left == nullptr && root->left->right == nullptr)
        ans += root->left->val;
      else
        ans += sumOfLeftLeaves(root->left);
    }
    ans += sumOfLeftLeaves(root->right);

    return ans;
  }
};",7,376,0.0,3.0,3.0,3.0,53.71428571428572,3.0,4.505714285714286
378.0,"class Solution {
 public:
  string toHex(unsigned num) {
    const vector<char> hex{'0', '1', '2', '3', '4', '5', '6', '7',
                           '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    string ans;

    while (num) {
      ans += hex[num & 0xf];
      num >>= 4;
    }

    reverse(begin(ans), end(ans));
    return ans.empty() ? ""0"" : ans;
  }
};",7,357,0.0,1.0,4.0,1.0,51.0,5.0,4.61
379.0,"class Solution {
 public:
  vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    vector<vector<int>> ans;

    sort(begin(people), end(people), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0];
    });

    for (const vector<int>& p : people)
      ans.insert(begin(ans) + p[1], p);

    return ans;
  }
};",6,365,0.0,0.0,3.0,1.0,60.833333333333336,8.0,3.545000000000001
380.0,"struct T {
  int i;
  int j;
  int h;  // heightMap[i][j] or the height after filling water
  T(int i, int j, int h) : i(i), j(j), h(h) {}
};

class Solution {
 public:
  int trapRainWater(vector<vector<int>>& heightMap) {
    const int m = heightMap.size();
    const int n = heightMap[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = 0;
    auto compare = [](const T& a, const T& b) { return a.h > b.h; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i) {
      minHeap.emplace(i, 0, heightMap[i][0]);
      minHeap.emplace(i, n - 1, heightMap[i][n - 1]);
      seen[i][0] = true;
      seen[i][n - 1] = true;
    }

    for (int j = 1; j < n - 1; ++j) {
      minHeap.emplace(0, j, heightMap[0][j]);
      minHeap.emplace(m - 1, j, heightMap[m - 1][j]);
      seen[0][j] = true;
      seen[m - 1][j] = true;
    }

    while (!minHeap.empty()) {
      const auto [i, j, h] = minHeap.top();
      minHeap.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        if (heightMap[x][y] < h) {
          ans += h - heightMap[x][y];
          minHeap.emplace(x, y, h);  // Fill the water on grid[x][y]
        } else {
          minHeap.emplace(x, y, heightMap[x][y]);
        }
        seen[x][y] = true;
      }
    }

    return ans;
  }
};",38,1545,2.0,5.0,12.0,7.0,40.6578947368421,29.0,2.500789473684211
381.0,"class Solution {
 public:
  bool validWordAbbreviation(const string& word, const string& abbr) {
    int i = 0;  // word's index
    int j = 0;  // abbr's index

    while (i < word.length() && j < abbr.length()) {
      if (word[i] == abbr[j]) {
        ++i;
        ++j;
        continue;
      }
      if (abbr[j] <= '0' || abbr[j] > '9')
        return false;
      int num = 0;
      while (j < abbr.length() && isdigit(abbr[j])) {
        num = num * 10 + abbr[j] - '0';
        ++j;
      }
      i += num;
    }

    return i == word.length() && j == abbr.length();
  }
};",12,580,2.0,2.0,5.0,4.0,48.333333333333336,9.0,4.41
382.0,"class Solution {
 public:
  int longestPalindrome(string s) {
    int ans = 0;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (const int c : count)
      ans += c % 2 == 0 ? c : c - 1;

    const bool hasOddCount =
        any_of(begin(count), end(count), [](int c) { return c & 1; });

    return ans + hasOddCount;
  }
};",8,359,0.0,1.0,3.0,2.0,44.875,12.0,4.52125
383.0,"class Solution {
 public:
  int splitArray(vector<int>& nums, int m) {
    const int n = nums.size();
    // dp[i][k] := min of largest sum to split first i nums into k groups
    dp.resize(n + 1, vector<int>(m + 1, INT_MAX));
    prefix.resize(n + 1);

    partial_sum(begin(nums), end(nums), begin(prefix) + 1);
    return splitArray(nums, n, m);
  }

 private:
  vector<vector<int>> dp;
  vector<int> prefix;

  int splitArray(const vector<int>& nums, int i, int k) {
    if (k == 1)
      return prefix[i];
    if (dp[i][k] < INT_MAX)
      return dp[i][k];

    // Try all possible partitions
    for (int j = k - 1; j < i; ++j)
      dp[i][k] =
          min(dp[i][k], max(splitArray(nums, j, k - 1), prefix[i] - prefix[j]));

    return dp[i][k];
  }
};",14,760,2.0,0.0,3.0,3.0,54.285714285714285,15.0,3.514285714285715
384.0,"class Solution {
 public:
  string minAbbreviation(string target, vector<string>& dictionary) {
    const int m = target.length();
    vector<int> masks;

    for (const string& word : dictionary) {
      if (word.length() != m)
        continue;
      masks.push_back(getMask(target, word));
    }

    if (masks.empty())
      return to_string(m);

    vector<string> abbrs;

    const int maxCand = pow(2, m);
    // For all candidate representation of target
    for (int cand = 0; cand < maxCand; ++cand)
      // All masks have at lease one bit different from candidate
      if (all_of(begin(masks), end(masks),
                 [cand](int mask) { return cand & mask; }))
        abbrs.push_back(getAbbr(target, cand));

    string ans = target;

    for (const string& abbr : abbrs)
      if (getAbbrLen(abbr) < getAbbrLen(ans))
        ans = abbr;

    return ans;
  }

 private:
  int getMask(const string& target, const string& word) {
    const int m = target.length();
    // mask[i] = 0 := target[i] == word[i]
    // mask[i] = 1 := target[i] != word[i]
    // E.g. target = ""apple""
    //        word = ""blade""
    //        mask =  11110
    int mask = 0;
    for (int i = 0; i < m; ++i)
      if (word[i] != target[i])
        mask |= 1 << m - 1 - i;
    return mask;
  }

  string getAbbr(const string& target, int cand) {
    const int m = target.length();
    string abbr;
    int replacedCount = 0;
    for (int i = 0; i < m; ++i)
      if (cand >> m - 1 - i & 1) {
        // cand[i] = 1, abbr should show the original character
        if (replacedCount > 0)
          abbr += to_string(replacedCount);
        abbr += target[i];
        replacedCount = 0;
      } else {
        // cand[i] = 0, abbr can be replaced
        ++replacedCount;
      }
    if (replacedCount > 0)
      abbr += to_string(replacedCount);
    return abbr;
  }

  int getAbbrLen(const string& abbr) {
    int abbrLen = 0;
    int i = 0;
    int j = 0;
    while (i < abbr.length()) {
      if (isalpha(abbr[j]))
        ++j;
      else
        while (j < abbr.length() && isdigit(abbr[j]))
          ++j;
      ++abbrLen;
      i = j;
    }
    return abbrLen;
  }
};",40,2167,9.0,12.0,10.0,18.0,54.175,41.0,0.0642499999999994
385.0,"class Solution {
 public:
  vector<string> fizzBuzz(int n) {
    vector<string> ans;

    for (int i = 1; i <= n; ++i) {
      string s;
      if (i % 3 == 0)
        s += ""Fizz"";
      if (i % 5 == 0)
        s += ""Buzz"";
      ans.push_back(s.empty() ? to_string(i) : s);
    }

    return ans;
  }
};",9,303,0.0,3.0,3.0,3.0,33.666666666666664,6.0,6.01
386.0,"class Solution {
 public:
  int numberOfArithmeticSlices(vector<int>& nums) {
    const int n = nums.size();
    if (n < 3)
      return 0;

    vector<int> dp(n);  // # arithmetic slices ends at i

    for (int i = 2; i < nums.size(); ++i)
      if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])
        dp[i] = dp[i - 1] + 1;

    return accumulate(begin(dp), end(dp), 0);
  }
};",8,387,1.0,2.0,2.0,3.0,48.375,7.0,4.74625
387.0,"class Solution {
 public:
  int thirdMax(vector<int>& nums) {
    long max1 = LONG_MIN;  // The maximum
    long max2 = LONG_MIN;  // 2nd maximum
    long max3 = LONG_MIN;  // 3rd maximum

    for (const int num : nums)
      if (num > max1) {
        max3 = max2;
        max2 = max1;
        max1 = num;
      } else if (max1 > num && num > max2) {
        max3 = max2;
        max2 = num;
      } else if (max2 > num && num > max3) {
        max3 = num;
      }

    return max3 == LONG_MIN ? max1 : max3;
  }
};",11,515,3.0,6.0,5.0,4.0,46.81818181818182,5.0,4.746363636363636
388.0,"class Solution {
 public:
  string addStrings(string num1, string num2) {
    string ans;
    int carry = 0;
    int i = num1.length() - 1;
    int j = num2.length() - 1;

    while (i >= 0 || j >= 0 || carry) {
      if (i >= 0)
        carry += num1[i--] - '0';
      if (j >= 0)
        carry += num2[j--] - '0';
      ans += carry % 10 + '0';
      carry /= 10;
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};",11,430,0.0,3.0,3.0,3.0,39.09090909090909,8.0,5.321818181818182
389.0,"class Solution {
 public:
  bool canPartition(vector<int>& nums) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    if (sum & 1)
      return false;
    return knapsack(nums, sum / 2);
  }

 private:
  bool knapsack(const vector<int>& nums, int subsetSum) {
    const int n = nums.size();
    // dp[i][j] := true if j can be formed by nums[0..i)
    vector<vector<bool>> dp(n + 1, vector<bool>(subsetSum + 1));
    dp[0][0] = true;

    for (int i = 1; i <= n; ++i) {
      const int num = nums[i - 1];
      for (int j = 0; j <= subsetSum; ++j)
        if (j < num)
          dp[i][j] = dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j] || dp[i - 1][j - num];
    }

    return dp[n][subsetSum];
  }
};",15,728,1.0,4.0,4.0,6.0,48.53333333333333,17.0,3.492
390.0,"class Solution {
 public:
  vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
    const int m = heights.size();
    const int n = heights[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    vector<vector<int>> ans;
    queue<pair<int, int>> qP;
    queue<pair<int, int>> qA;
    vector<vector<bool>> seenP(m, vector<bool>(n));
    vector<vector<bool>> seenA(m, vector<bool>(n));

    auto bfs = [&](queue<pair<int, int>>& q, vector<vector<bool>>& seen) {
      while (!q.empty()) {
        const auto [i, j] = q.front();
        q.pop();
        const int h = heights[i][j];
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || heights[x][y] < h)
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    };

    for (int i = 0; i < m; ++i) {
      qP.emplace(i, 0);
      qA.emplace(i, n - 1);
      seenP[i][0] = true;
      seenA[i][n - 1] = true;
    }

    for (int j = 0; j < n; ++j) {
      qP.emplace(0, j);
      qA.emplace(m - 1, j);
      seenP[0][j] = true;
      seenA[m - 1][j] = true;
    }

    bfs(qP, seenP);
    bfs(qA, seenA);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (seenP[i][j] && seenA[i][j])
          ans.push_back({i, j});

    return ans;
  }
};",41,1440,0.0,7.0,9.0,10.0,35.1219512195122,33.0,2.5790243902439025
391.0,"class Solution {
 public:
  int wordsTyping(vector<string>& sentence, int rows, int cols) {
    const string& combined = getCombined(sentence);
    const int n = combined.length();
    int i = 0;  // (i % n) points to the index of combined in each row

    while (rows--) {
      i += cols;
      if (combined[i % n] == ' ') {
        ++i;
      } else {
        while (i > 0 && combined[(i - 1) % n] != ' ')
          --i;
      }
    }

    return i / n;
  }

 private:
  string getCombined(const vector<string>& sentence) {
    string combined;
    for (const string& word : sentence)
      combined += (word + ' ');
    return combined;
  }
};",11,647,1.0,4.0,6.0,4.0,58.81818181818182,16.0,2.546363636363635
392.0,"class Solution {
 public:
  int countBattleships(vector<vector<char>>& board) {
    int ans = 0;

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < board[0].size(); ++j) {
        if (board[i][j] == '.')
          continue;
        if (i > 0 && board[i - 1][j] == 'X')
          continue;
        if (j > 0 && board[i][j - 1] == 'X')
          continue;
        ++ans;
      }

    return ans;
  }
};",11,419,0.0,2.0,3.0,5.0,38.09090909090909,6.0,5.671818181818182
393.0,"class Solution {
 public:
  int strongPasswordChecker(string s) {
    const int n = s.length();
    const int missing = getMissing(s);
    // # of replacements to deal with 3 repeating characters
    int replaces = 0;
    // # of seqs that can be substituted with 1 deletions, (3k)-seqs
    int oneSeq = 0;
    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs
    int twoSeq = 0;

    for (int i = 2; i < n;)
      if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {
        int length = 2;  // Length of repeating s
        while (i < n && s[i] == s[i - 1]) {
          ++length;
          ++i;
        }
        replaces += length / 3;  // 'aaaaaaa' -> 'aaxaaxa'
        if (length % 3 == 0)
          ++oneSeq;
        if (length % 3 == 1)
          ++twoSeq;
      } else {
        ++i;
      }

    if (n < 6)
      return max(6 - n, missing);
    if (n <= 20)
      return max(replaces, missing);

    const int deletes = n - 20;
    // Each replacement in (3k)-seqs can be substituted with 1 deletions
    replaces -= min(oneSeq, deletes);
    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions
    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;
    // Each replacement in other seqs can be substituted with 3 deletions
    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;
    return deletes + max(replaces, missing);
  }

 private:
  int getMissing(const string& s) {
    int missing = 3;
    if (any_of(begin(s), end(s), [](char c) { return isupper(c); }))
      --missing;
    if (any_of(begin(s), end(s), [](char c) { return islower(c); }))
      --missing;
    if (any_of(begin(s), end(s), [](char c) { return isdigit(c); }))
      --missing;
    return missing;
  }
};",30,1737,8.0,5.0,9.0,10.0,57.9,21.0,2.1690000000000005
394.0,"class Solution {
 public:
  int findMaximumXOR(vector<int>& nums) {
    const int maxNum = *max_element(begin(nums), end(nums));
    if (maxNum == 0)
      return 0;
    const int maxBit = static_cast<int>(log2(maxNum));
    int ans = 0;
    int mask = 0;

    // If ans is 11100 when i = 2, it means that before we reach the last two
    // bits, 11100 is the maximum XOR we have, and we're going to explore if we
    // can get another two '1's and put them into ans.
    for (int i = maxBit; i >= 0; --i) {
      // Mask grows like: 100...000, 110...000, 111...000, ..., 111...111.
      mask |= 1 << i;
      unordered_set<int> prefixes;
      // We only care about the left parts,
      // If i = 2, nums = {1110, 1011, 0111}
      //    -> prefixes = {1100, 1000, 0100}
      for (const int num : nums)
        prefixes.insert(num & mask);
      // If i = 1 and before this iteration, the ans is 10100, it means that we
      // want to grow the ans to 10100 | 1 << 1 = 10110 and we're looking for
      // XOR of two prefixes = candidate.
      const int candidate = ans | 1 << i;
      for (const int prefix : prefixes)
        if (prefixes.count(prefix ^ candidate)) {
          ans = candidate;
          break;
        }
    }

    return ans;
  }
};",15,1261,10.0,5.0,6.0,12.0,84.06666666666666,18.0,0.3740000000000005
395.0,"class Solution {
 public:
  bool validWordSquare(vector<string>& words) {
    for (int i = 0; i < words.size(); ++i)
      for (int j = 0; j < words[i].size(); ++j) {
        if (words.size() <= j || words[j].size() <= i)  // Out of bound
          return false;
        if (words[i][j] != words[j][i])
          return false;
      }

    return true;
  }
};",8,359,1.0,2.0,3.0,4.0,44.875,5.0,5.20125
396.0,"class Solution {
 public:
  string originalDigits(string s) {
    string ans;
    vector<int> count(10);

    for (const char c : s) {
      if (c == 'z')
        ++count[0];
      if (c == 'o')
        ++count[1];
      if (c == 'w')
        ++count[2];
      if (c == 'h')
        ++count[3];
      if (c == 'u')
        ++count[4];
      if (c == 'f')
        ++count[5];
      if (c == 'x')
        ++count[6];
      if (c == 's')
        ++count[7];
      if (c == 'g')
        ++count[8];
      if (c == 'i')
        ++count[9];
    }

    count[1] -= count[0] + count[2] + count[4];
    count[3] -= count[8];
    count[5] -= count[4];
    count[7] -= count[6];
    count[9] -= count[5] + count[6] + count[8];

    for (int i = 0; i < 10; ++i)
      for (int j = 0; j < count[i]; ++j)
        ans += i + '0';

    return ans;
  }
};",24,838,0.0,13.0,3.0,13.0,34.916666666666664,9.0,4.9975000000000005
397.0,"class Solution {
 public:
  int characterReplacement(string s, int k) {
    int ans = 0;
    int maxCount = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      maxCount = max(maxCount, ++count[s[r]]);
      while (maxCount + k < r - l + 1)
        --count[s[l++]];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",10,363,0.0,2.0,3.0,2.0,36.3,8.0,5.633000000000001
398.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  vector<const string*> startsWith;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  Trie(const vector<string>& words) {
    for (const string& word : words)
      insert(word);
  }

  vector<const string*> findBy(const string& prefix) {
    shared_ptr<TrieNode> node = root;
    for (const char c : prefix) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return {};
      node = node->children[i];
    }
    return node->startsWith;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
      node->startsWith.push_back(&word);
    }
  }
};

class Solution {
 public:
  vector<vector<string>> wordSquares(vector<string>& words) {
    if (words.empty())
      return {};

    const int n = words[0].length();
    vector<vector<string>> ans;
    vector<string> path;
    Trie trie(words);

    for (const string& word : words) {
      path.push_back(word);
      dfs(trie, n, path, ans);
      path.pop_back();
    }

    return ans;
  }

 private:
  void dfs(Trie& trie, const int n, vector<string>& path,
           vector<vector<string>>& ans) {
    if (path.size() == n) {
      ans.push_back(path);
      return;
    }

    const string prefix = getPrefix(path);

    for (const string* s : trie.findBy(prefix)) {
      path.push_back(*s);
      dfs(trie, n, path, ans);
      path.pop_back();
    }
  }

  // E.g. path = [""wall"",
  //              ""area""]
  //    prefix =  ""le..""
  string getPrefix(const vector<string>& path) {
    string prefix;
    const int index = path.size();
    for (const string& s : path)
      prefix += s[index];
    return prefix;
  }
};",36,1950,3.0,5.0,17.0,10.0,54.16666666666666,49.0,-0.9750000000000014
399.0,"class Solution {
 public:
  Node* treeToDoublyList(Node* root) {
    if (root == nullptr)
      return nullptr;

    Node* leftHead = treeToDoublyList(root->left);
    Node* rightHead = treeToDoublyList(root->right);
    root->left = root;
    root->right = root;
    return connect(connect(leftHead, root), rightHead);
  }

 private:
  Node* connect(Node* node1, Node* node2) {
    if (node1 == nullptr)
      return node2;
    if (node2 == nullptr)
      return node1;

    Node* tail1 = node1->left;
    Node* tail2 = node2->left;

    // Connect node1's tail with node2
    tail1->right = node2;
    node2->left = tail1;

    // Connect node2's tail with node1
    tail2->right = node1;
    node1->left = tail2;
    return node1;
  }
};",16,740,2.0,-1.0,3.0,3.0,46.25,1.0,5.697500000000001
400.0,"class Solution {
 public:
  Node* construct(vector<vector<int>>& grid) {
    return helper(grid, 0, 0, grid.size());
  }

 private:
  Node* helper(const vector<vector<int>>& grid, int i, int j, int w) {
    if (allSame(grid, i, j, w))
      return new Node(grid[i][j], true);

    Node* node = new Node(true, false);
    node->topLeft = helper(grid, i, j, w / 2);
    node->topRight = helper(grid, i, j + w / 2, w / 2);
    node->bottomLeft = helper(grid, i + w / 2, j, w / 2);
    node->bottomRight = helper(grid, i + w / 2, j + w / 2, w / 2);
    return node;
  }

  bool allSame(const vector<vector<int>>& grid, int i, int j, int w) {
    return all_of(begin(grid) + i, begin(grid) + i + w,
                  [&](const vector<int>& row) {
      return all_of(begin(row) + j, begin(row) + j + w,
                    [&](int num) { return num == grid[i][j]; });
    });
  }
};",12,877,0.0,-4.0,6.0,1.0,73.08333333333333,16.0,1.7025000000000006
401.0,"class Codec {
 public:
  // Encodes a tree to a single string.
  string serialize(Node* root) {
    if (root == nullptr)
      return """";

    string s;
    queue<Node*> q{{root}};
    s += to_string(root->val) + "" "";

    while (!q.empty())
      for (int sz = q.size(); sz > 0; --sz) {
        Node* node = q.front();
        q.pop();
        if (node->children.empty()) {
          s += ""n"";
        } else {
          for (Node* child : node->children) {
            q.push(child);
            s += to_string(child->val) + ""#"";
          }
        }
        s += "" "";
      }

    return s;
  }

  // Decodes your encoded data to tree.
  Node* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    string word;
    iss >> word;
    Node* root = new Node(stoi(word));
    queue<Node*> q{{root}};

    while (iss >> word) {
      Node* parent = q.front();
      q.pop();
      vector<string> kids = getKids(word);
      vector<Node*> children;
      for (const string& kid : kids) {
        if (kid == ""n"")
          continue;
        Node* child = new Node(stoi(kid));
        children.push_back(child);
        q.push(child);
      }
      parent->children = children;
    }

    return root;
  }

 private:
  vector<string> getKids(const string& word) {
    vector<string> kids;
    for (int i = 0, j = 0; j < word.length(); ++j)
      if (word[j] == '#') {
        kids.push_back(word.substr(i, j - i));
        i = j + 1;
      }
    return kids;
  }
};",36,1511,2.0,7.0,15.0,11.0,41.97222222222222,15.0,3.4825
402.0,"class Solution {
 public:
  vector<vector<int>> levelOrder(Node* root) {
    if (root == nullptr)
      return {};

    vector<vector<int>> ans;
    queue<Node*> q{{root}};

    while (!q.empty()) {
      vector<int> currLevel;
      for (int sz = q.size(); sz > 0; --sz) {
        Node* node = q.front();
        q.pop();
        currLevel.push_back(node->val);
        for (Node* child : node->children)
          q.push(child);
      }
      ans.push_back(currLevel);
    }

    return ans;
  }
};",13,500,0.0,3.0,7.0,4.0,38.46153846153846,5.0,5.438461538461539
403.0,"class Solution {
 public:
  Node* flatten(Node* head, Node* rest = nullptr) {
    if (head == nullptr)
      return rest;

    head->next = flatten(head->child, flatten(head->next, rest));
    if (head->next)
      head->next->prev = head;
    head->child = nullptr;
    return head;
  }
};",6,290,0.0,1.0,2.0,2.0,48.333333333333336,1.0,5.370000000000001
404.0,"class Codec {
 public:
  // Encodes an n-ary tree to a binary tree.
  TreeNode* encode(Node* root) {
    if (root == nullptr)
      return nullptr;

    TreeNode* rootTreeNode = new TreeNode(root->val);
    queue<pair<Node*, TreeNode*>> q{{{root, rootTreeNode}}};

    while (!q.empty()) {
      const auto [parentNode, parentTreeNode] = q.front();
      q.pop();
      TreeNode* prevTreeNode = nullptr;
      TreeNode* headTreeNode = nullptr;
      for (Node* child : parentNode->children) {
        TreeNode* currTreeNode = new TreeNode(child->val);
        if (prevTreeNode != nullptr)
          prevTreeNode->right = currTreeNode;
        else
          headTreeNode = currTreeNode;
        prevTreeNode = currTreeNode;
        q.emplace(child, currTreeNode);
      }
      parentTreeNode->left = headTreeNode;
    }

    return rootTreeNode;
  }

  // Decodes your binary tree to an n-ary tree.
  Node* decode(TreeNode* root) {
    if (root == nullptr)
      return nullptr;

    Node* rootNode = new Node(root->val);
    queue<pair<Node*, TreeNode*>> q{{{rootNode, root}}};

    while (!q.empty()) {
      const auto [parentNode, parentTreeNode] = q.front();
      q.pop();
      TreeNode* sibling = parentTreeNode->left;
      while (sibling) {
        Node* currNode = new Node(sibling->val);
        parentNode->children.push_back(currNode);
        q.emplace(currNode, sibling);
        sibling = sibling->right;
      }
    }

    return rootNode;
  }
};",26,1465,2.0,5.0,13.0,7.0,56.34615384615385,3.0,3.628846153846154
405.0,"class AllOne {
 public:
  void inc(string key) {
    const auto it = keyToIterator.find(key);

    // doesn't find the key
    if (it == cend(keyToIterator)) {
      if (l.empty() || l.front().value > 1)
        l.push_front({1, {key}});
      else
        l.front().keys.insert(key);
      keyToIterator[key] = begin(l);
      return;
    }

    const auto lit = it->second;  // List iterator
    auto nit = next(lit);         // Next iterator

    if (nit == end(l) || nit->value > lit->value + 1)
      nit = l.insert(nit, {lit->value + 1, {key}});
    else  // Nit->value == lit->value + 1
      nit->keys.insert(key);
    keyToIterator[key] = nit;  // Reset the mapping

    // Remove the key in keys set
    lit->keys.erase(key);
    if (lit->keys.empty())
      l.erase(lit);
  }

  void dec(string key) {
    const auto it = keyToIterator.find(key);

    // doens't find the key
    if (it == cend(keyToIterator))
      return;

    const auto lit = it->second;  // List iterator

    if (lit->value == 1) {  // No need to find prev iterator in this case
      keyToIterator.erase(key);
    } else {
      auto pit = prev(lit);  // Prev iterator

      if (lit == begin(l) || pit->value < lit->value - 1)
        pit = l.insert(lit, {lit->value - 1, {key}});
      else  // Pit->value == lit-value - 1
        pit->keys.insert(key);
      keyToIterator[key] = pit;  // Reset the mapping
    }

    // Remove the key in keys set
    lit->keys.erase(key);
    if (lit->keys.empty())
      l.erase(lit);
  }

  string getMaxKey() {
    return l.empty() ? """" : *cbegin(l.back().keys);
  }

  string getMinKey() {
    return l.empty() ? """" : *cbegin(l.front().keys);
  }

 private:
  struct Node {
    int value;
    unordered_set<string> keys;
  };

  list<Node> l;
  unordered_map<string, list<Node>::iterator> keyToIterator;
};",30,1833,13.0,10.0,15.0,8.0,61.1,15.0,2.021000000000001
406.0,"class Solution {
 public:
  int minMutation(string start, string end, vector<string>& bank) {
    unordered_set<string> bankSet{bank.begin(), bank.end()};
    if (!bankSet.count(end))
      return -1;

    int ans = 0;
    queue<string> q{{start}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int j = 0; j < word.length(); ++j) {
          const char cache = word[j];
          for (const char c : {'A', 'C', 'G', 'T'}) {
            word[j] = c;
            if (word == end)
              return ans;
            if (bankSet.count(word)) {
              bankSet.erase(word);
              q.push(word);
            }
          }
          word[j] = cache;
        }
      }
    }

    return -1;
  }
};",19,807,0.0,5.0,11.0,7.0,42.47368421052632,15.0,3.717368421052632
407.0,"class Solution {
 public:
  int countSegments(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i)
      if (s[i] != ' ' && (i == 0 || s[i - 1] == ' '))
        ++ans;

    return ans;
  }
};",6,209,0.0,2.0,2.0,2.0,34.833333333333336,5.0,6.125
408.0,"class Solution {
 public:
  int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    if (intervals.empty())
      return 0;

    sort(begin(intervals), end(intervals),
         [](const auto& a, const auto& b) { return a[1] < b[1]; });

    int ans = 0;
    int currentEnd = intervals[0][1];

    for (int i = 1; i < intervals.size(); ++i)
      if (intervals[i][0] >= currentEnd)
        currentEnd = intervals[i][1];
      else
        ++ans;

    return ans;
  }
};",11,475,0.0,2.0,3.0,3.0,43.18181818181818,8.0,5.013636363636364
409.0,"class Solution {
 public:
  vector<int> findRightInterval(vector<vector<int>>& intervals) {
    vector<int> ans;
    map<int, int> startToIndex;

    for (int i = 0; i < intervals.size(); ++i)
      startToIndex[intervals[i][0]] = i;

    for (const vector<int>& interval : intervals) {
      const auto it = startToIndex.lower_bound(interval[1]);
      if (it == cend(startToIndex))
        ans.push_back(-1);
      else
        ans.push_back(it->second);
    }

    return ans;
  }
};",10,486,0.0,4.0,3.0,3.0,48.6,10.0,4.206
410.0,"class Solution {
 public:
  int pathSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return 0;
    return dfs(root, sum) +            //
           pathSum(root->left, sum) +  //
           pathSum(root->right, sum);
  }

 private:
  int dfs(TreeNode* root, int sum) {
    if (root == nullptr)
      return 0;
    return (sum == root->val) +                //
           dfs(root->left, sum - root->val) +  //
           dfs(root->right, sum - root->val);
  }
};",5,475,4.0,-1.0,3.0,2.0,95.0,5.0,0.990000000000002
411.0,"class Solution {
 public:
  vector<int> findAnagrams(string s, string p) {
    vector<int> ans;
    vector<int> count(128);
    int required = p.length();

    for (const char c : p)
      ++count[c];

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (--count[s[r]] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 == p.length())
          ans.push_back(l);
        if (++count[s[l++]] > 0)
          ++required;
      }
    }

    return ans;
  }
};",11,489,0.0,6.0,4.0,6.0,44.45454545454545,10.0,4.3990909090909085
412.0,"class Solution {
 public:
  string parseTernary(string expression) {
    const char c = expression[i];

    if (i + 1 == expression.length() || expression[i + 1] == ':') {
      i += 2;  // Skip ':'
      return string(1, c);
    }

    i += 2;  // Skip '?'
    const string& first = parseTernary(expression);
    const string& second = parseTernary(expression);
    return c == 'T' ? first : second;
  }

 private:
  int i = 0;
};",9,431,2.0,0.0,3.0,1.0,47.888888888888886,11.0,4.49
413.0,"class Solution {
 public:
  int findKthNumber(long n, int k) {
    auto getGap = [&n](long a, long b) {
      long gap = 0;
      while (a <= n) {
        gap += min(n + 1, b) - a;
        a *= 10;
        b *= 10;
      }
      return gap;
    };

    long currNum = 1;

    for (int i = 1; i < k;) {
      long gap = getGap(currNum, currNum + 1);
      if (i + gap <= k) {
        i += gap;
        ++currNum;
      } else {
        ++i;
        currNum *= 10;
      }
    }

    return currNum;
  }
};",16,504,0.0,3.0,7.0,3.0,31.5,4.0,6.165
414.0,"class Solution {
 public:
  int arrangeCoins(long n) {
    return (-1 + sqrt(8 * n + 1)) / 2;
  }
};",2,100,0.0,0.0,2.0,0.0,50.0,2.0,5.18
415.0,"class Solution {
 public:
  vector<int> findDuplicates(vector<int>& nums) {
    vector<int> ans;

    for (const int num : nums) {
      nums[abs(num) - 1] *= -1;
      if (nums[abs(num) - 1] > 0)
        ans.push_back(abs(num));
    }

    return ans;
  }
};",5,259,0.0,2.0,3.0,2.0,51.8,6.0,4.438
416.0,"class Solution {
 public:
  int compress(vector<char>& chars) {
    int ans = 0;

    for (int i = 0; i < chars.size();) {
      const char letter = chars[i];
      int count = 0;
      while (i < chars.size() && chars[i] == letter) {
        ++count;
        ++i;
      }
      chars[ans++] = letter;
      if (count > 1)
        for (const char c : to_string(count))
          chars[ans++] = c;
    }

    return ans;
  }
};",11,426,0.0,4.0,4.0,4.0,38.72727272727273,10.0,5.034545454545454
417.0,"class Solution {
 public:
  bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {
    if (seqs.empty())
      return false;

    const int n = org.size();
    vector<vector<int>> graph(n);
    vector<int> inDegree(n);

    // Build graph
    for (const vector<int>& seq : seqs) {
      if (seq.size() == 1 && seq[0] < 1 || seq[0] > n)
        return false;
      for (int i = 0; i + 1 < seq.size(); ++i) {
        const int u = seq[i];
        const int v = seq[i + 1];
        if (u < 1 || u > n || v < 1 || v > n)
          return false;
        graph[u - 1].push_back(v - 1);
        ++inDegree[v - 1];
      }
    }

    // Topology
    queue<int> q;

    for (int i = 0; i < n; ++i)
      if (inDegree[i] == 0)
        q.push(i);

    int i = 0;  // org's index

    while (!q.empty()) {
      if (q.size() > 1)
        return false;
      const int u = q.front();
      q.pop();
      if (u != org[i] - 1)
        return false;
      ++i;
      for (const int v : graph[u])
        if (--inDegree[v] == 0)
          q.push(v);
    }

    return i == n;
  }
};",25,1086,3.0,7.0,5.0,12.0,43.44,22.0,3.2904
418.0,"class Solution {
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    stack<ListNode*> stack1;
    stack<ListNode*> stack2;

    while (l1) {
      stack1.push(l1);
      l1 = l1->next;
    }

    while (l2) {
      stack2.push(l2);
      l2 = l2->next;
    }

    ListNode* head = nullptr;
    int carry = 0;

    while (carry || !stack1.empty() || !stack2.empty()) {
      if (!stack1.empty())
        carry += stack1.top()->val, stack1.pop();
      if (!stack2.empty())
        carry += stack2.top()->val, stack2.pop();
      ListNode* node = new ListNode(carry % 10);
      node->next = head;
      head = node;
      carry /= 10;
    }

    return head;
  }
};",16,681,0.0,5.0,5.0,5.0,42.5625,2.0,5.369375000000001
419.0,"class Solution {
 public:
  int numberOfArithmeticSlices(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // dp[i][j] := # of subseqs end w/ nums[j] nums[i]
    vector<vector<int>> dp(n, vector<int>(n));
    unordered_map<long, vector<int>> numToIndices;

    for (int i = 0; i < n; ++i)
      numToIndices[nums[i]].push_back(i);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const long target = nums[j] * 2L - nums[i];
        if (const auto it = numToIndices.find(target); it != cend(numToIndices))
          for (const int k : it->second)
            if (k < j)
              dp[i][j] += (dp[j][k] + 1);
        ans += dp[i][j];
      }

    return ans;
  }
};",17,718,1.0,6.0,3.0,6.0,42.23529411764706,16.0,4.098823529411765
420.0,"class Solution {
 public:
  int numberOfBoomerangs(vector<vector<int>>& points) {
    int ans = 0;

    for (const vector<int>& p : points) {
      unordered_map<int, int> distCount;
      for (const vector<int>& q : points) {
        const int dist = getDist(p, q);
        ++distCount[dist];
      }
      for (const auto& [_, freq] : distCount)
        ans += freq * (freq - 1);  // C(freq, 2)
    }

    return ans;
  }

 private:
  int getDist(const vector<int>& p, const vector<int>& q) {
    return pow(p[0] - q[0], 2) + pow(p[1] - q[1], 2);
  }
};",8,555,1.0,2.0,5.0,3.0,69.375,18.0,1.57625
421.0,"class Solution {
 public:
  vector<int> findDisappearedNumbers(vector<int>& nums) {
    vector<int> ans;

    for (const int num : nums) {
      const int index = abs(num) - 1;
      nums[index] = -abs(nums[index]);
    }

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > 0)
        ans.push_back(i + 1);

    return ans;
  }
};",8,341,0.0,3.0,3.0,3.0,42.625,9.0,4.9037500000000005
422.0,"class Codec {
 public:
  string serialize(TreeNode* root) {
    if (root == nullptr)
      return """";

    string s;

    serialize(root, s);
    return s;
  }

  TreeNode* deserialize(string data) {
    if (data.empty())
      return nullptr;

    istringstream iss(data);
    queue<int> q;

    for (string s; iss >> s;)
      q.push(stoi(s));

    return deserialize(INT_MIN, INT_MAX, q);
  }

 private:
  void serialize(TreeNode* root, string& s) {
    if (root == nullptr)
      return;

    s += to_string(root->val) + "" "";
    serialize(root->left, s);
    serialize(root->right, s);
  }

  TreeNode* deserialize(int min, int max, queue<int>& q) {
    if (q.empty())
      return nullptr;

    const int val = q.front();
    if (val < min || val > max)
      return nullptr;

    q.pop();
    TreeNode* root = new TreeNode(val);
    root->left = deserialize(min, val, q);
    root->right = deserialize(val, max, q);
    return root;
  }
};",24,946,0.0,-1.0,5.0,6.0,39.41666666666666,13.0,4.9125
423.0,"class Solution {
 public:
  TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr)
      return nullptr;
    if (root->val == key) {
      if (root->left == nullptr)
        return root->right;
      if (root->right == nullptr)
        return root->left;
      TreeNode* minNode = getMin(root->right);
      root->right = deleteNode(root->right, minNode->val);
      minNode->left = root->left;
      minNode->right = root->right;
      root = minNode;
    } else if (root->val < key) {
      root->right = deleteNode(root->right, key);
    } else {  // root->val > key
      root->left = deleteNode(root->left, key);
    }
    return root;
  }

 private:
  TreeNode* getMin(TreeNode* node) {
    while (node->left)
      node = node->left;
    return node;
  }
};",14,782,1.0,4.0,6.0,6.0,55.85714285714285,2.0,4.212857142857143
424.0,"class Solution {
 public:
  string frequencySort(string s) {
    const int n = s.length();
    string ans;
    vector<int> count(128);
    // bucket[i] := stores chars that appear i times in s
    vector<vector<char>> bucket(n + 1);

    for (const char c : s)
      ++count[c];

    for (int i = 0; i < 128; ++i) {
      const int freq = count[i];
      if (freq > 0)
        bucket[freq].push_back((char)i);
    }

    for (int freq = n; freq > 0; --freq)
      for (const char c : bucket[freq])
        ans += string(freq, c);

    return ans;
  }
};",14,553,1.0,5.0,3.0,5.0,39.5,18.0,4.205000000000001
425.0,"class Solution {
 public:
  int findMinArrowShots(vector<vector<int>>& points) {
    sort(begin(points), end(points),
         [](const auto& a, const auto& b) { return a[1] < b[1]; });

    int ans = 1;
    int arrowX = points[0][1];

    for (int i = 1; i < points.size(); ++i)
      if (points[i][0] > arrowX) {
        arrowX = points[i][1];
        ++ans;
      }

    return ans;
  }
};",10,392,0.0,1.0,4.0,2.0,39.2,8.0,5.372
426.0,"class Solution {
 public:
  int minMoves(vector<int>& nums) {
    const int min = *min_element(begin(nums), end(nums));
    return accumulate(begin(nums), end(nums), 0,
                      [&](int a, int b) { return a + (b - min); });
  }
};",4,243,0.0,-1.0,3.0,0.0,60.75,7.0,3.7125
427.0,"class Solution {
 public:
  int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,
                   vector<int>& nums4) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int a : nums1)
      for (const int b : nums2)
        ++count[a + b];

    for (const int c : nums3)
      for (const int d : nums4)
        if (const auto it = count.find(-c - d); it != cend(count))
          ans += it->second;

    return ans;
  }
};",7,467,0.0,5.0,2.0,5.0,66.71428571428571,18.0,1.775714285714287
428.0,"class Solution {
 public:
  int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(begin(g), end(g));
    sort(begin(s), end(s));

    int i = 0;
    for (int j = 0; j < s.size() && i < g.size(); ++j)
      if (g[i] <= s[j])
        ++i;

    return i;
  }
};",8,271,0.0,2.0,2.0,2.0,33.875,6.0,6.11125
429.0,"class Solution {
 public:
  bool find132pattern(vector<int>& nums) {
    stack<int> stack;  // decreasing stack
    int ak = INT_MIN;  // We want to find a seq ai < ak < aj.

    for (int i = nums.size() - 1; i >= 0; --i) {
      // ai < ak, we're done because ai must also smaller than aj.
      if (nums[i] < ak)
        return true;
      while (!stack.empty() && stack.top() < nums[i])
        ak = stack.top(), stack.pop();
      stack.push(nums[i]);  // nums[i] is a candidate of aj.
    }

    return false;
  }
};",9,521,4.0,2.0,3.0,3.0,57.888888888888886,6.0,4.05
430.0,"class Solution {
 public:
  bool circularArrayLoop(vector<int>& nums) {
    const int n = nums.size();
    if (n < 2)
      return false;

    auto advance = [&](int i) {
      const int val = (i + nums[i]) % n;
      return i + nums[i] >= 0 ? val : n + val;
    };

    for (int i = 0; i < n; ++i) {
      if (nums[i] == 0)
        continue;
      int slow = i;
      int fast = advance(slow);
      while (nums[i] * nums[fast] > 0 && nums[i] * nums[advance(fast)] > 0) {
        if (slow == fast) {
          if (slow == advance(slow))
            break;
          return true;
        }
        slow = advance(slow);
        fast = advance(advance(fast));
      }

      slow = i;
      const int sign = nums[i];
      while (sign * nums[slow] > 0) {
        const int next = advance(slow);
        nums[slow] = 0;
        slow = next;
      }
    }

    return false;
  }
};",21,878,0.0,2.0,7.0,7.0,41.80952380952381,15.0,4.197142857142857
431.0,"class Solution {
 public:
  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
    return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));
  }
};",2,170,0.0,0.0,2.0,0.0,85.0,5.0,1.7300000000000022
432.0,"class Solution {
 public:
  bool repeatedSubstringPattern(string s) {
    const string ss = s + s;
    return ss.substr(1, ss.length() - 2).find(s) != string::npos;
  }
};",3,171,0.0,0.0,2.0,0.0,57.0,6.0,4.15
433.0,"struct Node {
  int key;
  int value;
  int freq;
  list<int>::const_iterator it;
};

class LFUCache {
 public:
  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}

  int get(int key) {
    const auto it = keyToNode.find(key);
    if (it == cend(keyToNode))
      return -1;

    Node& node = it->second;
    touch(node);
    return node.value;
  }

  void put(int key, int value) {
    if (capacity == 0)
      return;
    if (const auto it = keyToNode.find(key); it != cend(keyToNode)) {
      Node& node = it->second;
      node.value = value;
      touch(node);
      return;
    }

    if (keyToNode.size() == capacity) {
      // Evict LRU key from the minFreq list
      const int keyToEvict = freqToList[minFreq].back();
      freqToList[minFreq].pop_back();
      keyToNode.erase(keyToEvict);
    }

    minFreq = 1;
    freqToList[1].push_front(key);
    keyToNode[key] = {key, value, 1, cbegin(freqToList[1])};
  }

 private:
  int capacity;
  int minFreq;
  unordered_map<int, Node> keyToNode;
  unordered_map<int, list<int>> freqToList;

  void touch(Node& node) {
    // Update the node's frequency
    const int prevFreq = node.freq;
    const int newFreq = ++node.freq;

    // Remove the iterator from prevFreq's list
    freqToList[prevFreq].erase(node.it);
    if (freqToList[prevFreq].empty()) {
      freqToList.erase(prevFreq);
      // Update minFreq if needed
      if (prevFreq == minFreq)
        ++minFreq;
    }

    // Insert the key to the front of newFreq's list
    freqToList[newFreq].push_front(node.key);
    node.it = cbegin(freqToList[newFreq]);
  }
};",34,1598,5.0,4.0,10.0,7.0,47.0,26.0,2.53
434.0,"class Solution {
 public:
  int hammingDistance(int x, int y) {
    int ans = 0;

    while (x || y) {
      ans += (x & 1) ^ (y & 1);
      x >>= 1;
      y >>= 1;
    }

    return ans;
  }
};",6,194,0.0,1.0,3.0,1.0,32.333333333333336,5.0,6.35
435.0,"class Solution {
 public:
  int minMoves2(vector<int>& nums) {
    const int n = nums.size();
    nth_element(begin(nums), begin(nums) + n / 2, end(nums));
    const int median = nums[n / 2];
    return accumulate(begin(nums), end(nums), 0,
                      [&](int a, int b) { return a + abs(b - median); });
  }
};",6,321,0.0,-1.0,3.0,0.0,53.5,9.0,4.165
436.0,"class Solution {
 public:
  int islandPerimeter(vector<vector<int>>& grid) {
    int islands = 0;
    int neighbors = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j]) {
          ++islands;
          if (i - 1 >= 0 && grid[i - 1][j])
            ++neighbors;
          if (j - 1 >= 0 && grid[i][j - 1])
            ++neighbors;
        }

    return islands * 4 - neighbors * 2;
  }
};",11,453,0.0,5.0,3.0,5.0,41.18181818181818,7.0,5.113636363636364
437.0,"class Solution {
 public:
  bool canIWin(int maxChoosableInteger, int desiredTotal) {
    if (desiredTotal <= 0)
      return true;

    const int sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2;
    if (sum < desiredTotal)
      return false;

    return dp(desiredTotal, 0, maxChoosableInteger);
  }

 private:
  unordered_map<int, bool> memo;  // true: can win, false: can't win

  // state: record integers that have been chosen
  bool dp(int total, int state, int n) {
    if (total <= 0)
      return false;
    if (const auto it = memo.find(state); it != cend(memo))
      return it->second;

    for (int i = 1; i <= n; ++i) {
      if (state & 1 << i)  // Integer i is used
        continue;
      if (!dp(total - i, state | 1 << i, n))
        return true;
    }

    return memo[state] = false;
  }
};",14,822,3.0,0.0,4.0,7.0,58.71428571428572,14.0,3.1957142857142857
438.0,"class Solution {
 public:
  int minTransfers(vector<vector<int>>& transactions) {
    vector<int> balance(21);
    vector<int> debt;

    for (const vector<int>& t : transactions) {
      const int from = t[0];
      const int to = t[1];
      const int amount = t[2];
      balance[from] -= amount;
      balance[to] += amount;
    }

    for (const int b : balance)
      if (b > 0)
        debt.push_back(b);

    return dfs(debt, 0);
  }

 private:
  int dfs(vector<int>& debt, int s) {
    while (s < debt.size() && !debt[s])
      ++s;
    if (s == debt.size())
      return 0;

    int ans = INT_MAX;

    for (int i = s + 1; i < debt.size(); ++i)
      if (debt[i] * debt[s] < 0) {
        debt[i] += debt[s];  // debt[s] is settled
        ans = min(ans, 1 + dfs(debt, s + 1));
        debt[i] -= debt[s];  // Backtrack
      }

    return ans;
  }
};",19,860,2.0,5.0,5.0,7.0,45.26315789473684,20.0,3.406315789473685
439.0,"struct Record {
  int count;
  int nextIndex;
  Record(int count, int nextIndex) : count(count), nextIndex(nextIndex) {}
};

class Solution {
 public:
  int getMaxRepetitions(string s1, int n1, string s2, int n2) {
    vector<Record> records;  // [count(s1 matches s2[i:]), next index of s2[i:]]

    for (int i = 0; i < s2.length(); ++i) {
      int count = 0;
      int nextIndex = i;
      for (int j = 0; j < s1.length(); ++j)
        if (s2[nextIndex] == s1[j])
          if (++nextIndex == s2.length()) {  // Have a match
            ++count;
            nextIndex = 0;
          }
      records.emplace_back(count, nextIndex);
    }

    int matches = 0;  // S1 matches s2
    int index = 0;

    while (n1--) {
      matches += records[index].count;
      index = records[index].nextIndex;
    }

    return matches / n2;  // S1 matches S2
  }
};",19,854,4.0,5.0,7.0,5.0,44.94736842105263,17.0,3.694736842105264
440.0,"class Solution {
 public:
  int findSubstringInWraproundString(string p) {
    int maxLength = 1;
    vector<int> count(26);  // Substrings end at i

    for (int i = 0; i < p.length(); ++i) {
      if (i > 0 && (p[i] - p[i - 1] == 1 || p[i - 1] - p[i] == 25))
        ++maxLength;
      else
        maxLength = 1;
      const int index = p[i] - 'a';
      count[index] = max(count[index], maxLength);
    }

    return accumulate(begin(count), end(count), 0);
  }
};",10,468,1.0,3.0,3.0,2.0,46.8,8.0,4.668000000000001
441.0,"class Solution {
 public:
  string validIPAddress(string IP) {
    string digit;
    istringstream iss(IP);

    if (count(begin(IP), end(IP), '.') == 3) {
      for (int i = 0; i < 4; ++i)  // Make sure we have 4 parts
        if (!getline(iss, digit, '.') || !isIPv4(digit))
          return ""Neither"";
      return ""IPv4"";
    }

    if (count(begin(IP), end(IP), ':') == 7) {
      for (int i = 0; i < 8; ++i)  // Make sure we have 8 parts
        if (!getline(iss, digit, ':') || !isIPv6(digit))
          return ""Neither"";
      return ""IPv6"";
    }

    return ""Neither"";
  }

 private:
  static inline string validIPv6Chars = ""0123456789abcdefABCDEF"";

  bool isIPv4(const string& digit) {
    if (digit.empty() || digit.length() > 3)
      return false;
    if (digit.length() > 1 && digit[0] == '0')
      return false;

    for (const char c : digit)
      if (c < '0' || c > '9')
        return false;

    const int num = stoi(digit);
    return 0 <= num && num <= 255;
  }

  bool isIPv6(const string& digit) {
    if (digit.empty() || digit.length() > 4)
      return false;

    for (const char c : digit)
      if (validIPv6Chars.find(c) == string::npos)
        return false;

    return true;
  }
};",21,1218,2.0,2.0,6.0,13.0,58.0,20.0,2.38
442.0,"class Solution {
 public:
  bool isConvex(vector<vector<int>>& points) {
    auto getCross = [](const vector<int>& p, const vector<int>& q,
                       const vector<int>& r) -> int {
      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0]);
    };

    const int n = points.size();
    long sign = 0;

    for (int i = 0; i < points.size(); ++i) {
      const int cross =
          getCross(points[i], points[(i + 1) % n], points[(i + 2) % n]);
      if (cross == 0)  // P, q, r are collinear
        continue;
      if (sign == 0)  // Find first cross that's not 0
        sign = cross;
      else if (cross * sign < 0)
        return false;
    }

    return true;
  }
};",12,702,2.0,2.0,4.0,4.0,58.5,15.0,2.955
443.0,"// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
 public:
  int rand10() {
    int num = 40;

    while (num >= 40)
      num = (rand7() - 1) * 7 + rand7() - 1;

    return num % 10 + 1;
  }
};",5,273,3.0,1.0,2.0,2.0,54.6,4.0,4.626
444.0,"class Solution {
 public:
  string encode(string s) {
    const int n = s.length();
    // dp[i][j] := shortest encoded string of s[i..j]
    dp.resize(n, vector<string>(n));
    return encode(s, 0, n - 1);
  }

 private:
  vector<vector<string>> dp;

  string encode(const string& s, int i, int j) {
    if (!dp[i][j].empty())
      return dp[i][j];

    const string& curr = s.substr(i, j - i + 1);
    dp[i][j] = curr;

    if (dp[i][j].length() < 5)
      return dp[i][j];

    // Try all possible partitions
    for (int k = i; k < j; ++k) {
      const string& l = encode(s, i, k);
      const string& r = encode(s, k + 1, j);
      if (l.length() + r.length() < dp[i][j].length())
        dp[i][j] = l + r;
    }

    // Try to compress the string
    // E.g. s = aabaabaab -> 3[aab]
    for (int k = i; k <= j; ++k) {
      const string& pattern = s.substr(i, k - i + 1);
      if (curr.length() % pattern.length() == 0 &&
          regex_replace(curr, regex(pattern), """").empty()) {
        const string& candidate = to_string(curr.length() / pattern.length()) +
                                  '[' + encode(s, i, k) + ']';
        if (candidate.length() < dp[i][j].length())
          dp[i][j] = candidate;
      }
    }

    return dp[i][j];
  }
};",20,1261,4.0,4.0,6.0,7.0,63.05,26.0,1.2855000000000008
445.0,"class Solution {
 public:
  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
    vector<string> ans;
    unordered_set<string> wordSet{begin(words), end(words)};
    unordered_map<string, bool> memo;

    for (const string& word : words)
      if (isConcat(word, wordSet, memo))
        ans.push_back(word);

    return ans;
  }

 private:
  bool isConcat(const string& s, const unordered_set<string>& wordSet,
                unordered_map<string, bool>& memo) {
    if (const auto it = memo.find(s); it != cend(memo))
      return it->second;

    for (int i = 1; i < s.length(); ++i) {
      const string prefix = s.substr(0, i);
      const string suffix = s.substr(i);
      if (wordSet.count(prefix) &&
          (wordSet.count(suffix) || isConcat(suffix, wordSet, memo)))
        return memo[s] = true;
    }

    return memo[s] = false;
  }
};",14,874,0.0,2.0,5.0,5.0,62.42857142857143,22.0,1.7614285714285725
446.0,"class Solution {
 public:
  bool makesquare(vector<int>& matchsticks) {
    if (matchsticks.size() < 4)
      return false;

    const int perimeter = accumulate(begin(matchsticks), end(matchsticks), 0);
    if (perimeter % 4 != 0)
      return false;

    sort(begin(matchsticks), end(matchsticks), greater<int>());
    return dfs(matchsticks, 0, vector<int>(4, perimeter / 4));
  }

 private:
  bool dfs(const vector<int>& matchsticks, int selected, vector<int>&& edges) {
    if (selected == matchsticks.size())
      return all_of(begin(edges), end(edges),
                    [](int edge) { return edge == 0; });

    for (int i = 0; i < 4; ++i) {
      if (matchsticks[selected] > edges[i])
        continue;
      edges[i] -= matchsticks[selected];
      if (dfs(matchsticks, selected + 1, move(edges)))
        return true;
      edges[i] += matchsticks[selected];
    }

    return false;
  }
};",15,904,0.0,-1.0,5.0,6.0,60.266666666666666,14.0,2.936
447.0,"class Solution {
 public:
  int findMaxForm(vector<string>& strs, int m, int n) {
    // dp[i][j] := max size of the subset given i 0's and j 1's are available
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (const string& s : strs) {
      const int count0 = count(begin(s), end(s), '0');
      const int count1 = s.length() - count0;
      for (int i = m; i >= count0; --i)
        for (int j = n; j >= count1; --j)
          dp[i][j] = max(dp[i][j], dp[i - count0][j - count1] + 1);
    }

    return dp[m][n];
  }
};",10,536,1.0,3.0,3.0,4.0,53.6,15.0,3.3560000000000008
448.0,"class Solution {
 public:
  int findRadius(vector<int>& houses, vector<int>& heaters) {
    sort(begin(houses), end(houses));
    sort(begin(heaters), end(heaters));

    int ans = 0;
    int i = 0;  // Point to the heater that currently used

    for (const int house : houses) {
      while (i + 1 < heaters.size() &&
             house - heaters[i] > heaters[i + 1] - house)
        ++i;  // Next heater is better
      ans = max(ans, abs(heaters[i] - house));
    }

    return ans;
  }
};",8,493,2.0,2.0,3.0,2.0,61.625,8.0,3.4337500000000007
449.0,"class Solution {
 public:
  int findComplement(long num) {
    for (long i = 1; i <= num; i <<= 1)
      num ^= i;
    return num;
  }
};",5,137,0.0,1.0,2.0,1.0,27.4,2.0,7.154
450.0,"class Solution {
 public:
  int totalHammingDistance(vector<int>& nums) {
    int ans = 0;
    int mask = 1;

    for (int i = 0; i < 30; ++i) {
      const int onesCount = count_if(begin(nums), end(nums),
                                     [&mask](int num) { return num & mask; });
      const int zerosCount = nums.size() - onesCount;
      ans += onesCount * zerosCount;
      mask <<= 1;
    }

    return ans;
  }
};",11,423,0.0,0.0,4.0,2.0,38.45454545454545,11.0,5.199090909090909
451.0,"class Solution {
 public:
  Solution(double radius, double x_center, double y_center)
      : radius(radius), x_center(x_center), y_center(y_center) {}

  vector<double> randPoint() {
    const double length = sqrt(distribution(generator)) * radius;
    const double degree = distribution(generator) * 2 * M_PI;
    const double x = x_center + length * cos(degree);
    const double y = y_center + length * sin(degree);
    return {x, y};
  }

 private:
  const double radius;
  const double x_center;
  const double y_center;
  default_random_engine generator;
  uniform_real_distribution<double> distribution =
      uniform_real_distribution<double>(0.0, 1.0);
};",11,666,0.0,0.0,4.0,4.0,60.54545454545455,21.0,2.210909090909091
452.0,"class Solution {
 public:
  int largestPalindrome(int n) {
    if (n == 1)
      return 9;

    constexpr int kMod = 1337;
    const int upper = pow(10, n) - 1;
    const int lower = pow(10, n - 1) - 1;

    for (int i = upper; i > lower; --i) {
      const long cand = getPalindromeCandidate(i);
      for (long j = upper; j * j >= cand; --j)
        if (cand % j == 0)
          return cand % kMod;
    }

    throw;
  }

 private:
  long getPalindromeCandidate(int i) {
    string reversed = to_string(i);
    reverse(begin(reversed), end(reversed));
    return stol(to_string(i) + reversed);
  }
};",15,602,0.0,1.0,4.0,4.0,40.13333333333333,12.0,4.888000000000001
453.0,"class Solution {
 public:
  vector<double> medianSlidingWindow(vector<int>& nums, int k) {
    vector<double> ans;
    multiset<double> window(begin(nums), begin(nums) + k);
    auto it = next(begin(window), (k - 1) / 2);

    for (int i = k;; ++i) {
      const double median = k & 1 ? *it : (*it + *next(it)) / 2.0;
      ans.push_back(median);
      if (i == nums.size())
        break;
      window.insert(nums[i]);
      if (nums[i] < *it)
        --it;
      if (nums[i - k] <= *it)
        ++it;
      window.erase(window.lower_bound(nums[i - k]));
    }

    return ans;
  }
};",14,585,0.0,3.0,3.0,4.0,41.785714285714285,9.0,4.979285714285715
454.0,"class Solution {
 public:
  int magicalString(int n) {
    string s = "" 122"";

    for (int i = 3; i <= n; ++i)
      if (i & 1)
        s.append(s[i] - '0', '1');
      else
        s.append(s[i] - '0', '2');

    return count(begin(s), begin(s) + n + 1, '1');
  }
};",7,268,0.0,3.0,2.0,2.0,38.285714285714285,5.0,5.754285714285715
455.0,"class Solution {
 public:
  string licenseKeyFormatting(string s, int k) {
    string ans;
    int length = 0;

    for (int i = s.length() - 1; i >= 0; --i) {
      if (s[i] == '-')
        continue;
      if (length > 0 && length % k == 0)
        ans += ""-"";
      ans += toupper(s[i]);
      ++length;
    }

    return {rbegin(ans), rend(ans)};
  }
};",10,356,0.0,2.0,4.0,4.0,35.6,7.0,5.736
456.0,"class Solution {
 public:
  string smallestGoodBase(string n) {
    const long num = stol(n);

    for (int m = log2(num); m >= 2; --m) {
      const int k = pow(num, 1.0 / m);
      long sum = 1;
      long prod = 1;
      for (int i = 0; i < m; ++i) {
        prod *= k;
        sum += prod;
      }
      if (sum == num)
        return to_string(k);
    }

    return to_string(num - 1);
  }
};",13,397,0.0,2.0,4.0,3.0,30.53846153846154,8.0,6.091538461538462
457.0,"class Solution {
 public:
  vector<int> findPermutation(string s) {
    vector<int> ans;
    stack<int> stack;

    for (int i = 0; i < s.length(); ++i) {
      stack.push(i + 1);
      if (s[i] == 'I')
        while (!stack.empty())
          ans.push_back(stack.top()), stack.pop();
    }
    stack.push(s.length() + 1);

    while (!stack.empty())
      ans.push_back(stack.top()), stack.pop();

    return ans;
  }
};",10,421,0.0,4.0,3.0,4.0,42.1,6.0,5.191
458.0,"class Solution {
 public:
  int findMaxConsecutiveOnes(vector<int>& nums) {
    int ans = 0;
    int sum = 0;

    for (const int num : nums)
      if (num == 1)
        ans = max(ans, ++sum);
      else
        sum = 0;

    return ans;
  }
};",6,244,0.0,3.0,2.0,2.0,40.66666666666666,7.0,5.340000000000001
459.0,"class Solution {
 public:
  bool PredictTheWinner(vector<int>& nums) {
    const int n = nums.size();
    // dp[i][j] := max number you can get more than your opponent in nums[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = nums[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
      }

    return dp[0][n - 1] >= 0;
  }
};",13,507,1.0,3.0,3.0,3.0,39.0,12.0,4.970000000000001
460.0,"class Solution {
 public:
  int findMaxConsecutiveOnes(vector<int>& nums) {
    int ans = 0;
    int zeros = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        ++zeros;
      while (zeros == 2)
        if (nums[l++] == 0)
          --zeros;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",9,339,0.0,4.0,3.0,4.0,37.66666666666666,6.0,5.59
461.0,"class Solution {
 public:
  int findMinStep(string board, string hand) {
    const int ans = dfs(board + ""#"", hand, {});
    return ans == INT_MAX ? -1 : ans;
  }

 private:
  int dfs(string&& board, const string& hand,
          unordered_map<string, int>&& memo) {
    const string hashKey = board + '#' + hand;
    if (const auto it = memo.find(hashKey); it != cend(memo))
      return it->second;
    board = deDup(board);
    if (board == ""#"")
      return 0;

    unordered_set<char> boardSet = unordered_set(begin(board), end(board));

    string hs;  // Hand that in board
    for (const char h : hand)
      if (boardSet.count(h))
        hs += h;
    if (hs.empty())  // Infeasible
      return INT_MAX;

    int ans = INT_MAX;

    for (int i = 0; i < board.size(); ++i)
      for (int j = 0; j < hs.size(); ++j) {
        // Place hs[j] in board[i]
        const string& newHand = hs.substr(0, j) + hs.substr(j + 1);
        string newBoard = board.substr(0, i) + hs[j] + board.substr(i);
        const int res = dfs(move(newBoard), newHand, move(memo));
        if (res < INT_MAX)
          ans = min(ans, 1 + res);
      }

    return memo[hashKey] = ans;
  }

  string deDup(string board) {
    int start = 0;  // Start index of a color sequenece
    for (int i = 0; i < board.size(); ++i)
      if (board[i] != board[start]) {
        if (i - start >= 3)
          return deDup(board.substr(0, start) + board.substr(i));
        start = i;  // Meet a new sequence
      }
    return board;
  }
};",28,1512,5.0,5.0,7.0,11.0,54.0,31.0,1.5199999999999996
462.0,"/**
 * // This is the robot's control interface.
 * // You should not implement it, or speculate about its implementation
 * class Robot {
 *  public:
 *   // Returns true if the cell in front is open and robot moves into the cell.
 *   // Returns false if the cell in front is blocked and robot stays in the
 *   // Current cell. bool move();
 *
 *   // Robot will stay in the same cell after calling turnLeft/turnRight.
 *   // Each turn will be 90 degrees.
 *   void turnLeft();
 *   void turnRight();
 *
 *   // Clean the current cell.
 *   void clean();
 * };
 */

class Solution {
 public:
  void cleanRoom(Robot& robot) {
    dfs(robot, 0, 0, 0, unordered_set<pair<int, int>, pairHash>());
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };

  void dfs(Robot& robot, int i, int j, int d,
           unordered_set<pair<int, int>, pairHash>&& seen) {
    seen.insert({i, j});
    robot.clean();

    // Explore clockwise: 0: ^, 1: >, 2: v, 3: <
    // The order is important since the idea is always turn right
    for (int k = 0; k < 4; ++k) {
      const int newD = (d + k) % 4;
      const int x = i + dirs[newD];
      const int y = j + dirs[newD + 1];
      if (!seen.count({x, y}) && robot.move()) {
        dfs(robot, x, y, newD, move(seen));
        // Go back to the previous cell
        robot.turnRight();
        robot.turnRight();
        robot.move();
        // Go back to the original direction
        robot.turnRight();
        robot.turnRight();
      }
      robot.turnRight();  // Always turn the robot clockwise
    }
  }
};",24,1677,6.0,4.0,11.0,4.0,69.875,29.0,0.151250000000001
463.0,"class Solution {
 public:
  bool hasPath(vector<vector<int>>& maze, vector<int>& start,
               vector<int>& destination) {
    const int m = maze.size();
    const int n = maze[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q{{{start[0], start[1]}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[start[0]][start[1]] = true;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        int x = i;
        int y = j;
        while (isValid(maze, x + dirs[k], y + dirs[k + 1])) {
          x += dirs[k];
          y += dirs[k + 1];
        }
        if (x == destination[0] && y == destination[1])
          return true;
        if (seen[x][y])
          continue;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return false;
  }

 private:
  bool isValid(const vector<vector<int>>& maze, int x, int y) {
    return 0 <= x && x < maze.size() && 0 <= y && y < maze[0].size() &&
           maze[x][y] == 0;
  }
};",21,1050,0.0,2.0,10.0,5.0,50.0,24.0,2.38
464.0,"class Solution {
 public:
  vector<vector<int>> findSubsequences(vector<int>& nums) {
    vector<vector<int>> ans;
    dfs(nums, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const vector<int>& nums, int s, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (path.size() > 1)
      ans.push_back(path);

    unordered_set<int> used;

    for (int i = s; i < nums.size(); ++i) {
      if (used.count(nums[i]))
        continue;
      if (path.empty() || nums[i] >= path.back()) {
        used.insert(nums[i]);
        path.push_back(nums[i]);
        dfs(nums, i + 1, move(path), ans);
        path.pop_back();
      }
    }
  }
};",13,654,0.0,3.0,6.0,4.0,50.30769230769231,12.0,3.732307692307693
465.0,"class Solution {
 public:
  vector<int> constructRectangle(int area) {
    int width = sqrt(area);

    while (area % width)
      --width;

    return {area / width, width};
  }
};",4,181,0.0,1.0,3.0,1.0,45.25,4.0,5.2875000000000005
466.0,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  int reversePairs(vector<int>& nums) {
    int ans = 0;
    unordered_map<long, int> ranks;
    getRanks(nums, ranks);
    FenwickTree tree(ranks.size());

    for (int i = nums.size() - 1; i >= 0; --i) {
      const long num = nums[i];
      ans += tree.get(ranks[num] - 1);
      tree.update(ranks[num * 2], 1);
    }

    return ans;
  }

 private:
  void getRanks(const vector<int>& nums, unordered_map<long, int>& ranks) {
    set<long> sorted(begin(nums), end(nums));
    for (const long num : nums)
      sorted.insert(num * 2);
    int rank = 0;
    for (const long num : sorted)
      ranks[num] = ++rank;
  }
};",24,1064,0.0,3.0,11.0,5.0,44.333333333333336,26.0,2.5700000000000003
467.0,"class Solution {
 public:
  int findTargetSumWays(vector<int>& nums, int target) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    if (sum < abs(target) || (sum + target) & 1)
      return 0;
    return knapsack(nums, (sum + target) / 2);
  }

 private:
  int knapsack(const vector<int>& nums, int target) {
    const int n = nums.size();
    // dp[i][j] := # of ways to sum to j by nums[0..i)
    vector<vector<int>> dp(n + 1, vector<int>(target + 1));
    dp[0][0] = 1;

    for (int i = 1; i <= n; ++i) {
      const int num = nums[i - 1];
      for (int j = 0; j <= target; ++j)
        if (j < num)
          dp[i][j] = dp[i - 1][j];
        else
          dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num];
    }

    return dp[n][target];
  }
};",15,762,1.0,3.0,4.0,4.0,50.8,18.0,3.248000000000001
468.0,"class Solution {
 public:
  int findPoisonedDuration(vector<int>& timeSeries, int duration) {
    if (duration == 0)
      return 0;

    int ans = 0;

    for (int i = 0; i + 1 < timeSeries.size(); ++i)
      ans += min(timeSeries[i + 1] - timeSeries[i], duration);

    return ans + duration;
  }
};",7,301,0.0,1.0,2.0,2.0,43.0,6.0,5.3500000000000005
469.0,"class Solution {
 public:
  vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    vector<int> ans;
    unordered_map<int, int> numToNextGreater;
    stack<int> stack;  // decreasing stack

    for (const int num : nums2) {
      while (!stack.empty() && stack.top() < num)
        numToNextGreater[stack.top()] = num, stack.pop();
      stack.push(num);
    }

    for (const int num : nums1)
      if (const auto it = numToNextGreater.find(num);
          it != cend(numToNextGreater))
        ans.push_back(it->second);
      else
        ans.push_back(-1);

    return ans;
  }
};",10,606,1.0,5.0,3.0,4.0,60.6,13.0,2.806000000000001
470.0,"class Solution {
 public:
  vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<int> ans(m * n);
    int d = 1;  // Left-bottom -> right-top
    int row = 0;
    int col = 0;

    for (int i = 0; i < m * n; ++i) {
      ans[i] = matrix[row][col];
      row -= d;
      col += d;
      // Out of bound
      if (row == m)
        row = m - 1, col += 2, d = -d;
      if (col == n)
        col = n - 1, row += 2, d = -d;
      if (row < 0)
        row = 0, d = -d;
      if (col < 0)
        col = 0, d = -d;
    }

    return ans;
  }
};",17,625,2.0,5.0,3.0,5.0,36.76470588235294,12.0,5.091176470588236
471.0,"class Solution {
 public:
  string findShortestWay(vector<vector<int>>& maze, vector<int>& ball,
                         vector<int>& hole) {
    string ans = ""impossible"";
    dfs(maze, ball[0], ball[1], hole, 0, 0, 0, INT_MAX, """", ans);
    return ans;
  }

 private:
  void dfs(vector<vector<int>>& maze, int i, int j, const vector<int>& hole,
           int dx, int dy, int steps, int&& minSteps, string&& path,
           string& ans) {
    if (steps >= minSteps)
      return;

    if (dx != 0 || dy != 0) {  // Both are zero for the initial ball position
      while (i + dx >= 0 && i + dx < maze.size() && j + dy >= 0 &&
             j + dy < maze[0].size() && maze[i + dx][j + dy] != 1) {
        i += dx;
        j += dy;
        ++steps;
        if (i == hole[0] && j == hole[1] && steps < minSteps) {
          minSteps = steps;
          ans = path;
        }
      }
    }

    if (maze[i][j] == 0 || steps + 2 < maze[i][j]) {
      maze[i][j] = steps + 2;  // +2 to because of maze[i][j] == 0 || 1
      if (dx == 0)
        dfs(maze, i, j, hole, 1, 0, steps, move(minSteps), path + ""d"", ans);
      if (dy == 0)
        dfs(maze, i, j, hole, 0, -1, steps, move(minSteps), path + ""l"", ans);
      if (dy == 0)
        dfs(maze, i, j, hole, 0, 1, steps, move(minSteps), path + ""r"", ans);
      if (dx == 0)
        dfs(maze, i, j, hole, -1, 0, steps, move(minSteps), path + ""u"", ans);
    }
  }
};",15,1412,2.0,9.0,7.0,10.0,94.13333333333334,18.0,-1.152000000000001
472.0,"class Solution {
 public:
  vector<string> findWords(vector<string>& words) {
    vector<string> ans;
    const vector<int> rows{2, 3, 3, 2, 1, 2, 2, 2, 1, 2, 2, 2, 3,
                           3, 1, 1, 1, 1, 2, 1, 1, 3, 1, 3, 1, 3};

    for (const string& word : words) {
      string lowerWord = word;
      transform(begin(lowerWord), end(lowerWord), begin(lowerWord), ::tolower);
      const int row = rows[lowerWord[0] - 'a'];
      const bool isValid = all_of(begin(lowerWord), end(lowerWord),
                                  [&](int c) { return rows[c - 'a'] == row; });
      if (isValid)
        ans.push_back(word);
    }

    return ans;
  }
};",10,659,0.0,1.0,5.0,3.0,65.9,14.0,2.309
473.0,"class Solution {
 public:
  vector<int> findMode(TreeNode* root) {
    vector<int> ans;
    int count = 0;
    int maxCount = 0;

    inorder(root, count, maxCount, ans);
    return ans;
  }

 private:
  TreeNode* pred = nullptr;

  void inorder(TreeNode* root, int& count, int& maxCount, vector<int>& ans) {
    if (root == nullptr)
      return;

    inorder(root->left, count, maxCount, ans);
    updateCount(root, count, maxCount, ans);
    inorder(root->right, count, maxCount, ans);
  }

  void updateCount(TreeNode* root, int& count, int& maxCount,
                   vector<int>& ans) {
    if (pred && pred->val == root->val)
      ++count;
    else
      count = 1;

    if (count > maxCount) {
      maxCount = count;
      ans = {root->val};
    } else if (count == maxCount) {
      ans.push_back(root->val);
    }

    pred = root;
  }
};",17,852,0.0,5.0,7.0,4.0,50.11764705882353,13.0,3.469411764705882
474.0,"struct T {
  int pro;
  int cap;
  T(int pro, int cap) : pro(pro), cap(cap) {}
};

class Solution {
 public:
  int findMaximizedCapital(int k, int W, vector<int>& Profits,
                           vector<int>& Capital) {
    auto compareC = [](const T& a, const T& b) { return a.cap > b.cap; };
    auto compareP = [](const T& a, const T& b) { return a.pro < b.pro; };
    priority_queue<T, vector<T>, decltype(compareC)> minHeap(compareC);
    priority_queue<T, vector<T>, decltype(compareP)> maxHeap(compareP);

    for (int i = 0; i < Capital.size(); ++i)
      minHeap.emplace(Profits[i], Capital[i]);

    while (k--) {
      while (!minHeap.empty() && minHeap.top().cap <= W)
        maxHeap.push(minHeap.top()), minHeap.pop();
      if (maxHeap.empty())
        break;
      W += maxHeap.top().pro, maxHeap.pop();
    }

    return W;
  }
};",17,850,0.0,1.0,7.0,4.0,50.0,16.0,3.420000000000001
475.0,"class Solution {
 public:
  vector<int> nextGreaterElements(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n, -1);
    stack<int> stack;  // decreasing stack storing indices

    for (int i = 0; i < n * 2; ++i) {
      const int num = nums[i % n];
      while (!stack.empty() && nums[stack.top()] < num)
        ans[stack.top()] = num, stack.pop();
      if (i < n)
        stack.push(i);
    }

    return ans;
  }
};",10,443,1.0,3.0,3.0,3.0,44.3,10.0,4.6930000000000005
476.0,"class Solution {
 public:
  string convertToBase7(int num) {
    if (num < 0)
      return ""-"" + convertToBase7(-num);
    if (num < 7)
      return to_string(num);
    return convertToBase7(num / 7) + to_string(num % 7);
  }
};",4,228,0.0,0.0,2.0,2.0,57.0,3.0,4.45
477.0,"class Solution {
 public:
  int shortestDistance(vector<vector<int>>& maze, vector<int>& start,
                       vector<int>& destination) {
    const int m = maze.size();
    const int n = maze[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q{{{start[0], start[1]}}};
    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
    dist[start[0]][start[1]] = 0;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        int x = i;
        int y = j;
        int steps = dist[i][j];
        while (isValid(maze, x + dirs[k], y + dirs[k + 1])) {
          x += dirs[k];
          y += dirs[k + 1];
          ++steps;
        }
        if (steps < dist[x][y]) {
          dist[x][y] = steps;
          if (x == destination[0] && y == destination[1])
            continue;
          q.emplace(x, y);
        }
      }
    }

    return dist[destination[0]][destination[1]] == INT_MAX
               ? -1
               : dist[destination[0]][destination[1]];
  }

 private:
  bool isValid(const vector<vector<int>>& maze, int x, int y) {
    return x >= 0 && x < maze.size() && y >= 0 && y < maze[0].size() &&
           maze[x][y] == 0;
  }
};",22,1243,0.0,3.0,11.0,5.0,56.5,25.0,1.575000000000001
478.0,"class Solution {
 public:
  vector<string> findRelativeRanks(vector<int>& nums) {
    const int n = nums.size();
    vector<string> ans(n);
    vector<int> indices(n);

    iota(begin(indices), end(indices), 0);

    sort(begin(indices), end(indices),
         [&](const int a, const int b) { return nums[a] > nums[b]; });

    for (int i = 0; i < n; ++i)
      if (i == 0)
        ans[indices[0]] = ""Gold Medal"";
      else if (i == 1)
        ans[indices[1]] = ""Silver Medal"";
      else if (i == 2)
        ans[indices[2]] = ""Bronze Medal"";
      else
        ans[indices[i]] = to_string(i + 1);

    return ans;
  }
};",14,622,0.0,6.0,3.0,4.0,44.42857142857143,12.0,4.261428571428572
479.0,"class Solution {
 public:
  bool checkPerfectNumber(int num) {
    if (num == 1)
      return false;

    int sum = 1;

    for (int i = 2; i <= sqrt(num); ++i)
      if (num % i == 0)
        sum += i + num / i;

    return sum == num;
  }
};",7,243,0.0,2.0,2.0,3.0,34.714285714285715,5.0,6.135714285714286
480.0,"class Solution {
 public:
  vector<int> findFrequentTreeSum(TreeNode* root) {
    vector<int> ans;
    unordered_map<int, int> count;
    int maxCount = 0;

    sumDownFrom(root, count);

    for (const auto& [_, freq] : count)
      maxCount = max(maxCount, freq);

    for (const auto& [sum, freq] : count)
      if (freq == maxCount)
        ans.push_back(sum);

    return ans;
  }

 private:
  int sumDownFrom(TreeNode* root, unordered_map<int, int>& count) {
    if (root == nullptr)
      return 0;

    const int sum = root->val + sumDownFrom(root->left, count) +
                    sumDownFrom(root->right, count);
    ++count[sum];
    return sum;
  }
};",12,665,0.0,2.0,3.0,4.0,55.41666666666666,13.0,3.4125000000000005
481.0,"class Solution {
 public:
  int fib(int n) {
    if (n < 2)
      return n;

    vector<int> dp{0, 0, 1};

    for (int i = 2; i <= n; ++i) {
      dp[0] = dp[1];
      dp[1] = dp[2];
      dp[2] = dp[0] + dp[1];
    }

    return dp.back();
  }
};",9,248,0.0,1.0,4.0,2.0,27.55555555555556,5.0,6.720000000000001
482.0,"class Solution {
 public:
  Node* inorderSuccessor(Node* node) {
    // The successor is somewhere lower in the right subtree
    if (node->right) {
      node = node->right;
      while (node->left)
        node = node->left;
      return node;
    }

    // The successor is somewhere upper in the tree
    while (node->parent && node->parent->left != node)
      node = node->parent;
    return node->parent;
  }
};",6,418,2.0,2.0,3.0,3.0,69.66666666666667,1.0,3.41
483.0,"class Solution {
 public:
  int findBottomLeftValue(TreeNode* root) {
    queue<TreeNode*> q{{root}};
    TreeNode* node = nullptr;

    while (!q.empty()) {
      node = q.front();
      q.pop();
      if (node->right)
        q.push(node->right);
      if (node->left)
        q.push(node->left);
    }

    return node->val;
  }
};",8,334,0.0,3.0,5.0,3.0,41.75,2.0,5.5625
484.0,"class Solution {
 public:
  int findRotateSteps(string ring, string key) {
    return dfs(ring, key, 0, {}) + key.length();
  }

 private:
  // # of rotates of ring to match key[index:]
  int dfs(const string& ring, const string& key, int index,
          unordered_map<string, int>&& memo) {
    if (index == key.length())
      return 0;
    // Add the index to prevent duplicate
    const string hashKey = ring + to_string(index);
    if (const auto it = memo.find(hashKey); it != cend(memo))
      return it->second;

    int ans = INT_MAX;

    // For each ring[i] == key[index]
    // We rotate the ring to match ring[i] w/ key[index]
    // Then recursively match newRing w/ key[index + 1:]
    for (size_t i = 0; i < ring.length(); ++i)
      if (ring[i] == key[index]) {
        const int minRotates = min(i, ring.length() - i);
        const string& newRing = ring.substr(i) + ring.substr(0, i);
        const int remainingRotates = dfs(newRing, key, index + 1, move(memo));
        ans = min(ans, minRotates + remainingRotates);
      }

    return memo[hashKey] = ans;
  }
};",14,1087,5.0,1.0,5.0,5.0,77.64285714285714,22.0,0.6521428571428558
485.0,"class Solution {
 public:
  vector<int> largestValues(TreeNode* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      int maxi = INT_MIN;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        maxi = max(maxi, node->val);
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(maxi);
    }

    return ans;
  }
};",14,530,0.0,4.0,7.0,5.0,37.85714285714285,5.0,5.432857142857143
486.0,"class Solution {
 public:
  int longestPalindromeSubseq(string s) {
    const int n = s.length();
    // dp[i][j] := LPS's length in s[i..j]
    dp.resize(n, vector<int>(n));
    return lps(s, 0, n - 1);
  }

 private:
  vector<vector<int>> dp;

  int lps(const string& s, int i, int j) {
    if (i > j)
      return 0;
    if (i == j)
      return 1;
    if (dp[i][j] > 0)
      return dp[i][j];

    if (s[i] == s[j])
      dp[i][j] = 2 + lps(s, i + 1, j - 1);
    else
      dp[i][j] = max(lps(s, i + 1, j), lps(s, i, j - 1));

    return dp[i][j];
  }
};",11,558,1.0,1.0,3.0,4.0,50.72727272727273,12.0,4.034545454545455
487.0,"class Solution {
 public:
  int findMinMoves(vector<int>& machines) {
    const int dresses = accumulate(begin(machines), end(machines), 0);
    if (dresses % machines.size() != 0)
      return -1;

    int ans = 0;
    int inout = 0;
    const int average = dresses / machines.size();

    for (const int dress : machines) {
      inout += dress - average;
      ans = max({ans, abs(inout), dress - average});
    }

    return ans;
  }
};",9,440,0.0,1.0,4.0,2.0,48.888888888888886,11.0,4.2
488.0,"class Solution {
 public:
  int change(int amount, vector<int>& coins) {
    vector<int> dp(amount + 1);
    dp[0] = 1;

    for (const int coin : coins)
      for (int i = coin; i <= amount; ++i)
        dp[i] += dp[i - coin];

    return dp[amount];
  }
};",7,258,0.0,2.0,2.0,2.0,36.85714285714285,8.0,5.642857142857143
489.0,"class Solution {
 public:
  Solution(int n_rows, int n_cols)
      : rows(n_rows), cols(n_cols), total(n_rows * n_cols) {}

  vector<int> flip() {
    // All candidates are used out
    if (used.size() == total)
      return {};

    int index = rand() % total;
    while (used.count(index))
      index = ++index % total;
    used.insert(index);

    return {index / cols, index % cols};
  }

  void reset() {
    used = {};
  }

 private:
  unordered_set<int> used;
  int rows;
  int cols;
  int total;
};",11,507,1.0,1.0,7.0,2.0,46.09090909090909,10.0,4.411818181818182
490.0,"class Solution {
 public:
  bool detectCapitalUse(string word) {
    for (int i = 1; i < word.length(); ++i)
      if (isupper(word[1]) != isupper(word[i]) ||
          islower(word[0]) && isupper(word[i]))
        return false;
    return true;
  }
};",5,252,0.0,1.0,2.0,2.0,50.4,4.0,4.884
491.0,"class Solution {
 public:
  int findLUSlength(string a, string b) {
    return a == b ? -1 : max(a.length(), b.length());
  }
};",2,128,0.0,0.0,2.0,0.0,64.0,4.0,3.72
492.0,"class Solution {
 public:
  int findLUSlength(vector<string>& strs) {
    unordered_set<string> seen;
    unordered_set<string> duplicates;

    for (const string& str : strs)
      if (seen.count(str))
        duplicates.insert(str);
      else
        seen.insert(str);

    sort(begin(strs), end(strs),
         [](const auto& a, const auto& b) { return a.length() > b.length(); });

    for (int i = 0; i < strs.size(); ++i) {
      if (duplicates.count(strs[i]))
        continue;
      bool isASubsequence = false;
      for (int j = 0; j < i; ++j)
        isASubsequence |= isSubsequence(strs[i], strs[j]);
      if (!isASubsequence)
        return strs[i].length();
    }

    return -1;
  }

 private:
  // Returns true if a is a subsequence of b
  bool isSubsequence(const string& a, const string& b) {
    int i = 0;
    for (const char c : b)
      if (i < a.length() && c == a[i])
        ++i;
    return i == a.length();
  };
};",20,942,1.0,6.0,5.0,9.0,47.1,20.0,3.141
493.0,"class Solution {
 public:
  bool checkSubarraySum(vector<int>& nums, int k) {
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i];
      if (k != 0)
        prefix %= k;
      if (const auto it = prefixToIndex.find(prefix);
          it != cend(prefixToIndex)) {
        if (i - it->second > 1)
          return true;
      } else {
        // Only add if absent, because the previous index is better
        prefixToIndex[prefix] = i;
      }
    }

    return false;
  }
};",11,564,1.0,5.0,7.0,5.0,51.27272727272727,9.0,3.8054545454545456
494.0,"class Solution {
 public:
  string findLongestWord(string s, vector<string>& d) {
    string ans;

    for (const string& word : d)
      if (isSubsequence(word, s))
        if (word.length() > ans.length() ||
            word.length() == ans.length() && word.compare(ans) < 0)
          ans = word;

    return ans;
  }

 private:
  // Returns true if a is a subsequence of b
  bool isSubsequence(const string& a, const string& b) {
    int i = 0;
    for (const char c : b)
      if (i < a.length() && c == a[i])
        ++i;
    return i == a.length();
  };
};",8,563,1.0,5.0,3.0,6.0,70.375,15.0,1.7262500000000005
495.0,"class Solution {
 public:
  int findMaxLength(vector<int>& nums) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums.size(); ++i) {
      prefix += nums[i] ? 1 : -1;
      if (const auto it = prefixToIndex.find(prefix); it != cend(prefixToIndex))
        ans = max(ans, i - it->second);
      else
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};",11,431,0.0,3.0,5.0,2.0,39.18181818181818,9.0,5.093636363636365
496.0,"class Solution {
 public:
  int countArrangement(int n) {
    return dfs(n, 1, string(n + 1, 'x'), {});
  }

 private:
  int dfs(int n, int num, string&& filled, unordered_map<string, int>&& memo) {
    if (num == n + 1)
      return 1;
    if (const auto it = memo.find(filled); it != cend(memo))
      return it->second;

    int count = 0;

    for (int i = 1; i <= n; ++i)
      if (filled[i] == 'x' && (num % i == 0 || i % num == 0)) {
        filled[i] = 'o';
        count += dfs(n, num + 1, move(filled), move(memo));
        filled[i] = 'x';
      }

    return memo[filled] = count;
  }
};",12,599,0.0,1.0,5.0,4.0,49.91666666666666,13.0,3.847500000000001
497.0,"class Solution {
 public:
  vector<string> wordsAbbreviation(vector<string>& words) {
    const int n = words.size();
    vector<string> ans;
    // prefix[i] := ans[i] takes words[i][0..prefix[i]]
    vector<int> prefix(n);

    for (const string& word : words)
      ans.push_back(getAbbrev(word, 0));

    for (int i = 0; i < n; ++i) {
      while (true) {
        vector<int> dupeIndices;
        for (int j = i + 1; j < n; ++j)
          if (ans[i] == ans[j])
            dupeIndices.push_back(j);
        if (dupeIndices.empty())
          break;
        dupeIndices.push_back(i);
        for (const int index : dupeIndices)
          ans[index] = getAbbrev(words[index], ++prefix[index]);
      }
    }

    return ans;
  }

 private:
  string getAbbrev(const string& s, int prefixIndex) {
    const int n = s.length();
    const int num = n - (prefixIndex + 1) - 1;
    const int numLength = num < 10 ? 1 : num < 100 ? 2 : 3;
    const int abbrevLength = (prefixIndex + 1) + numLength + 1;
    if (abbrevLength >= n)
      return s;
    return s.substr(0, prefixIndex + 1) + to_string(num) + s.back();
  }
};",21,1116,1.0,5.0,5.0,8.0,53.142857142857146,26.0,2.057142857142858
498.0,"class Solution {
 public:
  vector<vector<char>> updateBoard(vector<vector<char>>& board,
                                   vector<int>& click) {
    if (board[click[0]][click[1]] == 'M') {
      board[click[0]][click[1]] = 'X';
      return board;
    }

    dfs(board, click[0], click[1]);
    return board;
  }

 private:
  const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                    {0, 1},   {1, -1}, {1, 0},  {1, 1}};

  void dfs(vector<vector<char>>& board, int i, int j) {
    if (i < 0 || i == board.size() || j < 0 || j == board[0].size())
      return;
    if (board[i][j] != 'E')
      return;

    const int minesCount = getMinesCount(board, i, j);
    board[i][j] = minesCount == 0 ? 'B' : '0' + minesCount;

    if (minesCount == 0)
      for (const auto& [dx, dy] : dirs)
        dfs(board, i + dx, j + dy);
  }

  int getMinesCount(const vector<vector<char>>& board, int i, int j) {
    int minesCount = 0;
    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == board.size() || y < 0 || y == board[0].size())
        continue;
      if (board[x][y] == 'M')
        ++minesCount;
    }
    return minesCount;
  }
};",17,1244,0.0,3.0,15.0,8.0,73.17647058823529,25.0,-0.1658823529411766
499.0,"class Solution {
 public:
  // Similar to 94. Binary Tree Inorder Traversal
  int getMinimumDifference(TreeNode* root) {
    int ans = INT_MAX;
    int prev = -1;
    stack<TreeNode*> stack;

    while (root || !stack.empty()) {
      while (root) {
        stack.push(root);
        root = root->left;
      }
      root = stack.top(), stack.pop();
      if (prev >= 0)
        ans = min(ans, root->val - prev);
      prev = root->val;
      root = root->right;
    }

    return ans;
  }
};",11,492,1.0,3.0,4.0,4.0,44.72727272727273,4.0,5.194545454545454
500.0,"class Solution {
 public:
  int findLonelyPixel(vector<vector<char>>& picture) {
    const int m = picture.size();
    const int n = picture[0].size();
    int ans = 0;
    vector<int> rows(m);  // rows[i] := # of Bs in rows i
    vector<int> cols(n);  // cols[i] := # of Bs in cols i

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (picture[i][j] == 'B') {
          ++rows[i];
          ++cols[j];
        }

    for (int i = 0; i < m; ++i)
      if (rows[i] == 1)  // Only have to examine the rows when rows[i] == 1
        for (int j = 0; j < n; ++j)
          // After we met the 'B' in this rows, we break and search the next row
          if (picture[i][j] == 'B') {
            if (cols[j] == 1)
              ++ans;
            break;
          }

    return ans;
  }
};",19,809,4.0,6.0,4.0,8.0,42.578947368421055,14.0,4.327894736842104
501.0,"class Solution {
 public:
  int findPairs(vector<int>& nums, int k) {
    int ans = 0;
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < nums.size(); ++i)
      numToIndex[nums[i]] = i;

    for (int i = 0; i < nums.size(); ++i) {
      const int target = nums[i] + k;
      if (const auto it = numToIndex.find(target);
          it != cend(numToIndex) && it->second != i) {
        ++ans;
        numToIndex.erase(target);
      }
    }

    return ans;
  }
};",13,476,0.0,3.0,4.0,3.0,36.61538461538461,12.0,5.084615384615384
502.0,"class Solution {
 public:
  int findBlackPixel(vector<vector<char>>& picture, int target) {
    const int m = picture.size();
    const int n = picture[0].size();
    int ans = 0;
    vector<int> rows(m);
    vector<int> cols(n);
    vector<string> rowStrings(m);
    unordered_map<string, int> countRowStrings;

    for (int i = 0; i < m; ++i) {
      string s;
      for (int j = 0; j < n; ++j) {
        if (picture[i][j] == 'B') {
          ++rows[i];
          ++cols[j];
        }
        s += picture[i][j];
      }
      rowStrings[i] = s;
      ++countRowStrings[s];
    }

    for (int i = 0; i < m; ++i)
      if (rows[i] == target && countRowStrings[rowStrings[i]] == target)
        for (int j = 0; j < n; ++j)
          if (picture[i][j] == 'B' && cols[j] == target)
            ++ans;

    return ans;
  }
};",24,823,0.0,7.0,5.0,7.0,34.291666666666664,19.0,4.29375
503.0,"class Solution {
 public:
  string encode(string longUrl) {
    while (!urlToCode.count(longUrl)) {
      string code;
      for (int i = 0; i < 6; ++i)
        code += alphabets[rand() % alphabets.size()];
      if (!codeToUrl.count(code)) {
        codeToUrl[code] = longUrl;
        urlToCode[longUrl] = code;
        return ""http://tinyurl.com/"" + code;
      }
    }

    throw;
  }

  string decode(string shortUrl) {
    return codeToUrl[shortUrl.substr(19)];
  }

 private:
  const string alphabets =
      ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"";
  unordered_map<string, string> urlToCode;
  unordered_map<string, string> codeToUrl;
};",13,669,1.0,1.0,5.0,3.0,51.46153846153846,13.0,3.748461538461539
504.0,"class Solution {
 public:
  TreeNode* str2tree(string s) {
    if (s.empty())
      return nullptr;
    int i = 0;
    return str2tree(s, i);
  }

 private:
  TreeNode* str2tree(const string& s, int& i) {
    const int start = i;  // Start index of val
    if (s[i] == '-')
      ++i;
    while (i < s.length() && isdigit(s[i]))
      ++i;

    const int val = stoi(s.substr(start, i - start));
    TreeNode* root = new TreeNode(val);

    // Left child
    if (i < s.length() && s[i] == '(') {
      ++i;  // '('
      root->left = str2tree(s, i);
      ++i;  // ')'
    }

    // Right child
    if (i < s.length() && s[i] == '(') {
      ++i;  // '('
      root->right = str2tree(s, i);
      ++i;  // ')'
    }

    return root;
  }
};",16,739,7.0,3.0,5.0,5.0,46.1875,10.0,4.643125000000001
505.0,"class Solution {
 public:
  string complexNumberMultiply(string a, string b) {
    const auto& [A, B] = getRealAndImag(a);
    const auto& [C, D] = getRealAndImag(b);
    return to_string(A * C - B * D) + ""+"" + to_string(A * D + B * C) + ""i"";
  }

 private:
  pair<int, int> getRealAndImag(const string& s) {
    const string& real = s.substr(0, s.find_first_of('+'));
    const string& imag = s.substr(s.find_first_of('+') + 1);
    return {stoi(real), stoi(imag)};
  };
};",8,474,0.0,-1.0,4.0,0.0,59.25,14.0,3.0874999999999995
506.0,"class Solution {
 public:
  TreeNode* convertBST(TreeNode* root) {
    int prefix = 0;
    reversedInorder(root, prefix);
    return root;
  }

 private:
  void reversedInorder(TreeNode* root, int& prefix) {
    if (root == nullptr)
      return;

    reversedInorder(root->right, prefix);
    prefix += root->val;
    root->val = prefix;
    reversedInorder(root->left, prefix);
  }
};",9,386,0.0,0.0,3.0,1.0,42.888888888888886,4.0,5.5600000000000005
507.0,"class Solution {
 public:
  int findMinDifference(vector<string>& timePoints) {
    int ans = 24 * 60;
    int first = 24 * 60;
    vector<bool> bucket(24 * 60);

    for (const string& time : timePoints) {
      const int num = stoi(time.substr(0, 2)) * 60 + stoi(time.substr(3));
      first = min(first, num);
      if (bucket[num])
        return 0;
      bucket[num] = true;
    }

    int prev = first;

    for (int i = first + 1; i < bucket.size(); ++i)
      if (bucket[i]) {
        ans = min(ans, i - prev);
        prev = i;
      }

    return min(ans, 24 * 60 - prev + first);
  }
};",14,597,0.0,3.0,4.0,5.0,42.642857142857146,12.0,4.542142857142856
508.0,"class Solution {
 public:
  int singleNonDuplicate(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      int m = (l + r) / 2;
      if (m & 1)
        --m;
      if (nums[m] == nums[m + 1])
        l = m + 2;
      else
        r = m;
    }

    return nums[l];
  }
};",8,306,0.0,4.0,3.0,3.0,38.25,6.0,5.5375
509.0,"class Solution {
 public:
  string reverseStr(string s, int k) {
    for (size_t i = 0; i < s.length(); i += 2 * k) {
      int l = i;
      int r = min(i + k - 1, s.length() - 1);
      while (l < r)
        swap(s[l++], s[r--]);
    }

    return s;
  }
};",7,258,0.0,2.0,3.0,2.0,36.85714285714285,6.0,5.782857142857143
510.0,"class Solution {
 public:
  vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q;
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j] == 0) {
          q.emplace(i, j);
          seen[i][j] = true;
        }

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        mat[x][y] = mat[i][j] + 1;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return mat;
  }
};",24,863,0.0,5.0,6.0,7.0,35.958333333333336,21.0,4.00375
511.0,"class Solution {
 public:
  int diameterOfBinaryTree(TreeNode* root) {
    int ans = 0;
    maxDepth(root, ans);
    return ans;
  }

 private:
  int maxDepth(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = maxDepth(root->left, ans);
    const int r = maxDepth(root->right, ans);
    ans = max(ans, l + r);
    return 1 + max(l, r);
  }
};",9,379,0.0,-1.0,3.0,1.0,42.11111111111112,9.0,5.19
512.0,"class Solution {
 public:
  string findContestMatch(int n) {
    vector<string> matches(n);

    for (int i = 0; i < n; ++i)
      matches[i] = to_string(i + 1);

    return generateMatches(matches);
  }

 private:
  string generateMatches(const vector<string>& matches) {
    if (matches.size() == 1)
      return matches[0];

    vector<string> nextMatches;

    for (int i = 0; i < matches.size() / 2; ++i)
      nextMatches.push_back(""("" + matches[i] + "","" +
                            matches[matches.size() - 1 - i] + "")"");

    return generateMatches(nextMatches);
  }
};",12,579,0.0,1.0,3.0,3.0,48.25,10.0,4.4175
513.0,"class Solution {
 public:
  vector<int> boundaryOfBinaryTree(TreeNode* root) {
    if (root == nullptr)
      return {};
    vector<int> ans{root->val};
    dfs(root->left, true, false, ans);
    dfs(root->right, false, true, ans);
    return ans;
  }

 private:
  /**
   * 1. root->left is left boundary if root is left boundary
   *    root->right if left boundary if root->left == nullptr
   * 2. same applys for right boundary
   * 3. if root is left boundary, add it before 2 children - preorder
   *    if root is right boundary, add it after 2 children - postorder
   * 4. a leaf that is neighter left/right boundary belongs to the bottom
   */
  void dfs(TreeNode* root, bool lb, bool rb, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (lb)
      ans.push_back(root->val);
    if (!lb && !rb && root->left == nullptr && root->right != nullptr)
      ans.push_back(root->val);

    dfs(root->left, lb, rb && root->right == nullptr, ans);
    dfs(root->right, lb && root->left == nullptr, rb, ans);
    if (rb)
      ans.push_back(root->val);
  }
};",12,1074,1.0,9.0,5.0,12.0,89.5,7.0,0.4450000000000003
514.0,"class Solution {
 public:
  int removeBoxes(vector<int>& boxes) {
    const int n = boxes.size();
    // dp[i][j][k] := max score of boxes[i..j] if k boxes eqaul to boxes[j]
    dp.resize(n, vector<vector<int>>(n, vector<int>(n)));
    return removeBoxes(boxes, 0, n - 1, 0);
  }

 private:
  vector<vector<vector<int>>> dp;

  int removeBoxes(const vector<int>& boxes, int i, int j, int k) {
    if (i > j)
      return 0;
    if (dp[i][j][k] > 0)
      return dp[i][j][k];

    int r = j;
    int sameBoxes = k + 1;
    while (r > 0 && boxes[r - 1] == boxes[r]) {
      --r;
      ++sameBoxes;
    }
    dp[i][j][k] = removeBoxes(boxes, i, r - 1, 0) + sameBoxes * sameBoxes;

    for (int p = i; p < r; ++p)
      if (boxes[p] == boxes[r])
        dp[i][j][k] = max(dp[i][j][k], removeBoxes(boxes, i, p, sameBoxes) +
                                           removeBoxes(boxes, p + 1, r - 1, 0));

    return dp[i][j][k];
  }
};",16,931,1.0,3.0,4.0,6.0,58.1875,17.0,2.6831250000000004
515.0,"class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int findCircleNum(vector<vector<int>>& isConnected) {
    const int n = isConnected.size();
    UnionFind uf(n);

    for (int i = 0; i < n; ++i)
      for (int j = i; j < n; ++j)
        if (isConnected[i][j] == 1)
          uf.unionByRank(i, j);

    return uf.getCount();
  }
};",24,910,0.0,5.0,10.0,6.0,37.91666666666666,23.0,3.3875
516.0,"class Solution {
 public:
  bool splitArray(vector<int>& nums) {
    const int n = nums.size();
    if (n < 7)
      return false;

    vector<int> prefix(n);

    partial_sum(begin(nums), end(nums), begin(prefix));

    for (int j = 3; j < n - 3; ++j) {
      unordered_set<int> seen;
      for (int i = 1; i < j - 1; ++i)
        if (prefix[i - 1] == prefix[j - 1] - prefix[i])
          seen.insert(prefix[i - 1]);
      for (int k = j + 2; k < n - 1; ++k)
        if (prefix[n - 1] - prefix[k] == prefix[k - 1] - prefix[j] &&
            seen.count(prefix[k - 1] - prefix[j]))
          return true;
    }

    return false;
  }
};",15,635,0.0,4.0,3.0,6.0,42.333333333333336,10.0,4.77
517.0,"struct T {
  int inc;  // Length of longest incrementing branch
  int dec;  // Length of longest decrementing branch
};

class Solution {
 public:
  int longestConsecutive(TreeNode* root) {
    int ans = 0;
    longestPath(root, ans);
    return ans;
  }

 private:
  // Returns (longest increment, longest decrement)
  T longestPath(TreeNode* root, int& ans) {
    if (root == nullptr)
      return {0, 0};

    int inc = 1;
    int dec = 1;

    if (root->left) {
      T l = longestPath(root->left, ans);
      if (root->val + 1 == root->left->val)
        inc = l.inc + 1;
      else if (root->val - 1 == root->left->val)
        dec = l.dec + 1;
    }

    if (root->right) {
      T r = longestPath(root->right, ans);
      if (root->val + 1 == root->right->val)
        inc = max(inc, r.inc + 1);
      else if (root->val - 1 == root->right->val)
        dec = max(dec, r.dec + 1);
    }

    ans = max(ans, inc + dec - 1);
    return {inc, dec};
  }
};",18,960,3.0,7.0,8.0,7.0,53.333333333333336,9.0,3.5200000000000005
518.0,"class Solution {
 public:
  bool checkRecord(string s) {
    int countA = 0;
    int countL = 0;

    for (const char c : s) {
      if (c == 'A' && ++countA > 1)
        return false;
      if (c != 'L')
        countL = 0;
      else if (++countL > 2)
        return false;
    }

    return true;
  }
};",7,306,0.0,3.0,3.0,4.0,43.71428571428572,7.0,5.005714285714286
519.0,"class Solution {
 public:
  int checkRecord(int n) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := length so far w/ i A's and the latest chars are j L's
    vector<vector<long>> dp(2, vector<long>(3));
    dp[0][0] = 1;

    while (n--) {
      const auto prev(dp);

      // Append P
      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % kMod;

      // Append L
      dp[0][1] = prev[0][0];

      // Append L
      dp[0][2] = prev[0][1];

      // Append A or append P
      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +  //
                  prev[1][0] + prev[1][1] + prev[1][2]) %
                 kMod;

      // Append L
      dp[1][1] = prev[1][0];

      // Append L
      dp[1][2] = prev[1][1];
    }

    return accumulate(begin(dp), end(dp), 0, [](int s, vector<long>& row) {
      return (s + accumulate(begin(row), end(row), 0L)) % kMod;
    });
  }
};",13,888,8.0,0.0,4.0,1.0,68.3076923076923,6.0,3.332307692307692
520.0,"class Solution {
 public:
  string optimalDivision(vector<int>& nums) {
    string ans = to_string(nums[0]);

    if (nums.size() == 1)
      return ans;
    if (nums.size() == 2)
      return ans + ""/"" + to_string(nums[1]);

    ans += ""/("" + to_string(nums[1]);
    for (int i = 2; i < nums.size(); ++i)
      ans += ""/"" + to_string(nums[i]);
    ans += "")"";
    return ans;
  }
};",10,383,0.0,1.0,2.0,3.0,38.3,5.0,5.873000000000001
521.0,"class Solution {
 public:
  int leastBricks(vector<vector<int>>& wall) {
    int maxCount = 0;
    unordered_map<int, int> count;

    for (const vector<int>& row : wall) {
      int prefix = 0;
      for (int i = 0; i < row.size() - 1; ++i) {
        prefix += row[i];
        maxCount = max(maxCount, ++count[prefix]);
      }
    }

    return wall.size() - maxCount;
  }
};",9,377,0.0,2.0,4.0,2.0,41.888888888888886,10.0,4.87
522.0,"class Solution {
 public:
  string splitLoopedString(vector<string>& strs) {
    string ans;
    vector<string> sortedStrs;

    for (const string& s : strs)
      sortedStrs.push_back(max(s, {rbegin(s), rend(s)}));

    for (int i = 0; i < sortedStrs.size(); ++i)
      for (const string& s :
           {sortedStrs[i], {rbegin(sortedStrs[i]), rend(sortedStrs[i])}})
        for (int j = 0; j <= s.length(); ++j)
          ans = max(ans, s.substr(j) + join(sortedStrs, i) + s.substr(0, j));

    return ans;
  }

 private:
  string reversed(const string& s) {
    string r = s;
    reverse(begin(r), end(r));
    return r;
  }

  string join(const vector<string>& sortedStrs, int i) {
    string joined;
    for (int j = i + 1; j < sortedStrs.size(); ++j)
      joined += sortedStrs[j];
    for (int j = 0; j < i; ++j)
      joined += sortedStrs[j];
    return joined;
  }
};",21,876,0.0,4.0,7.0,6.0,41.71428571428572,22.0,3.385714285714285
523.0,"class Solution {
 public:
  int nextGreaterElement(int n) {
    const string& s = nextPermutation(to_string(n));
    const long ans = stol(s);
    return ans > INT_MAX || ans <= n ? -1 : ans;
  }

 private:
  // Similar to 31. Next Permutation
  string nextPermutation(string s) {
    const int n = s.length();

    int i;
    for (i = n - 2; i >= 0; --i)
      if (s[i] < s[i + 1])
        break;

    if (i >= 0) {
      for (int j = n - 1; j > i; --j)
        if (s[j] > s[i]) {
          swap(s[i], s[j]);
          break;
        }
    }

    reverse(s, i + 1, n - 1);
    return s;
  }

  void reverse(string& s, int l, int r) {
    while (l < r)
      swap(s[l++], s[r--]);
  }
};",16,687,1.0,3.0,6.0,6.0,42.9375,16.0,4.035625
524.0,"class Solution {
 public:
  string reverseWords(string s) {
    int i = 0;
    int j = 0;

    while (i < s.length()) {
      while (i < j || i < s.length() && s[i] == ' ')
        ++i;
      while (j < i || j < s.length() && s[j] != ' ')
        ++j;
      reverse(begin(s) + i, begin(s) + j);
    }

    return s;
  }
};",7,322,0.0,3.0,3.0,3.0,46.0,5.0,5.000000000000001
525.0,"class Solution {
 public:
  Node* intersect(Node* quadTree1, Node* quadTree2) {
    if (quadTree1->isLeaf)
      return quadTree1->val ? quadTree1 : quadTree2;
    if (quadTree2->isLeaf)
      return quadTree2->val ? quadTree2 : quadTree1;

    Node* topLeft = intersect(quadTree1->topLeft, quadTree2->topLeft);
    Node* topRight = intersect(quadTree1->topRight, quadTree2->topRight);
    Node* bottomLeft = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);
    Node* bottomRight =
        intersect(quadTree1->bottomRight, quadTree2->bottomRight);

    if (topLeft->val == topRight->val &&        //
        topLeft->val == bottomLeft->val &&      //
        topLeft->val == bottomRight->val &&     //
        topLeft->isLeaf && topRight->isLeaf &&  //
        bottomLeft->isLeaf && bottomRight->isLeaf)
      return new Node(topLeft->val, true);
    return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);
  }
};",9,941,4.0,0.0,2.0,3.0,104.55555555555556,1.0,0.5300000000000011
526.0,"class Solution {
 public:
  int maxDepth(Node* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;

    for (Node* child : root->children)
      ans = max(ans, maxDepth(child));

    return 1 + ans;
  }
};",5,220,0.0,1.0,2.0,2.0,44.0,3.0,5.5600000000000005
527.0,"class Solution {
 public:
  int subarraySum(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> count{{0, 1}};  // {prefix sum: count}

    for (const int num : nums) {
      prefix += num;
      const int target = prefix - k;
      if (const auto it = count.find(target); it != cend(count))
        ans += it->second;
      ++count[prefix];
    }

    return ans;
  }
};",10,412,1.0,2.0,6.0,2.0,41.2,13.0,4.552
528.0,"class Solution {
 public:
  int arrayPairSum(vector<int>& nums) {
    int ans = 0;

    sort(begin(nums), end(nums));

    for (int i = 0; i < nums.size(); i += 2)
      ans += nums[i];

    return ans;
  }
};",7,209,0.0,1.0,2.0,1.0,29.857142857142858,5.0,6.632857142857143
529.0,"class Solution {
 public:
  int longestLine(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;
    // dp[i][j][0] := horizontal
    // dp[i][j][1] := vertical
    // dp[i][j][2] := diagonal
    // dp[i][j][3] := anti-diagonal
    vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(4)));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j] == 1) {
          dp[i][j][0] = j > 0 ? dp[i][j - 1][0] + 1 : 1;
          dp[i][j][1] = i > 0 ? dp[i - 1][j][1] + 1 : 1;
          dp[i][j][2] = (i > 0 && j > 0) ? dp[i - 1][j - 1][2] + 1 : 1;
          dp[i][j][3] = (i > 0 && j < n - 1) ? dp[i - 1][j + 1][3] + 1 : 1;
          ans = max(ans, *max_element(begin(dp[i][j]), end(dp[i][j])));
        }

    return ans;
  }
};",15,826,4.0,3.0,3.0,3.0,55.06666666666667,13.0,3.5440000000000005
530.0,"class Solution {
 public:
  int findTilt(TreeNode* root) {
    int ans = 0;
    sum(root, ans);
    return ans;
  }

 private:
  int sum(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = sum(root->left, ans);
    const int r = sum(root->right, ans);
    ans += abs(l - r);
    return root->val + l + r;
  }
};",9,347,0.0,-1.0,3.0,1.0,38.55555555555556,9.0,5.51
531.0,"class Solution {
 public:
  string nearestPalindromic(string n) {
    const auto& [prevPalindrome, nextPalindrome] = getPalindromes(n);
    return abs(prevPalindrome - stol(n)) <= abs(nextPalindrome - stol(n))
               ? to_string(prevPalindrome)
               : to_string(nextPalindrome);
  }

 private:
  pair<long, long> getPalindromes(const string& s) {
    const long num = stol(s);
    const int n = s.length();
    pair<long, long> palindromes;
    const string& half = s.substr(0, (n + 1) / 2);
    const string& reversedHalf = reversed(half.substr(0, n / 2));
    const long candidate = stol(half + reversedHalf);

    if (candidate < num)
      palindromes.first = candidate;
    else {
      const string& prevHalf = to_string(stol(half) - 1);
      const string& reversedPrevHalf = reversed(prevHalf.substr(0, n / 2));
      if (n % 2 == 0 && stol(prevHalf) == 0)
        palindromes.first = 9;
      else if (n % 2 == 0 && (stol(prevHalf) + 1) % 10 == 0)
        palindromes.first = stol(prevHalf + '9' + reversedPrevHalf);
      else
        palindromes.first = stol(prevHalf + reversedPrevHalf);
    }

    if (candidate > num)
      palindromes.second = candidate;
    else {
      const string& nextHalf = to_string(stol(half) + 1);
      const string& reversedNextHalf = reversed(nextHalf.substr(0, n / 2));
      palindromes.second = stol(nextHalf + reversedNextHalf);
    }

    return palindromes;
  }

  string reversed(const string& s) {
    return {rbegin(s), rend(s)};
  }
};",21,1507,0.0,6.0,7.0,4.0,71.76190476190476,25.0,0.2614285714285724
532.0,"class Solution {
 public:
  int arrayNesting(vector<int>& nums) {
    int ans = 0;

    for (const int num : nums) {
      if (num == -1)
        continue;
      int index = num;
      int count = 0;
      while (nums[index] != -1) {  // Not yet seen
        const int cache = index;
        index = nums[index];  // Get next index
        nums[cache] = -1;     // Already seen
        ++count;
      }
      ans = max(ans, count);
    }

    return ans;
  }
};",11,461,3.0,2.0,4.0,3.0,41.90909090909091,10.0,4.988181818181818
533.0,"class Solution {
 public:
  vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
    if (nums.empty() || r * c != nums.size() * nums[0].size())
      return nums;

    vector<vector<int>> ans(r, vector<int>(c));
    int k = 0;

    for (const vector<int>& row : nums)
      for (const int num : row) {
        ans[k / c][k % c] = num;
        ++k;
      }

    return ans;
  }
};",7,403,0.0,2.0,3.0,3.0,57.57142857142857,12.0,3.3185714285714285
534.0,"class Solution {
 public:
  bool checkInclusion(string s1, string s2) {
    vector<int> count(128);
    int required = s1.length();

    for (const char c : s1)
      ++count[c];

    for (int l = 0, r = 0; r < s2.length(); ++r) {
      if (--count[s2[r]] >= 0)
        --required;
      while (required == 0) {
        if (r - l + 1 == s1.length())
          return true;
        if (++count[s2[l++]] > 0)
          ++required;
      }
    }

    return false;
  }
};",10,468,0.0,5.0,4.0,6.0,46.8,9.0,4.348
535.0,"class Solution {
 public:
  int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {
    // dp[i][j] := # of vacations can be taken from i-th city and k-th week
    dp.resize(days.size(), vector<int>(days[0].size(), INT_MIN));
    return maxVacationDays(flights, days, 0, 0);
  }

 private:
  vector<vector<int>> dp;

  int maxVacationDays(const vector<vector<int>>& flights,
                      const vector<vector<int>>& days, int i, int k) {
    if (k == days[0].size())
      return 0;
    if (dp[i][k] != INT_MIN)
      return dp[i][k];

    int ans = 0;

    // Stay at j or fly from i -> j
    for (int j = 0; j < flights.size(); ++j)
      if (j == i || flights[i][j] == 1)
        ans = max(ans, days[j][k] + maxVacationDays(flights, days, j, k + 1));

    return dp[i][k] = ans;
  }
};",11,819,2.0,1.0,3.0,4.0,74.45454545454545,15.0,1.6390909090909105
536.0,"class Solution {
 public:
  bool isSubtree(TreeNode* s, TreeNode* t) {
    if (s == nullptr)
      return false;
    if (isSameTree(s, t))
      return true;
    return isSubtree(s->left, t) || isSubtree(s->right, t);
  }

 private:
  bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p || !q)
      return p == q;
    return p->val == q->val &&              //
           isSameTree(p->left, q->left) &&  //
           isSameTree(p->right, q->right);
  }
};",6,461,2.0,-1.0,3.0,3.0,76.83333333333333,3.0,2.745000000000001
537.0,"class Solution {
 public:
  int minDistance(int height, int width, vector<int>& tree,
                  vector<int>& squirrel, vector<vector<int>>& nuts) {
    int totDist = 0;
    int maxSave = INT_MIN;

    for (const vector<int>& nut : nuts) {
      totDist += dist(nut, tree) * 2;
      maxSave = max(maxSave, dist(nut, tree) - dist(nut, squirrel));
    }

    return totDist - maxSave;
  }

 private:
  int dist(const vector<int>& a, const vector<int>& b) {
    return abs(a[0] - b[0]) + abs(a[1] - b[1]);
  }
};",7,517,0.0,0.0,4.0,1.0,73.85714285714286,16.0,1.5128571428571416
538.0,"class Solution {
 public:
  int distributeCandies(vector<int>& candies) {
    bitset<200001> bitset;

    for (const int candy : candies)
      bitset.set(candy + 100000);

    return min(candies.size() / 2, bitset.count());
  }
};",4,231,0.0,1.0,2.0,1.0,57.75,5.0,4.1225000000000005
539.0,"class Solution {
 public:
  int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
    this->m = m;
    this->n = n;
    // dp[k][i][j] := # of paths to move the ball (i, j) out of bound w/ k moves
    dp.resize(maxMove + 1, vector<vector<int>>(m, vector<int>(n, -1)));
    return findPaths(maxMove, startRow, startColumn);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  int m;
  int n;
  vector<vector<vector<int>>> dp;

  int findPaths(int k, int i, int j) {
    if (i < 0 || i == m || j < 0 || j == n)
      return 1;
    if (k == 0)
      return 0;
    if (dp[k][i][j] != -1)
      return dp[k][i][j];
    return dp[k][i][j] =
               ((findPaths(k - 1, i + 1, j) + findPaths(k - 1, i - 1, j)) %
                    kMod +
                (findPaths(k - 1, i, j + 1) + findPaths(k - 1, i, j - 1)) %
                    kMod) %
               kMod;
  }
};",13,899,1.0,-1.0,3.0,3.0,69.15384615384616,17.0,1.9961538461538453
540.0,"class Solution {
 public:
  int findUnsortedSubarray(vector<int>& nums) {
    const int n = nums.size();
    int mini = INT_MAX;
    int maxi = INT_MIN;
    bool meetDecrease = false;
    bool meetIncrease = false;

    for (int i = 1; i < n; ++i) {
      if (nums[i] < nums[i - 1])
        meetDecrease = true;
      if (meetDecrease)
        mini = min(mini, nums[i]);
    }

    for (int i = n - 2; i >= 0; --i) {
      if (nums[i] > nums[i + 1])
        meetIncrease = true;
      if (meetIncrease)
        maxi = max(maxi, nums[i]);
    }

    int l;
    for (l = 0; l < n; ++l)
      if (nums[l] > mini)
        break;

    int r;
    for (r = n - 1; r >= 0; --r)
      if (nums[r] < maxi)
        break;

    return l < r ? r - l + 1 : 0;
  }
};",23,752,0.0,8.0,4.0,10.0,32.69565217391305,13.0,5.037391304347826
541.0,"class Solution {
 public:
  vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
    vector<int> ans;
    unordered_map<int, vector<int>> tree;

    for (int i = 0; i < pid.size(); ++i) {
      if (ppid[i] == 0)
        continue;
      tree[ppid[i]].push_back(pid[i]);
    }

    dfs(tree, kill, ans);
    return ans;
  }

 private:
  void dfs(const unordered_map<int, vector<int>>& tree, int u,
           vector<int>& ans) {
    ans.push_back(u);
    if (!tree.count(u))
      return;
    for (const int v : tree.at(u))
      dfs(tree, v, ans);
  }
};",12,573,0.0,2.0,4.0,4.0,47.75,17.0,3.6425
542.0,"class Solution {
 public:
  int minDistance(string word1, string word2) {
    const int k = lcs(word1, word2);
    return (word1.length() - k) + (word2.length() - k);
  }

 private:
  int lcs(const string& A, const string& B) {
    const int m = A.length();
    const int n = B.length();
    // dp[i][j] := LCS's length of A[0..i) and B[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (A[i - 1] == B[j - 1])
          dp[i][j] = 1 + dp[i - 1][j - 1];
        else
          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);

    return dp[m][n];
  }
};",13,639,1.0,3.0,3.0,3.0,49.15384615384615,19.0,3.3561538461538465
543.0,"// Monotone Chain
class Solution {
 public:
  vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
    vector<vector<int>> hull;

    sort(begin(trees), end(trees), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });

    // Build lower hull: left-to-right scan
    for (const auto& tree : trees) {
      while (hull.size() > 1 &&
             cross(hull.back(), hull[hull.size() - 2], tree) > 0)
        hull.pop_back();
      hull.push_back(tree);
    }
    hull.pop_back();

    // Build upper hull: right-to-left scan
    for (int i = trees.size() - 1; i >= 0; --i) {
      while (hull.size() > 1 &&
             cross(hull.back(), hull[hull.size() - 2], trees[i]) > 0)
        hull.pop_back();
      hull.push_back(trees[i]);
    }

    // Remove redundant elements from the stack
    sort(begin(hull), end(hull), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });
    hull.erase(
        unique(begin(hull), end(hull),
               [](const auto& a,
                  const auto& b) { return a[0] == b[0] && a[1] == b[1]; }),
        end(hull));
    return hull;
  }

 private:
  int cross(const vector<int>& p, const vector<int>& q, const vector<int>& r) {
    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
  }
};",17,1347,4.0,0.0,8.0,4.0,79.23529411764706,19.0,0.6488235294117644
544.0,"struct TrieNode {
  map<string, shared_ptr<TrieNode>> children;  // Map: lexicographical
  bool isFile = false;
  string content;
};

class FileSystem {
 public:
  vector<string> ls(string path) {
    auto [node, lastDir] = createDirAndGetPair(path);
    if (node->isFile)
      return {lastDir};

    vector<string> ans;

    for (const auto& [file, _] : node->children)
      ans.push_back(file);

    return ans;
  }

  void mkdir(string path) {
    createDirAndGetPair(path);
  }

  void addContentToFile(string filePath, string content) {
    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;
    node->isFile = true;
    node->content += content;
  }

  string readContentFromFile(string filePath) {
    shared_ptr<TrieNode> node = createDirAndGetPair(filePath).first;
    return node->content;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  // CreateDirAndGetPair(""/a//b"") -> {TrieNode b, string ""b""}
  pair<shared_ptr<TrieNode>, string> createDirAndGetPair(const string& path) {
    const vector<string> dirs = getDirs(path);
    shared_ptr<TrieNode> node = root;

    for (const string& dir : dirs) {
      if (!node->children.count(dir))
        node->children[dir] = make_shared<TrieNode>();
      node = node->children[dir];
    }

    return {node, dirs.empty() ? """" : dirs.back()};
  }

  // GetDirs(""/a//b"") -> [""a"", ""b""]
  vector<string> getDirs(const string& path) {
    vector<string> dirs;
    istringstream iss(path);

    for (string dir; getline(iss, dir, '/');)
      if (!dir.empty())  // ""/a//b"" == ""/a/b""
        dirs.push_back(dir);

    return dirs;
  }
};",28,1625,4.0,2.0,12.0,6.0,58.035714285714285,29.0,1.1967857142857137
545.0,"class Solution {
 public:
  vector<int> preorder(Node* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    stack<Node*> stack{{root}};

    while (!stack.empty()) {
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      for (auto it = rbegin(root->children); it != rend(root->children); ++it)
        stack.push(*it);
    }

    return ans;
  }
};",10,393,0.0,2.0,6.0,3.0,39.3,3.0,5.683
546.0,"class Solution {
 public:
  vector<int> postorder(Node* root) {
    if (root == nullptr)
      return {};

    vector<int> ans;
    stack<Node*> stack{{root}};

    while (!stack.empty()) {
      root = stack.top(), stack.pop();
      ans.push_back(root->val);
      for (Node* child : root->children)
        stack.push(child);
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};",9,393,0.0,2.0,6.0,3.0,43.66666666666666,3.0,5.29
547.0,"class Solution {
 public:
  bool isValid(string code) {
    if (code[0] != '<' || code.back() != '>')
      return false;

    stack<string> stack;

    for (int i = 0; i < code.length(); ++i) {
      int closeIndex = 0;
      if (stack.empty() && containsTag)
        return false;
      if (code[i] == '<') {
        // Inside a tag, so we can check if it's a cdata
        if (!stack.empty() && code[i + 1] == '!') {
          closeIndex = code.find(""]]>"", i + 2);
          if (closeIndex == string::npos ||
              !isValidCdata(code.substr(i + 2, closeIndex - i - 2)))
            return false;
        } else if (code[i + 1] == '/') {  // End tag
          closeIndex = code.find('>', i + 2);
          if (closeIndex == string::npos ||
              !isValidTagName(stack, code.substr(i + 2, closeIndex - i - 2),
                              true))
            return false;
        } else {  // Start tag
          closeIndex = code.find('>', i + 1);
          if (closeIndex == string::npos ||
              !isValidTagName(stack, code.substr(i + 1, closeIndex - i - 1),
                              false))
            return false;
        }
        i = closeIndex;
      }
    }

    return stack.empty() && containsTag;
  }

 private:
  bool containsTag = false;

  bool isValidCdata(const string& s) {
    return s.find(""[CDATA["") == 0;
  }

  bool isValidTagName(stack<string>& stack, const string& tagName,
                      bool isEndTag) {
    if (tagName.empty() || tagName.length() > 9)
      return false;

    for (const char c : tagName)
      if (!isupper(c))
        return false;

    if (isEndTag) {
      if (stack.empty())
        return false;
      if (stack.top() != tagName)
        return false;
      stack.pop();
      return true;
    }

    containsTag = true;
    stack.push(tagName);
    return true;
  }
};",26,1860,3.0,6.0,10.0,16.0,71.53846153846153,20.0,0.7215384615384615
548.0,"class Solution {
 public:
  string fractionAddition(string expression) {
    istringstream iss(expression);
    char _;
    int a;
    int b;
    int A = 0;
    int B = 1;

    // Init: A / B = 0 / 1
    // A / B + a / b = (Ab + aB) / Bb
    // So, each round set A = Ab + aB, B = Bb
    while (iss >> a >> _ >> b) {
      A = A * b + a * B;
      B *= b;
      const int g = abs(__gcd(A, B));
      A /= g;
      B /= g;
    }

    return to_string(A) + ""/"" + to_string(B);
  }
};",13,481,3.0,1.0,3.0,1.0,37.0,10.0,5.550000000000001
549.0,"class Solution {
 public:
  bool validSquare(vector<int>& p1, vector<int>& p2,  //
                   vector<int>& p3, vector<int>& p4) {
    unordered_set<int> distSet;
    vector<vector<int>> points{p1, p2, p3, p4};

    for (int i = 0; i < 4; ++i)
      for (int j = i + 1; j < 4; ++j)
        distSet.insert(dist(points[i], points[j]));

    return !distSet.count(0) && distSet.size() == 2;
  }

 private:
  int dist(vector<int>& p1, vector<int>& p2) {
    return (p1[0] - p2[0]) * (p1[0] - p2[0]) +
           (p1[1] - p2[1]) * (p1[1] - p2[1]);
  }
};",10,556,1.0,1.0,4.0,2.0,55.6,13.0,3.436000000000001
550.0,"class Solution {
 public:
  int findLHS(vector<int>& nums) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [num, freq] : count)
      if (const auto it = count.find(num + 1); it != cend(count))
        ans = max(ans, freq + it->second);

    return ans;
  }
};",7,340,0.0,3.0,2.0,3.0,48.57142857142857,10.0,4.328571428571429
551.0,"class Solution {
 public:
  int maxCount(int m, int n, vector<vector<int>>& ops) {
    int minY = m;
    int minX = n;

    for (const vector<int>& op : ops) {
      minY = min(minY, op[0]);
      minX = min(minX, op[1]);
    }

    return minX * minY;
  }
};",6,259,0.0,1.0,3.0,1.0,43.16666666666666,9.0,4.9750000000000005
552.0,"class Solution {
 public:
  vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
    vector<string> ans;
    unordered_map<string, int> restaurantToIndex;
    int minSum = INT_MAX;

    for (int i = 0; i < list1.size(); ++i)
      restaurantToIndex[list1[i]] = i;

    for (int i = 0; i < list2.size(); ++i) {
      const string& restaurant = list2[i];
      if (const auto it = restaurantToIndex.find(restaurant);
          it != cend(restaurantToIndex)) {
        const int sum = it->second + i;
        if (sum < minSum) {
          minSum = sum;
          ans = {restaurant};
        } else if (sum == minSum) {
          ans.push_back(restaurant);
        }
      }
    }

    return ans;
  }
};",16,725,0.0,6.0,7.0,5.0,45.3125,15.0,3.641875
553.0,"class Solution {
 public:
  int findIntegers(int num) {
    string bits;
    for (; num; num >>= 1)
      bits += to_string(num & 1);

    const int n = bits.length();
    vector<int> zero(n, 1);
    vector<int> one(n, 1);

    for (int i = 1; i < n; ++i) {
      zero[i] = zero[i - 1] + one[i - 1];
      one[i] = zero[i - 1];
    }

    int ans = zero[n - 1] + one[n - 1];

    for (int i = n - 2; i >= 0; --i) {
      // Numbers greater than num and <= 2^n - 1 are invalid
      if (bits[i] == '1' && bits[i + 1] == '1')
        break;
      if (bits[i] == '0' && bits[i + 1] == '0')
        ans -= one[i];
    }

    return ans;
  }
};",18,639,1.0,4.0,4.0,5.0,35.5,11.0,5.265
554.0,"class Solution {
 public:
  bool canPlaceFlowers(vector<int>& flowerbed, int n) {
    if (n == 0)
      return true;

    for (int i = 0; i < flowerbed.size(); ++i)
      if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) &&
          (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {
        flowerbed[i] = 1;
        if (--n == 0)
          return true;
      }

    return false;
  }
};",7,403,0.0,2.0,3.0,4.0,57.57142857142857,5.0,4.018571428571429
555.0,"class Solution {
 public:
  string tree2str(TreeNode* t) {
    return dfs(t);
  }

 private:
  string dfs(TreeNode* root) {
    if (root == nullptr)
      return """";

    const string& rootStr = to_string(root->val);
    if (root->right)
      return rootStr + ""("" + dfs(root->left) + "")("" + dfs(root->right) + "")"";
    if (root->left)
      return rootStr + ""("" + dfs(root->left) + "")"";
    return rootStr + """";
  }
};",7,419,0.0,-1.0,3.0,3.0,59.85714285714285,5.0,3.992857142857143
556.0,"class Solution {
 public:
  vector<vector<string>> findDuplicate(vector<string>& paths) {
    vector<vector<string>> ans;
    unordered_map<string, vector<string>> contentToFilePaths;

    for (const string& path : paths) {
      istringstream iss(path);
      string rootPath;
      iss >> rootPath;  // ""root/d1/d2/.../dm""

      string fileAndContent;
      while (iss >> fileAndContent) {  // ""fn.txt(fn_content)""
        const int l = fileAndContent.find('(');
        const int r = fileAndContent.find(')');
        // ""fn.txt""
        const string file = fileAndContent.substr(0, l);
        // ""fn_content""
        const string content = fileAndContent.substr(l + 1, r - l - 1);
        // ""root/d1/d2/.../dm/fn.txt""
        const string filePath = rootPath + '/' + file;
        contentToFilePaths[content].push_back(filePath);
      }
    }

    for (const auto& [_, filePaths] : contentToFilePaths)
      if (filePaths.size() > 1)
        ans.push_back(filePaths);

    return ans;
  }
};",15,999,5.0,4.0,4.0,4.0,66.6,21.0,1.6259999999999994
557.0,"class Solution {
 public:
  int triangleNumber(vector<int>& nums) {
    if (nums.size() < 3)
      return 0;

    int ans = 0;

    sort(begin(nums), end(nums));

    for (int k = nums.size() - 1; k > 1; --k) {
      int i = 0;
      int j = k - 1;
      while (i < j)
        if (nums[i] + nums[j] > nums[k]) {
          // (nums[i], nums[j], nums[k])
          // (nums[i + 1], nums[j], nums[k])
          // ...
          // (nums[j - 1], nums[j], nums[k])
          ans += j - i;
          --j;
        } else {
          ++i;
        }
    }

    return ans;
  }
};",12,570,4.0,4.0,5.0,4.0,47.5,7.0,4.6450000000000005
558.0,"class Solution {
 public:
  string addBoldTag(string s, vector<string>& words) {
    const int n = s.length();
    string ans;
    // bold[i] := true if s[i] should be bolded
    vector<bool> bold(n);

    int boldEnd = -1;  // s[i:boldEnd] should be bolded
    for (int i = 0; i < n; ++i) {
      for (const string& word : words)
        if (s.substr(i).find(word) == 0)  // StartsWith
          boldEnd = max(boldEnd, i + static_cast<int>(word.length()));
      bold[i] = boldEnd > i;
    }

    // Construct the string with bold tags
    int i = 0;
    while (i < n)
      if (bold[i]) {
        int j = i;
        while (j < n && bold[j])
          ++j;
        // s[i:j] should be bolded
        ans += ""<b>"" + s.substr(i, j - i) + ""</b>"";
        i = j;
      } else {
        ans += s[i++];
      }

    return ans;
  }
};",16,829,5.0,8.0,5.0,7.0,51.8125,16.0,3.1568749999999994
559.0,"class Solution {
 public:
  TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (root1 == nullptr && root2 == nullptr)
      return nullptr;
    const int val = (root1 == nullptr ? 0 : root1->val) +
                    (root2 == nullptr ? 0 : root2->val);
    TreeNode* root = new TreeNode(val);
    root->left = mergeTrees(root1 == nullptr ? nullptr : root1->left,
                            root2 == nullptr ? nullptr : root2->left);
    root->right = mergeTrees(root1 == nullptr ? nullptr : root1->right,
                             root2 == nullptr ? nullptr : root2->right);
    return root;
  }
};",7,617,0.0,0.0,2.0,1.0,88.14285714285714,3.0,1.6471428571428586
560.0,"class Solution {
 public:
  int leastInterval(vector<char>& tasks, int n) {
    if (n == 0)
      return tasks.size();

    vector<int> count(26);

    for (const char task : tasks)
      ++count[task - 'A'];

    const int maxFreq = *max_element(begin(count), end(count));
    // Put the most frequent task in the slot first
    const int maxFreqTaskOccupy = (maxFreq - 1) * (n + 1);
    // Get # of tasks with same frequency as maxFreq,
    // we'll append them after maxFreqTaskOccupy
    const int nMaxFreq = std::count(begin(count), end(count), maxFreq);
    // Max(
    //   the most frequent task is frequent enough to force some idle slots,
    //   the most frequent task is not frequent enough to force idle slots
    // )
    return max(maxFreqTaskOccupy + nMaxFreq, static_cast<int>(tasks.size()));
  }
};",8,817,7.0,1.0,2.0,4.0,102.125,14.0,-0.4912500000000008
561.0,"class MyCircularQueue {
 public:
  /** Initialize your data structure here. Set the size of the queue to be k. */
  MyCircularQueue(int k) : k(k), q(k), rear(k - 1) {}

  /** Insert an element into the circular queue. Return true if the operation is
   * successful. */
  bool enQueue(int value) {
    if (isFull())
      return false;

    rear = ++rear % k;
    q[rear] = value;
    ++size;
    return true;
  }

  /** Delete an element from the circular queue. Return true if the operation is
   * successful. */
  bool deQueue() {
    if (isEmpty())
      return false;

    front = ++front % k;
    --size;
    return true;
  }

  /** Get the front item from the queue. */
  int Front() {
    return isEmpty() ? -1 : q[front];
  }

  /** Get the last item from the queue. */
  int Rear() {
    return isEmpty() ? -1 : q[rear];
  }

  /** Checks whether the circular queue is empty or not. */
  bool isEmpty() {
    return size == 0;
  }

  /** Checks whether the circular queue is full or not. */
  bool isFull() {
    return size == k;
  }

 private:
  const int k;
  vector<int> q;
  int size = 0;
  int front = 0;
  int rear;
};",19,1136,7.0,-3.0,8.0,4.0,59.78947368421053,15.0,3.0989473684210536
562.0,"class Solution {
 public:
  TreeNode* addOneRow(TreeNode* root, int v, int d) {
    if (d == 1) {
      TreeNode* newRoot = new TreeNode(v);
      newRoot->left = root;
      return newRoot;
    }

    int depth = 0;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      ++depth;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
        if (depth == d - 1) {
          TreeNode* cachedLeft = node->left;
          TreeNode* cachedRight = node->right;
          node->left = new TreeNode(v);
          node->right = new TreeNode(v);
          node->left->left = cachedLeft;
          node->right->right = cachedRight;
        }
      }
      if (depth == d - 1)
        break;
    }

    return root;
  }
};",21,876,0.0,5.0,8.0,7.0,41.71428571428572,5.0,4.965714285714285
563.0,"class Solution {
 public:
  int maxDistance(vector<vector<int>>& arrays) {
    int ans = 0;
    int min = 10000;
    int max = -10000;

    for (const vector<int>& A : arrays) {
      ans = std::max({ans, A.back() - min, max - A.front()});
      min = std::min(min, A.front());
      max = std::max(max, A.back());
    }

    return ans;
  }
};",8,344,0.0,1.0,4.0,1.0,43.0,8.0,5.03
564.0,"class Solution {
 public:
  int smallestFactorization(int num) {
    if (num == 1)
      return 1;

    long ans = 0;
    long base = 1;

    for (int i = 9; i > 1; --i)
      while (num % i == 0) {
        num /= i;
        ans = base * i + ans;
        base *= 10;
      }

    return num == 1 && ans <= INT_MAX ? ans : 0;
  }
};",10,331,0.0,2.0,3.0,3.0,33.1,4.0,6.321
565.0,"class Solution {
 public:
  int maximumProduct(vector<int>& nums) {
    const int n = nums.size();
    sort(begin(nums), end(nums));
    return max(nums[n - 1] * nums[0] * nums[1],
               nums[n - 1] * nums[n - 2] * nums[n - 3]);
  }
};",4,244,0.0,0.0,2.0,0.0,61.0,5.0,3.89
566.0,"class Solution {
 public:
  int kInversePairs(int n, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := # of permutations of numbers 1..i with j inverse pairs
    vector<vector<int>> dp(n + 1, vector<int>(k + 1));

    // If there's no inverse pair, the permutation is unique ""123..i""
    for (int i = 0; i <= n; ++i)
      dp[i][0] = 1;

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= k; ++j) {
        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % kMod;
        if (j - i >= 0)
          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + kMod) % kMod;
      }

    return dp[n][k];
  }
};",13,609,2.0,4.0,3.0,5.0,46.84615384615385,10.0,4.443846153846154
567.0,"class Solution {
 public:
  int scheduleCourse(vector<vector<int>>& courses) {
    int time = 0;
    sort(begin(courses), end(courses),
         [](const auto& a, const auto& b) { return a[1] < b[1]; });
    priority_queue<int> maxHeap;

    for (const vector<int>& c : courses) {
      const int duration = c[0];
      const int lastDay = c[1];
      maxHeap.push(duration);
      time += c[0];
      // If current course could not be taken, check if it's able to swap with a
      // Previously taken course with larger duration, to increase the time
      // Available to take upcoming courses
      if (time > lastDay)
        time -= maxHeap.top(), maxHeap.pop();
    }

    return maxHeap.size();
  }
};",11,709,3.0,2.0,4.0,4.0,64.45454545454545,13.0,2.659090909090909
568.0,"struct T {
  int i;
  int j;
  int num;  // nums[i][j]
  T(int i, int j, int num) : i(i), j(j), num(num) {}
};

class Solution {
 public:
  vector<int> smallestRange(vector<vector<int>>& nums) {
    auto compare = [&](const T& a, const T& b) { return a.num > b.num; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    int mini = INT_MAX;
    int maxi = INT_MIN;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i][0];
      minHeap.emplace(i, 0, num);
      mini = min(mini, num);
      maxi = max(maxi, num);
    }

    int minRange = mini;
    int maxRange = maxi;

    while (minHeap.size() == nums.size()) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      if (j + 1 < nums[i].size()) {
        minHeap.emplace(i, j + 1, nums[i][j + 1]);
        maxi = max(maxi, nums[i][j + 1]);
        mini = minHeap.top().num;
        if (maxi - mini < maxRange - minRange) {
          minRange = mini;
          maxRange = maxi;
        }
      }
    }

    return {minRange, maxRange};
  }
};",26,1055,1.0,3.0,10.0,4.0,40.57692307692308,20.0,3.608076923076923
569.0,"class Solution {
 public:
  bool judgeSquareSum(int c) {
    unsigned l = 0;
    unsigned r = sqrt(c);

    while (l <= r) {
      const unsigned sum = l * l + r * r;
      if (sum == c)
        return true;
      if (sum < c)
        ++l;
      else
        --r;
    }

    return false;
  }
};",8,295,0.0,3.0,3.0,3.0,36.875,4.0,5.92125
570.0,"class Solution {
 public:
  int findDerangement(int n) {
    dp.resize(n + 1);
    return find(n);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<int> dp;

  int find(int i) {
    if (i == 0)
      return 1;
    if (i == 1)
      return 0;
    if (dp[i])
      return dp[i];
    return dp[i] = (i - 1L) * (find(i - 1) + find(i - 2)) % kMod;
  }
};",9,369,0.0,-1.0,3.0,3.0,41.0,7.0,5.49
571.0,"class Solution {
 public:
  vector<int> exclusiveTime(int n, vector<string>& logs) {
    vector<int> ans(n);
    stack<int> stack;  // [oldest_id, ..., latest_id]
    int prevTime;

    for (const string& log : logs) {
      // Get seperators' indices.
      const int colon1 = log.find_first_of(':');
      const int colon2 = log.find_last_of(':');
      // Get function_id, label, and timestamp.
      const int id = stoi(log.substr(0, colon1));  // {function_id}
      const char label = log[colon1 + 1];  // {""s"" (""start"") | ""e"" (""end"") }
      const int timestamp = stoi(log.substr(colon2 + 1));  // {timestamp}
      if (label == 's') {
        if (!stack.empty())
          ans[stack.top()] += timestamp - prevTime;
        stack.push(id);
        prevTime = timestamp;
      } else {
        ans[stack.top()] += timestamp - prevTime + 1, stack.pop();
        prevTime = timestamp + 1;
      }
    }

    return ans;
  }
};",15,930,6.0,4.0,8.0,3.0,62.0,19.0,2.039999999999999
572.0,"class Solution {
 public:
  vector<double> averageOfLevels(TreeNode* root) {
    vector<double> ans;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      long sum = 0;
      const int size = q.size();
      for (int i = 0; i < size; ++i) {
        TreeNode* node = q.front();
        q.pop();
        sum += node->val;
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
      ans.push_back(sum / (double)size);
    }

    return ans;
  }
};",14,518,0.0,4.0,6.0,4.0,37.0,7.0,5.369999999999999
573.0,"class Solution {
 public:
  int shoppingOffers(vector<int>& price, vector<vector<int>>& special,
                     vector<int>& needs) {
    return dfs(price, special, needs, 0);
  }

 private:
  int dfs(const vector<int>& price, const vector<vector<int>>& special,
          vector<int>& needs, int s) {
    int ans = 0;
    for (int i = 0; i < price.size(); ++i)
      ans += price[i] * needs[i];

    for (int i = s; i < special.size(); ++i)
      if (isValid(special[i], needs)) {
        // Use special[i]
        for (int j = 0; j < needs.size(); ++j)
          needs[j] -= special[i][j];
        ans = min(ans, special[i].back() + dfs(price, special, needs, i));
        // Backtracking - unuse special[i]
        for (int j = 0; j < needs.size(); ++j)
          needs[j] += special[i][j];
      }

    return ans;
  }

  // Check if this special offer is a valid one
  bool isValid(const vector<int>& offer, const vector<int>& needs) {
    for (int i = 0; i < needs.size(); ++i)
      if (needs[i] < offer[i])
        return false;
    return true;
  }
};",20,1066,3.0,5.0,5.0,8.0,53.3,23.0,2.423000000000001
574.0,"class Solution {
 public:
  int numDecodings(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    // dp[i] := # of ways to decode s[i:n]
    vector<long> dp(n + 1);
    dp.back() = 1;
    dp[n - 1] = count(s[n - 1]);

    for (int i = n - 2; i >= 0; --i) {
      dp[i] += count(s[i], s[i + 1]) * dp[i + 2];
      dp[i] += count(s[i]) * dp[i + 1];
      dp[i] %= kMod;
    }

    return dp[0];
  }

 private:
  int count(char c) {
    if (c == '*')
      return 9;
    return c != '0';
  }

  int count(char c1, char c2) {
    if (c1 == '*' && c2 == '*')  // C1c2: [11-19, 21-26]
      return 15;
    if (c1 == '*') {
      if ('0' <= c2 && c2 <= '6')  // C1: [1-2]
        return 2;
      else  // C1: [1]
        return 1;
    }
    if (c2 == '*') {
      if (c1 == '1')  // C2: [1-9]
        return 9;
      if (c1 == '2')  // C2: [1-6]
        return 6;
      return 0;
    }
    return c1 == '1' || (c1 == '2' && c2 <= '6');
  }
};",21,968,6.0,0.0,7.0,8.0,46.095238095238095,12.0,4.471428571428572
575.0,"class Solution {
 public:
  string solveEquation(string equation) {
    const string lhsEquation = equation.substr(0, equation.find('='));
    const string rhsEquation = equation.substr(equation.find('=') + 1);
    const auto& [lhsCoefficient, lhsConstant] = calculate(lhsEquation);
    const auto& [rhsCoefficient, rhsConstant] = calculate(rhsEquation);
    const int coefficient = lhsCoefficient - rhsCoefficient;
    const int constant = rhsConstant - lhsConstant;

    if (coefficient == 0 && constant == 0)
      return ""Infinite solutions"";
    if (coefficient == 0 && constant != 0)
      return ""No solution"";
    return ""x="" + to_string(constant / coefficient);
  }

 private:
  pair<int, int> calculate(const string& s) {
    int coefficient = 0;
    int constant = 0;
    int num = 0;
    int sign = 1;

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c))
        num = num * 10 + (c - '0');
      else if (c == '+' || c == '-') {
        constant += sign * num;
        sign = c == '+' ? 1 : -1;
        num = 0;
      } else {
        if (i > 0 && num == 0 && s[i - 1] == '0')
          continue;
        coefficient += num == 0 ? sign : sign * num;
        num = 0;
      }
    }

    return {coefficient, constant + sign * num};
  }
};",25,1290,0.0,4.0,7.0,6.0,51.6,24.0,2.296
576.0,"class MyCircularDeque {
 public:
  /** Initialize your data structure here. Set the size of the deque to be k. */
  MyCircularDeque(int k) : k(k), q(k), rear(k - 1) {}

  /** Adds an item at the front of Deque. Return true if the operation is
   * successful. */
  bool insertFront(int value) {
    if (isFull())
      return false;

    front = (--front + k) % k;
    q[front] = value;
    ++size;
    return true;
  }

  /** Adds an item at the rear of Deque. Return true if the operation is
   * successful. */
  bool insertLast(int value) {
    if (isFull())
      return false;

    rear = ++rear % k;
    q[rear] = value;
    ++size;
    return true;
  }

  /** Deletes an item from the front of Deque. Return true if the operation is
   * successful. */
  bool deleteFront() {
    if (isEmpty())
      return false;

    front = ++front % k;
    --size;
    return true;
  }

  /** Deletes an item from the rear of Deque. Return true if the operation is
   * successful. */
  bool deleteLast() {
    if (isEmpty())
      return false;

    rear = (--rear + k) % k;
    --size;
    return true;
  }

  /** Get the front item from the deque. */
  int getFront() {
    return isEmpty() ? -1 : q[front];
  }

  /** Get the last item from the deque. */
  int getRear() {
    return isEmpty() ? -1 : q[rear];
  }

  /** Checks whether the circular deque is empty or not. */
  bool isEmpty() {
    return size == 0;
  }

  /** Checks whether the circular deque is full or not. */
  bool isFull() {
    return size == k;
  }

 private:
  const int k;
  vector<int> q;
  int size = 0;
  int front = 0;
  int rear;
};",28,1614,9.0,-3.0,10.0,8.0,57.642857142857146,18.0,2.9521428571428574
577.0,"class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    double sum = accumulate(begin(nums), begin(nums) + k, 0);
    double ans = sum;

    for (int i = k; i < nums.size(); ++i) {
      sum += nums[i] - nums[i - k];
      ans = max(ans, sum);
    }

    return ans / k;
  }
};",8,303,0.0,1.0,3.0,1.0,37.875,7.0,5.651250000000001
578.0,"class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
    constexpr double kErr = 1e-5;
    double l = *min_element(begin(nums), end(nums));
    double r = *max_element(begin(nums), end(nums));

    while (r - l > kErr) {
      const double m = (l + r) / 2;
      if (check(nums, k, m))
        l = m;
      else
        r = m;
    }

    return l;
  }

 private:
  // Returns true if there's a subarray with length >= k and average sum >= m.
  bool check(const vector<int>& nums, int k, double m) {
    double sum = 0;
    double prevSum = 0;
    double minPrevSum = 0;

    for (int i = 0; i < nums.size(); ++i) {
      // Trick: -m for each num so that we can check if the sum of the
      // Subarray >= 0
      sum += nums[i] - m;
      if (i >= k) {
        prevSum += nums[i - k] - m;
        minPrevSum = min(minPrevSum, prevSum);
      }
      // If sum - minPrevSum >= 0,
      // We know there's a subarray with length >= k and average sum >= m
      if (i + 1 >= k && sum >= minPrevSum)
        return true;
    }

    return false;
  };
};",19,1076,5.0,7.0,6.0,9.0,56.63157894736842,18.0,2.5231578947368423
579.0,"class Solution {
 public:
  vector<int> findErrorNums(vector<int>& nums) {
    int duplicate;

    for (const int num : nums)
      if (nums[abs(num) - 1] < 0)
        duplicate = abs(num);
      else
        nums[abs(num) - 1] *= -1;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > 0)
        return {duplicate, i + 1};

    throw;
  }
};",8,354,0.0,4.0,3.0,4.0,44.25,7.0,4.8975
580.0,"class Solution {
 public:
  int findLongestChain(vector<vector<int>>& pairs) {
    int ans = 0;
    int prevEnd = INT_MIN;

    sort(begin(pairs), end(pairs),
         [](const auto& a, const auto& b) { return a[1] < b[1]; });

    for (const vector<int>& pair : pairs)
      if (pair[0] > prevEnd) {
        ++ans;
        prevEnd = pair[1];
      }

    return ans;
  }
};",8,374,0.0,1.0,4.0,2.0,46.75,9.0,4.5925
581.0,"class Solution {
 public:
  int countSubstrings(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i) {
      ans += extendPalindromes(s, i, i);
      ans += extendPalindromes(s, i, i + 1);
    }

    return ans;
  }

 private:
  int extendPalindromes(const string& s, int l, int r) {
    int count = 0;

    while (l >= 0 && r < s.length() && s[l] == s[r]) {
      ++count;
      --l;
      ++r;
    }

    return count;
  }
};",12,445,0.0,1.0,5.0,2.0,37.083333333333336,11.0,5.202500000000001
582.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string replaceWords(vector<string>& dictionary, string sentence) {
    for (const string& word : dictionary)
      insert(word);

    string ans;
    istringstream iss(sentence);

    for (string s; iss >> s;)
      ans += search(s) + ' ';
    ans.pop_back();

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  string search(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      if (node->word)
        return *node->word;
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return word;
      node = node->children[i];
    }
    return word;
  }
};",24,1106,0.0,4.0,8.0,7.0,46.083333333333336,25.0,2.6325000000000003
583.0,"class Solution {
 public:
  string predictPartyVictory(string senate) {
    const int n = senate.length();
    queue<int> qR;
    queue<int> qD;

    for (int i = 0; i < n; ++i)
      if (senate[i] == 'R')
        qR.push(i);
      else
        qD.push(i);

    while (!qR.empty() && !qD.empty()) {
      const int indexR = qR.front();
      qR.pop();
      const int indexD = qD.front();
      qD.pop();
      if (indexR < indexD)
        qR.push(indexR + n);
      else
        qD.push(indexD + n);
    }

    return qR.empty() ? ""Dire"" : ""Radiant"";
  }
};",15,558,0.0,6.0,3.0,4.0,37.2,12.0,4.912
584.0,"class Solution {
 public:
  int minSteps(int n) {
    if (n <= 1)
      return 0;

    // dp[i] := min steps to get i 'A'
    vector<int> dp(n + 1);

    // Copy 'A', then paste 'A' i - 1 times
    iota(begin(dp), end(dp), 0);

    for (int i = 2; i <= n; ++i)
      for (int j = i / 2; j > 2; --j)
        if (i % j == 0) {
          dp[i] = dp[j] + i / j;  // Paste dp[j] i / j times
          break;
        }

    return dp[n];
  }
};",11,438,3.0,2.0,3.0,4.0,39.81818181818182,6.0,5.636363636363637
585.0,"class Solution {
 public:
  int maxA(int n) {
    int ans = n;

    for (int i = 1; i <= n - 3; ++i)
      ans = max(ans, maxA(i) * (n - i - 1));

    return ans;
  }
};",6,169,0.0,1.0,2.0,1.0,28.166666666666668,5.0,6.785
586.0,"class Solution {
 public:
  vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
    vector<TreeNode*> ans;
    unordered_map<string, int> count;
    encode(root, count, ans);
    return ans;
  }

 private:
  string encode(TreeNode* root, unordered_map<string, int>& count,
                vector<TreeNode*>& ans) {
    if (root == nullptr)
      return """";

    const string encoded = to_string(root->val) + ""#"" +
                           encode(root->left, count, ans) + ""#"" +
                           encode(root->right, count, ans);
    if (++count[encoded] == 2)
      ans.push_back(root);
    return encoded;
  }
};",9,630,0.0,0.0,3.0,2.0,70.0,8.0,2.7200000000000006
587.0,"class BSTIterator {
 public:
  BSTIterator(TreeNode* root, bool leftToRight) : leftToRight(leftToRight) {
    pushUntilNull(root);
  }

  int next() {
    TreeNode* root = stack.top();
    stack.pop();
    pushUntilNull(leftToRight ? root->right : root->left);
    return root->val;
  }

 private:
  stack<TreeNode*> stack;
  bool leftToRight;

  void pushUntilNull(TreeNode* root) {
    while (root != nullptr) {
      stack.push(root);
      root = leftToRight ? root->left : root->right;
    }
  }
};

class Solution {
 public:
  bool findTarget(TreeNode* root, int k) {
    if (root == nullptr)
      return false;

    BSTIterator left(root, true);
    BSTIterator right(root, false);

    for (int l = left.next(), r = right.next(); l < r;) {
      const int sum = l + r;
      if (sum == k)
        return true;
      if (sum < k)
        l = left.next();
      else
        r = right.next();
    }

    return false;
  }
};",21,931,0.0,3.0,8.0,5.0,44.333333333333336,11.0,4.25
588.0,"class Solution {
 public:
  TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
    return build(nums, 0, nums.size() - 1);
  }

 private:
  TreeNode* build(const vector<int>& nums, int i, int j) {
    if (i > j)
      return nullptr;

    const auto it = max_element(begin(nums) + i, begin(nums) + j + 1);
    const int maxNum = *it;
    const int maxIndex = it - begin(nums);

    TreeNode* root = new TreeNode(maxNum);
    root->left = build(nums, i, maxIndex - 1);
    root->right = build(nums, maxIndex + 1, j);
    return root;
  }
};",10,546,0.0,-1.0,3.0,1.0,54.6,11.0,3.866000000000001
589.0,"class Solution {
 public:
  vector<vector<string>> printTree(TreeNode* root) {
    const int m = maxHeight(root);
    const int n = pow(2, m) - 1;
    vector<vector<string>> ans(m, vector<string>(n));
    dfs(root, 0, 0, ans[0].size() - 1, ans);
    return ans;
  }

 private:
  int maxHeight(TreeNode* root) {
    if (root == nullptr)
      return 0;
    return 1 + max(maxHeight(root->left), maxHeight(root->right));
  }

  void dfs(TreeNode* root, int row, int left, int right,
           vector<vector<string>>& ans) {
    if (root == nullptr)
      return;

    const int mid = (left + right) / 2;
    ans[row][mid] = to_string(root->val);
    dfs(root->left, row + 1, left, mid - 1, ans);
    dfs(root->right, row + 1, mid + 1, right, ans);
  }
};",13,753,0.0,-1.0,4.0,2.0,57.92307692307692,16.0,3.0069230769230773
590.0,"class Solution {
 public:
  vector<int> cheapestJump(vector<int>& coins, int maxJump) {
    if (coins.back() == -1)
      return {};

    const int n = coins.size();
    vector<int> next(n, -1);

    // dp[i] := min cost to jump from i to n - 1
    dp.resize(n, INT_MAX);
    cheapestJump(coins, maxJump, 0, next);

    if (dp[0] == INT_MAX)
      return {};
    return constructPath(next, 0);
  }

 private:
  vector<int> dp;

  int cheapestJump(const vector<int>& coins, int maxJump, int i,
                   vector<int>& next) {
    if (i == coins.size() - 1)
      return dp[i] = coins[i];
    if (dp[i] < INT_MAX)
      return dp[i];
    if (coins[i] == -1)
      return INT_MAX;

    for (int j = i + 1; j <= i + maxJump && j < coins.size(); ++j) {
      const int res = cheapestJump(coins, maxJump, j, next);
      if (res == INT_MAX)
        continue;
      const int cost = coins[i] + res;
      if (cost < dp[i]) {
        dp[i] = cost;
        next[i] = j;
      }
    }

    return dp[i];
  }

  vector<int> constructPath(const vector<int>& next, int i) {
    vector<int> ans;
    while (i != -1) {
      ans.push_back(i + 1);  // 1-indexed
      i = next[i];
    }
    return ans;
  }
};",24,1201,2.0,1.0,9.0,9.0,50.04166666666666,24.0,2.576250000000001
591.0,"class Solution {
 public:
  bool judgeCircle(string moves) {
    int right = 0;
    int up = 0;

    for (const char move : moves) {
      switch (move) {
        case 'R':
          ++right;
          break;
        case 'L':
          --right;
          break;
        case 'U':
          ++up;
          break;
        case 'D':
          --up;
          break;
      }
    }

    return right == 0 && up == 0;
  }
};",12,420,0.0,2.0,4.0,1.0,35.0,7.0,5.79
592.0,"class Solution {
 public:
  vector<int> findClosestElements(vector<int>& arr, int k, int x) {
    int l = 0;
    int r = arr.size() - k;

    while (l < r) {
      const int m = (l + r) / 2;
      if (x - arr[m] <= arr[m + k] - x)
        r = m;
      else
        l = m + 1;
    }

    return {begin(arr) + l, begin(arr) + l + k};
  }
};",7,338,0.0,3.0,4.0,2.0,48.285714285714285,9.0,4.3342857142857145
593.0,"class Solution {
 public:
  bool isPossible(vector<int>& nums) {
    unordered_map<int, int> count;
    vector<int> starts;  // Start index of subsequence
    vector<int> ends;    // End index of subsequence

    for (const int num : nums)
      ++count[num];

    for (int i = 0; i < nums.size(); ++i) {
      if (i > 0 && nums[i] == nums[i - 1])
        continue;
      const int num = nums[i];
      const int currCount = count[num];
      const int prevCount = count.count(num - 1) ? count[num - 1] : 0;
      const int nextCount = count.count(num + 1) ? count[num + 1] : 0;
      for (int j = 0; j < currCount - prevCount; ++j)
        starts.push_back(num);
      for (int j = 0; j < currCount - nextCount; ++j)
        ends.push_back(num);
    }

    for (int i = 0; i < starts.size(); ++i)
      if (ends[i] - starts[i] < 2)
        return false;

    return true;
  }
};",22,879,2.0,5.0,3.0,7.0,39.95454545454545,21.0,3.90409090909091
594.0,"class Solution {
 public:
  int newInteger(int n) {
    string ans;
    while (n) {
      ans = to_string(n % 9) + ans;
      n /= 9;
    }
    return stoi(ans);
  }
};",5,168,0.0,1.0,3.0,1.0,33.6,4.0,6.336
595.0,"class Solution {
 public:
  vector<vector<int>> imageSmoother(vector<vector<int>>& M) {
    const int m = M.size();
    const int n = M[0].size();
    vector<vector<int>> ans(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        int ones = 0;
        int count = 0;
        for (int x = max(0, i - 1); x < min(m, i + 2); ++x)
          for (int y = max(0, j - 1); y < min(n, j + 2); ++y) {
            ones += M[x][y];
            ++count;
          }
        ans[i][j] = ones / count;
      }

    return ans;
  }
};",18,560,0.0,4.0,4.0,4.0,31.11111111111111,15.0,5.22
596.0,"class Solution {
 public:
  int widthOfBinaryTree(TreeNode* root) {
    if (root == nullptr)
      return 0;

    int ans = 0;
    queue<pair<TreeNode*, int>> q{{{root, 1}}};  // {node, index}

    while (!q.empty()) {
      const int offset = q.front().second * 2;
      ans = max(ans, q.back().second - q.front().second + 1);
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [node, index] = q.front();
        q.pop();
        if (node->left)
          q.emplace(node->left, index * 2 - offset);
        if (node->right)
          q.emplace(node->right, index * 2 + 1 - offset);
      }
    }

    return ans;
  }
};",13,634,1.0,4.0,8.0,5.0,48.76923076923077,8.0,4.130769230769231
597.0,"class Solution {
 public:
  bool checkEqualTree(TreeNode* root) {
    if (root == nullptr)
      return false;

    unordered_set<int> seen;
    const int sum = root->val + dfs(root->left, seen) + dfs(root->right, seen);
    return sum % 2 == 0 && seen.count(sum / 2);
  }

 private:
  int dfs(TreeNode* root, unordered_set<int>& seen) {
    if (root == nullptr)
      return 0;

    const int sum = root->val + dfs(root->left, seen) + dfs(root->right, seen);
    seen.insert(sum);
    return sum;
  }
};",9,504,0.0,-1.0,3.0,2.0,56.0,9.0,3.94
598.0,"class Solution {
 public:
  int strangePrinter(string s) {
    const int n = s.length();
    // dp[i][j] := min # of turns to print s[i..j]
    dp.resize(n, vector<int>(n));
    return strangePrinter(s, 0, n - 1);
  }

 private:
  vector<vector<int>> dp;

  int strangePrinter(const string& s, int i, int j) {
    if (i > j)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    // Print s[i]
    dp[i][j] = strangePrinter(s, i + 1, j) + 1;

    for (int k = i + 1; k <= j; ++k)
      if (s[k] == s[i])
        dp[i][j] = min(dp[i][j], strangePrinter(s, i, k - 1) +
                                     strangePrinter(s, k + 1, j));

    return dp[i][j];
  }
};",12,673,2.0,1.0,3.0,4.0,56.083333333333336,13.0,3.4925000000000006
599.0,"class Solution {
 public:
  bool checkPossibility(vector<int>& nums) {
    bool modified = false;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] < nums[i - 1]) {
        if (modified)
          return false;
        if (i == 1 || nums[i] >= nums[i - 2])
          nums[i - 1] = nums[i];  // Decrease previous value
        else
          nums[i] = nums[i - 1];  // Increase current value
        modified = true;
      }

    return true;
  }
};",9,459,2.0,4.0,3.0,7.0,51.0,5.0,4.57
600.0,"class Solution {
 public:
  int pathSum(vector<int>& nums) {
    int ans = 0;
    vector<vector<int>> tree(4, vector<int>(8, -1));

    for (const int num : nums) {
      const int d = num / 100 - 1;
      const int p = (num % 100) / 10 - 1;
      const int v = num % 10;
      tree[d][p] = v;
    }

    dfs(tree, 0, 0, 0, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& tree, int i, int j, int path, int& ans) {
    if (tree[i][j] == -1)
      return;
    if (i == 3 || max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1) {
      ans += path + tree[i][j];
      return;
    }

    dfs(tree, i + 1, j * 2, path + tree[i][j], ans);
    dfs(tree, i + 1, j * 2 + 1, path + tree[i][j], ans);
  }
};",14,725,0.0,1.0,5.0,3.0,51.785714285714285,21.0,2.8792857142857144
601.0,"class Solution {
 public:
  vector<int> constructArray(int n, int k) {
    vector<int> ans;

    for (int i = 0; i < n - k; ++i)
      ans.push_back(i + 1);

    for (int i = 0; i < k; ++i)
      if (i % 2 == 0)
        ans.push_back(n - i / 2);
      else
        ans.push_back(n - k + (i + 1) / 2);

    return ans;
  }
};",10,324,0.0,4.0,2.0,3.0,32.4,7.0,6.024
602.0,"class Solution {
 public:
  int findKthNumber(int m, int n, int k) {
    int l = 1;
    int r = m * n;

    auto numsNoGreaterThan = [&](int target) {
      int count = 0;
      // For each row i, count # of numbers <= target
      for (int i = 1; i <= m; ++i)
        count += min(target / i, n);
      return count;
    };

    while (l < r) {
      const int mid = (l + r) / 2;
      if (numsNoGreaterThan(mid) >= k)
        r = mid;
      else
        l = mid + 1;
    }

    return l;
  }
};",13,496,1.0,3.0,4.0,4.0,38.15384615384615,12.0,4.986153846153846
603.0,"class Solution {
 public:
  TreeNode* trimBST(TreeNode* root, int L, int R) {
    if (root == nullptr)
      return nullptr;
    if (root->val < L)
      return trimBST(root->right, L, R);
    if (root->val > R)
      return trimBST(root->left, L, R);
    root->left = trimBST(root->left, L, R);
    root->right = trimBST(root->right, L, R);
    return root;
  }
};",7,365,0.0,0.0,2.0,3.0,52.142857142857146,3.0,4.887142857142857
604.0,"class Solution {
 public:
  int maximumSwap(int num) {
    string s = to_string(num);
    vector<int> lastIndex(10, -1);  // {digit: last index}

    for (int i = 0; i < s.length(); ++i)
      lastIndex[s[i] - '0'] = i;

    for (int i = 0; i < s.length(); ++i)
      for (int d = 9; d > s[i] - '0'; --d)
        if (lastIndex[d] > i) {
          swap(s[i], s[lastIndex[d]]);
          return stoi(s);
        }

    return num;
  }
};",13,435,1.0,3.0,4.0,4.0,33.46153846153846,8.0,5.808461538461539
605.0,"class Solution {
 public:
  int findSecondMinimumValue(TreeNode* root) {
    if (root == nullptr)
      return -1;
    return findSecondMinimumValue(root, root->val);
  }

 private:
  int findSecondMinimumValue(TreeNode* root, int mini) {
    if (root == nullptr)
      return -1;
    if (root->val > mini)
      return root->val;

    const int leftMin = findSecondMinimumValue(root->left, mini);
    const int rightMin = findSecondMinimumValue(root->right, mini);

    if (leftMin == -1 || rightMin == -1)
      return max(leftMin, rightMin);
    return min(leftMin, rightMin);
  }
};",9,586,0.0,-1.0,3.0,4.0,65.11111111111111,8.0,3.22
606.0,"class Solution {
 public:
  int flipLights(int n, int m) {
    n = min(n, 3);

    if (m == 0)
      return 1;
    if (m == 1)
      return vector{2, 3, 4}[n - 1];
    if (m == 2)
      return vector{2, 4, 7}[n - 1];

    return pow(2, n);
  }
};",6,246,0.0,0.0,4.0,3.0,41.0,4.0,5.67
607.0,"class Solution {
 public:
  int findNumberOfLIS(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    int maxLength = 0;
    vector<int> length(n, 1);  // length[i] := LIS's length ending w/ nums[i]
    vector<int> count(n, 1);   // count[i] := # of the LIS ending w/ nums[i]

    // Calculate length and count arrays
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j)
        if (nums[j] < nums[i])
          if (length[i] < length[j] + 1) {
            length[i] = length[j] + 1;
            count[i] = count[j];
          } else if (length[i] == length[j] + 1) {
            count[i] += count[j];
          }

    // Get # of LIS
    for (int i = 0; i < n; ++i)
      if (length[i] > maxLength) {
        maxLength = length[i];
        ans = count[i];
      } else if (length[i] == maxLength) {
        ans += count[i];
      }

    return ans;
  }
};",19,888,4.0,10.0,6.0,8.0,46.73684210526316,12.0,3.793684210526316
608.0,"class Solution {
 public:
  int findLengthOfLCIS(vector<int>& nums) {
    int ans = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (r > 0 && nums[r] <= nums[r - 1])
        l = r;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",7,259,0.0,2.0,3.0,2.0,37.0,5.0,5.87
609.0,"struct T {
  int i;
  int j;
  int height;
  T(int i, int j, int height) : i(i), j(j), height(height) {}
};

class Solution {
 public:
  int cutOffTree(vector<vector<int>>& forest) {
    auto compare = [&](const T& a, const T& b) { return a.height > b.height; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < forest.size(); ++i)
      for (int j = 0; j < forest[0].size(); ++j)
        if (forest[i][j] > 1)
          minHeap.emplace(i, j, forest[i][j]);

    int ans = 0;
    int x = 0;
    int y = 0;

    while (!minHeap.empty()) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      // Walk from (x, y) to (i, j).
      const int steps = bfs(forest, x, y, i, j);
      if (steps < 0)
        return -1;
      ans += steps;
      x = i;
      y = j;
    }

    return ans;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  int bfs(const vector<vector<int>>& forest, int si, int sj, int ei, int ej) {
    const int m = forest.size();
    const int n = forest[0].size();
    int steps = 0;
    queue<pair<int, int>> q{{{si, sj}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[si][sj] = true;

    while (!q.empty()) {
      for (int s = q.size(); s > 0; --s) {
        const auto [i, j] = q.front();
        q.pop();
        if (i == ei && j == ej)
          return steps;
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || forest[x][y] == 0)
            continue;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
      ++steps;
    }

    return -1;
  };
};",47,1742,1.0,5.0,14.0,21.0,37.06382978723404,45.0,1.064255319148934
610.0,"class Solution {
 public:
  bool checkValidString(const string& s) {
    int low = 0;   // Lower bound of valid '(' count
    int high = 0;  // Upper bound of valid '(' count

    for (const char c : s) {
      switch (c) {
        case '(':
          ++low;
          ++high;
          break;
        case ')':
          low = max(0, --low);
          --high;
          break;
        case '*':
          low = max(0, --low);
          ++high;
          break;
      }
      if (high < 0)
        return false;
    }

    return low == 0;
  }
};",14,546,2.0,2.0,4.0,2.0,39.0,8.0,5.41
611.0,"class Solution {
 public:
  bool validPalindrome(string s) {
    for (int l = 0, r = s.length() - 1; l < r; ++l, --r)
      if (s[l] != s[r])
        return validPalindrome(s, l + 1, r) ||  //
               validPalindrome(s, l, r - 1);
    return true;
  }

 private:
  bool validPalindrome(const string& s, int l, int r) {
    while (l < r)
      if (s[l++] != s[r--])
        return false;
    return true;
  }
};",7,417,1.0,1.0,3.0,4.0,59.57142857142857,9.0,3.538571428571429
612.0,"class Solution {
 public:
  string nextClosestTime(string time) {
    const set<char> digitsSet{time[0], time[1], time[3], time[4]};
    string ans = time;

    ans[4] = nextClosest(digitsSet, ans[4], '9');
    if (time[4] < ans[4])
      return ans;

    ans[3] = nextClosest(digitsSet, ans[3], '5');
    if (time[3] < ans[3])
      return ans;

    ans[1] = nextClosest(digitsSet, ans[1], ans[0] == '2' ? '3' : '9');
    if (time[1] < ans[1])
      return ans;

    ans[0] = nextClosest(digitsSet, ans[0], '2');
    return ans;
  }

 private:
  char nextClosest(const set<char>& digitsSet, char digit, char limit) {
    auto it = digitsSet.upper_bound(digit);
    return it == end(digitsSet) || *it > limit ? *begin(digitsSet) : *it;
  }
};",13,742,0.0,-1.0,4.0,3.0,57.07692307692308,11.0,3.5830769230769226
613.0,"class Solution {
 public:
  int kEmptySlots(vector<int>& bulbs, int k) {
    const int n = bulbs.size();
    int ans = INT_MAX;
    // day[i] := the day when bulbs[i] is turned on
    vector<int> day(n);

    for (int i = 0; i < n; ++i)
      day[bulbs[i] - 1] = i + 1;

    // Find a subarray of day[l..r], where its length is k + 2
    // For all that l < i < r, day[i] > max(day[l], day[r])
    int l = 0;
    int r = l + k + 1;
    for (int i = 1; r < n; ++i)
      if (i == r) {
        ans = min(ans, max(day[l], day[r]));
        l = i;
        r = i + k + 1;
      } else if (day[i] < max(day[l], day[r])) {
        l = i;
        r = i + k + 1;
      }

    return ans == INT_MAX ? -1 : ans;
  }
};",17,707,3.0,5.0,4.0,5.0,41.588235294117645,12.0,4.637058823529412
614.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  bool unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return false;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    return true;
  }

 private:
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> findRedundantConnection(vector<vector<int>>& edges) {
    UnionFind uf(edges.size() + 1);

    for (const vector<int>& edge : edges)
      if (!uf.unionByRank(edge[0], edge[1]))
        return edge;

    throw;
  }
};",17,797,0.0,3.0,9.0,5.0,46.88235294117647,18.0,3.260588235294118
615.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  bool unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return false;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    return true;
  }

 private:
  vector<int> id;
  vector<int> rank;
  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
    vector<int> ids(edges.size() + 1);
    int nodeWithTwoParents = 0;

    for (const vector<int>& edge : edges) {
      const int v = edge[1];
      if (++ids[v] == 2) {
        nodeWithTwoParents = v;
        break;
      }
    }

    // If there is no edge with two ids
    // We don't have to skip any edge
    if (nodeWithTwoParents == 0)
      return findRedundantDirectedConnection(edges, -1);

    for (int i = edges.size() - 1; i >= 0; --i)
      if (edges[i][1] == nodeWithTwoParents)
        // Try to delete edges[i]
        if (findRedundantDirectedConnection(edges, i).empty())
          return edges[i];

    throw;
  }

  vector<int> findRedundantDirectedConnection(const vector<vector<int>>& edges,
                                              int skippedEdgeIndex) {
    UnionFind uf(edges.size() + 1);

    for (int i = 0; i < edges.size(); ++i) {
      if (i == skippedEdgeIndex)
        continue;
      if (!uf.unionByRank(edges[i][0], edges[i][1]))
        return edges[i];
    }

    return {};
  }
};",30,1667,3.0,5.0,14.0,13.0,55.56666666666667,28.0,1.1789999999999985
616.0,"class Solution {
 public:
  int repeatedStringMatch(string a, string b) {
    const int n = ceil((double)b.length() / a.length());
    string s;

    for (int i = 0; i < n; ++i)
      s += a;

    if (s.find(b) != string::npos)
      return n;
    if ((s + a).find(b) != string::npos)
      return n + 1;
    return -1;
  }
};",9,326,0.0,1.0,2.0,3.0,36.22222222222222,11.0,5.460000000000001
617.0,"class Solution {
 public:
  int longestUnivaluePath(TreeNode* root) {
    int ans = 0;
    longestUnivaluePathDownFrom(root, ans);
    return ans;
  }

 private:
  int longestUnivaluePathDownFrom(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = longestUnivaluePathDownFrom(root->left, ans);
    const int r = longestUnivaluePathDownFrom(root->right, ans);
    const int arrowLeft =
        root->left && root->left->val == root->val ? l + 1 : 0;
    const int arrowRight =
        root->right && root->right->val == root->val ? r + 1 : 0;
    ans = max(ans, arrowLeft + arrowRight);
    return max(arrowLeft, arrowRight);
  }
};",11,667,0.0,-1.0,3.0,1.0,60.63636363636363,13.0,3.122727272727273
618.0,"class Solution {
 public:
  double knightProbability(int n, int K, int r, int c) {
    constexpr double kProb = 0.125;
    const vector<pair<int, int>> dirs{{-2, 1}, {-1, 2}, {1, 2},   {2, 1},
                                      {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};

    // dp[i][j] := probability to stand on (i, j)
    vector<vector<double>> dp(n, vector<double>(n));
    dp[r][c] = 1.0;

    for (int k = 0; k < K; ++k) {
      vector<vector<double>> newDp(n, vector<double>(n));
      for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
          if (dp[i][j] > 0.0) {
            for (const auto& [dx, dy] : dirs) {
              const int x = i + dx;
              const int y = j + dy;
              if (x < 0 || x >= n || y < 0 || y >= n)
                continue;
              newDp[x][y] += dp[i][j] * kProb;
            }
          }
      dp = move(newDp);
    }

    return accumulate(begin(dp), end(dp), 0.0,
                      [](double s, const vector<double>& row) {
      return s + accumulate(begin(row), end(row), 0.0);
    });
  }
};",19,1074,1.0,4.0,15.0,6.0,56.526315789473685,25.0,1.312631578947368
619.0,"class Solution {
 public:
  vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
    const int n = nums.size() - k + 1;
    vector<int> sums(n);  // sums[i] := sum of nums[i..i + k)
    vector<int> l(n);     // l[i] := index in [0..i] having max sums[i]
    vector<int> r(n);     // r[i] := index in [i..n) having max sums[i]

    int sum = 0;
    for (int i = 0; i < nums.size(); ++i) {
      sum += nums[i];
      if (i >= k)
        sum -= nums[i - k];
      if (i >= k - 1)
        sums[i - k + 1] = sum;
    }

    int maxIndex = 0;
    for (int i = 0; i < n; ++i) {
      if (sums[i] > sums[maxIndex])
        maxIndex = i;
      l[i] = maxIndex;
    }

    maxIndex = n - 1;
    for (int i = n - 1; i >= 0; --i) {
      if (sums[i] >= sums[maxIndex])
        maxIndex = i;
      r[i] = maxIndex;
    }

    vector<int> ans{-1, -1, -1};

    for (int i = k; i < n - k; ++i)
      if (ans[0] == -1 || sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <
                              sums[l[i - k]] + sums[i] + sums[r[i + k]]) {
        ans[0] = l[i - k];
        ans[1] = i;
        ans[2] = r[i + k];
      }

    return ans;
  }
};",28,1141,3.0,9.0,7.0,9.0,40.75,16.0,3.8925
620.0,"class Solution {
 public:
  int getImportance(vector<Employee*> employees, int id) {
    unordered_map<int, Employee*> idToEmployee;

    for (Employee* employee : employees)
      idToEmployee[employee->id] = employee;

    return dfs(id, idToEmployee);
  }

 private:
  int dfs(int id, const unordered_map<int, Employee*>& idToEmployee) {
    int values = 0;

    for (const int subId : idToEmployee.at(id)->subordinates)
      values += dfs(subId, idToEmployee);

    return idToEmployee.at(id)->importance + values;
  }
};",7,526,0.0,1.0,3.0,2.0,75.14285714285714,11.0,1.8971428571428568
621.0,"class Solution {
 public:
  int minStickers(vector<string>& stickers, string target) {
    const int n = target.size();
    const int maxMask = 1 << n;
    // dp[i] := min # of stickers to spell out i, where i is the bit mask of
    // target.
    vector<int> dp(maxMask, INT_MAX);
    dp[0] = 0;

    for (int mask = 0; mask < maxMask; ++mask) {
      if (dp[mask] == INT_MAX)
        continue;
      // Try to expand from `mask` by using each sticker.
      for (const string& sticker : stickers) {
        int superMask = mask;
        for (const char c : sticker)
          for (int i = 0; i < n; ++i)
            // Try to apply it on a missing char.
            if (c == target[i] && !(superMask >> i & 1)) {
              superMask |= 1 << i;
              break;
            }
        dp[superMask] = min(dp[superMask], dp[mask] + 1);
      }
    }

    return dp.back() == INT_MAX ? -1 : dp.back();
  }
};",15,914,4.0,4.0,5.0,6.0,60.93333333333333,17.0,2.436000000000001
622.0,"class Solution {
 public:
  vector<string> topKFrequent(vector<string>& words, int k) {
    const int n = words.size();
    vector<string> ans;
    vector<vector<string>> bucket(n + 1);
    unordered_map<string, int> count;

    for (const string& word : words)
      ++count[word];

    for (const auto& [word, freq] : count)
      bucket[freq].push_back(word);

    for (int freq = n; freq > 0; --freq) {
      sort(begin(bucket[freq]), end(bucket[freq]));
      for (const string& word : bucket[freq]) {
        ans.push_back(word);
        if (ans.size() == k)
          return ans;
      }
    }

    throw;
  }
};",13,619,0.0,4.0,4.0,5.0,47.61538461538461,16.0,3.634615384615385
623.0,"class Solution {
 public:
  int numDistinctIslands(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    set<vector<pair<int, int>>> islands;  // All different islands
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        vector<pair<int, int>> island;
        dfs(grid, i, j, i, j, seen, island);
        if (!island.empty())
          islands.insert(island);
      }

    return islands.size();
  }

 private:
  void dfs(const vector<vector<int>>& grid, int i, int j, int i0, int j0,
           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 0 || seen[i][j])
      return;

    seen[i][j] = true;
    island.emplace_back(i - i0, j - j0);

    dfs(grid, i + 1, j, i0, j0, seen, island);
    dfs(grid, i - 1, j, i0, j0, seen, island);
    dfs(grid, i, j + 1, i0, j0, seen, island);
    dfs(grid, i, j - 1, i0, j0, seen, island);
  }
};",21,1071,1.0,3.0,4.0,6.0,51.0,25.0,2.53
624.0,"class Solution {
 public:
  int maxAreaOfIsland(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        ans = max(ans, dfs(grid, i, j));

    return ans;
  }

 private:
  int dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;
    if (grid[i][j] != 1)
      return 0;

    grid[i][j] = 2;

    return 1 +                                          //
           dfs(grid, i + 1, j) + dfs(grid, i - 1, j) +  //
           dfs(grid, i, j + 1) + dfs(grid, i, j - 1);
  }
};",12,634,2.0,1.0,3.0,4.0,52.833333333333336,10.0,4.085000000000001
625.0,"class Solution {
 public:
  int countBinarySubstrings(string s) {
    int ans = 0;
    int prevEquals = 0;
    int currEquals = 1;

    for (int i = 0; i + 1 < s.length(); ++i)
      if (s[i] == s[i + 1])
        ++currEquals;
      else {
        ans += min(prevEquals, currEquals);
        prevEquals = currEquals;
        currEquals = 1;
      }

    return ans + min(prevEquals, currEquals);
  }
};",11,402,0.0,3.0,3.0,2.0,36.54545454545455,7.0,5.650909090909091
626.0,"class Solution {
 public:
  int findShortestSubArray(vector<int>& nums) {
    int ans = 0;
    int degree = 0;
    unordered_map<int, int> debut;
    unordered_map<int, int> count;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i];
      if (!debut.count(num))
        debut[num] = i;
      if (++count[num] > degree) {
        degree = count[num];
        ans = i - debut[num] + 1;
      } else if (count[num] == degree) {
        ans = min(ans, i - debut[num] + 1);
      }
    }

    return ans;
  }
};",13,530,0.0,5.0,5.0,4.0,40.76923076923077,12.0,4.530769230769232
627.0,"class Solution {
 public:
  bool canPartitionKSubsets(vector<int>& nums, int k) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    if (sum % k != 0)
      return false;

    const int t = sum / k;  // Each subset's target sum
    return dfs(nums, 0, k, t, t, vector<bool>(nums.size()));
  }

 private:
  bool dfs(const vector<int>& nums, int s, int k, int target,
           const int subsetTargetSum, vector<bool>&& seen) {
    if (k == 0)
      return true;
    if (target < 0)
      return false;
    if (target == 0)
      return dfs(nums, 0, k - 1, subsetTargetSum, subsetTargetSum, move(seen));

    for (int i = s; i < nums.size(); ++i) {
      if (seen[i])
        continue;
      seen[i] = true;
      if (dfs(nums, i + 1, k, target - nums[i], subsetTargetSum, move(seen)))
        return true;
      seen[i] = false;
    }

    return false;
  }
};",15,872,1.0,0.0,4.0,7.0,58.13333333333333,19.0,2.668
628.0,"class Solution {
 public:
  vector<int> fallingSquares(vector<vector<int>>& positions) {
    vector<int> ans;
    map<pair<int, int>, int> xsToHeight;  // {{xStart, xEnd}, height}
    int maxHeight = INT_MIN;

    for (const vector<int>& p : positions) {
      const int left = p[0];
      const int sideLength = p[1];
      const int right = left + sideLength;
      // First range intersect with [left, right)
      auto it = xsToHeight.upper_bound({left, right});
      if (it != begin(xsToHeight) && (--it)->first.second <= left)
        ++it;
      int maxHeightInRange = 0;
      vector<tuple<int, int, int>> ranges;
      while (it != end(xsToHeight) && it->first.first < right) {
        const int l = it->first.first;
        const int r = it->first.second;
        const int h = it->second;
        if (l < left)
          ranges.emplace_back(l, left, h);
        if (right < r)
          ranges.emplace_back(right, r, h);
        maxHeightInRange = max(maxHeightInRange, h);
        it = xsToHeight.erase(it);
      }
      const int newHeight = maxHeightInRange + sideLength;
      xsToHeight[{left, right}] = newHeight;
      for (const auto& [l, r, h] : ranges)
        xsToHeight[{l, r}] = h;
      maxHeight = max(maxHeight, newHeight);
      ans.push_back(maxHeight);
    }

    return ans;
  }
};",24,1314,2.0,6.0,9.0,6.0,54.75,29.0,1.352500000000001
629.0,"class Solution {
 public:
  TreeNode* searchBST(TreeNode* root, int val) {
    if (root == nullptr)
      return nullptr;
    if (root->val == val)
      return root;
    if (root->val > val)
      return searchBST(root->left, val);
    return searchBST(root->right, val);
  }
};",5,279,0.0,0.0,2.0,3.0,55.8,2.0,4.658
630.0,"class Solution {
 public:
  TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (root == nullptr)
      return new TreeNode(val);
    if (root->val > val)
      root->left = insertIntoBST(root->left, val);
    else
      root->right = insertIntoBST(root->right, val);
    return root;
  }
};",5,297,0.0,2.0,2.0,2.0,59.4,2.0,4.214
631.0,"/**
 * // This is the ArrayReader's API interface.
 * // You should not implement it, or speculate about its implementation
 * class ArrayReader {
 *  public:
 *   int get(int index);
 * };
 */

class Solution {
 public:
  int search(const ArrayReader& reader, int target) {
    int l = 0;
    int r = 10'000;

    while (l < r) {
      const int m = (l + r) / 2;
      if (reader.get(m) >= target)
        r = m;
      else
        l = m + 1;
    }

    return reader.get(l) == target ? l : -1;
  }
};",9,502,1.0,3.0,4.0,2.0,55.77777777777778,11.0,3.500000000000001
632.0,"class KthLargest {
 public:
  KthLargest(int k, vector<int>& nums) : k(k) {
    for (const int num : nums)
      heapify(num);
  }

  int add(int val) {
    heapify(val);
    return minHeap.top();
  }

 private:
  const int k;
  priority_queue<int, vector<int>, greater<>> minHeap;

  void heapify(int val) {
    minHeap.push(val);
    if (minHeap.size() > k)
      minHeap.pop();
  }
};",8,387,0.0,2.0,4.0,5.0,48.375,13.0,3.98625
633.0,"class MyHashSet {
 public:
  /** Initialize your data structure here. */
  MyHashSet() : set(1000001) {}

  void add(int key) {
    set[key] = true;
  }

  void remove(int key) {
    set[key] = false;
  }

  /** Returns true if this set contains the specified element */
  bool contains(int key) {
    return set[key];
  }

 private:
  vector<bool> set;
};",5,356,2.0,1.0,5.0,2.0,71.2,8.0,2.5120000000000005
634.0,"class MyHashMap {
 public:
  /** Initialize your data structure here. */
  MyHashMap() : lists(kSize) {}

  /** value will always be non-negative. */
  void put(int key, int value) {
    auto& pairs = lists[key % kSize];
    for (auto& [k, v] : pairs)
      if (k == key) {
        v = value;
        return;
      }
    pairs.emplace_back(key, value);
  }

  /** Returns the value to which the specified key is mapped, or -1 if this map
   * contains no mapping for the key */
  int get(int key) {
    const list<pair<int, int>>& pairs = lists[key % kSize];
    for (const auto& [k, v] : pairs)
      if (k == key)
        return v;
    return -1;
  }

  /** Removes the mapping of the specified value key if this map contains a
   * mapping for the key */
  void remove(int key) {
    auto& pairs = lists[key % kSize];
    for (auto it = begin(pairs); it != end(pairs); ++it)
      if (it->first == key) {
        pairs.erase(it);
        return;
      }
  }

 private:
  static constexpr int kSize = 10000;
  vector<list<pair<int, int>>> lists;  // Each slot store (key, value) list
};",15,1088,5.0,7.0,7.0,12.0,72.53333333333333,15.0,1.3320000000000007
635.0,"class MyLinkedList {
  struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
  };

 public:
  int get(int index) {
    if (index < 0 || index >= length)
      return -1;
    ListNode* curr = dummy.next;
    for (int i = 0; i < index; ++i)
      curr = curr->next;
    return curr->val;
  }

  void addAtHead(int val) {
    ListNode* head = dummy.next;
    ListNode* node = new ListNode(val);
    node->next = head;
    dummy.next = node;
    ++length;
  }

  void addAtTail(int val) {
    ListNode* curr = &dummy;
    while (curr->next)
      curr = curr->next;
    curr->next = new ListNode(val);
    ++length;
  }

  void addAtIndex(int index, int val) {
    if (index > length)
      return;
    ListNode* curr = &dummy;
    for (int i = 0; i < index; ++i)
      curr = curr->next;
    ListNode* cache = curr->next;
    ListNode* node = new ListNode(val);
    node->next = cache;
    curr->next = node;
    ++length;
  }

  void deleteAtIndex(int index) {
    if (index < 0 || index >= length)
      return;
    ListNode* curr = &dummy;
    for (int i = 0; i < index; ++i)
      curr = curr->next;
    ListNode* cache = curr->next;
    curr->next = cache->next;
    --length;
    delete cache;
  }

 private:
  int length = 0;
  ListNode dummy = ListNode(0);
};",40,1308,0.0,4.0,8.0,7.0,32.7,19.0,4.436999999999999
636.0,"class Solution {
 public:
  Node* insert(Node* head, int insertVal) {
    if (head == nullptr) {
      Node* newNode = new Node(insertVal);
      newNode->next = newNode;
      return newNode;
    }

    Node* prev = head;
    Node* curr = head->next;

    while (curr != head) {
      // Case 1: min <= insertVal <= max
      // Case 2: insertVal >= max or insertVal <= min
      if ((prev->val <= insertVal && insertVal <= curr->val) ||
          (prev->val > curr->val &&  // Prev is max, curr is min
           (insertVal >= prev->val || insertVal <= curr->val))) {
        // Insert the node between prev and curr
        prev->next = new Node(insertVal, curr);
        return head;
      }
      prev = prev->next;
      curr = curr->next;
    }

    // All vals in the list are identical
    prev->next = new Node(insertVal, curr);
    return head;
  }
};",12,862,5.0,1.0,5.0,3.0,71.83333333333333,2.0,3.1750000000000016
637.0,"class Solution {
 public:
  string toLowerCase(string str) {
    const int diff = 'A' - 'a';

    for (char& c : str)
      if (c >= 'A' && c <= 'Z')
        c -= diff;

    return str;
  }
};",4,192,0.0,2.0,2.0,4.0,48.0,6.0,4.84
638.0,"class Solution {
 public:
  Solution(int n, vector<int>& blacklist) : validRange(n - blacklist.size()) {
    for (const int b : blacklist)
      map[b] = -1;

    int maxAvailable = n - 1;

    for (const int b : blacklist)
      if (b < validRange) {
        while (map.count(maxAvailable))  // Find the slot that haven't been used
          --maxAvailable;
        map[b] = maxAvailable--;
      }
  }

  int pick() {
    const int num = rand() % validRange;
    const auto it = map.find(num);
    return it == cend(map) ? num : it->second;
  }

 private:
  const int validRange;
  unordered_map<int, int> map;
};",10,615,1.0,4.0,4.0,4.0,61.5,16.0,2.425
639.0,"class Solution {
 public:
  int numDistinctIslands2(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    set<vector<pair<int, int>>> islands;  // All different shape islands
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        vector<pair<int, int>> island;
        dfs(grid, i, j, seen, island);
        if (!island.empty())
          islands.insert(normalize(island));
      }

    return islands.size();
  }

 private:
  void dfs(const vector<vector<int>>& grid, int i, int j,
           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 0 || seen[i][j])
      return;

    seen[i][j] = true;
    island.emplace_back(i, j);

    dfs(grid, i + 1, j, seen, island);
    dfs(grid, i - 1, j, seen, island);
    dfs(grid, i, j + 1, seen, island);
    dfs(grid, i, j - 1, seen, island);
  }

  vector<pair<int, int>> normalize(const vector<pair<int, int>>& island) {
    // points[i] := 8 different rotations/reflections of island
    vector<vector<pair<int, int>>> points(8);

    for (const auto& [i, j] : island) {
      points[0].emplace_back(i, j);
      points[1].emplace_back(i, -j);
      points[2].emplace_back(-i, j);
      points[3].emplace_back(-i, -j);
      points[4].emplace_back(j, i);
      points[5].emplace_back(j, -i);
      points[6].emplace_back(-j, i);
      points[7].emplace_back(-j, -i);
    }

    for (vector<pair<int, int>>& p : points)
      sort(begin(p), end(p));

    // Normalize each p by minus p[1:] w/ p[0]
    for (vector<pair<int, int>>& p : points) {
      for (int i = 1; i < island.size(); ++i)
        p[i] = {p[i].first - p[0].first, p[i].second - p[0].second};
      p[0] = {0, 0};
    }

    sort(begin(points), end(points));
    return points[0];
  }
};",37,1932,3.0,6.0,9.0,11.0,52.21621621621622,36.0,0.9205405405405412
640.0,"class Solution {
 public:
  int minimumDeleteSum(string s1, string s2) {
    const int m = s1.length();
    const int n = s2.length();
    // dp[i][j] := min cost to make s1[0..i) and s2[0..j) equal
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // Delete s1[i - 1]
    for (int i = 1; i <= m; ++i)
      dp[i][0] = dp[i - 1][0] + s1[i - 1];

    // Delete s2[j - 1]
    for (int j = 1; j <= n; ++j)
      dp[0][j] = dp[0][j - 1] + s2[j - 1];

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s1[i - 1] == s2[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);

    return dp[m][n];
  }
};",17,719,3.0,6.0,2.0,5.0,42.294117647058826,14.0,4.433529411764705
641.0,"class Solution {
 public:
  int numSubarrayProductLessThanK(vector<int>& nums, int k) {
    if (k <= 1)
      return 0;

    int ans = 0;
    int prod = 1;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      prod *= nums[r];
      while (prod >= k)
        prod /= nums[l++];
      ans += r - l + 1;
    }

    return ans;
  }
};",10,335,0.0,2.0,3.0,3.0,33.5,7.0,5.985
642.0,"class Solution {
 public:
  int maxProfit(vector<int>& prices, int fee) {
    int sell = 0;
    int hold = INT_MIN;

    for (const int price : prices) {
      sell = max(sell, hold + price);
      hold = max(hold, sell - price - fee);
    }

    return sell;
  }
};",6,266,0.0,1.0,3.0,1.0,44.333333333333336,8.0,4.970000000000001
643.0,"class Solution {
 public:
  bool isOneBitCharacter(vector<int>& bits) {
    const int n = bits.size();

    int i = 0;
    while (i < n - 1)
      if (bits[i] == 0)
        i += 1;
      else
        i += 2;

    return i == n - 1;
  }
};",6,238,0.0,3.0,2.0,2.0,39.66666666666666,6.0,5.53
644.0,"class Solution {
 public:
  int findLength(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    int ans = 0;
    // dp[i][j] := max length of nums1[i:] and nums2[j:]
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j)
        if (nums1[i] == nums2[j]) {
          dp[i][j] = dp[i + 1][j + 1] + 1;
          ans = max(ans, dp[i][j]);
        }

    return ans;
  }
};",12,503,1.0,3.0,3.0,3.0,41.91666666666666,13.0,4.607500000000001
645.0,"class Solution {
 public:
  int smallestDistancePair(vector<int>& nums, int k) {
    sort(begin(nums), end(nums));

    int l = 0;
    int r = nums.back() - nums.front();

    while (l < r) {
      const int m = (l + r) / 2;
      if (pairDistancesNoGreaterThan(nums, m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int pairDistancesNoGreaterThan(const vector<int>& nums, int m) {
    int count = 0;
    int j = 1;
    // For each index i, find the first index j s.t. nums[j] > nums[i] + m,
    // So pairDistancesNoGreaterThan for index i will be j - i - 1
    for (int i = 0; i < nums.size(); ++i) {
      while (j < nums.size() && nums[j] <= nums[i] + m)
        ++j;
      count += j - i - 1;
    }
    return count;
  }
};",15,771,2.0,5.0,5.0,6.0,51.4,15.0,3.354000000000001
646.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string longestWord(vector<string>& words) {
    for (const string& word : words)
      insert(word);
    return longestWordFrom(root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  string longestWordFrom(shared_ptr<TrieNode> node) {
    string ans = node->word ? *node->word : """";

    for (shared_ptr<TrieNode> child : node->children)
      if (child && child->word) {
        string childWord = longestWordFrom(child);
        if (childWord.length() > ans.length())
          ans = childWord;
      }

    return ans;
  }
};",16,1002,0.0,5.0,8.0,6.0,62.625,18.0,1.7837499999999995
647.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), sz(n, 1) {
    iota(begin(id), end(id), 0);
  }

  void unionBySize(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> sz;
};

class Solution {
 public:
  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
    vector<vector<string>> ans;
    unordered_map<string, int> emailToIndex;        // {email: index}
    unordered_map<int, set<string>> indexToEmails;  // {index: {emails}}
    UnionFind uf(accounts.size());

    for (int i = 0; i < accounts.size(); ++i) {
      const string name = accounts[i][0];
      for (int j = 1; j < accounts[i].size(); ++j) {
        const string email = accounts[i][j];
        const auto it = emailToIndex.find(email);
        if (it == emailToIndex.end()) {
          // Only record if it's the first time we see thie email
          emailToIndex[email] = i;
        } else {
          // Otherwise, union i w/ emailToIndex[index]
          uf.unionBySize(i, it->second);
        }
      }
    }

    for (const auto& [email, index] : emailToIndex)
      indexToEmails[uf.find(index)].insert(email);

    for (const auto& [index, emails] : indexToEmails) {
      const string name = accounts[index][0];
      vector<string> row{name};
      row.insert(end(row), begin(emails), end(emails));
      ans.push_back(row);
    }

    return ans;
  }
};",32,1652,4.0,8.0,17.0,8.0,51.625,33.0,0.7137499999999992
648.0,"class Solution {
 public:
  vector<string> removeComments(vector<string>& source) {
    vector<string> ans;
    bool commenting = false;
    string modified;

    for (const string& line : source) {
      for (int i = 0; i < line.length();) {
        if (i + 1 == line.length()) {
          if (!commenting)
            modified += line[i];
          ++i;
          break;
        }
        const string& twoChars = line.substr(i, 2);
        if (twoChars == ""/*"" && !commenting) {
          commenting = true;
          i += 2;
        } else if (twoChars == ""*/"" && commenting) {
          commenting = false;
          i += 2;
        } else if (twoChars == ""//"") {
          if (!commenting)
            break;
          else
            i += 2;
        } else {
          if (!commenting)
            modified += line[i];
          ++i;
        }
      }
      if (modified.length() > 0 && !commenting) {
        ans.push_back(modified);
        modified = """";
      }
    }

    return ans;
  }
};",21,1003,2.0,12.0,10.0,16.0,47.76190476190476,11.0,3.361428571428573
649.0,"class Solution {
 public:
  vector<vector<int>> candyCrush(vector<vector<int>>& board) {
    const int m = board.size();
    const int n = board[0].size();
    bool haveCrushes = true;

    while (haveCrushes) {
      haveCrushes = false;

      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j) {
          const int val = abs(board[i][j]);
          if (val == 0)
            continue;
          // Crush vertical candies
          if (j + 2 < n && abs(board[i][j + 1]) == val &&
              abs(board[i][j + 2]) == val) {
            haveCrushes = true;
            for (int k = j; k < j + 3; ++k)
              board[i][k] = -val;
          }
          // Crush horizontal candies
          if (i + 2 < m && abs(board[i + 1][j]) == val &&
              abs(board[i + 2][j]) == val) {
            haveCrushes = true;
            for (int k = i; k < i + 3; ++k)
              board[k][j] = -val;
          }
        }

      if (haveCrushes) {
        // For each column, drop candies
        for (int j = 0; j < n; ++j) {
          int nextIndex = m - 1;
          for (int i = m - 1; i >= 0; --i)
            if (board[i][j] > 0)
              board[nextIndex--][j] = board[i][j];
          // Set board[0..nextIndex][j] to 0s
          for (int i = nextIndex; i >= 0; --i)
            board[i][j] = 0;
        }
      }
    }

    return board;
  }
};",29,1372,4.0,12.0,8.0,14.0,47.310344827586206,18.0,2.902068965517242
650.0,"class Solution {
 public:
  int pivotIndex(vector<int>& nums) {
    const int sum = accumulate(begin(nums), end(nums), 0);
    int prefix = 0;

    for (int i = 0; i < nums.size(); ++i) {
      if (prefix == sum - prefix - nums[i])
        return i;
      prefix += nums[i];
    }

    return -1;
  }
};",8,303,0.0,1.0,3.0,2.0,37.875,7.0,5.651250000000001
651.0,"class Solution {
 public:
  vector<ListNode*> splitListToParts(ListNode* root, int k) {
    vector<ListNode*> ans(k);
    const int length = getLength(root);
    const int subLength = length / k;
    int remainder = length % k;

    ListNode* prev = nullptr;
    ListNode* head = root;

    for (int i = 0; i < k; ++i, --remainder) {
      ans[i] = head;
      for (int j = 0; j < subLength + (remainder > 0); ++j) {
        prev = head;
        head = head->next;
      }
      if (prev != nullptr)
        prev->next = nullptr;
    }

    return ans;
  }

 private:
  int getLength(ListNode* root) {
    int length = 0;
    for (ListNode* curr = root; curr; curr = curr->next)
      ++length;
    return length;
  }
};",21,720,0.0,3.0,5.0,4.0,34.285714285714285,11.0,5.334285714285715
652.0,"class Solution {
 public:
  string countOfAtoms(string formula) {
    string ans;
    int i = 0;

    for (const auto& [elem, freq] : parse(formula, i)) {
      ans += elem;
      if (freq > 1)
        ans += to_string(freq);
    }

    return ans;
  }

 private:
  map<string, int> parse(const string& s, int& i) {
    map<string, int> count;

    while (i < s.length())
      if (s[i] == '(') {
        for (const auto& [elem, freq] : parse(s, ++i))
          count[elem] += freq;
      } else if (s[i] == ')') {
        const int num = getNum(s, ++i);
        for (auto&& [_, freq] : count)
          freq *= num;
        return count;  // Returns back to previous scope
      } else {         // s[i] must be uppercased
        const string& elem = getElem(s, i);
        const int num = getNum(s, i);
        count[elem] += num;
      }

    return count;
  }

  string getElem(const string& s, int& i) {
    const int elemStart = i++;  // s[elemStart] is uppercased
    while (i < s.length() && islower(s[i]))
      ++i;
    return s.substr(elemStart, i - elemStart);
  }

  int getNum(const string& s, int& i) {
    const int numStart = i;
    while (i < s.length() && isdigit(s[i]))
      ++i;
    const string& numString = s.substr(numStart, i - numStart);
    return numString.empty() ? 1 : stoi(numString);
  }
};",22,1324,3.0,7.0,9.0,11.0,60.18181818181818,34.0,0.3436363636363637
653.0,"class Solution {
 public:
  string minWindow(string s1, string s2) {
    const int m = s2.length();
    const int n = s1.length();
    // dp[i][j] := start index (1-indexed) of the min window of s2[0..i] and
    // s1[0..j).
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // Fill in placeholder values
    for (int j = 0; j <= n; ++j)
      dp[0][j] = j + 1;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (s2[i - 1] == s1[j - 1])
          dp[i][j] = dp[i - 1][j - 1];
        else
          dp[i][j] = dp[i][j - 1];

    int bestLeft = 0;
    int minLength = INT_MAX;

    for (int j = 1; j <= n; ++j)
      if (dp[m][j] > 0 && j - dp[m][j] + 1 < minLength) {
        bestLeft = dp[m][j] - 1;
        minLength = j - dp[m][j] + 1;
      }

    return minLength == INT_MAX ? """" : s1.substr(bestLeft, minLength);
  }
};",20,865,3.0,7.0,3.0,6.0,43.25,16.0,4.027500000000001
654.0,"class Solution {
 public:
  vector<int> selfDividingNumbers(int left, int right) {
    vector<int> ans;

    for (int num = left; num <= right; ++num)
      if (selfDividingNumbers(num))
        ans.push_back(num);

    return ans;
  }

 private:
  bool selfDividingNumbers(int num) {
    for (int n = num; n > 0; n /= 10)
      if (n % 10 == 0 || num % (n % 10) != 0)
        return false;
    return true;
  }
};",10,414,0.0,2.0,3.0,4.0,41.4,9.0,5.074000000000001
655.0,"class MyCalendar {
 public:
  bool book(int start, int end) {
    for (const auto& [s, e] : timeline)
      if (max(start, s) < min(end, e))
        return false;
    timeline.emplace_back(start, end);
    return true;
  }

 private:
  vector<pair<int, int>> timeline;
};",5,271,0.0,1.0,2.0,2.0,54.2,7.0,4.242
656.0,"class Solution {
 public:
  int countPalindromicSubsequences(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();

    // dp[i][j] := # of different non-empty palindromic subseqs in s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j]) {
          int lo = i + 1;
          int hi = j - 1;
          while (lo <= hi && s[lo] != s[i])
            ++lo;
          while (lo <= hi && s[hi] != s[i])
            --hi;
          if (lo > hi)
            dp[i][j] = dp[i + 1][j - 1] * 2 + 2;
          else if (lo == hi)
            dp[i][j] = dp[i + 1][j - 1] * 2 + 1;
          else
            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1];
        } else {
          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];
        }
        dp[i][j] = (dp[i][j] + kMod) % kMod;
      }

    return dp[0][n - 1];
  }
};",22,1037,1.0,11.0,5.0,9.0,47.13636363636363,15.0,3.337727272727273
657.0,"class MyCalendarThree {
 public:
  int book(int start, int end) {
    ++timeline[start];
    --timeline[end];

    int ans = 0;
    int activeEvents = 0;

    for (const auto& [_, count] : timeline) {
      activeEvents += count;
      ans = max(ans, activeEvents);
    }

    return ans;
  }

 private:
  map<int, int> timeline;
};",9,332,0.0,1.0,3.0,1.0,36.888888888888886,9.0,5.540000000000001
658.0,"class Solution {
 public:
  vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc,
                                int newColor) {
    dfs(image, sr, sc,
        vector<vector<bool>>(image.size(), vector<bool>(image[0].size())),
        image[sr][sc], newColor);
    return image;
  }

 private:
  void dfs(vector<vector<int>>& image, int i, int j,
           vector<vector<bool>>&& seen, int startColor, int newColor) {
    if (i < 0 || i == image.size() || j < 0 || j == image[0].size())
      return;
    if (image[i][j] != startColor || seen[i][j])
      return;

    image[i][j] = newColor;
    seen[i][j] = true;

    dfs(image, i + 1, j, move(seen), startColor, newColor);
    dfs(image, i - 1, j, move(seen), startColor, newColor);
    dfs(image, i, j + 1, move(seen), startColor, newColor);
    dfs(image, i, j - 1, move(seen), startColor, newColor);
  }
};",11,885,0.0,0.0,3.0,2.0,80.45454545454545,15.0,1.07909090909091
659.0,"class Solution {
 public:
  bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2,
                           vector<vector<string>>& similarPairs) {
    if (sentence1.size() != sentence2.size())
      return false;

    // map[key] := all similar words of key
    unordered_map<string, unordered_set<string>> map;

    for (const vector<string>& pair : similarPairs) {
      map[pair[1]].insert(pair[0]);
      map[pair[0]].insert(pair[1]);
    }

    for (int i = 0; i < sentence1.size(); ++i) {
      if (sentence1[i] == sentence2[i])
        continue;
      if (!map.count(sentence1[i]))
        return false;
      if (!map[sentence1[i]].count(sentence2[i]))
        return false;
    }

    return true;
  }
};",11,740,1.0,2.0,4.0,6.0,67.27272727272727,10.0,2.625454545454546
660.0,"class Solution {
 public:
  vector<int> asteroidCollision(vector<int>& asteroids) {
    vector<int> stack;

    for (const int a : asteroids)
      if (a > 0) {
        stack.push_back(a);
      } else {  // A < 0
        // Destroy previous positive one(s)
        while (!stack.empty() && stack.back() > 0 && stack.back() < -a)
          stack.pop_back();
        if (stack.empty() || stack.back() < 0)
          stack.push_back(a);
        else if (stack.back() == -a)
          stack.pop_back();  // Both explode
        else                 // Stack.back() > current
          ;                  // Destroy current, so do nothing
      }

    return stack;
  }
};",8,668,5.0,8.0,4.0,5.0,83.5,6.0,1.3649999999999984
661.0,"class Solution {
 public:
  int evaluate(string expression) {
    return evaluate(expression, unordered_map<string, int>());
  }

 private:
  int evaluate(const string& e, unordered_map<string, int> scope) {
    if (isdigit(e[0]) || e[0] == '-')
      return stoi(e);
    if (const auto it = scope.find(e); it != cend(scope))
      return it->second;

    const int spaceIndex = e.find_first_of(' ');
    const string nextExpression =
        e.substr(spaceIndex + 1, e.length() - spaceIndex - 2);  // -2: ""()""
    const vector<string> tokens = split(nextExpression);

    // Note that e[0] == '('
    if (e[1] == 'm')  // Mult
      return evaluate(tokens[0], scope) * evaluate(tokens[1], scope);
    if (e[1] == 'a')  // Add
      return evaluate(tokens[0], scope) + evaluate(tokens[1], scope);

    // Let
    for (int i = 0; i + 1 < tokens.size(); i += 2)
      scope[tokens[i]] = evaluate(tokens[i + 1], scope);
    return evaluate(tokens.back(), scope);
  };

  vector<string> split(const string& e) {
    vector<string> tokens;
    string s;
    int parenthesis = 0;

    for (const char c : e) {
      if (c == '(')
        ++parenthesis;
      else if (c == ')')
        --parenthesis;
      if (parenthesis == 0 && c == ' ') {
        tokens.push_back(s);
        s = """";
      } else {
        s += c;
      }
    }

    if (!s.empty())
      tokens.push_back(s);
    return tokens;
  }
};",25,1400,5.0,6.0,7.0,10.0,56.0,26.0,1.7799999999999994
662.0,"class Solution {
 public:
  bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2,
                              vector<vector<string>>& pairs) {
    if (words1.size() != words2.size())
      return false;

    // graph[key] := all similar words of key
    unordered_map<string, unordered_set<string>> graph;

    for (const vector<string>& pair : pairs) {
      graph[pair[1]].insert(pair[0]);
      graph[pair[0]].insert(pair[1]);
    }

    for (int i = 0; i < words1.size(); ++i) {
      if (words1[i] == words2[i])
        continue;
      if (!graph.count(words1[i]))
        return false;
      if (!dfs(graph, words1[i], words2[i], {}))
        return false;
    }

    return true;
  }

 private:
  bool dfs(const unordered_map<string, unordered_set<string>>& graph,
           const string& source, const string& target,
           unordered_set<string>&& seen) {
    if (graph.at(source).count(target))
      return true;

    seen.insert(source);

    for (const string& child : graph.at(source)) {
      if (seen.count(child))
        continue;
      if (dfs(graph, child, target, move(seen)))
        return true;
    }

    return false;
  }
};",16,1179,1.0,2.0,7.0,10.0,73.6875,21.0,0.7681249999999995
663.0,"class Solution {
 public:
  int monotoneIncreasingDigits(int n) {
    string s = to_string(n);
    const int n = s.length();
    int k = n;  // s[k:] -> '9'

    for (int i = n - 1; i > 0; --i)
      if (s[i] < s[i - 1]) {
        --s[i - 1];
        k = i;
      }

    for (int i = k; i < n; ++i)
      s[i] = '9';

    return stoi(s);
  }
};",12,344,1.0,3.0,3.0,3.0,28.666666666666668,9.0,6.199999999999999
664.0,"class Solution {
 public:
  vector<int> dailyTemperatures(vector<int>& temperatures) {
    vector<int> ans(temperatures.size());
    stack<int> stack;  // decreasing stack

    for (int i = 0; i < temperatures.size(); ++i) {
      while (!stack.empty() && temperatures[stack.top()] < temperatures[i]) {
        const int index = stack.top();
        stack.pop();
        ans[index] = i - index;
      }
      stack.push(i);
    }

    return ans;
  }
};",10,453,1.0,2.0,4.0,2.0,45.3,8.0,4.803
665.0,"class Solution {
 public:
  int deleteAndEarn(vector<int>& nums) {
    // Reduce to 198. House Robber
    vector<int> bucket(10001);

    for (const int num : nums)
      bucket[num] += num;

    int prev1 = 0;
    int prev2 = 0;

    for (const int num : bucket) {
      const int dp = max(prev1, prev2 + num);
      prev2 = prev1;
      prev1 = dp;
    }

    return prev1;
  }
};",9,382,1.0,2.0,3.0,2.0,42.44444444444444,12.0,4.720000000000001
666.0,"class Solution {
 public:
  int cherryPickup(vector<vector<int>>& grid) {
    // The problem is identical as two people start picking cherries
    // From grid[0][0] simultaneously
    n = grid.size();
    // dp[x1][y1][x2] := max cherries we could pick from
    // g[0][0] -> g[x1 - 1][y1 - 1] + g[0][0] -> g[x2 - 1][y2 - 1],
    // Where y2 = x1 + y1 - x2 (reduce states from 4 to 3)
    dp.resize(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, INT_MIN)));
    return max(0, cherryPickup(grid, 0, 0, 0));
  }

 private:
  int n;
  vector<vector<vector<int>>> dp;

  int cherryPickup(const vector<vector<int>>& grid, int x1, int y1, int x2) {
    const int y2 = x1 + y1 - x2;
    if (x1 == n || y1 == n || x2 == n || y2 == n)
      return -1;
    if (x1 == n - 1 && y1 == n - 1)
      return grid[x1][y1];
    if (grid[x1][y1] == -1 || grid[x2][y2] == -1)
      return -1;
    int& ans = dp[x1][y1][x2];
    if (ans > INT_MIN)
      return ans;

    ans = max({cherryPickup(grid, x1 + 1, y1, x2),
               cherryPickup(grid, x1 + 1, y1, x2 + 1),
               cherryPickup(grid, x1, y1 + 1, x2),
               cherryPickup(grid, x1, y1 + 1, x2 + 1)});
    if (ans == -1)
      return ans;

    ans += grid[x1][y1];  // Do pick some cherries
    if (x1 != x2)         // Two people are on different grids
      ans += grid[x2][y2];

    return ans;
  }
};",17,1369,7.0,0.0,4.0,7.0,80.52941176470588,16.0,1.1923529411764695
667.0,"class Solution {
 public:
  int findClosestLeaf(TreeNode* root, int k) {
    int ans = -1;
    int minDist = 1000;
    // {node: distance to TreeNode(k)}
    unordered_map<TreeNode*, int> nodeToDist;

    getDists(root, k, nodeToDist);
    getClosestLeaf(root, 0, nodeToDist, minDist, ans);

    return ans;
  }

 private:
  void getDists(TreeNode* root, int k,
                unordered_map<TreeNode*, int>& nodeToDist) {
    if (root == nullptr)
      return;
    if (root->val == k) {
      nodeToDist[root] = 0;
      return;
    }

    getDists(root->left, k, nodeToDist);
    if (const auto it = nodeToDist.find(root->left); it != cend(nodeToDist)) {
      // The TreeNode(k) is in the left subtree
      nodeToDist[root] = it->second + 1;
      return;
    }

    getDists(root->right, k, nodeToDist);
    if (const auto it = nodeToDist.find(root->right); it != cend(nodeToDist))
      // The TreeNode(k) is in the right subtree
      nodeToDist[root] = it->second + 1;
  }

  void getClosestLeaf(TreeNode* root, int dist,
                      unordered_map<TreeNode*, int>& nodeToDist, int& minDist,
                      int& ans) {
    if (root == nullptr)
      return;
    if (nodeToDist.count(root))
      dist = nodeToDist[root];
    if (root->left == nullptr && root->right == nullptr) {  // Is leaf
      if (dist < minDist) {
        minDist = dist;
        ans = root->val;
      }
      return;
    }

    getClosestLeaf(root->left, dist + 1, nodeToDist, minDist, ans);
    getClosestLeaf(root->right, dist + 1, nodeToDist, minDist, ans);
  }
};",24,1565,4.0,3.0,9.0,8.0,65.20833333333333,16.0,1.9712500000000013
668.0,"class Solution {
 public:
  int networkDelayTime(vector<vector<int>>& times, int n, int k) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& time : times) {
      const int u = time[0] - 1;
      const int v = time[1] - 1;
      const int w = time[2];
      graph[u].emplace_back(v, w);
    }

    return dijkstra(graph, k - 1);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {
    vector<int> dist(graph.size(), INT_MAX);
    using P = pair<int, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(dist[v], v);
        }
    }

    const int maxDist = *max_element(begin(dist), end(dist));
    return maxDist == INT_MAX ? -1 : maxDist;
  }
};",18,1001,1.0,3.0,6.0,4.0,55.61111111111112,27.0,1.795
669.0,"class Solution {
 public:
  char nextGreatestLetter(vector<char>& letters, char target) {
    int l = 0;
    int r = letters.size();

    while (l < r) {
      const int m = (l + r) / 2;
      if (letters[m] > target)
        r = m;
      else
        l = m + 1;
    }

    return letters[l % letters.size()];
  }
};",7,316,0.0,3.0,3.0,2.0,45.142857142857146,8.0,4.777142857142858
670.0,"class WordFilter {
 public:
  WordFilter(vector<string>& words) {
    for (int i = 0; i < words.size(); ++i) {
      const string& word = words[i];
      vector<string> prefixes;
      vector<string> suffixes;
      for (int j = 0; j <= word.length(); ++j) {
        const string prefix = word.substr(0, j);
        const string suffix = word.substr(j);
        prefixes.push_back(prefix);
        suffixes.push_back(suffix);
      }
      for (const string& prefix : prefixes)
        for (const string& suffix : suffixes)
          keyToIndex[prefix + '_' + suffix] = i;
    }
  }

  int f(string prefix, string suffix) {
    const string key = prefix + '_' + suffix;
    if (const auto it = keyToIndex.find(key); it != cend(keyToIndex))
      return it->second;
    return -1;
  }

 private:
  unordered_map<string, int> keyToIndex;
};",18,838,0.0,4.0,5.0,5.0,46.55555555555556,24.0,2.869999999999999
671.0,"class Solution {
 public:
  int minCostClimbingStairs(vector<int>& cost) {
    const int n = cost.size();

    for (int i = 2; i < n; ++i)
      cost[i] += min(cost[i - 1], cost[i - 2]);

    return min(cost[n - 1], cost[n - 2]);
  }
};",6,236,0.0,1.0,2.0,1.0,39.333333333333336,6.0,5.68
672.0,"class Solution {
 public:
  int dominantIndex(vector<int>& nums) {
    int ans;
    int max = 0;
    int secondMax = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] > max) {
        secondMax = max;
        max = nums[i];
        ans = i;
      } else if (nums[i] > secondMax) {
        secondMax = nums[i];
      }

    return max >= 2 * secondMax ? ans : -1;
  }
};",11,383,0.0,4.0,4.0,3.0,34.81818181818182,7.0,5.686363636363636
673.0,"class Solution {
 public:
  string shortestCompletingWord(string licensePlate, vector<string>& words) {
    string ans(16, '.');
    vector<int> count(26);

    for (const char c : licensePlate)
      if (isalpha(c))
        ++count[tolower(c) - 'a'];

    for (const string& word : words)
      if (word.length() < ans.length() && isComplete(count, getCount(word)))
        ans = word;

    return ans;
  }

 private:
  // Check if c1 is a subset of c2
  bool isComplete(const vector<int>& c1, const vector<int> c2) {
    for (int i = 0; i < 26; ++i)
      if (c1[i] > c2[i])
        return false;
    return true;
  }

  vector<int> getCount(const string& word) {
    vector<int> count(26);
    for (const char c : word)
      ++count[c - 'a'];
    return count;
  }
};",13,771,1.0,5.0,4.0,8.0,59.30769230769231,22.0,1.9623076923076912
674.0,"struct Region {
  // Given m = # of rows and n = # of cols, (x, y) will be hashed as x * n + y
  unordered_set<int> infected;
  unordered_set<int> noninfected;  // Noninfected neighbors
  int wallsRequired = 0;
};

class Solution {
 public:
  int containVirus(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;

    while (true) {
      vector<Region> regions;
      vector<vector<bool>> seen(m, vector<bool>(n));

      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
          if (grid[i][j] == 1 && !seen[i][j]) {
            Region region;
            dfs(grid, i, j, region, seen);  // Use DFS to find all regions (1s)
            if (!region.noninfected.empty())
              regions.push_back(region);
          }

      if (regions.empty())
        break;  // No region causes further infection

      // Region which infects most neighbors is in the back
      sort(begin(regions), end(regions), [](const auto& a, const auto& b) {
        return a.noninfected.size() < b.noninfected.size();
      });

      // Build walls around the region which infects most neighbors
      Region mostInfectedRegion = regions.back();
      regions.pop_back();
      ans += mostInfectedRegion.wallsRequired;

      for (const int neighbor : mostInfectedRegion.infected) {
        const int i = neighbor / n;
        const int j = neighbor % n;
        // The grid is now contained and won't be infected anymore
        grid[i][j] = 2;
      }

      // For remaining regions, expand (infect their neighbors)
      for (const Region& region : regions)
        for (const int neighbor : region.noninfected) {
          const int i = neighbor / n;
          const int j = neighbor % n;
          grid[i][j] = 1;
        }
    }

    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& grid, int i, int j, Region& region,
           vector<vector<bool>>& seen) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (seen[i][j] || grid[i][j] == 2)
      return;
    if (grid[i][j] == 0) {
      region.noninfected.insert(i * grid[0].size() + j);
      ++region.wallsRequired;
      return;
    }

    // grid[i][j] == 1
    seen[i][j] = true;
    region.infected.insert(i * grid[0].size() + j);

    dfs(grid, i + 1, j, region, seen);
    dfs(grid, i - 1, j, region, seen);
    dfs(grid, i, j + 1, region, seen);
    dfs(grid, i, j - 1, region, seen);
  }
};",41,2473,9.0,7.0,10.0,13.0,60.31707317073171,37.0,0.2114634146341458
675.0,"class Solution {
 public:
  int countCornerRectangles(vector<vector<int>>& grid) {
    int ans = 0;

    for (int row1 = 0; row1 < grid.size() - 1; ++row1)
      for (int row2 = row1 + 1; row2 < grid.size(); ++row2) {
        int count = 0;
        for (int j = 0; j < grid[0].size(); ++j)
          if (grid[row1][j] && grid[row2][j])
            ++count;
        ans += count * (count - 1) / 2;
      }

    return ans;
  }
};",12,428,0.0,4.0,3.0,4.0,35.666666666666664,8.0,5.57
676.0,"class Solution {
 public:
  vector<string> ipToCIDR(string ip, int n) {
    vector<string> ans;
    long num = getNum(ip);

    while (n > 0) {
      const long lowbit = num & -num;
      const long count = lowbit == 0 ? maxLow(n) : firstFit(lowbit, n);
      ans.push_back(getCIDR(num, getPrefix(count)));
      n -= count;
      num += count;
    }

    return ans;
  }

 private:
  long getNum(const string& ip) {
    istringstream iss(ip);
    long num = 0;
    for (string token; getline(iss, token, '.');)
      num = num * 256 + stol(token);
    return num;
  }

  // Returns max i s.t. 2^i < n
  int maxLow(int n) {
    for (int i = 0; i < 32; ++i)
      if (1 << i + 1 > n)
        return 1 << i;
    throw;
  }

  long firstFit(long lowbit, long n) {
    while (lowbit > n)
      lowbit >>= 1;
    return lowbit;
  }

  string getCIDR(long num, long prefix) {
    const long d = num & 255;
    num >>= 8;
    const long c = num & 255;
    num >>= 8;
    const long b = num & 255;
    num >>= 8;
    const long a = num & 255;
    return to_string(a) + '.' + to_string(b) + '.' + to_string(c) + '.' +
           to_string(d) + '/' + to_string(prefix);
  }

  // E.g. count = 8 = 2^3 -> prefix = 32 - 3 = 29
  //      count = 1 = 2^0 -> prefix = 32 - 0 = 32
  int getPrefix(long count) {
    for (int i = 0; i < 32; ++i)
      if (count == 1 << i)
        return 32 - i;
    throw;
  }
};",33,1395,3.0,0.0,8.0,7.0,42.27272727272727,20.0,3.835454545454545
677.0,"class Solution {
 public:
  int openLock(vector<string>& deadends, string target) {
    unordered_set<string> seen{begin(deadends), end(deadends)};
    if (seen.count(""0000""))
      return -1;
    if (target == ""0000"")
      return 0;

    int ans = 0;
    queue<string> q{{""0000""}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        string word = q.front();
        q.pop();
        for (int i = 0; i < 4; ++i) {
          const char cache = word[i];
          // Increase i-th digit by 1
          word[i] = word[i] == '9' ? '0' : word[i] + 1;
          if (word == target)
            return ans;
          if (!seen.count(word)) {
            q.push(word);
            seen.insert(word);
          }
          word[i] = cache;
          // Decrease i-th digit by 1
          word[i] = word[i] == '0' ? '9' : word[i] - 1;
          if (word == target)
            return ans;
          if (!seen.count(word)) {
            q.push(word);
            seen.insert(word);
          }
          word[i] = cache;
        }
      }
    }

    return -1;
  }
};",25,1099,2.0,5.0,10.0,9.0,43.96,12.0,4.023600000000001
678.0,"class Solution {
 public:
  string crackSafe(int n, int k) {
    string ans(n, '0');
    dfs(pow(k, n), n, k, {ans}, ans);
    return ans;
  }

 private:
  bool dfs(int passwordSize, int n, int k, unordered_set<string>&& seen,
           string& path) {
    if (seen.size() == passwordSize)
      return true;

    string prefix = path.substr(path.length() - n + 1);

    for (char c = '0'; c < '0' + k; ++c) {
      prefix.push_back(c);
      if (!seen.count(prefix)) {
        seen.insert(prefix);
        path.push_back(c);
        if (dfs(passwordSize, n, k, move(seen), path))
          return true;
        path.pop_back();
        seen.erase(prefix);
      }
      prefix.pop_back();
    }

    return false;
  }
};",16,722,0.0,1.0,6.0,4.0,45.125,13.0,4.21875
679.0,"class Solution {
 public:
  int reachNumber(int target) {
    const int newTarget = abs(target);
    int ans = 0;
    int pos = 0;

    while (pos < newTarget)
      pos += ++ans;
    while ((pos - newTarget) & 1)
      pos += ++ans;

    return ans;
  }
};",7,257,0.0,2.0,2.0,2.0,36.71428571428572,7.0,5.755714285714285
680.0,"class Solution {
 public:
  vector<int> pourWater(vector<int>& heights, int volume, int k) {
    int i = k;

    while (volume-- > 0) {
      while (i > 0 && heights[i] >= heights[i - 1])
        --i;
      while (i + 1 < heights.size() && heights[i] >= heights[i + 1])
        ++i;
      while (i > k && heights[i] == heights[i - 1])
        --i;
      ++heights[i];
    }

    return heights;
  }
};",7,401,0.0,4.0,3.0,4.0,57.285714285714285,6.0,3.8242857142857134
681.0,"class Solution {
 public:
  bool pyramidTransition(string bottom, vector<string>& allowed) {
    unordered_map<string, vector<char>> prefixToBlocks;

    for (const string& a : allowed)
      prefixToBlocks[a.substr(0, 2)].push_back(a[2]);

    return dfs(bottom, """", 0, prefixToBlocks);
  }

 private:
  bool dfs(const string& row, const string& nextRow, int i,
           const unordered_map<string, vector<char>>& prefixToBlocks) {
    if (row.length() == 1)
      return true;
    if (nextRow.length() + 1 == row.length())
      return dfs(nextRow, """", 0, prefixToBlocks);

    const string& prefix = row.substr(i, 2);

    if (const auto it = prefixToBlocks.find(prefix); it != cend(prefixToBlocks))
      for (const char c : it->second)
        if (dfs(row, nextRow + c, i + 1, prefixToBlocks))
          return true;

    return false;
  }
};",10,849,0.0,2.0,3.0,6.0,84.9,22.0,-0.141
682.0,"class Solution {
 public:
  int intersectionSizeTwo(vector<vector<int>>& intervals) {
    int ans = 0;
    int max = -1;
    int secondMax = -1;

    sort(begin(intervals), end(intervals), [](const auto& a, const auto& b) {
      return a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];
    });

    for (const vector<int>& interval : intervals) {
      const int a = interval[0];
      const int b = interval[1];
      // Max and 2nd max still satisfy
      if (max >= a && secondMax >= a)
        continue;
      if (max >= a) {  // Max still satisfy
        secondMax = max;
        max = b;  // Add b to the set S
        ans += 1;
      } else {              // Max and 2nd max can't satisfy
        max = b;            // Add b to the set S
        secondMax = b - 1;  // Add b - 1 to the set S
        ans += 2;
      }
    }

    return ans;
  }
};",16,848,6.0,2.0,6.0,3.0,53.0,14.0,3.59
683.0,"class Solution {
 public:
  string boldWords(vector<string>& words, string s) {
    const int n = s.length();
    string ans;
    // bold[i] := true if s[i] should be bolded
    vector<bool> bold(n);

    int boldEnd = -1;  // s[i:boldEnd] should be bolded
    for (int i = 0; i < n; ++i) {
      for (const string& word : words)
        if (s.substr(i).find(word) == 0)  // StartsWith
          boldEnd = max(boldEnd, i + static_cast<int>(word.length()));
      bold[i] = boldEnd > i;
    }

    // Construct the string with bold tags
    int i = 0;
    while (i < n)
      if (bold[i]) {
        int j = i;
        while (j < n && bold[j])
          ++j;
        // s[i:j] should be bolded
        ans += ""<b>"" + s.substr(i, j - i) + ""</b>"";
        i = j;
      } else {
        ans += s[i++];
      }

    return ans;
  }
};",16,828,5.0,8.0,5.0,7.0,51.75,16.0,3.1625
684.0,"class Solution {
 public:
  vector<Interval> employeeFreeTime(vector<vector<Interval>> schedule) {
    vector<Interval> ans;
    vector<Interval> intervals;

    for (const vector<Interval>& s : schedule)
      intervals.insert(end(intervals), begin(s), end(s));

    sort(begin(intervals), end(intervals),
         [](const auto& a, const auto& b) { return a.start < b.start; });

    int prevEnd = intervals[0].end;

    for (const auto& [start, end] : intervals) {
      if (start > prevEnd)
        ans.emplace_back(prevEnd, start);
      prevEnd = max(prevEnd, end);
    }

    return ans;
  }
};",10,601,0.0,2.0,4.0,3.0,60.1,6.0,3.6309999999999993
685.0,"class Solution {
 public:
  string makeLargestSpecial(string s) {
    vector<string> specials;
    int count = 0;

    for (int i = 0, j = 0; j < s.length(); ++j) {
      count += s[j] == '1' ? 1 : -1;
      if (count == 0) {  // Find a special string
        const string& inner = s.substr(i + 1, j - i - 1);
        specials.push_back('1' + makeLargestSpecial(inner) + '0');
        i = j + 1;
      }
    }

    sort(begin(specials), end(specials), greater<>());
    return join(specials);
  }

 private:
  string join(const vector<string>& specials) {
    string joined;
    for (const string& special : specials)
      joined += special;
    return joined;
  }
};",14,668,1.0,2.0,5.0,3.0,47.71428571428572,15.0,3.8257142857142856
686.0,"class Solution {
 public:
  int countPrimeSetBits(int L, int R) {
    // { 2, 3, 5, 7, 11, 13, 17, 19 }th bits are 1s
    // (10100010100010101100)2 = (665772)10
    constexpr int magic = 665772;
    int ans = 0;

    for (int n = L; n <= R; ++n)
      if (magic & 1 << __builtin_popcountll(n))
        ++ans;

    return ans;
  }
};",7,333,2.0,2.0,3.0,2.0,47.57142857142857,7.0,4.798571428571429
687.0,"class Solution {
 public:
  vector<int> partitionLabels(string s) {
    vector<int> ans;
    vector<int> rightmost(128);

    for (int i = 0; i < s.length(); ++i)
      rightmost[s[i]] = i;

    int l = 0;  // First index of current running string
    int r = 0;  // Right most so far

    for (int i = 0; i < s.length(); ++i) {
      r = max(r, rightmost[s[i]]);
      if (r == i) {
        ans.push_back(i - l + 1);
        l = i + 1;
      }
    }

    return ans;
  }
};",14,474,2.0,3.0,4.0,3.0,33.857142857142854,10.0,5.612857142857143
688.0,"class Solution {
 public:
  int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
    vector<vector<int>> grid(n, vector<int>(n, n));

    for (const vector<int>& mine : mines)
      grid[mine[0]][mine[1]] = 0;

    // Extend four directions, if meet 0, need to start over from 0
    for (int i = 0; i < n; ++i) {
      for (int j = 0, leftToRight = 0; j < n; ++j) {
        leftToRight = (grid[i][j] == 0 ? 0 : leftToRight + 1);
        grid[i][j] = min(grid[i][j], leftToRight);
      }
      for (int j = n - 1, rightToLeft = 0; j >= 0; --j) {
        rightToLeft = (grid[i][j] == 0 ? 0 : rightToLeft + 1);
        grid[i][j] = min(grid[i][j], rightToLeft);
      }
      for (int j = 0, upToDown = 0; j < n; ++j) {
        upToDown = (grid[j][i] == 0 ? 0 : upToDown + 1);
        grid[j][i] = min(grid[j][i], upToDown);
      }
      for (int j = n - 1, downToUp = 0; j >= 0; --j) {
        downToUp = (grid[j][i] == 0) ? 0 : downToUp + 1;
        grid[j][i] = min(grid[j][i], downToUp);
      }
    }

    int ans = 0;

    for (const vector<int>& row : grid)
      ans = max(ans, *max_element(begin(row), end(row)));

    return ans;
  }
};",24,1156,1.0,8.0,7.0,8.0,48.16666666666666,16.0,3.205
689.0,"class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int minSwapsCouples(vector<int>& row) {
    const int n = row.size() / 2;
    UnionFind uf(n);

    for (int i = 0; i < n; ++i) {
      const int a = row[2 * i];
      const int b = row[2 * i + 1];
      uf.unionByRank(a / 2, b / 2);
    }

    return n - uf.getCount();
  }
};",24,906,0.0,3.0,11.0,4.0,37.75,26.0,3.1625
690.0,"class Solution {
 public:
  bool isToeplitzMatrix(vector<vector<int>>& matrix) {
    for (int i = 0; i + 1 < matrix.size(); ++i)
      for (int j = 0; j + 1 < matrix[0].size(); ++j)
        if (matrix[i][j] != matrix[i + 1][j + 1])
          return false;
    return true;
  }
};",7,279,0.0,2.0,2.0,3.0,39.85714285714285,5.0,5.672857142857144
691.0,"class Solution {
 public:
  string reorganizeString(string s) {
    unordered_map<char, int> count;
    int maxFreq = 0;

    for (const char c : s)
      maxFreq = max(maxFreq, ++count[c]);

    if (maxFreq > (s.length() + 1) / 2)
      return """";

    string ans;
    priority_queue<pair<int, char>> maxHeap;  // (freq, c)
    int prevFreq = 0;
    char prevChar = '@';

    for (const auto& [c, freq] : count)
      maxHeap.emplace(freq, c);

    while (!maxHeap.empty()) {
      // Get the most freq letter
      const auto [freq, c] = maxHeap.top();
      maxHeap.pop();
      ans += c;
      // Add the previous letter back so that
      // Any two adjacent characters are not the same
      if (prevFreq > 0)
        maxHeap.emplace(prevFreq, prevChar);
      prevFreq = freq - 1;
      prevChar = c;
    }

    return ans;
  }
};",17,837,4.0,4.0,3.0,5.0,49.23529411764706,15.0,3.808823529411765
692.0,"class Solution {
 public:
  int maxChunksToSorted(vector<int>& arr) {
    const int n = arr.size();
    int ans = 0;
    vector<int> maxL(n);  // l[i] := max(arr[0..i])
    vector<int> minR(n);  // r[i] := min(arr[i..n))

    for (int i = 0; i < n; ++i)
      maxL[i] = i == 0 ? arr[i] : max(arr[i], maxL[i - 1]);

    for (int i = n - 1; i >= 0; --i)
      minR[i] = i == n - 1 ? arr[i] : min(arr[i], minR[i + 1]);

    for (int i = 0; i + 1 < n; ++i)
      if (maxL[i] <= minR[i + 1])
        ++ans;

    return ans + 1;
  }
};",15,529,2.0,4.0,2.0,4.0,35.266666666666666,11.0,5.446
693.0,"class Solution {
 public:
  int maxChunksToSorted(vector<int>& arr) {
    int ans = 0;
    int maxi = INT_MIN;

    for (int i = 0; i < arr.size(); ++i) {
      maxi = max(maxi, arr[i]);
      if (maxi == i)
        ++ans;
    }

    return ans;
  }
};",8,252,0.0,2.0,3.0,2.0,31.5,6.0,6.265
694.0,"class Poly {
  friend Poly operator+(const Poly& lhs, const Poly& rhs) {
    Poly res(lhs);
    for (const auto& [term, coef] : rhs.terms)
      res.terms[term] += coef;
    return res;
  }

  friend Poly operator-(const Poly& lhs, const Poly& rhs) {
    Poly res(lhs);
    for (const auto& [term, coef] : rhs.terms)
      res.terms[term] -= coef;
    return res;
  }

  friend Poly operator*(const Poly& lhs, const Poly& rhs) {
    Poly res;
    for (const auto& [a, aCoef] : lhs.terms)
      for (const auto& [b, bCoef] : rhs.terms)
        res.terms[merge(a, b)] += aCoef * bCoef;
    return res;
  }

  // Friend ostream& operator<<(ostream& os, const Poly& poly) {
  //   os << ""{"";
  //   for (const auto& [term, coef] : poly.terms)
  //     os << term << "": "" << coef << "", "";
  //   os << ""}"";
  //   return os;
  // }

 public:
  vector<string> toList() {
    vector<string> res;
    vector<string> keys;
    for (const auto& [term, _] : terms)
      keys.push_back(term);
    sort(begin(keys), end(keys), [&](const auto& a, const auto& b) {
      // Smallest degree is the last
      if (a == ""1"")
        return false;
      if (b == ""1"")
        return true;
      const vector<string> as = split(a, '*');
      const vector<string> bs = split(b, '*');
      // Largest degree is the first
      // Breaking ties by lexicographic order
      return as.size() == bs.size() ? a < b : as.size() > bs.size();
    });
    auto concat = [&](const string& term) -> string {
      if (term == ""1"")
        return to_string(terms[term]);
      return to_string(terms[term]) + '*' + term;
    };
    for (const string& key : keys)
      if (terms[key])
        res.push_back(concat(key));
    return res;
  }

  Poly() = default;
  Poly(const string& term, int coef) {
    terms[term] = coef;
  }

 private:
  unordered_map<string, int> terms;

  // E.g. merge(""a*b"", ""a*c"") -> ""a*a*b*c""
  static string merge(const string& a, const string& b) {
    if (a == ""1"")
      return b;
    if (b == ""1"")
      return a;
    string res;
    vector<string> A = split(a, '*');
    vector<string> B = split(b, '*');
    int i = 0;  // A's index
    int j = 0;  // B's index
    while (i < A.size() && j < B.size())
      if (A[i] < B[j])
        res += '*' + A[i++];
      else
        res += '*' + B[j++];
    while (i < A.size())
      res += '*' + A[i++];
    while (j < B.size())
      res += '*' + B[j++];
    return res.substr(1);
  }

  static vector<string> split(const string& token, char c) {
    vector<string> vars;
    istringstream iss(token);
    for (string var; getline(iss, var, c);)
      vars.push_back(var);
    return vars;
  }
};

class Solution {
 public:
  vector<string> basicCalculatorIV(string expression, vector<string>& evalvars,
                                   vector<int>& evalints) {
    vector<string> tokens = getTokens(expression);
    unordered_map<string, int> evalMap;

    for (int i = 0; i < evalvars.size(); ++i)
      evalMap[evalvars[i]] = evalints[i];

    for (string& token : tokens)
      if (const auto it = evalMap.find(token); it != cend(evalMap))
        token = to_string(it->second);

    const vector<string>& postfix = infixToPostfix(tokens);
    return evaluate(postfix).toList();
  }

 private:
  vector<string> getTokens(const string& s) {
    vector<string> tokens;
    int i = 0;
    for (int j = 0; j < s.length(); ++j)
      if (s[j] == ' ') {
        if (i < j)
          tokens.push_back(s.substr(i, j - i));
        i = j + 1;
      } else if (string(""()+-*"").find(s[j]) != string::npos) {
        if (i < j)
          tokens.push_back(s.substr(i, j - i));
        tokens.push_back(s.substr(j, 1));
        i = j + 1;
      }
    if (i < s.length())
      tokens.push_back(s.substr(i));
    return tokens;
  }

  bool isOperator(const string& token) {
    return token == ""+"" || token == ""-"" || token == ""*"";
  }

  vector<string> infixToPostfix(const vector<string>& tokens) {
    vector<string> postfix;
    stack<string> ops;

    auto precedes = [](const string& prevOp, const string& currOp) -> bool {
      if (prevOp == ""("")
        return false;
      return prevOp == ""*"" || currOp == ""+"" || currOp == ""-"";
    };

    for (const string& token : tokens)
      if (token == ""("") {
        ops.push(token);
      } else if (token == "")"") {
        while (ops.top() != ""("")
          postfix.push_back(ops.top()), ops.pop();
        ops.pop();
      } else if (isOperator(token)) {
        while (!ops.empty() && precedes(ops.top(), token))
          postfix.push_back(ops.top()), ops.pop();
        ops.push(token);
      } else {  // IsOperand(token)
        postfix.push_back(token);
      }

    while (!ops.empty())
      postfix.push_back(ops.top()), ops.pop();

    return postfix;
  }

  Poly evaluate(const vector<string>& postfix) {
    vector<Poly> polys;
    for (const string& token : postfix)
      if (isOperator(token)) {
        const Poly b = polys.back();
        polys.pop_back();
        const Poly a = polys.back();
        polys.pop_back();
        if (token == ""+"")
          polys.push_back(a + b);
        else if (token == ""-"")
          polys.push_back(a - b);
        else  // Token == ""*""
          polys.push_back(a * b);
      } else if (token[0] == '-' || all_of(begin(token), end(token),
                                           [](char c) { return isdigit(c); })) {
        polys.push_back(Poly(""1"", stoi(token)));
      } else {
        polys.push_back(Poly(token, 1));
      }
    return polys[0];
  }
};",96,5510,15.0,28.0,29.0,40.0,57.395833333333336,92.0,-7.185625000000002
695.0,"class Solution {
 public:
  int numJewelsInStones(string jewels, string stones) {
    int ans = 0;
    unordered_set<char> jewelsSet(begin(jewels), end(jewels));

    for (const char stone : stones)
      if (jewelsSet.count(stone))
        ++ans;

    return ans;
  }
};",5,271,0.0,2.0,2.0,2.0,54.2,8.0,4.082
696.0,"class Solution {
 public:
  int calculate(string s) {
    stack<int> nums;
    stack<int> ops;
    bool hasPrevNum = false;

    auto calc = [&]() {
      const int b = nums.top();
      nums.pop();
      const int a = nums.top();
      nums.pop();
      const char op = ops.top();
      ops.pop();
      if (op == '+')
        nums.push(a + b);
      else if (op == '-')
        nums.push(a - b);
      else if (op == '*')
        nums.push(a * b);
      else  // Op == '/'
        nums.push(a / b);
    };

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (isdigit(c)) {
        int num = c - '0';
        while (i + 1 < s.length() && isdigit(s[i + 1]))
          num = num * 10 + (s[i++ + 1] - '0');
        nums.push(num);
        hasPrevNum = true;
      } else if (c == '(') {
        ops.push('(');
        hasPrevNum = false;
      } else if (c == ')') {
        while (ops.top() != '(')
          calc();
        ops.pop();  // Pop '('
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        if (!hasPrevNum)
          nums.push(0);
        while (!ops.empty() && precedes(ops.top(), c))
          calc();
        ops.push(c);
      }
    }

    while (!ops.empty())
      calc();

    return nums.top();
  }

 private:
  // Returns true if prevOp is a operator and
  // Priority(prevOp) >= priority(currOp)
  bool precedes(char prevOp, char currOp) {
    if (prevOp == '(')
      return false;
    return prevOp == '*' || prevOp == '/' || currOp == '+' || currOp == '-';
  }
};",33,1534,4.0,19.0,9.0,15.0,46.48484848484848,19.0,2.3963636363636365
697.0,"class Solution {
 public:
  int slidingPuzzle(vector<vector<int>>& board) {
    constexpr int m = 2;
    constexpr int n = 3;
    const vector<int> dirs{0, 1, 0, -1, 0};
    const string goal = ""123450"";
    int steps = 0;
    string start;

    // Hash 2D vector to string
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        start += '0' + board[i][j];

    if (start == goal)
      return 0;

    queue<string> q{{start}};
    unordered_set<string> seen{start};

    while (!q.empty()) {
      ++steps;
      for (int sz = q.size(); sz > 0; --sz) {
        string s = q.front();
        q.pop();
        const int zeroIndex = s.find('0');
        const int i = zeroIndex / n;
        const int j = zeroIndex % n;
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          const int swappedIndex = x * n + y;
          swap(s[zeroIndex], s[swappedIndex]);
          if (s == goal)
            return steps;
          if (!seen.count(s)) {
            q.push(s);
            seen.insert(s);
          }
          swap(s[zeroIndex], s[swappedIndex]);
        }
      }
    }

    return -1;
  }
};",35,1257,1.0,6.0,10.0,9.0,35.91428571428571,31.0,2.747714285714286
698.0,"class Solution {
 public:
  double minmaxGasDist(vector<int>& stations, int k) {
    constexpr double kErr = 1e-6;
    double l = 0;
    double r = stations.back() - stations[0];

    while (r - l > kErr) {
      const double m = (l + r) / 2;
      if (check(stations, k, m))
        r = m;
      else
        l = m;
    }

    return l;
  }

 private:
  // Returns true if can use k or less gas stations to ensure that each adjacent
  // distance between gas stations is at most m.
  bool check(const vector<int>& stations, int k, double m) {
    for (int i = 1; i < stations.size(); ++i) {
      const int diff = stations[i] - stations[i - 1];
      if (diff > m) {
        k -= ceil(diff / m) - 1;
        if (k < 0)
          return false;
      }
    }
    return true;
  };
};",15,782,2.0,5.0,6.0,9.0,52.13333333333333,17.0,3.028
699.0,"class Solution {
 public:
  bool isIdealPermutation(vector<int>& nums) {
    int maxi = -1;  // The most likely to be greater than nums[i + 2].

    for (int i = 0; i + 2 < nums.size(); ++i) {
      maxi = max(maxi, nums[i]);
      if (maxi > nums[i + 2])
        return false;
    }

    return true;
  }
};",7,308,1.0,1.0,3.0,2.0,44.0,5.0,5.340000000000001
700.0,"class Solution {
 public:
  vector<TreeNode*> splitBST(TreeNode* root, int target) {
    if (root == nullptr)
      return {nullptr, nullptr};
    if (root->val > target) {
      const vector<TreeNode*> res = splitBST(root->left, target);
      root->left = res[1];
      return {res[0], root};
    } else {  // root.val <= target
      const vector<TreeNode*> res = splitBST(root->right, target);
      root->right = res[0];
      return {root, res[1]};
    }
  }
};",8,467,1.0,1.0,7.0,2.0,58.375,4.0,3.90625
701.0,"class Solution {
 public:
  bool canTransform(string start, string end) {
    if (removeX(start) != removeX(end))
      return false;

    int i = 0;  // start's index
    int j = 0;  // end's index

    while (i < start.length() && j < end.length()) {
      while (i < start.length() && start[i] == 'X')
        ++i;
      while (j < end.length() && end[j] == 'X')
        ++j;
      if (i == start.length() && j == end.length())
        return true;
      if (i == start.length() || j == end.length())
        return false;
      if (start[i] == 'L' && i < j)
        return false;
      if (start[i] == 'R' && i > j)
        return false;
      ++i;
      ++j;
    }

    return true;
  }

 private:
  string removeX(const string& s) {
    string t = s;
    t.erase(remove(begin(t), end(t), 'X'), end(t));
    return t;
  }
};",16,829,2.0,2.0,4.0,9.0,51.8125,10.0,4.056875
702.0,"class Solution {
 public:
  int swimInWater(vector<vector<int>>& grid) {
    const int n = grid.size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = grid[0][0];
    using T = tuple<int, int, int>;  // (grid[i][j], i, j)
    priority_queue<T, vector<T>, greater<>> minHeap;
    vector<vector<bool>> seen(n, vector<bool>(n));

    minHeap.emplace(grid[0][0], 0, 0);
    seen[0][0] = true;

    while (!minHeap.empty()) {
      const auto [height, i, j] = minHeap.top();
      minHeap.pop();
      ans = max(ans, height);
      if (i == n - 1 && j == n - 1)
        break;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == n || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        minHeap.emplace(grid[x][y], x, y);
        seen[x][y] = true;
      }
    }

    return ans;
  }
};",22,912,1.0,2.0,5.0,5.0,41.45454545454545,19.0,3.989090909090909
703.0,"class Solution {
 public:
  int kthGrammar(int n, int k) {
    if (n == 1)
      return 0;
    if (k & 1)
      return kthGrammar(n - 1, (k + 1) / 2) != 0;  // Left node
    return kthGrammar(n - 1, k / 2) == 0;          // Right node
  }
};",4,241,2.0,0.0,2.0,2.0,60.25,4.0,4.1375
704.0,"class Solution {
 public:
  bool reachingPoints(int sx, int sy, int tx, int ty) {
    while (sx < tx && sy < ty)
      if (tx > ty)
        tx %= ty;
      else
        ty %= tx;

    return sx == tx && sy <= ty && (ty - sy) % sx == 0 ||
           sy == ty && sx <= tx && (tx - sx) % sy == 0;
  }
};",4,300,0.0,3.0,2.0,2.0,75.0,6.0,2.3500000000000005
705.0,"class Solution {
 public:
  int numRabbits(vector<int>& answers) {
    int ans = 0;
    vector<int> count(1000);

    for (const int answer : answers) {
      if (count[answer] % (answer + 1) == 0)
        ans += answer + 1;
      ++count[answer];
    }

    return ans;
  }
};",6,277,0.0,2.0,3.0,2.0,46.16666666666666,7.0,4.845000000000001
706.0,"class Solution {
 public:
  int movesToChessboard(vector<vector<int>>& board) {
    const int n = board.size();
    int rowSum = 0;
    int colSum = 0;
    int rowSwaps = 0;
    int colSwaps = 0;

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j] == 1)
          return -1;

    for (int i = 0; i < n; ++i) {
      rowSum += board[0][i];
      colSum += board[i][0];
    }

    if (rowSum != n / 2 && rowSum != (n + 1) / 2)
      return -1;
    if (colSum != n / 2 && colSum != (n + 1) / 2)
      return -1;

    for (int i = 0; i < n; ++i) {
      rowSwaps += board[i][0] == (i & 1);
      colSwaps += board[0][i] == (i & 1);
    }

    if (n & 1) {
      if (rowSwaps & 1)
        rowSwaps = n - rowSwaps;
      if (colSwaps & 1)
        colSwaps = n - colSwaps;
    } else {
      rowSwaps = min(rowSwaps, n - rowSwaps);
      colSwaps = min(colSwaps, n - colSwaps);
    }

    return (rowSwaps + colSwaps) / 2;
  }
};",26,1003,0.0,8.0,6.0,10.0,38.57692307692308,13.0,4.388076923076923
707.0,"class Solution {
 public:
  int minDiffInBST(TreeNode* root) {
    int ans = INT_MAX;
    inorder(root, ans);
    return ans;
  }

 private:
  int pred = -1;

  void inorder(TreeNode* root, int& ans) {
    if (root == nullptr)
      return;

    inorder(root->left, ans);
    if (pred >= 0)
      ans = min(ans, root->val - pred);
    pred = root->val;
    inorder(root->right, ans);
  }
};",10,390,0.0,1.0,3.0,3.0,39.0,6.0,5.650000000000001
708.0,"class Solution {
 public:
  vector<string> letterCasePermutation(string s) {
    vector<string> ans;
    dfs(s, 0, ans);
    return ans;
  }

 private:
  void dfs(string& s, int i, vector<string>& ans) {
    if (i == s.length()) {
      ans.push_back(s);
      return;
    }
    if (isdigit(s[i])) {
      dfs(s, i + 1, ans);
      return;
    }

    s[i] = tolower(s[i]);
    dfs(s, i + 1, ans);
    s[i] = toupper(s[i]);
    dfs(s, i + 1, ans);
  }
};",12,453,0.0,0.0,5.0,2.0,37.75,8.0,5.5025
709.0,"enum class Color { kWhite, kRed, kGreen };

class Solution {
 public:
  bool isBipartite(vector<vector<int>>& graph) {
    vector<Color> colors(graph.size(), Color::kWhite);

    for (int i = 0; i < graph.size(); ++i) {
      // Already colored, do nothing
      if (colors[i] != Color::kWhite)
        continue;
      // colors[i] == Color::kWhite
      colors[i] = Color::kRed;  // Always paint w/ Color::kRed
      // BFS
      queue<int> q{{i}};
      while (!q.empty()) {
        const int u = q.front();
        q.pop();
        for (const int v : graph[u]) {
          if (colors[v] == colors[u])
            return false;
          if (colors[v] == Color::kWhite) {
            colors[v] = colors[u] == Color::kRed ? Color::kGreen : Color::kRed;
            q.push(v);
          }
        }
      }
    }

    return true;
  }
};",14,837,4.0,4.0,9.0,6.0,59.785714285714285,10.0,2.9992857142857146
710.0,"class Solution {
 public:
  vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
    const int n = arr.size();
    double l = 0.0;
    double r = 1.0;

    while (l < r) {
      const double m = (l + r) / 2.0;
      int fractionsNoGreaterThanM = 0;
      int p = 0;
      int q = 1;

      // For each index i, find the first index j s.t. arr[i] / arr[j] <= m,
      // So fractionsNoGreaterThanM for index i will be n - j
      for (int i = 0, j = 1; i < n; ++i) {
        while (j < n && arr[i] > m * arr[j])
          ++j;
        if (j == n)
          break;
        fractionsNoGreaterThanM += n - j;
        if (p * arr[j] < q * arr[i]) {
          p = arr[i];
          q = arr[j];
        }
      }

      if (fractionsNoGreaterThanM == k)
        return {p, q};
      if (fractionsNoGreaterThanM > k)
        r = m;
      else
        l = m;
    }

    throw;
  }
};",19,885,2.0,7.0,6.0,9.0,46.578947368421055,14.0,3.707894736842104
711.0,"class Solution {
 public:
  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,
                        int k) {
    vector<vector<pair<int, int>>> graph(n);
    using T = tuple<int, int, int>;  // (d, u, stops)
    priority_queue<T, vector<T>, greater<>> minHeap;
    vector<vector<int>> dist(n, vector<int>(k + 2, INT_MAX));

    minHeap.emplace(0, src, k + 1);  // Start with node src with d == 0
    dist[src][k + 1] = 0;

    for (const vector<int>& flight : flights) {
      const int u = flight[0];
      const int v = flight[1];
      const int w = flight[2];
      graph[u].emplace_back(v, w);
    }

    return dijkstra(graph, src, dst, k);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,
               int k) {
    vector<vector<int>> dist(graph.size(), vector<int>(k + 2, INT_MAX));
    using T = tuple<int, int, int>;  // (d, u, stops)
    priority_queue<T, vector<T>, greater<>> minHeap;

    dist[src][k + 1] = 0;
    minHeap.emplace(dist[src][k + 1], src, k + 1);

    while (!minHeap.empty()) {
      const auto [d, u, stops] = minHeap.top();
      minHeap.pop();
      if (u == dst)
        return d;
      if (stops == 0)
        continue;
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v][stops - 1]) {
          dist[v][stops - 1] = d + w;
          minHeap.emplace(dist[v][stops - 1], v, stops - 1);
        }
    }

    return -1;
  }
};",24,1451,3.0,3.0,6.0,6.0,60.458333333333336,36.0,0.5387500000000003
712.0,"class Solution {
 public:
  int rotatedDigits(int n) {
    int ans = 0;

    for (int i = 1; i <= n; ++i)
      if (isGoodNumber(i))
        ++ans;

    return ans;
  }

 private:
  bool isGoodNumber(int i) {
    bool isRotated = false;

    for (const char c : to_string(i)) {
      if (c == '0' || c == '1' || c == '8')
        continue;
      if (c == '2' || c == '5' || c == '6' || c == '9')
        isRotated = true;
      else
        return false;
    }

    return isRotated;
  }
};",11,490,0.0,3.0,4.0,5.0,44.54545454545455,10.0,4.570909090909091
713.0,"class Solution {
 public:
  bool escapeGhosts(vector<vector<int>>& ghosts, vector<int>& target) {
    const int d = abs(target[0]) + abs(target[1]);

    for (const vector<int>& ghost : ghosts)
      if (d >= abs(ghost[0] - target[0]) + abs(ghost[1] - target[1]))
        return false;

    return true;
  }
};",4,310,0.0,1.0,2.0,2.0,77.5,8.0,2.045000000000001
714.0,"class Solution {
 public:
  int numTilings(int n) {
    constexpr int kMod = 1'000'000'007;
    vector<long> dp(1001, 0);
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 5;

    for (int i = 4; i <= n; ++i)
      dp[i] = (2 * dp[i - 1] + dp[i - 3]) % kMod;

    return dp[n];
  }
};",10,276,0.0,1.0,2.0,1.0,27.6,5.0,6.836
715.0,"class Solution {
 public:
  string customSortString(string order, string s) {
    string ans;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (const char c : order)
      while (count[c]-- > 0)
        ans += c;

    for (char c = 'a'; c <= 'z'; ++c)
      while (count[c]-- > 0)
        ans += c;

    return ans;
  }
};",9,356,0.0,5.0,2.0,5.0,39.55555555555556,11.0,4.92
716.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  int numMatchingSubseq(string s, vector<string>& words) {
    for (const string& word : words)
      insert(word);
    return dfs(s, 0, root);
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    ++node->count;
  }

  int dfs(const string& s, int i, shared_ptr<TrieNode> node) {
    int ans = node->count;
    if (i >= s.length())
      return ans;

    for (int j = 0; j < 26; ++j)
      if (node->children[j]) {
        const int index = s.find('a' + j, i);
        if (index != -1)
          ans += dfs(s, index + 1, node->children[j]);
      }

    return ans;
  }
};",19,997,0.0,5.0,8.0,7.0,52.47368421052632,23.0,2.197368421052631
717.0,"class Solution {
 public:
  int preimageSizeFZF(int k) {
    long l = 0;
    long r = 5L * k;

    while (l < r) {
      const long m = (l + r) / 2;
      if (trailingZeroes(m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return trailingZeroes(l) == k ? 5 : 0;
  }

 private:
  // 172. Factorial Trailing Zeroes
  int trailingZeroes(long n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
  }
};",8,421,1.0,2.0,4.0,2.0,52.625,5.0,4.44375
718.0,"class Solution {
 public:
  bool validTicTacToe(vector<string>& board) {
    const int countX = sum(board, 'X');
    const int countO = sum(board, 'O');

    if (countX < countO || countX - countO > 1)
      return false;
    if (isWinned(board, 'X') && countX == countO ||
        isWinned(board, 'O') && countX != countO)
      return false;

    return true;
  }

 private:
  int sum(const vector<string>& board, char c) {
    int ans = 0;

    for (const string& row : board)
      ans += count(begin(row), end(row), c);

    return ans;
  }

  bool isWinned(const vector<string>& board, char c) {
    vector<string> rotated = rotate(board);

    auto equalsToThree = [&c](const string& row) {
      return count(begin(row), end(row), c) == 3;
    };

    return any_of(begin(board), end(board), equalsToThree) ||
           any_of(begin(rotated), end(rotated), equalsToThree) ||
           board[0][0] == c && board[1][1] == c && board[2][2] == c ||
           board[0][2] == c && board[1][1] == c && board[2][0] == c;
  }

  vector<string> rotate(const vector<string>& board) {
    vector<string> rotated(3);

    for (const string& row : board)
      for (int i = 0; i < 3; ++i)
        rotated[i].push_back(row[i]);

    return rotated;
  }
};",18,1251,0.0,-1.0,6.0,5.0,69.5,28.0,0.6450000000000014
719.0,"class Solution {
 public:
  int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
    int ans = 0;
    int l = -1;
    int r = -1;

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] > right)  // Handle reset value
        l = i;
      if (nums[i] >= left)  // Handle reset and needed value
        r = i;
      ans += r - l;
    }

    return ans;
  }
};",10,380,2.0,3.0,3.0,3.0,38.0,9.0,5.4
720.0,"class Solution {
 public:
  bool rotateString(string A, string B) {
    return A.length() == B.length() && (A + A).find(B) != string::npos;
  }
};",2,146,0.0,0.0,2.0,0.0,73.0,5.0,2.8100000000000005
721.0,"class Solution {
 public:
  vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
    vector<vector<int>> ans;
    dfs(graph, 0, {0}, ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, vector<int>&& path,
           vector<vector<int>>& ans) {
    if (u == graph.size() - 1) {
      ans.push_back(path);
      return;
    }

    for (const int v : graph[u]) {
      path.push_back(v);
      dfs(graph, v, move(path), ans);
      path.pop_back();
    }
  }
};",9,513,0.0,1.0,6.0,2.0,57.0,12.0,3.25
722.0,"class Solution {
 public:
  int bestRotation(vector<int>& nums) {
    const int n = nums.size();
    // rotate[i] := how many points losing after rotating left i times
    vector<int> rotate(n);

    // Rotating i - nums[i] times makes nums[i] == its new index.
    // So, rotating i - nums[i] + 1 times will ""start"" to make nums[i] > its
    // index, Which is the starting index to lose point
    for (int i = 0; i < n; ++i)
      --rotate[(i - nums[i] + 1 + n) % n];

    // Each time we rotate, we make index 0 to index n - 1, so we get 1 point.
    for (int i = 1; i < n; ++i)
      rotate[i] += rotate[i - 1] + 1;

    return distance(begin(rotate), max_element(begin(rotate), end(rotate)));
  }
};",10,704,5.0,2.0,2.0,2.0,70.4,8.0,2.824
723.0,"class Solution {
 public:
  double champagneTower(int poured, int query_row, int query_glass) {
    vector<vector<double>> dp(query_row + 1, vector<double>(query_row + 1));
    dp[0][0] = poured;

    for (int i = 0; i < query_row; ++i)
      for (int j = 0; j <= i; ++j)
        if (dp[i][j] > 1) {
          dp[i + 1][j] += (dp[i][j] - 1) / 2.0;
          dp[i + 1][j + 1] += (dp[i][j] - 1) / 2.0;
        }

    return min(1.0, dp[query_row][query_glass]);
  }
};",10,466,0.0,3.0,3.0,3.0,46.6,9.0,4.546
724.0,"class Solution {
 public:
  int minSwap(vector<int>& nums1, vector<int>& nums2) {
    vector<int> keepAt(nums1.size(), INT_MAX);
    vector<int> swapAt(nums1.size(), INT_MAX);
    keepAt[0] = 0;
    swapAt[0] = 1;

    for (int i = 1; i < nums1.size(); ++i) {
      if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {
        keepAt[i] = keepAt[i - 1];
        swapAt[i] = swapAt[i - 1] + 1;
      }
      if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {
        keepAt[i] = min(keepAt[i], swapAt[i - 1]);
        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1);
      }
    }

    return min(keepAt.back(), swapAt.back());
  }
};",12,643,0.0,3.0,5.0,3.0,53.583333333333336,7.0,3.997500000000001
725.0,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
    vector<int> ans;
    vector<State> state(graph.size());

    for (int i = 0; i < graph.size(); ++i)
      if (!hasCycle(graph, i, state))
        ans.push_back(i);

    return ans;
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state) {
    if (state[u] == State::kVisiting)
      return true;
    if (state[u] == State::kVisited)
      return false;

    state[u] = State::kVisiting;
    for (const int v : graph[u])
      if (hasCycle(graph, v, state))
        return true;
    state[u] = State::kVisited;

    return false;
  }
};",14,715,0.0,2.0,4.0,6.0,51.07142857142857,12.0,3.843571428571429
726.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), sz(n, 1) {
    iota(begin(id), end(id), 0);
  }

  void unionBySize(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (sz[i] < sz[j]) {
      sz[j] += sz[i];
      id[i] = j;
    } else {
      sz[i] += sz[j];
      id[j] = i;
    }
  }

  int getStableSize() {
    // Bricks connected with 0 (top) are stable
    return sz[find(0)];
  }

 private:
  vector<int> id;
  vector<int> sz;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
    m = grid.size();
    n = grid[0].size();

    UnionFind uf(m * n + 1);  // 0 := top (stable)

    // Mark cells to hit as 2
    for (const vector<int>& hit : hits) {
      const int i = hit[0];
      const int j = hit[1];
      if (grid[i][j] == 1)
        grid[i][j] = 2;
    }

    // Union all 1s
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)
          unionNeighbors(grid, uf, i, j);

    vector<int> ans(hits.size());
    int stableSize = uf.getStableSize();

    for (int i = hits.size() - 1; i >= 0; --i) {
      const int x = hits[i][0];
      const int y = hits[i][1];
      if (grid[x][y] == 2) {  // Cells marked from 1 to 2
        grid[x][y] = 1;       // Unhit, restore back to 1
        unionNeighbors(grid, uf, x, y);
        const int newStableSize = uf.getStableSize();
        if (newStableSize > stableSize)
          ans[i] = newStableSize - stableSize - 1;  // 1 := the hit cell
        stableSize = newStableSize;
      }
    }

    return ans;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};
  int m;
  int n;

  void unionNeighbors(const vector<vector<int>>& grid, UnionFind& uf, int i,
                      int j) {
    const int hashed = hash(i, j);

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k];
      const int y = j + dirs[k + 1];
      if (x < 0 || x == m || y < 0 || y == n)
        continue;
      if (grid[x][y] != 1)
        continue;
      uf.unionBySize(hashed, hash(x, y));
    }

    if (i == 0)
      uf.unionBySize(hashed, 0);
  }

  int hash(int i, int j) {
    return i * n + j + 1;
  }
};",50,2297,7.0,9.0,16.0,14.0,45.94,54.0,-0.7546000000000035
727.0,"class Solution {
 public:
  int uniqueMorseRepresentations(vector<string>& words) {
    const vector<string> morse{
        "".-"",   ""-..."", ""-.-."", ""-.."",  ""."",   ""..-."", ""--."",  ""...."", "".."",
        "".---"", ""-.-"",  "".-.."", ""--"",   ""-."",  ""---"",  "".--."", ""--.-"", "".-."",
        ""..."",  ""-"",    ""..-"",  ""...-"", "".--"", ""-..-"", ""-.--"", ""--..""};
    unordered_set<string> transformations;

    for (const string& word : words) {
      string transformation;
      for (const char c : word)
        transformation += morse[c - 'a'];
      transformations.insert(transformation);
    }

    return transformations.size();
  }
};",7,623,0.0,2.0,4.0,8.0,89.0,11.0,0.5300000000000011
728.0,"class Solution {
 public:
  bool splitArraySameAverage(vector<int>& nums) {
    const int n = nums.size();
    const int sum = accumulate(begin(nums), end(nums), 0);
    if (!isPossible(sum, n))
      return false;

    vector<unordered_set<int>> sums(n / 2 + 1);
    sums[0].insert(0);

    for (const int num : nums)
      for (int i = n / 2; i > 0; --i)
        for (const int val : sums[i - 1])
          sums[i].insert(num + val);

    for (int i = 1; i < n / 2 + 1; ++i)
      if (i * sum % n == 0 && sums[i].count(i * sum / n))
        return true;

    return false;
  }

 private:
  bool isPossible(int sum, int n) {
    for (int i = 1; i < n / 2 + 1; ++i)
      if (i * sum % n == 0)
        return true;
    return false;
  }
};",17,739,0.0,4.0,3.0,8.0,43.47058823529412,18.0,3.86764705882353
729.0,"class Solution {
 public:
  int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    vector<int> rowMax(n);
    vector<int> colMax(n);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        rowMax[i] = max(rowMax[i], grid[i][j]);
        colMax[j] = max(colMax[j], grid[i][j]);
      }

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        ans += min(rowMax[i], colMax[j]) - grid[i][j];

    return ans;
  }
};",17,507,0.0,4.0,3.0,4.0,29.823529411764707,12.0,5.695882352941176
730.0,"class Solution {
 public:
  double soupServings(int n) {
    return n >= 4800 ? 1.0 : dfs((n + 24) / 25, (n + 24) / 25);
  }

 private:
  vector<vector<double>> memo =
      vector<vector<double>>(4800 / 25, vector<double>(4800 / 25));

  double dfs(int a, int b) {
    if (a <= 0 && b <= 0)
      return 0.5;
    if (a <= 0)
      return 1.0;
    if (b <= 0)
      return 0.0;
    if (memo[a][b] > 0)
      return memo[a][b];
    return memo[a][b] = 0.25 * (dfs(a - 4, b) + dfs(a - 3, b - 1) +
                                dfs(a - 2, b - 2) + dfs(a - 1, b - 3));
  }
};",8,573,0.0,-1.0,3.0,4.0,71.625,9.0,2.5337499999999995
731.0,"class Solution {
 public:
  int expressiveWords(string s, vector<string>& words) {
    int ans = 0;

    for (const string& word : words)
      if (isStretchy(s, word))
        ++ans;

    return ans;
  }

 private:
  bool isStretchy(const string& s, const string& word) {
    const int n = s.length();
    const int m = word.length();

    int j = 0;
    for (int i = 0; i < n; ++i)
      if (j < m && s[i] == word[j])
        ++j;
      else if (i > 1 && s[i] == s[i - 1] && s[i - 1] == s[i - 2])
        continue;
      else if (0 < i && i + 1 < n && s[i - 1] == s[i] && s[i] == s[i + 1])
        continue;
      else
        return false;

    return j == m;
  }
};",14,669,0.0,5.0,3.0,6.0,47.785714285714285,18.0,3.419285714285716
732.0,"class Solution {
 public:
  bool xorGame(vector<int>& nums) {
    const int xors = accumulate(begin(nums), end(nums), 0, bit_xor<int>());
    return xors == 0 || nums.size() % 2 == 0;
  }
};",3,190,0.0,0.0,2.0,0.0,63.333333333333336,6.0,3.579999999999999
733.0,"class Solution {
 public:
  vector<string> subdomainVisits(vector<string>& cpdomains) {
    vector<string> ans;
    unordered_map<string, int> count;

    for (const string& cpdomain : cpdomains) {
      const int space = cpdomain.find(' ');
      const int num = stoi(cpdomain.substr(0, space));
      const string& domain = cpdomain.substr(space + 1);
      count[domain] += num;
      for (int i = 0; i < domain.length(); ++i)
        if (domain[i] == '.')
          count[domain.substr(i + 1)] += num;
    }

    for (const auto& [subdomain, freq] : count)
      ans.push_back(to_string(freq) + ' ' + subdomain);

    return ans;
  }
};",12,640,0.0,4.0,3.0,4.0,53.333333333333336,16.0,3.18
734.0,"class Solution {
 public:
  double largestTriangleArea(vector<vector<int>>& points) {
    double ans = 0;

    for (const vector<int>& A : points)
      for (const vector<int>& B : points)
        for (const vector<int>& C : points)
          ans = max(ans, 0.5 * abs((B[0] - A[0]) * (C[1] - A[1]) -
                                   (C[0] - A[0]) * (B[1] - A[1])));

    return ans;
  }
};",4,391,0.0,3.0,2.0,3.0,97.75,10.0,-0.0974999999999983
735.0,"class Solution {
 public:
  double largestSumOfAverages(vector<int>& nums, int K) {
    const int n = nums.size();
    // dp[i][k] := largest score to partition first i nums into k groups
    dp.resize(n + 1, vector<double>(K + 1));
    prefix.resize(n + 1);

    partial_sum(begin(nums), end(nums), begin(prefix) + 1);
    return largestSumOfAverages(nums, n, K);
  }

 private:
  vector<vector<double>> dp;
  vector<double> prefix;

  double largestSumOfAverages(const vector<int>& A, int i, int k) {
    if (k == 1)
      return prefix[i] / i;
    if (dp[i][k])
      return dp[i][k];

    // Try all possible partitions
    for (int j = k - 1; j < i; ++j)
      dp[i][k] = max(dp[i][k], largestSumOfAverages(A, j, k - 1) +
                                   (prefix[i] - prefix[j]) / (i - j));

    return dp[i][k];
  }
};",14,826,2.0,0.0,3.0,3.0,59.0,15.0,3.0900000000000007
736.0,"class Solution {
 public:
  TreeNode* pruneTree(TreeNode* root) {
    if (root == nullptr)
      return nullptr;
    root->left = pruneTree(root->left);
    root->right = pruneTree(root->right);
    if (root->left == nullptr && root->right == nullptr && root->val == 0)
      return nullptr;
    return root;
  }
};",6,315,0.0,0.0,2.0,2.0,52.5,1.0,5.055000000000001
737.0,"class Solution {
 public:
  int numBusesToDestination(vector<vector<int>>& routes, int source,
                            int target) {
    if (source == target)
      return 0;

    unordered_map<int, vector<int>> graph;  // {route: [buses]}
    unordered_set<int> usedBuses;

    for (int i = 0; i < routes.size(); ++i)
      for (const int route : routes[i])
        graph[route].push_back(i);

    int ans = 0;
    queue<int> q{{source}};

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const int route = q.front();
        q.pop();
        for (const int bus : graph[route])
          if (usedBuses.insert(bus).second)
            for (const int nextRoute : routes[bus]) {
              if (nextRoute == target)
                return ans;
              q.push(nextRoute);
            }
      }
    }

    return -1;
  }
};",17,874,1.0,7.0,8.0,9.0,51.41176470588236,20.0,2.512941176470588
738.0,"class Solution {
 public:
  vector<string> ambiguousCoordinates(string s) {
    vector<string> ans;
    s = s.substr(1, s.length() - 2);

    for (int i = 1; i < s.length(); ++i)
      for (const string& x : splits(s.substr(0, i)))
        for (const string& y : splits(s.substr(i)))
          ans.push_back('(' + x + "", "" + y + ')');

    return ans;
  }

 private:
  vector<string> splits(const string& s) {
    if (s.empty() || s.length() > 1 && s.front() == '0' && s.back() == '0')
      return {};
    if (s.back() == '0')
      return {s};
    if (s.front() == '0')
      return {""0."" + s.substr(1)};

    vector<string> candidates{s};
    for (int i = 1; i < s.length(); ++i)
      candidates.push_back(s.substr(0, i) + '.' + s.substr(i));
    return candidates;
  }
};",15,776,0.0,3.0,7.0,7.0,51.73333333333333,14.0,3.3440000000000003
739.0,"class Solution {
 public:
  int numComponents(ListNode* head, vector<int>& nums) {
    int ans = 0;
    unordered_set<int> setNums{begin(nums), end(nums)};

    for (; head; head = head->next)
      if (setNums.count(head->val) &&
          (!head->next || !setNums.count(head->next->val)))
        ++ans;

    return ans;
  }
};",7,329,0.0,2.0,3.0,2.0,47.0,5.0,4.970000000000001
740.0,"class Solution {
 public:
  int racecar(int target) {
    dp.resize(target + 1, -1);
    return rc(target);
  }

 private:
  vector<int> dp;

  int rc(int i) {
    if (dp[i] >= 0)
      return dp[i];

    int ans = INT_MAX;
    int x = 1;             // XA: (2^x - 1) unit distance
    int j = (1 << x) - 1;  // J = 2^x - 1, k = 2^y - 1

    // (xA + 1R) + (yA + 1R) + rc(i - (j - k))
    for (; j < i; j = (1 << ++x) - 1)
      for (int y = 0, k = 0; k < j; k = (1 << ++y) - 1)
        ans = min(ans, (x + 1) + (y + 1) + rc(i - (j - k)));

    // XA || (xA + 1R) + rc(j - i)
    ans = min(ans, i == j ? x : x + 1 + rc(j - i));
    return dp[i] = ans;
  }
};",15,658,4.0,1.0,3.0,3.0,43.86666666666667,10.0,4.972
741.0,"class Solution {
 public:
  string mostCommonWord(string paragraph, vector<string>& banned) {
    string ans;
    int maxCount = 0;
    unordered_map<string, int> count;
    unordered_set<string> bannedSet{begin(banned), end(banned)};

    // Make paragraph to lowercase and empty punctuations
    for (char& c : paragraph)
      c = isalpha(c) ? tolower(c) : ' ';

    istringstream iss(paragraph);

    for (string word; iss >> word;)
      if (!bannedSet.count(word))
        ++count[word];

    for (const auto& [word, freq] : count)
      if (freq > maxCount) {
        maxCount = freq;
        ans = word;
      }

    return ans;
  }
};",13,643,1.0,5.0,4.0,5.0,49.46153846153846,12.0,3.848461538461539
742.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int depth = 0;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  int minimumLengthEncoding(vector<string>& words) {
    int ans = 0;
    shared_ptr<TrieNode> root = make_shared<TrieNode>();
    vector<shared_ptr<TrieNode>> heads;

    for (const string& word : unordered_set<string>(begin(words), end(words)))
      heads.push_back(insert(root, word));

    for (shared_ptr<TrieNode> head : heads)
      if (all_of(begin(head->children), end(head->children),
                 [](const auto& child) { return child == nullptr; }))
        ans += head->depth + 1;

    return ans;
  }

 private:
  shared_ptr<TrieNode> insert(shared_ptr<TrieNode> root, const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : string(rbegin(word), rend(word))) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->depth = word.length();
    return node;
  }
};",17,1060,0.0,3.0,7.0,5.0,62.35294117647059,17.0,2.088235294117648
743.0,"class Solution {
 public:
  int flipgame(vector<int>& fronts, vector<int>& backs) {
    int ans = 2001;
    unordered_set<int> same;

    for (int i = 0; i < fronts.size(); ++i)
      if (fronts[i] == backs[i])
        same.insert(fronts[i]);

    for (const int f : fronts)
      if (!same.count(f))
        ans = min(ans, f);

    for (const int b : backs)
      if (!same.count(b))
        ans = min(ans, b);

    return ans == 2001 ? 0 : ans;
  }
};",9,453,0.0,6.0,2.0,6.0,50.333333333333336,11.0,3.889999999999999
744.0,"class Solution {
 public:
  int numFactoredBinaryTrees(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    // dp[i] := # of binary trees with arr[i] as root
    vector<long> dp(n, 1);
    unordered_map<int, int> numToIndex;

    sort(begin(arr), end(arr));

    for (int i = 0; i < n; ++i)
      numToIndex[arr[i]] = i;

    for (int i = 0; i < n; ++i)  // arr[i] is root
      for (int j = 0; j < i; ++j)
        if (arr[i] % arr[j] == 0) {  // arr[j] is left subtree
          const int right = arr[i] / arr[j];
          if (const auto it = numToIndex.find(right); it != cend(numToIndex)) {
            dp[i] += dp[j] * dp[it->second];
            dp[i] %= kMod;
          }
        }

    return accumulate(begin(dp), end(dp), 0L) % kMod;
  }
};",18,791,3.0,5.0,4.0,5.0,43.94444444444444,14.0,4.2250000000000005
745.0,"class Solution {
 public:
  string toGoatLatin(string s) {
    string ans;
    const unordered_set<char> vowels{'a', 'e', 'i', 'o', 'u',
                                     'A', 'E', 'I', 'O', 'U'};
    istringstream iss(s);
    string word;
    int i = 1;

    while (iss >> word) {
      if (i > 1)
        ans += ' ';
      if (vowels.count(word[0]))
        ans += word;
      else
        ans += word.substr(1) + word[0];
      ans += ""ma"" + string(i++, 'a');
    }

    return ans;
  }
};",11,495,0.0,4.0,4.0,3.0,45.0,9.0,4.569999999999999
746.0,"class Solution {
 public:
  int numFriendRequests(vector<int>& ages) {
    int ans = 0;
    unordered_map<int, int> count;

    for (const int age : ages)
      ++count[age];

    for (const auto& [ageA, countA] : count)
      for (const auto& [ageB, countB] : count)
        if (request(ageA, ageB))
          if (ageA == ageB)
            ans += countA * (countB - 1);
          else
            ans += countA * countB;

    return ans;
  }

 private:
  bool request(int ageA, int ageB) {
    return !(ageB <= 0.5 * ageA + 7 || ageB > ageA || ageB > 100 && ageA < 100);
  }
};",8,578,0.0,5.0,3.0,5.0,72.25,13.0,1.7175000000000011
747.0,"class Solution {
 public:
  int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit,
                          vector<int>& worker) {
    int ans = 0;
    vector<pair<int, int>> jobs;

    for (int i = 0; i < difficulty.size(); ++i)
      jobs.emplace_back(difficulty[i], profit[i]);

    sort(begin(jobs), end(jobs));
    sort(begin(worker), end(worker));

    int i = 0;
    int maxProfit = 0;

    for (const int w : worker) {
      for (; i < jobs.size() && w >= jobs[i].first; ++i)
        maxProfit = max(maxProfit, jobs[i].second);
      ans += maxProfit;
    }

    return ans;
  }
};",15,605,0.0,3.0,3.0,6.0,40.333333333333336,13.0,4.710000000000001
748.0,"class Solution {
 public:
  int largestIsland(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int maxSize = 0;
    // sizes[i] := size of i-th connected component (start from 2)
    vector<int> sizes{0, 0};

    // For each 1 in the grid, paint all connected 1 with the next available
    // Color (2, 3, and so on). Also, remember the size of the island we just
    // Painted with that color.
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1)
          sizes.push_back(paint(grid, i, j, sizes.size()));  // Paint 2, 3, ...

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0) {
          const unordered_set<int> neighborIds{
              getId(grid, i + 1, j), getId(grid, i - 1, j),
              getId(grid, i, j + 1), getId(grid, i, j - 1)};
          maxSize = max(maxSize, 1 + getSize(neighborIds, sizes));
        }

    return maxSize == 0 ? m * n : maxSize;
  }

 private:
  int paint(vector<vector<int>>& grid, int i, int j, int id) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;
    if (grid[i][j] != 1)
      return 0;

    grid[i][j] = id;  // grid[i][j] is part of id-th connected component

    return 1 + paint(grid, i + 1, j, id) + paint(grid, i - 1, j, id) +
           paint(grid, i, j + 1, id) + paint(grid, i, j - 1, id);
  }

  // Get the id of grid[i][j], return 0 if out of bound
  int getId(const vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return 0;  // Invalid
    return grid[i][j];
  }

  int getSize(const unordered_set<int>& neighborIds, const vector<int>& sizes) {
    int size = 0;
    for (const int neighborId : neighborIds)
      size += sizes[neighborId];
    return size;
  }
};",26,1867,8.0,4.0,8.0,12.0,71.8076923076923,33.0,-0.1626923076923088
749.0,"class Solution {
 public:
  int uniqueLetterString(string s) {
    int ans = 0;
    int count = 0;
    vector<int> lastCount(26);
    vector<int> lastSeen(26, -1);

    for (int i = 0; i < s.length(); ++i) {
      const int c = s[i] - 'A';
      const int currentCount = i - lastSeen[c];
      count = count - lastCount[c] + currentCount;
      lastCount[c] = currentCount;
      lastSeen[c] = i;
      ans += count;
    }

    return ans;
  }
};",14,446,0.0,1.0,3.0,1.0,31.857142857142858,12.0,5.692857142857144
750.0,"class Solution {
 public:
  int consecutiveNumbersSum(int n) {
    int ans = 0;
    for (int i = 1, triangleNum = i; triangleNum <= n; ++i, triangleNum += i)
      if ((n - triangleNum) % i == 0)
        ++ans;
    return ans;
  }
};",6,233,0.0,2.0,2.0,2.0,38.833333333333336,5.0,5.765
751.0,"class Solution {
 public:
  vector<vector<int>> largeGroupPositions(string s) {
    const int n = s.length();
    vector<vector<int>> ans;

    for (int i = 0, j = 0; i < n; i = j) {
      while (j < n && s[j] == s[i])
        ++j;
      if (j - i >= 3)
        ans.push_back({i, j - 1});
    }

    return ans;
  }
};",8,318,0.0,3.0,4.0,3.0,39.75,7.0,5.3025
752.0,"class Solution {
 public:
  string maskPII(string s) {
    const int atIndex = s.find('@');
    if (atIndex != string::npos) {
      transform(begin(s), end(s), begin(s), ::tolower);
      return s.substr(0, 1) + ""*****"" + s.substr(atIndex - 1);
    }

    string ans;
    for (const char c : s)
      if (isdigit(c))
        ans += c;

    if (ans.length() == 10)
      return ""***-***-"" + ans.substr(ans.length() - 4);
    return '+' + string(ans.length() - 10, '*') + ""-***-***-"" +
           ans.substr(ans.length() - 4);
  }
};",8,532,0.0,2.0,3.0,5.0,66.5,10.0,2.7150000000000007
753.0,"class Solution {
 public:
  vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {
    const int n = A.size();

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < (n + 1) / 2; ++j) {
        const int temp = A[i][j];
        A[i][j] = A[i][n - j - 1] ^ 1;
        A[i][n - j - 1] = temp ^ 1;
      }

    return A;
  }
};",10,338,0.0,2.0,3.0,2.0,33.8,9.0,5.758
754.0,"class Solution {
 public:
  string findReplaceString(string s, vector<int>& indices,
                           vector<string>& sources, vector<string>& targets) {
    vector<pair<int, int>> sortedIndices;

    for (int i = 0; i < indices.size(); ++i)
      sortedIndices.emplace_back(indices[i], i);

    sort(rbegin(sortedIndices), rend(sortedIndices));

    for (const auto& [index, i] : sortedIndices) {
      const string& source = sources[i];
      const string& target = targets[i];
      if (s.substr(index, source.length()) == source)
        s = s.substr(0, index) + target + s.substr(index + source.length());
    }

    return s;
  }
};",10,648,0.0,3.0,3.0,3.0,64.8,14.0,2.4080000000000004
755.0,"class Solution {
 public:
  vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
    vector<int> ans(n);
    vector<int> count(n, 1);
    vector<unordered_set<int>> tree(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].insert(v);
      tree[v].insert(u);
    }

    postorder(tree, 0, -1, count, ans);
    preorder(tree, 0, -1, count, ans);
    return ans;
  }

 private:
  void postorder(const vector<unordered_set<int>>& tree, int node, int parent,
                 vector<int>& count, vector<int>& ans) {
    for (const int child : tree[node]) {
      if (child == parent)
        continue;
      postorder(tree, child, node, count, ans);
      count[node] += count[child];
      ans[node] += ans[child] + count[child];
    }
  }

  void preorder(const vector<unordered_set<int>>& tree, int node, int parent,
                vector<int>& count, vector<int>& ans) {
    for (const int child : tree[node]) {
      if (child == parent)
        continue;
      // count[child] nodes are 1 step closer from child than parent
      // (n - count[child]) nodes are 1 step farther from child than parent
      ans[child] = ans[node] - count[child] + (tree.size() - count[child]);
      preorder(tree, child, node, count, ans);
    }
  }
};",18,1323,2.0,3.0,7.0,5.0,73.5,31.0,-0.2349999999999994
756.0,"class Solution {
 public:
  int largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B) {
    const int n = A.size();
    const int magic = 100;
    int ans = 0;
    vector<pair<int, int>> onesA;
    vector<pair<int, int>> onesB;
    unordered_map<int, int> map;

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        if (A[i][j] == 1)
          onesA.emplace_back(i, j);
        if (B[i][j] == 1)
          onesB.emplace_back(i, j);
      }

    for (const pair<int, int>& a : onesA)
      for (const pair<int, int>& b : onesB)
        ++map[(a.first - b.first) * magic + (a.second - b.second)];

    for (const auto& [_, value] : map)
      ans = max(ans, value);

    return ans;
  }
};",16,718,0.0,7.0,3.0,7.0,44.875,24.0,2.96125
757.0,"class Solution {
 public:
  bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
    return rec1[0] < rec2[2] && rec2[0] < rec1[2] &&  //
           rec1[1] < rec2[3] && rec2[1] < rec1[3];
  }
};",2,206,1.0,0.0,2.0,0.0,103.0,4.0,0.25
758.0,"class Solution {
 public:
  double new21Game(int n, int k, int maxPts) {
    // When the game ends, the point is in [k..k - 1 + maxPts]
    //   P = 1, if n >= k - 1 + maxPts
    //   P = 0, if n < k (note the constraints already have k <= n)
    if (k == 0 || n >= k - 1 + maxPts)
      return 1.0;

    double ans = 0.0;
    vector<double> dp(n + 1);  // dp[i] := prob to have i points
    dp[0] = 1.0;
    double windowSum = dp[0];  // P(i - 1) + P(i - 2) + ... + P(i - maxPts)

    for (int i = 1; i <= n; ++i) {
      // The prob to get point i is
      // P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts
      dp[i] = windowSum / maxPts;
      if (i < k)
        windowSum += dp[i];
      else  // The game ends
        ans += dp[i];
      if (i - maxPts >= 0)
        windowSum -= dp[i - maxPts];
    }

    return ans;
  }
};",13,845,8.0,6.0,3.0,6.0,65.0,9.0,3.03
759.0,"class Solution {
 public:
  string pushDominoes(string dominoes) {
    int L = -1;
    int R = -1;

    for (int i = 0; i <= dominoes.length(); ++i)
      if (i == dominoes.length() || dominoes[i] == 'R') {
        if (L < R)
          while (R < i)
            dominoes[R++] = 'R';
        R = i;
      } else if (dominoes[i] == 'L') {
        if (R < L || L == -1 && R == -1) {
          if (L == -1 && R == -1)
            ++L;
          while (L < i)
            dominoes[L++] = 'L';
        } else {
          int l = R + 1;
          int r = i - 1;
          while (l < r) {
            dominoes[l++] = 'R';
            dominoes[r--] = 'L';
          }
        }
        L = i;
      }

    return dominoes;
  }
};",15,720,0.0,11.0,7.0,9.0,48.0,8.0,3.8
760.0,"class Solution {
 public:
  int numSimilarGroups(vector<string>& A) {
    int ans = 0;
    vector<bool> seen(A.size());

    for (int i = 0; i < A.size(); ++i)
      if (!seen[i]) {
        dfs(A, i, seen);
        ++ans;
      }

    return ans;
  }

 private:
  // Dfs on string A[i]
  void dfs(const vector<string>& A, int i, vector<bool>& seen) {
    seen[i] = true;
    for (int j = 0; j < A.size(); ++j)
      if (!seen[j] && isSimilar(A[i], A[j]))
        dfs(A, j, seen);
  }

  bool isSimilar(const string& X, const string& Y) {
    int diff = 0;
    for (int i = 0; i < X.length(); ++i)
      if (X[i] != Y[i] && ++diff > 2)
        return false;
    return true;
  }
};",17,680,1.0,4.0,5.0,8.0,40.0,20.0,3.9
761.0,"class Solution {
 public:
  int numMagicSquaresInside(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i + 2 < grid.size(); ++i)
      for (int j = 0; j + 2 < grid[0].size(); ++j)
        if (grid[i][j] % 2 == 0 && grid[i + 1][j + 1] == 5)
          ans += isMagic(grid, i, j);

    return ans;
  }

 private:
  int isMagic(const vector<vector<int>>& grid, int i, int j) {
    string s;

    for (const int num : {0, 1, 2, 5, 8, 7, 6, 3})
      s += to_string(grid[i + num / 3][j + num % 3]);

    return string(""4381672943816729"").find(s) != string::npos ||
           string(""9276183492761834"").find(s) != string::npos;
  }
};",11,646,0.0,3.0,4.0,4.0,58.72727272727273,18.0,2.494545454545455
762.0,"class Solution {
 public:
  bool canVisitAllRooms(vector<vector<int>>& rooms) {
    vector<bool> seen(rooms.size());
    dfs(rooms, 0, seen);
    return all_of(begin(seen), end(seen), [](int s) { return s == true; });
  }

 private:
  void dfs(const vector<vector<int>>& rooms, int node, vector<bool>& seen) {
    seen[node] = true;
    for (const int child : rooms[node])
      if (!seen[child])
        dfs(rooms, child, seen);
  }
};",7,436,0.0,1.0,4.0,2.0,62.285714285714285,12.0,2.894285714285715
763.0,"class Solution {
 public:
  vector<int> splitIntoFibonacci(string num) {
    vector<int> ans;
    dfs(num, 0, ans);
    return ans;
  }

 private:
  bool dfs(const string& num, int s, vector<int>& ans) {
    if (s == num.length() && ans.size() >= 3)
      return true;

    for (int i = s; i < num.length(); ++i) {
      if (num[s] == '0' && i > s)
        break;
      const long val = stol(num.substr(s, i + 1 - s));
      if (val > INT_MAX)
        break;
      if (ans.size() >= 2 &&
          val > ans[ans.size() - 2] + static_cast<long>(ans.back()))
        break;
      if (ans.size() <= 1 ||
          val == ans[ans.size() - 2] + static_cast<long>(ans.back())) {
        ans.push_back(val);
        if (dfs(num, i + 1, ans))
          return true;
        ans.pop_back();
      }
    }

    return false;
  }
};",15,821,0.0,1.0,5.0,7.0,54.73333333333333,11.0,3.6140000000000008
764.0,"/**
 * // This is the Master's API interface.
 * // You should not implement it, or speculate about its implementation
 * class Master {
 *  public:
 *   int guess(string word);
 * };
 */
class Solution {
 public:
  void findSecretWord(vector<string>& wordlist, Master& master) {
    srand(time(nullptr));  // Required

    for (int i = 0; i < 10; ++i) {
      const string& guessedWord = wordlist[rand() % wordlist.size()];
      const int matches = master.guess(guessedWord);
      if (matches == 6)
        break;
      vector<string> updated;
      for (const string& word : wordlist)
        if (getMatches(guessedWord, word) == matches)
          updated.push_back(word);
      wordlist = move(updated);
    }
  }

 private:
  int getMatches(const string& s1, const string& s2) {
    int matches = 0;
    for (int i = 0; i < s1.length(); ++i)
      if (s1[i] == s2[i])
        ++matches;
    return matches;
  }
};",17,920,2.0,5.0,5.0,6.0,54.11764705882353,21.0,2.5094117647058827
765.0,"class Solution {
 public:
  bool backspaceCompare(string s, string t) {
    return backspace(s) == backspace(t);
  }

 private:
  string backspace(const string& s) {
    string stack;
    for (const char c : s)
      if (c != '#')
        stack.push_back(c);
      else if (!stack.empty())
        stack.pop_back();
    return stack;
  }
};",6,340,0.0,3.0,3.0,3.0,56.66666666666666,10.0,3.540000000000001
766.0,"class Solution {
 public:
  int longestMountain(vector<int>& arr) {
    int ans = 0;

    for (int i = 0; i + 1 < arr.size();) {
      while (i + 1 < arr.size() && arr[i] == arr[i + 1])
        ++i;

      int increasing = 0;
      int decreasing = 0;

      while (i + 1 < arr.size() && arr[i] < arr[i + 1]) {
        ++increasing;
        ++i;
      }

      while (i + 1 < arr.size() && arr[i] > arr[i + 1]) {
        ++decreasing;
        ++i;
      }

      if (increasing > 0 && decreasing > 0)
        ans = max(ans, increasing + decreasing + 1);
    }

    return ans;
  }
};",13,583,0.0,5.0,5.0,5.0,44.84615384615385,7.0,4.663846153846154
767.0,"class Solution {
 public:
  bool isNStraightHand(vector<int>& hand, int groupSize) {
    map<int, int> count;

    for (const int card : hand)
      ++count[card];

    for (const auto& [start, _] : count) {
      const int value = count[start];
      if (value > 0)
        for (int i = start; i < start + groupSize; ++i) {
          count[i] -= value;
          if (count[i] < 0)
            return false;
        }
    }

    return true;
  }
};",9,448,0.0,4.0,4.0,5.0,49.77777777777778,12.0,3.84
768.0,"class Solution {
 public:
  int shortestPathLength(vector<vector<int>>& graph) {
    const int n = graph.size();
    const int goal = (1 << n) - 1;

    int ans = 0;
    queue<pair<int, int>> q;  // (u, state)
    vector<vector<bool>> seen(n, vector<bool>(1 << n));

    for (int i = 0; i < n; ++i)
      q.emplace(i, 1 << i);

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [u, state] = q.front();
        q.pop();
        if (state == goal)
          return ans;
        if (seen[u][state])
          continue;
        seen[u][state] = true;
        for (const int v : graph[u])
          q.emplace(v, state | (1 << v));
      }
      ++ans;
    }

    return -1;
  }
};",19,715,1.0,4.0,4.0,6.0,37.63157894736842,17.0,4.473157894736842
769.0,"class Solution {
 public:
  string shiftingLetters(string s, vector<int>& shifts) {
    string ans;

    for (int i = shifts.size() - 2; i >= 0; --i)
      shifts[i] = (shifts[i] + shifts[i + 1]) % 26;

    for (int i = 0; i < s.length(); ++i)
      ans += (s[i] - 'a' + shifts[i]) % 26 + 'a';

    return ans;
  }
};",9,317,0.0,2.0,2.0,9.0,35.22222222222222,7.0,5.89
770.0,"class Solution {
 public:
  int maxDistToClosest(vector<int>& seats) {
    const int n = seats.size();
    int ans = 0;
    int j = -1;

    for (int i = 0; i < n; ++i)
      if (seats[i] == 1) {
        ans = j == -1 ? i : max(ans, (i - j) / 2);
        j = i;
      }

    return max(ans, n - j - 1);
  }
};",9,309,0.0,2.0,3.0,2.0,34.333333333333336,8.0,5.81
771.0,"struct Event {
  int x;
  int y1;
  int y2;
  char type;
  Event(int x, int y1, int y2, char type) : x(x), y1(y1), y2(y2), type(type) {}
};

class Solution {
 public:
  int rectangleArea(vector<vector<int>>& rectangles) {
    constexpr int kMod = 1'000'000'007;

    vector<Event> events;

    for (const vector<int>& r : rectangles) {
      events.emplace_back(r[0], r[1], r[3], 's');
      events.emplace_back(r[2], r[1], r[3], 'e');
    }

    sort(begin(events), end(events),
         [](const auto& a, const auto& b) { return a.x < b.x; });

    long ans = 0;
    int prevX = 0;
    vector<pair<int, int>> yPairs;

    for (const auto& [currX, y1, y2, type] : events) {
      if (currX > prevX) {
        const int width = currX - prevX;
        ans = (ans + width * getHeight(yPairs)) % kMod;
        prevX = currX;
      }
      if (type == 's') {
        yPairs.emplace_back(y1, y2);
        sort(begin(yPairs), end(yPairs));
      } else {  // Type == 'e'
        const auto it =
            find(begin(yPairs), end(yPairs), pair<int, int>(y1, y2));
        yPairs.erase(it);
      }
    }

    return ans % kMod;
  }

 private:
  long getHeight(const vector<pair<int, int>>& yPairs) {
    int height = 0;
    int prevY = 0;

    for (const auto& [y1, y2] : yPairs) {
      prevY = max(prevY, y1);
      if (y2 > prevY) {
        height += y2 - prevY;
        prevY = y2;
      }
    }

    return height;
  }
};",29,1421,1.0,5.0,13.0,6.0,49.0,32.0,1.349999999999998
772.0,"class Solution {
 public:
  vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
    const int n = quiet.size();
    vector<int> ans(n, -1);
    vector<vector<int>> graph(n);

    for (const vector<int>& r : richer) {
      const int u = r[1];
      const int v = r[0];
      graph[u].push_back(v);
    }

    for (int i = 0; i < n; ++i)
      dfs(graph, i, quiet, ans);

    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, const vector<int>& quiet,
          vector<int>& ans) {
    if (ans[u] != -1)
      return ans[u];

    ans[u] = u;

    for (const int v : graph[u]) {
      const int res = dfs(graph, v, quiet, ans);
      if (quiet[res] < quiet[ans[u]])
        ans[u] = res;
    }

    return ans[u];
  }
};",16,769,0.0,3.0,5.0,5.0,48.0625,26.0,2.5943750000000003
773.0,"class Solution {
 public:
  int peakIndexInMountainArray(vector<int>& arr) {
    int l = 0;
    int r = arr.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (arr[m] >= arr[m + 1])
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",7,278,0.0,3.0,3.0,2.0,39.71428571428572,7.0,5.365714285714287
774.0,"struct Car {
  int pos;
  double time;  // Time to reach the target
};

class Solution {
 public:
  int carFleet(int target, vector<int>& position, vector<int>& speed) {
    int ans = 0;
    vector<Car> cars(position.size());

    for (int i = 0; i < position.size(); ++i)
      cars[i] = {position[i], (double)(target - position[i]) / speed[i]};

    sort(begin(cars), end(cars),
         [](const auto& a, const auto& b) { return a.pos > b.pos; });

    double maxTime = 0;  // The time of the slowest car to reach the target

    for (const Car& car : cars)
      // A car needs more time to reach the target, so it becomes slowest
      if (car.time > maxTime) {
        maxTime = car.time;
        ++ans;
      }

    return ans;
  }
};",15,741,3.0,2.0,6.0,3.0,49.4,15.0,3.694
775.0,"class Solution {
 public:
  int kSimilarity(string s1, string s2) {
    int ans = 0;
    queue<string> q{{s1}};
    unordered_set<string> seen{{s1}};

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        string curr = q.front();
        q.pop();
        if (curr == s2)
          return ans;
        for (const string& child : getChildren(curr, s2)) {
          if (seen.count(child))
            continue;
          q.push(child);
          seen.insert(child);
        }
      }
      ++ans;
    }

    return -1;
  }

 private:
  vector<string> getChildren(string& curr, const string& target) {
    vector<string> children;
    int i = 0;  // First index s.t. curr[i] != target[i]
    while (curr[i] == target[i])
      ++i;

    for (int j = i + 1; j < curr.length(); ++j)
      if (curr[j] == target[i]) {
        swap(curr[i], curr[j]);
        children.push_back(curr);
        swap(curr[i], curr[j]);
      }

    return children;
  }
};",23,970,1.0,5.0,11.0,8.0,42.17391304347826,18.0,3.4843478260869567
776.0,"class Solution {
 public:
  int scoreOfParentheses(string s) {
    int ans = 0;
    int layer = 0;

    for (int i = 0; i + 1 < s.length(); ++i) {
      const char a = s[i];
      const char b = s[i + 1];
      if (a == '(' && b == ')')
        ans += 1 << layer;
      layer += a == '(' ? 1 : -1;
    }

    return ans;
  }
};",10,327,0.0,2.0,3.0,2.0,32.7,10.0,5.757
777.0,"class Solution {
 public:
  double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {
    double ans = DBL_MAX;
    int qualitySum = 0;
    // (wagePerQuality, quality) sorted by wagePerQuality
    vector<pair<double, int>> workers;
    priority_queue<int> maxHeap;

    for (int i = 0; i < quality.size(); ++i)
      workers.emplace_back((double)wage[i] / quality[i], quality[i]);

    sort(begin(workers), end(workers));

    for (const auto& [wagePerQuality, q] : workers) {
      maxHeap.push(q);
      qualitySum += q;
      if (maxHeap.size() > k)
        qualitySum -= maxHeap.top(), maxHeap.pop();
      if (maxHeap.size() == k)
        ans = min(ans, qualitySum * wagePerQuality);
    }

    return ans;
  }
};",14,739,1.0,4.0,3.0,4.0,52.785714285714285,13.0,3.569285714285715
778.0,"class Solution {
 public:
  int mirrorReflection(int p, int q) {
    while (p % 2 == 0 && q % 2 == 0) {
      p /= 2;
      q /= 2;
    }

    if (p % 2 == 0)
      return 2;
    if (q % 2 == 0)
      return 0;
    return 1;
  }
};",6,231,0.0,1.0,3.0,3.0,38.5,4.0,5.8950000000000005
779.0,"class Solution {
 public:
  bool buddyStrings(string A, string B) {
    if (A.length() != B.length())
      return false;
    if (A == B && set<char>(begin(A), end(A)).size() < A.length())
      return true;

    vector<int> diff;

    for (int i = 0; i < A.length(); ++i)
      if (A[i] != B[i])
        diff.push_back(i);

    return diff.size() == 2 && A[diff[0]] == B[diff[1]] &&
           A[diff[1]] == B[diff[0]];
  }
};",8,427,0.0,2.0,2.0,11.0,53.375,7.0,4.25625
780.0,"class Solution {
 public:
  int matrixScore(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;

    // Flip rows with leading 0
    for (auto& row : grid)
      if (row[0] == 0)
        flip(row);

    // Flip cols with 1s < 0s
    for (int j = 0; j < n; ++j)
      if (onesColCount(grid, j) * 2 < m)
        flipCol(grid, j);

    // Add binary number for each row
    for (const vector<int>& row : grid)
      ans += binary(row);

    return ans;
  }

 private:
  void flip(vector<int>& row) {
    for (int i = 0; i < row.size(); ++i)
      row[i] ^= 1;
  }

  int onesColCount(const vector<vector<int>>& grid, int j) {
    int ones = 0;
    for (int i = 0; i < grid.size(); ++i)
      ones += grid[i][j];
    return ones;
  }

  void flipCol(vector<vector<int>>& grid, int j) {
    for (int i = 0; i < grid.size(); ++i)
      grid[i][j] ^= 1;
  }

  int binary(const vector<int>& row) {
    int res = row[0];
    for (int j = 1; j < row.size(); ++j)
      res = res * 2 + row[j];
    return res;
  }
};",26,1065,3.0,8.0,6.0,10.0,40.96153846153846,29.0,2.6934615384615377
781.0,"class Solution {
 public:
  int shortestSubarray(vector<int>& nums, int k) {
    const int n = nums.size();
    int ans = n + 1;
    deque<int> q;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + nums[i]);

    for (int i = 0; i < n + 1; ++i) {
      while (!q.empty() && prefix[i] - prefix[q.front()] >= k)
        ans = min(ans, i - q.front()), q.pop_front();
      while (!q.empty() && prefix[i] <= prefix[q.back()])
        q.pop_back();
      q.push_back(i);
    }

    return ans <= n ? ans : -1;
  }
};",14,560,0.0,4.0,4.0,4.0,40.0,10.0,4.92
782.0,"class Solution {
 public:
  vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
    vector<int> ans;
    unordered_map<TreeNode*, int> nodeToDist;  // {node: distance to target}

    getDists(root, target, nodeToDist);
    dfs(root, k, 0, nodeToDist, ans);
    return ans;
  }

 private:
  void getDists(TreeNode* root, TreeNode* target,
                unordered_map<TreeNode*, int>& nodeToDist) {
    if (root == nullptr)
      return;
    if (root == target) {
      nodeToDist[root] = 0;
      return;
    }

    getDists(root->left, target, nodeToDist);
    if (const auto it = nodeToDist.find(root->left); it != cend(nodeToDist)) {
      // The target is in the left subtree
      nodeToDist[root] = it->second + 1;
      return;
    }

    getDists(root->right, target, nodeToDist);
    if (const auto it = nodeToDist.find(root->right); it != cend(nodeToDist))
      // The target is in the right subtree
      nodeToDist[root] = it->second + 1;
  }

  void dfs(TreeNode* root, int k, int dist,
           unordered_map<TreeNode*, int>& nodeToDist, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (const auto it = nodeToDist.find(root); it != cend(nodeToDist))
      dist = it->second;
    if (dist == k)
      ans.push_back(root->val);

    dfs(root->left, k, dist + 1, nodeToDist, ans);
    dfs(root->right, k, dist + 1, nodeToDist, ans);
  }
};",22,1385,3.0,3.0,7.0,7.0,62.95454545454545,15.0,2.354090909090909
783.0,"struct T {
  int i;
  int j;
  int keys;  // Keys in bitmask
  T(int i, int j, int keys) : i(i), j(j), keys(keys) {}
};

class Solution {
 public:
  int shortestPathAllKeys(vector<string>& grid) {
    const int m = grid.size();
    const int n = grid[0].length();
    const int keysCount = getKeysCount(grid);
    const int kKeys = (1 << keysCount) - 1;
    const vector<int> dirs{0, 1, 0, -1, 0};
    const vector<int> start = getStart(grid);
    int ans = 0;
    queue<T> q{{{start[0], start[1], 0}}};
    vector<vector<vector<bool>>> seen(
        m, vector<vector<bool>>(n, vector<bool>(kKeys)));
    seen[start[0]][start[1]][0] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j, keys] = q.front();
        q.pop();
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          const char c = grid[x][y];
          if (c == '#')
            continue;
          const int newKeys = 'a' <= c && c <= 'f' ? keys | 1 << c - 'a' : keys;
          if (newKeys == kKeys)
            return ans;
          if (seen[x][y][newKeys])
            continue;
          if ('A' <= c && c <= 'F' && ((newKeys >> c - 'A') & 1) == 0)
            continue;
          q.emplace(x, y, newKeys);
          seen[x][y][newKeys] = true;
        }
      }
    }

    return -1;
  }

 private:
  int getKeysCount(const vector<string>& grid) {
    int count = 0;
    for (const string& s : grid)
      count += std::count_if(begin(s), end(s),
                             [](char c) { return 'a' <= c && c <= 'f'; });
    return count;
  }

  vector<int> getStart(const vector<string>& grid) {
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].length(); ++j)
        if (grid[i][j] == '@')
          return {i, j};
    throw;
  }
};",44,1938,1.0,3.0,15.0,13.0,44.04545454545455,49.0,0.0959090909090907
784.0,"struct T {
  TreeNode* lca;
  int depth;
};

class Solution {
 public:
  TreeNode* subtreeWithAllDeepest(TreeNode* root) {
    return dfs(root).lca;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {nullptr, 0};

    const T left = dfs(root->left);
    const T right = dfs(root->right);
    if (left.depth > right.depth)
      return {left.lca, left.depth + 1};
    if (left.depth < right.depth)
      return {right.lca, right.depth + 1};
    return {root, left.depth + 1};
  }
};",11,510,0.0,-1.0,8.0,3.0,46.36363636363637,5.0,4.907272727272727
785.0,"class Solution {
 public:
  int primePalindrome(int n) {
    if (n <= 2)
      return 2;
    if (n == 3)
      return 3;
    if (n <= 5)
      return 5;
    if (n <= 7)
      return 7;
    if (n <= 11)
      return 11;

    int nLength = to_string(n).length();

    while (true) {
      for (const int num : getPalindromes(nLength))
        if (num >= n && isPrime(num))
          return num;
      ++nLength;
    }

    throw;
  }

 private:
  vector<int> getPalindromes(int n) {
    vector<int> palindromes;
    const int length = n / 2;

    for (int i = pow(10, length - 1); i < pow(10, length); ++i) {
      const string s = to_string(i);
      string reversedS = s;
      reverse(begin(reversedS), end(reversedS));
      for (int j = 0; j < 10; ++j)
        palindromes.push_back(stoi(s + to_string(j) + reversedS));
    }

    return palindromes;
  }

  bool isPrime(int num) {
    for (int i = 2; i < sqrt(num) + 1; ++i)
      if (num % i == 0)
        return false;

    return true;
  }
};",25,999,0.0,3.0,6.0,12.0,39.96,19.0,3.9636
786.0,"class Solution {
 public:
  vector<vector<int>> transpose(vector<vector<int>>& A) {
    vector<vector<int>> ans(A[0].size(), vector<int>(A.size()));

    for (int i = 0; i < A.size(); ++i)
      for (int j = 0; j < A[0].size(); ++j)
        ans[j][i] = A[i][j];

    return ans;
  }
};",8,285,0.0,2.0,2.0,2.0,35.625,7.0,5.85375
787.0,"class Solution {
 public:
  int binaryGap(int n) {
    int ans = 0;

    // D := distance between any two 1's
    // Initialized to a reasonable small value
    for (int d = -32; n; n /= 2, ++d)
      if (n & 1) {
        ans = max(ans, d);
        d = 0;
      }

    return ans;
  }
};",7,287,2.0,2.0,3.0,2.0,41.0,5.0,5.590000000000001
788.0,"class Solution {
 public:
  bool reorderedPowerOf2(int n) {
    int count = counter(n);

    for (int i = 0; i < 30; ++i)
      if (counter(1 << i) == count)
        return true;

    return false;
  }

 private:
  int counter(int n) {
    int count = 0;

    for (; n > 0; n /= 10)
      count += pow(10, n % 10);

    return count;
  }
};",11,340,0.0,1.0,3.0,3.0,30.90909090909091,8.0,6.178181818181818
789.0,"class Solution {
 public:
  vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
    multiset<int> set{begin(nums1), end(nums1)};

    for (int i = 0; i < nums2.size(); ++i) {
      const auto p =
          *rbegin(set) <= nums2[i] ? begin(set) : set.upper_bound(nums2[i]);
      nums1[i] = *p;
      set.erase(p);
    }

    return nums1;
  }
};",8,362,0.0,1.0,4.0,1.0,45.25,7.0,4.9275
790.0,"class Solution {
 public:
  int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
    // dp[i] := farthest position we can reach w/ i refuels
    vector<long> dp(stations.size() + 1);
    dp[0] = startFuel;

    for (int i = 0; i < stations.size(); ++i)
      for (int j = i + 1; j > 0; --j)
        if (dp[j - 1] >=
            stations[i][0])  // With j - 1 refuels, we can reach stations[i][0]
          dp[j] = max(dp[j], dp[j - 1] + stations[i][1]);

    for (int i = 0; i < dp.size(); ++i)
      if (dp[i] >= target)
        return i;

    return -1;
  }
};",12,588,2.0,4.0,2.0,5.0,49.0,8.0,4.51
791.0,"class Solution {
 public:
  bool leafSimilar(TreeNode* root1, TreeNode* root2) {
    vector<int> leaves1;
    vector<int> leaves2;
    dfs(root1, leaves1);
    dfs(root2, leaves2);
    return leaves1 == leaves2;
  }

  void dfs(TreeNode* root, vector<int>& leaves) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      leaves.push_back(root->val);
      return;
    }

    dfs(root->left, leaves);
    dfs(root->right, leaves);
  }
};",11,486,0.0,0.0,4.0,2.0,44.18181818181818,6.0,5.183636363636364
792.0,"class Solution {
 public:
  int lenLongestFibSubseq(vector<int>& arr) {
    const int n = arr.size();
    int ans = 0;
    vector<vector<int>> dp(n, vector<int>(n, 2));
    unordered_map<int, int> numToIndex;

    for (int i = 0; i < n; ++i)
      numToIndex[arr[i]] = i;

    for (int j = 0; j < n; ++j)
      for (int k = j + 1; k < n; ++k) {
        const int ai = arr[k] - arr[j];
        if (ai < arr[j] && numToIndex.count(ai)) {
          const int i = numToIndex[ai];
          dp[j][k] = dp[i][j] + 1;
          ans = max(ans, dp[j][k]);
        }
      }

    return ans;
  }
};",17,588,0.0,4.0,4.0,4.0,34.588235294117645,17.0,4.707058823529412
793.0,"class Solution {
 public:
  int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = 0;
    int d = 0;  // 0 := north, 1 := east, 2 := south, 3 := west
    int x = 0;  // Start x
    int y = 0;  // Start y
    unordered_set<pair<int, int>, pairHash> obstaclesSet;

    for (const vector<int>& o : obstacles)
      obstaclesSet.insert({o[0], o[1]});

    for (const int c : commands) {
      if (c == -1) {
        d = (d + 1) % 4;
      } else if (c == -2) {
        d = (d + 3) % 4;
      } else {
        for (int step = 0; step < c; ++step) {
          if (obstaclesSet.count({x + dirs[d], y + dirs[d + 1]}))
            break;
          x += dirs[d];
          y += dirs[d + 1];
        }
      }
      ans = max(ans, x * x + y * y);
    }

    return ans;
  }

 private:
  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",19,968,3.0,6.0,12.0,6.0,50.94736842105263,22.0,2.254736842105263
794.0,"class Solution {
 public:
  int minEatingSpeed(vector<int>& piles, int h) {
    int l = 1;
    int r = *max_element(begin(piles), end(piles));

    while (l < r) {
      const int m = (l + r) / 2;
      if (eatHours(piles, m) <= h)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  // Returns hours to eat all piles with speed m.
  int eatHours(const vector<int>& piles, int m) {
    return accumulate(begin(piles), end(piles), 0, [&](int subtotal, int pile) {
      return subtotal + (pile - 1) / m + 1;  // ceil(pile / m)
    });
  }
};",9,571,2.0,1.0,5.0,2.0,63.44444444444444,14.0,2.6100000000000003
795.0,"class Solution {
 public:
  ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
    }

    return slow;
  }
};",6,241,0.0,1.0,3.0,1.0,40.16666666666666,1.0,6.045
796.0,"class Solution {
 public:
  bool stoneGame(vector<int>& piles) {
    const int n = piles.size();
    // dp[i][j] := max stones you can get more than your opponent in piles[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = piles[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
      }

    return dp[0][n - 1] > 0;
  }
};",13,505,1.0,3.0,3.0,3.0,38.84615384615385,12.0,4.983846153846154
797.0,"class Solution {
 public:
  int nthMagicalNumber(long n, long a, long b) {
    constexpr int kMod = 1'000'000'007;
    const long lcm = a * b / __gcd(a, b);
    long l = min(a, b);
    long r = min(a, b) * n;

    while (l < r) {
      const long m = (l + r) / 2;
      if (m / a + m / b - m / lcm >= n)
        r = m;
      else
        l = m + 1;
    }

    return l % kMod;
  }
};",9,383,0.0,3.0,3.0,2.0,42.55555555555556,5.0,5.3100000000000005
798.0,"class Solution {
 public:
  int profitableSchemes(int n, int minProfit, vector<int>& group,
                        vector<int>& profit) {
    constexpr int kMod = 1'000'000'007;
    // dp[k][i][j] := # of schemes w/ first k crimes, AT MOST i members, and at
    // Least j profits
    vector<vector<vector<int>>> dp(
        group.size() + 1,
        vector<vector<int>>(n + 1, vector<int>(minProfit + 1)));

    // No crimes, no profits, and any # of members
    for (int i = 0; i <= n; ++i)
      dp[0][i][0] = 1;

    for (int k = 1; k <= group.size(); ++k) {
      const int g = group[k - 1];
      const int p = profit[k - 1];
      for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= minProfit; ++j)
          if (i < g) {
            dp[k][i][j] = dp[k - 1][i][j];
          } else {
            dp[k][i][j] = dp[k - 1][i][j] + dp[k - 1][i - g][max(0, j - p)];
            dp[k][i][j] %= kMod;
          }
    }

    return dp[group.size()][n][minProfit];
  }
};",18,976,3.0,6.0,5.0,5.0,54.22222222222222,18.0,2.78
799.0,"class Solution {
 public:
  string decodeAtIndex(string s, int k) {
    long size = 0;  // Length of decoded `s`

    for (const char c : s)
      if (isdigit(c))
        size *= c - '0';
      else
        ++size;

    for (int i = s.length() - 1; i >= 0; --i) {
      k %= size;
      if (k == 0 && isalpha(s[i]))
        return string(1, s[i]);
      if (isdigit(s[i]))
        size /= s[i] - '0';
      else
        --size;
    }

    throw;
  }
};",11,452,1.0,6.0,3.0,5.0,41.09090909090909,8.0,5.001818181818182
800.0,"class Solution {
 public:
  int numRescueBoats(vector<int>& people, int limit) {
    int ans = 0;

    sort(begin(people), end(people));

    for (int i = 0, j = people.size() - 1; i <= j; ++ans) {
      int remain = limit - people[j--];
      if (people[i] <= remain)
        ++i;
    }

    return ans;
  }
};",8,311,0.0,2.0,3.0,2.0,38.875,7.0,5.501250000000001
801.0,"class Solution {
 public:
  int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
    vector<vector<pair<int, int>>> graph(n);
    vector<int> dist(graph.size(), maxMoves + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int cnt = edge[2];
      graph[u].emplace_back(v, cnt);
      graph[v].emplace_back(u, cnt);
    }

    const int reachableNodes = dijkstra(graph, 0, maxMoves, dist);
    int reachableSubnodes = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int cnt = edge[2];
      // Reachable nodes of `edge` from `u`.
      const int a = dist[u] > maxMoves ? 0 : min(maxMoves - dist[u], cnt);
      // Reachable nodes of `edge` from `v`.
      const int b = dist[v] > maxMoves ? 0 : min(maxMoves - dist[v], cnt);
      reachableSubnodes += min(a + b, cnt);
    }

    return reachableNodes + reachableSubnodes;
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src,
               int maxMoves, vector<int>& dist) {
    using P = pair<int, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      // Already take `maxMoves` to reach `u`, can't explore anymore.
      for (const auto& [v, w] : graph[u])
        if (d + w + 1 < dist[v]) {
          dist[v] = d + w + 1;
          minHeap.emplace(dist[v], v);
        }
    }

    return count_if(begin(dist), end(dist),
                    [&](int d) { return d <= maxMoves; });
  }
};",27,1700,4.0,3.0,8.0,6.0,62.96296296296296,43.0,-0.466666666666665
802.0,"class Solution {
 public:
  int projectionArea(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i) {
      int maxOfRow = 0;
      int maxOfCol = 0;
      for (int j = 0; j < grid.size(); ++j) {
        maxOfRow = max(maxOfRow, grid[i][j]);
        maxOfCol = max(maxOfCol, grid[j][i]);
        if (grid[i][j])
          ++ans;
      }
      ans += maxOfRow + maxOfCol;
    }

    return ans;
  }
};",13,436,0.0,3.0,4.0,3.0,33.53846153846154,8.0,5.7615384615384615
803.0,"class Solution {
 public:
  vector<string> uncommonFromSentences(string A, string B) {
    vector<string> ans;
    unordered_map<string, int> count;
    istringstream iss(A + ' ' + B);

    while (iss >> A)
      ++count[A];

    for (const auto& [word, freq] : count)
      if (freq == 1)
        ans.push_back(word);

    return ans;
  }
};",7,342,0.0,3.0,2.0,3.0,48.85714285714285,8.0,4.502857142857144
804.0,"class Solution {
 public:
  vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart,
                                      int cStart) {
    const vector<int> dx{1, 0, -1, 0};
    const vector<int> dy{0, 1, 0, -1};
    vector<vector<int>> ans{{rStart, cStart}};

    for (int i = 0; ans.size() < rows * cols; ++i)
      for (int step = 0; step < i / 2 + 1; ++step) {
        rStart += dy[i % 4];
        cStart += dx[i % 4];
        if (0 <= rStart && rStart < rows && 0 <= cStart && cStart < cols)
          ans.push_back({rStart, cStart});
      }

    return ans;
  }
};",12,584,0.0,3.0,8.0,3.0,48.66666666666666,13.0,3.66
805.0,"enum Color { kWhite, kRed, kGreen };

class Solution {
 public:
  bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
    vector<vector<int>> graph(n + 1);
    vector<Color> colors(n + 1, Color::kWhite);

    for (const vector<int>& d : dislikes) {
      const int u = d[0];
      const int v = d[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    // Reduce to 785. Is Graph Bipartite?
    for (int i = 1; i <= n; ++i)
      if (colors[i] == Color::kWhite &&
          !isValidColor(graph, i, colors, Color::kRed))
        return false;

    return true;
  }

 private:
  bool isValidColor(const vector<vector<int>>& graph, int u,
                    vector<Color>& colors, Color color) {
    // The painted color should be same as the `color`
    if (colors[u] != Color::kWhite)
      return colors[u] == color;

    colors[u] = color;  // Always paint w/ `color`

    // All children should have valid colors
    for (const int v : graph[u])
      if (!isValidColor(graph, v, colors,
                        color == Color::kRed ? Color::kGreen : Color::kRed))
        return false;

    return true;
  }
};",16,1144,4.0,2.0,5.0,6.0,71.5,18.0,1.5050000000000008
806.0,"class Solution {
 public:
  int superEggDrop(int k, int n) {
    // dp[k][n] := min # of moves to know f with k eggs and n floors
    dp.resize(k + 1, vector<int>(n + 1, -1));
    return drop(k, n);
  }

 private:
  vector<vector<int>> dp;

  int drop(int k, int n) {
    if (k == 0)  // No eggs -> done
      return 0;
    if (k == 1)  // One egg -> drop from 1-th floor to n-th floor
      return n;
    if (n == 0)  // No floor -> done
      return 0;
    if (n == 1)  // One floor -> drop from that floor
      return 1;
    if (dp[k][n] != -1)
      return dp[k][n];

    dp[k][n] = INT_MAX;

    for (int i = 1; i <= n; ++i) {
      const int broken = drop(k - 1, i - 1);
      const int unbroken = drop(k, n - i);
      dp[k][n] = min(dp[k][n], 1 + max(broken, unbroken));
    }

    return dp[k][n];
  }
};",16,814,5.0,0.0,4.0,6.0,50.875,14.0,3.98125
807.0,"class Solution {
 public:
  vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {
    const int diff = (accumulate(begin(aliceSizes), end(aliceSizes), 0) -
                      accumulate(begin(bobSizes), end(bobSizes), 0)) /
                     2;
    const unordered_set<int> bobSizesSet{begin(bobSizes), end(bobSizes)};

    for (const int aliceSize : aliceSizes) {
      const int target = aliceSize - diff;
      if (bobSizesSet.count(target))
        return {aliceSize, target};
    }

    throw;
  }
};",6,533,0.0,1.0,5.0,4.0,88.83333333333333,12.0,0.4449999999999985
808.0,"class Solution {
 public:
  TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {
    unordered_map<int, int> postToIndex;

    for (int i = 0; i < post.size(); ++i)
      postToIndex[post[i]] = i;

    return build(pre, 0, pre.size() - 1, post, 0, post.size() - 1, postToIndex);
  }

 private:
  TreeNode* build(const vector<int>& pre, int preStart, int preEnd,
                  const vector<int>& post, int postStart, int postEnd,
                  const unordered_map<int, int>& postToIndex) {
    if (preStart > preEnd)
      return nullptr;
    if (preStart == preEnd)
      return new TreeNode(pre[preStart]);

    const int rootVal = pre[preStart];
    const int leftRootVal = pre[preStart + 1];
    const int leftRootPostIndex = postToIndex.at(leftRootVal);
    const int leftSize = leftRootPostIndex - postStart + 1;

    TreeNode* root = new TreeNode(rootVal);
    root->left = build(pre, preStart + 1, preStart + leftSize, post, postStart,
                       leftRootPostIndex, postToIndex);
    root->right = build(pre, preStart + leftSize + 1, preEnd, post,
                        leftRootPostIndex + 1, postEnd - 1, postToIndex);
    return root;
  }
};",16,1189,0.0,0.0,3.0,3.0,74.3125,25.0,0.6318750000000009
809.0,"class Solution {
 public:
  vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
    vector<string> ans;

    for (const string& word : words)
      if (isIsomorphic(word, pattern))
        ans.push_back(word);

    return ans;
  }

 private:
  bool isIsomorphic(const string& w, const string& p) {
    vector<int> map_w(128);
    vector<int> map_p(128);

    for (int i = 0; i < w.length(); ++i) {
      if (map_w[w[i]] != map_p[p[i]])
        return false;
      map_w[w[i]] = i + 1;
      map_p[p[i]] = i + 1;
    }

    return true;
  }
};",12,568,0.0,2.0,4.0,4.0,47.333333333333336,15.0,3.88
810.0,"class Solution {
 public:
  int sumSubseqWidths(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    long ans = 0;
    long exp = 1;

    sort(begin(nums), end(nums));

    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {
      ans += (nums[i] - nums[n - i - 1]) * exp;
      ans %= kMod;
    }

    return ans;
  }
};",11,364,0.0,1.0,3.0,1.0,33.09090909090909,7.0,6.081818181818181
811.0,"class Solution {
 public:
  int surfaceArea(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid.size(); ++j) {
        if (grid[i][j])
          ans += grid[i][j] * 4 + 2;
        if (i > 0)
          ans -= min(grid[i][j], grid[i - 1][j]) * 2;
        if (j > 0)
          ans -= min(grid[i][j], grid[i][j - 1]) * 2;
      }

    return ans;
  }
};",10,417,0.0,5.0,3.0,5.0,41.7,6.0,5.167000000000001
812.0,"class Solution {
 public:
  int numSpecialEquivGroups(vector<string>& A) {
    unordered_set<string> set;

    for (const string& s : A) {
      string even;
      string odd;
      for (int i = 0; i < s.length(); ++i)
        if (i % 2 == 0)
          even += s[i];
        else
          odd += s[i];
      sort(begin(even), end(even));
      sort(begin(odd), end(odd));
      set.insert(even + odd);
    }

    return set.size();
  }
};",12,439,0.0,4.0,3.0,3.0,36.583333333333336,9.0,5.3875
813.0,"class Solution {
 public:
  vector<TreeNode*> allPossibleFBT(int n) {
    if (n % 2 == 0)
      return {};
    if (n == 1)
      return {new TreeNode(0)};
    if (const auto it = memo.find(n); it != cend(memo))
      return it->second;

    vector<TreeNode*> ans;

    for (int leftCount = 0; leftCount < n; ++leftCount) {
      const int rightCount = n - 1 - leftCount;
      for (TreeNode* left : allPossibleFBT(leftCount))
        for (TreeNode* right : allPossibleFBT(rightCount)) {
          ans.push_back(new TreeNode(0));
          ans.back()->left = left;
          ans.back()->right = right;
        }
    }

    return memo[n] = ans;
  }

 private:
  unordered_map<int, vector<TreeNode*>> memo;
};",14,707,0.0,3.0,6.0,6.0,50.5,7.0,4.215
814.0,"class Solution {
 public:
  bool isMonotonic(vector<int>& nums) {
    bool increasing = true;
    bool decreasing = true;

    for (int i = 1; i < nums.size(); ++i) {
      increasing &= nums[i] >= nums[i - 1];
      decreasing &= nums[i] <= nums[i - 1];
    }

    return increasing || decreasing;
  }
};",8,305,0.0,1.0,3.0,1.0,38.125,6.0,5.728750000000001
815.0,"class Solution {
 public:
  TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {
    if (root == nullptr)
      return tail;

    TreeNode* ans = increasingBST(root->left, root);
    root->left = nullptr;
    root->right = increasingBST(root->right, tail);
    return ans;
  }
};",6,294,0.0,0.0,2.0,1.0,49.0,1.0,5.37
816.0,"class Solution {
 public:
  int subarrayBitwiseORs(vector<int>& arr) {
    vector<int> s;
    int l = 0;

    for (const int a : arr) {
      const int r = s.size();
      s.push_back(a);
      // s[l..r) are values generated in previous iteration
      for (int i = l; i < r; ++i)
        if (s.back() != (s[i] | a))
          s.push_back(s[i] | a);
      l = r;
    }

    return unordered_set<int>(begin(s), end(s)).size();
  }
};",10,433,1.0,3.0,3.0,3.0,43.3,11.0,4.683000000000001
817.0,"class Solution {
 public:
  string orderlyQueue(string s, int k) {
    if (k > 1) {
      sort(begin(s), end(s));
      return s;
    }

    string ans = s;

    for (int i = 1; i < s.length(); ++i)
      ans = min(ans, s.substr(i) + s.substr(0, i));

    return ans;
  }
};",8,274,0.0,1.0,3.0,2.0,34.25,6.0,6.0775
818.0,"class StockSpanner {
 public:
  int next(int price) {
    int span = 1;
    while (!stack.empty() && stack.top().first <= price)
      span += stack.top().second, stack.pop();
    stack.emplace(price, span);
    return span;
  }

 private:
  stack<pair<int, int>> stack;  // (price, span)
};",6,291,1.0,1.0,2.0,1.0,48.5,6.0,4.8950000000000005
819.0,"class Solution {
 public:
  int atMostNGivenDigitSet(vector<string>& digits, int n) {
    int ans = 0;
    const string num = to_string(n);

    for (int i = 1; i < num.length(); ++i)
      ans += pow(digits.size(), i);

    for (int i = 0; i < num.length(); ++i) {
      bool dHasSameNum = false;
      for (const string& digit : digits) {
        if (digit[0] < num[i])
          ans += pow(digits.size(), num.length() - i - 1);
        else if (digit[0] == num[i])
          dHasSameNum = true;
      }
      if (!dHasSameNum)
        return ans;
    }

    return ans + 1;
  }
};",13,583,0.0,6.0,4.0,6.0,44.84615384615385,12.0,4.163846153846153
820.0,"class Solution {
 public:
  int numPermsDISequence(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    // dp[i][j] := # of valid permutations w/ i + 1 digits, where s[i] is j-th
    // Digit of remaining digits
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    // When there's only one digit, the # of perms is 1
    for (int j = 0; j <= n; ++j)
      dp[0][j] = 1;

    for (int i = 1; i <= n; ++i)
      if (s[i - 1] == 'I') {  // s[i - 1] == 'I'
        // Calculate postfix sum to prevent duplicate calculation
        int postfixsum = 0;
        for (int j = n - i; j >= 0; --j) {
          postfixsum = (postfixsum + dp[i - 1][j + 1]) % kMod;
          dp[i][j] = postfixsum;
        }
      } else {  // s[i - 1] == 'D'
        // Calculate prefix sum to prevent duplicate calculation
        int prefix = 0;
        for (int j = 0; j <= n - i; ++j) {
          prefix = (prefix + dp[i - 1][j]) % kMod;
          dp[i][j] = prefix;
        }
      }

    return dp[n][0];
  }
};",20,1029,7.0,6.0,6.0,5.0,51.45,14.0,3.5294999999999987
821.0,"class Solution {
 public:
  int totalFruit(vector<int>& fruits) {
    int ans = 0;
    unordered_map<int, int> count;

    for (int l = 0, r = 0; r < fruits.size(); ++r) {
      ++count[fruits[r]];
      while (count.size() > 2) {
        if (--count[fruits[l]] == 0)
          count.erase(fruits[l]);
        ++l;
      }
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",10,385,0.0,3.0,4.0,3.0,38.5,7.0,5.415
822.0,"class Solution {
 public:
  vector<int> sortArrayByParity(vector<int>& nums) {
    int l = 0;
    int r = nums.size() - 1;

    while (l < r) {
      if (nums[l] % 2 == 1 && nums[r] % 2 == 0)
        swap(nums[l], nums[r]);
      if (nums[l] % 2 == 0)
        ++l;
      if (nums[r] % 2 == 1)
        --r;
    }

    return nums;
  }
};",7,336,0.0,4.0,3.0,4.0,48.0,5.0,4.76
823.0,"class Solution {
 public:
  int superpalindromesInRange(string left, string right) {
    int ans = 0;
    long long l = stoll(left);
    long long r = stoll(right);

    for (long long i = sqrt(l); i * i <= r;) {
      long long palindrome = nextPalindrome(i);
      long long squared = palindrome * palindrome;
      if (squared <= r && isPalindrome(squared))
        ++ans;
      i = palindrome + 1;
    }

    return ans;
  }

 private:
  long long nextPalindrome(int num) {
    const string s = to_string(num);
    const int n = s.length();
    string half = s.substr(0, (n + 1) / 2);
    string reversedHalf = reversed(half.substr(0, n / 2));
    const long long candidate = stoll(half + reversedHalf);
    if (candidate >= num)
      return candidate;

    half = to_string(stoll(half) + 1);
    reversedHalf = reversed(half.substr(0, n / 2));
    return stoll(half + reversedHalf);
  }

  string reversed(const string& s) {
    return {rbegin(s), rend(s)};
  }

  bool isPalindrome(long long num) {
    const string s = to_string(num);
    int l = 0;
    int r = s.length() - 1;

    while (l < r)
      if (s[l++] != s[r--])
        return false;

    return true;
  }
};",26,1179,0.0,0.0,7.0,5.0,45.34615384615385,21.0,3.3988461538461543
824.0,"class Solution {
 public:
  int sumSubarrayMins(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    long ans = 0;
    // prevMin[i] := index k s.t. arr[k] is the prev min in arr[:i]
    vector<int> prevMin(n, -1);
    // nextMin[i] := index k s.t. arr[k] is the next min in arr[i + 1:]
    vector<int> nextMin(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && arr[stack.top()] > arr[i]) {
        const int index = stack.top();
        stack.pop();
        nextMin[index] = i;
      }
      if (!stack.empty())
        prevMin[i] = stack.top();
      stack.push(i);
    }

    for (int i = 0; i < n; ++i) {
      ans += static_cast<long>(arr[i]) * (i - prevMin[i]) * (nextMin[i] - i);
      ans %= kMod;
    }

    return ans;
  }
};",19,820,2.0,4.0,5.0,4.0,43.1578947368421,13.0,4.355789473684211
825.0,"class Solution {
 public:
  int smallestRangeI(vector<int>& nums, int k) {
    const int max = *max_element(begin(nums), end(nums));
    const int min = *min_element(begin(nums), end(nums));
    return std::max(0, max - min - 2 * k);
  }
};",4,240,0.0,0.0,2.0,0.0,60.0,8.0,3.6800000000000006
826.0,"class Solution {
 public:
  int snakesAndLadders(vector<vector<int>>& board) {
    const int n = board.size();
    int ans = 0;
    queue<int> q{{1}};
    vector<bool> seen(1 + n * n);
    vector<int> A(1 + n * n);  // 2D -> 1D

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        A[(n - 1 - i) * n + (n - i & 1 ? j + 1 : n - j)] = board[i][j];

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const int curr = q.front();
        q.pop();
        for (int next = curr + 1; next <= min(curr + 6, n * n); ++next) {
          const int dest = A[next] > 0 ? A[next] : next;
          if (dest == n * n)
            return ans;
          if (seen[dest])
            continue;
          q.push(dest);
          seen[dest] = true;
        }
      }
    }

    return -1;
  }
};",24,836,1.0,5.0,7.0,7.0,34.833333333333336,17.0,4.484999999999999
827.0,"class Solution {
 public:
  int smallestRangeII(vector<int>& nums, int k) {
    sort(begin(nums), end(nums));

    int ans = nums.back() - nums.front();
    const int left = nums.front() + k;
    const int right = nums.back() - k;

    for (int i = 0; i + 1 < nums.size(); ++i) {
      const int mini = min(left, nums[i + 1] - k);
      const int maxi = max(right, nums[i] + k);
      ans = min(ans, maxi - mini);
    }

    return ans;
  }
};",11,443,0.0,1.0,3.0,1.0,40.27272727272727,14.0,4.735454545454546
828.0,"class Solution {
 public:
  vector<int> sortArray(vector<int>& nums) {
    mergeSort(nums, 0, nums.size() - 1);
    return nums;
  }

 private:
  void mergeSort(vector<int>& A, int l, int r) {
    if (l >= r)
      return;

    const int m = (l + r) / 2;
    mergeSort(A, l, m);
    mergeSort(A, m + 1, r);
    merge(A, l, m, r);
  }

  void merge(vector<int>& A, int l, int m, int r) {
    vector<int> sorted(r - l + 1);
    int k = 0;      // sorted's index
    int i = l;      // left's index
    int j = m + 1;  // right's index

    while (i <= m && j <= r)
      if (A[i] < A[j])
        sorted[k++] = A[i++];
      else
        sorted[k++] = A[j++];

    // Put possible remaining left part to the sorted array
    while (i <= m)
      sorted[k++] = A[i++];

    // Put possible remaining right part to the sorted array
    while (j <= r)
      sorted[k++] = A[j++];

    copy(begin(sorted), end(sorted), begin(A) + l);
  }
};",17,933,5.0,5.0,4.0,5.0,54.88235294117647,18.0,2.920588235294118
829.0,"enum class State { kDraw, kMouseWin, kCatWin };

class Solution {
 public:
  int catMouseGame(vector<vector<int>>& graph) {
    const int n = graph.size();
    // Result of (cat, mouse, move)
    // Move := 0 (mouse) / 1 (cat)
    vector<vector<vector<State>>> states(
        n, vector<vector<State>>(n, vector<State>(2)));
    vector<vector<vector<int>>> outDegree(
        n, vector<vector<int>>(n, vector<int>(2)));
    queue<tuple<int, int, int, State>> q;  // (cat, mouse, move, state)

    for (int cat = 0; cat < n; ++cat)
      for (int mouse = 0; mouse < n; ++mouse) {
        outDegree[cat][mouse][0] = graph[mouse].size();
        outDegree[cat][mouse][1] =
            graph[cat].size() - count(begin(graph[cat]), end(graph[cat]), 0);
      }

    // Start from states that winner can be determined
    for (int cat = 1; cat < n; ++cat)
      for (int move = 0; move < 2; ++move) {
        // Mouse is in the hole -> State::kMouseWin
        states[cat][0][move] = State::kMouseWin;
        q.emplace(cat, 0, move, State::kMouseWin);
        // Cat catches mouse -> State::kCatWin
        states[cat][cat][move] = State::kCatWin;
        q.emplace(cat, cat, move, State::kCatWin);
      }

    while (!q.empty()) {
      const auto [cat, mouse, move, state] = q.front();
      q.pop();
      if (cat == 2 && mouse == 1 && move == 0)
        return static_cast<int>(state);
      const int prevMove = move ^ 1;
      for (const int prev : graph[prevMove ? cat : mouse]) {
        const int prevCat = prevMove ? prev : cat;
        if (prevCat == 0)  // Invalid
          continue;
        const int prevMouse = prevMove ? mouse : prev;
        // The state is already determined
        if (states[prevCat][prevMouse][prevMove] != State::kDraw)
          continue;
        if (prevMove == 0 && state == State::kMouseWin ||
            prevMove == 1 && state == State::kCatWin ||
            --outDegree[prevCat][prevMouse][prevMove] == 0) {
          states[prevCat][prevMouse][prevMove] = state;
          q.emplace(prevCat, prevMouse, prevMove, state);
        }
      }
    }

    return static_cast<int>(states[2][1][0]);
  }
};",31,2144,8.0,7.0,8.0,10.0,69.16129032258064,27.0,0.4954838709677425
830.0,"class Solution {
 public:
  bool hasGroupsSizeX(vector<int>& deck) {
    unordered_map<int, int> count;
    int gcd = 0;

    for (const int d : deck)
      ++count[d];

    for (const auto& [_, value] : count)
      gcd = __gcd(gcd, value);

    return gcd >= 2;
  }
};",6,270,0.0,2.0,2.0,2.0,45.0,9.0,4.81
831.0,"class Solution {
 public:
  int partitionDisjoint(vector<int>& nums) {
    const int n = nums.size();
    vector<int> min(n);
    min[n - 1] = nums[n - 1];
    int max = INT_MIN;

    for (int i = n - 2; i >= 0; --i)
      min[i] = std::min(min[i + 1], nums[i]);

    for (int i = 0; i < n; ++i) {
      max = std::max(max, nums[i]);
      if (max <= min[i + 1])
        return i + 1;
    }

    throw;
  }
};",13,409,0.0,2.0,3.0,3.0,31.46153846153846,9.0,5.968461538461539
832.0,"class Solution {
 public:
  vector<string> wordSubsets(vector<string>& A, vector<string>& B) {
    vector<string> ans;
    vector<int> countB(26);

    for (const string& b : B) {
      vector<int> temp = counter(b);
      for (int i = 0; i < 26; ++i)
        countB[i] = max(countB[i], temp[i]);
    }

    for (const string& a : A)
      if (isUniversal(counter(a), countB))
        ans.push_back(a);

    return ans;
  }

 private:
  vector<int> counter(const string& s) {
    vector<int> count(26);
    for (char c : s)
      ++count[c - 'a'];
    return count;
  }

  bool isUniversal(vector<int> countA, vector<int>& countB) {
    for (int i = 0; i < 26; ++i)
      if (countA[i] < countB[i])
        return false;
    return true;
  }
};",16,744,0.0,4.0,5.0,7.0,46.5,21.0,3.175
833.0,"class Solution {
 public:
  string reverseOnlyLetters(string s) {
    for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {
      while (i < j && !isalpha(s[i]))
        ++i;
      while (i < j && !isalpha(s[j]))
        --j;
      swap(s[i], s[j]);
    }
    return s;
  }
};",7,277,0.0,3.0,3.0,3.0,39.57142857142857,4.0,5.67857142857143
834.0,"class Solution {
 public:
  int maxSubarraySumCircular(vector<int>& nums) {
    int totalSum = 0;
    int currMaxSum = 0;
    int currMinSum = 0;
    int maxSum = INT_MIN;
    int minSum = INT_MAX;

    for (const int num : nums) {
      totalSum += num;
      currMaxSum = max(currMaxSum + num, num);
      currMinSum = min(currMinSum + num, num);
      maxSum = max(maxSum, currMaxSum);
      minSum = min(minSum, currMinSum);
    }

    return maxSum < 0 ? maxSum : max(maxSum, totalSum - minSum);
  }
};",12,507,0.0,1.0,3.0,1.0,42.25,10.0,4.9575000000000005
835.0,"class Solution {
 public:
  int numMusicPlaylists(int n, int goal, int k) {
    this->n = n;
    this->k = k;
    // dp[i][j] := # of playlists with i songs and j different songs
    dp.resize(goal + 1, vector<long>(n + 1, -1));
    return playlists(goal, n);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  int n;
  int k;
  vector<vector<long>> dp;

  long playlists(int i, int j) {
    if (i == 0)
      return j == 0;
    if (j == 0)
      return 0;
    if (dp[i][j] >= 0)
      return dp[i][j];

    dp[i][j] = playlists(i - 1, j - 1) * (n - (j - 1));  // Last song is new
    dp[i][j] += playlists(i - 1, j) * max(0, j - k);     // Last song is old
    return dp[i][j] %= kMod;
  }
};",15,704,3.0,-1.0,3.0,4.0,46.93333333333333,10.0,4.776000000000001
836.0,"class Solution {
 public:
  int minAddToMakeValid(string s) {
    int l = 0;
    int r = 0;

    for (const char c : s)
      if (c == '(') {
        ++l;
      } else {
        if (l == 0)
          ++r;
        else
          --l;
      }

    return l + r;
  }
};",7,266,0.0,5.0,4.0,3.0,38.0,7.0,5.34
837.0,"class Solution {
 public:
  vector<int> sortArrayByParityII(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0, j = 1; i < n; i += 2, j += 2) {
      while (i < n && nums[i] % 2 == 0)
        i += 2;
      while (j < n && nums[j] % 2 == 1)
        j += 2;
      if (i < n)
        swap(nums[i], nums[j]);
    }

    return nums;
  }
};",8,356,0.0,4.0,3.0,4.0,44.5,6.0,4.975
838.0,"class Solution {
 public:
  int threeSumMulti(vector<int>& arr, int target) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    unordered_map<int, int> count;

    for (const int a : arr)
      ++count[a];

    for (const auto& [i, x] : count)
      for (const auto& [j, y] : count) {
        const int k = target - i - j;
        const auto it = count.find(k);
        if (it == cend(count))
          continue;
        if (i == j && j == k)
          ans = (ans + static_cast<long>(x) * (x - 1) * (x - 2) / 6) % kMod;
        else if (i == j && j != k)
          ans = (ans + static_cast<long>(x) * (x - 1) / 2 * it->second) % kMod;
        else if (i < j && j < k)
          ans = (ans + static_cast<long>(x) * y * it->second) % kMod;
      }

    return ans;
  }
};",12,780,0.0,8.0,3.0,7.0,65.0,15.0,1.99
839.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    const int n = graph.size();
    UnionFind uf(n);
    vector<int> ufSize(n);
    vector<int> malwareCount(n);

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j)
        if (graph[i][j] == 1)
          uf.unionByRank(i, j);

    for (int i = 0; i < n; ++i)
      ++ufSize[uf.find(i)];

    for (const int i : initial)
      ++malwareCount[uf.find(i)];

    sort(begin(initial), end(initial));

    int ans = initial[0];
    int maxUfSize = 0;

    // Find the max union's malware if it only contains 1 malware
    for (const int i : initial) {
      const int id = uf.find(i);
      if (ufSize[id] > maxUfSize && malwareCount[id] == 1) {
        maxUfSize = ufSize[id];
        ans = i;
      }
    }

    return ans;
  }
};",33,1364,1.0,11.0,11.0,11.0,41.333333333333336,32.0,1.8000000000000007
840.0,"class Solution {
 public:
  bool isLongPressedName(string name, string typed) {
    int i = 0;

    for (int j = 0; j < typed.length(); ++j)
      if (i < name.length() && name[i] == typed[j])
        ++i;
      else if (j == 0 || typed[j] != typed[j - 1])
        return false;

    return i == name.length();
  }
};",7,317,0.0,3.0,2.0,3.0,45.285714285714285,6.0,5.024285714285715
841.0,"class Solution {
 public:
  int minFlipsMonoIncr(string s) {
    vector<int> dp(2);

    for (const char c : s) {
      const int temp = dp[0] + (c == '1');
      dp[1] = min(dp[0], dp[1]) + (c == '0');
      dp[0] = temp;
    }

    return min(dp[0], dp[1]);
  }
};",6,266,0.0,1.0,3.0,1.0,44.333333333333336,8.0,4.970000000000001
842.0,"class Solution {
 public:
  vector<int> threeEqualParts(vector<int>& arr) {
    const int ones =
        count_if(begin(arr), end(arr), [](int a) { return a == 1; });

    if (ones == 0)
      return {0, static_cast<int>(arr.size()) - 1};
    if (ones % 3 != 0)
      return {-1, -1};

    int k = ones / 3;
    int i;
    int j;
    int first;
    int second;
    int third;

    for (i = 0; i < arr.size(); ++i)
      if (arr[i] == 1) {
        first = i;
        break;
      }

    int gapOnes = k;

    for (j = i + 1; j < arr.size(); ++j)
      if (arr[j] == 1 && --gapOnes == 0) {
        second = j;
        break;
      }

    gapOnes = k;

    for (i = j + 1; i < arr.size(); ++i)
      if (arr[i] == 1 && --gapOnes == 0) {
        third = i;
        break;
      }

    while (third < arr.size() && arr[first] == arr[second] &&
           arr[second] == arr[third]) {
      ++first;
      ++second;
      ++third;
    }

    if (third == arr.size())
      return {first - 1, second};
    return {-1, -1};
  }
};",30,1022,0.0,3.0,11.0,11.0,34.06666666666667,14.0,4.694
843.0,"class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int ans = 0;
    int minCount = graph.size();

    sort(begin(initial), end(initial));

    for (const int i : initial) {
      const int count = bfs(graph, i, initial);
      if (count < minCount) {
        minCount = count;
        ans = i;
      }
    }

    return ans;
  }

 private:
  int bfs(const vector<vector<int>>& graph, int removed, vector<int>& initial) {
    queue<int> q;
    vector<bool> seen(graph.size());
    seen[removed] = true;

    int count = 0;

    for (const int i : initial)
      if (i != removed) {
        q.push(i);
        seen[i] = true;
      }

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      ++count;
      for (int i = 0; i < graph.size(); ++i) {
        if (seen[i])
          continue;
        if (i != u && graph[i][u]) {
          q.push(i);
          seen[i] = true;
        }
      }
    }

    return count;
  }
};",23,994,0.0,6.0,9.0,8.0,43.21739130434783,23.0,2.9104347826086947
844.0,"class Solution {
 public:
  int numUniqueEmails(vector<string>& emails) {
    unordered_set<string> normalized;

    for (const string& email : emails) {
      string local;
      for (const char c : email) {
        if (c == '+' || c == '@')
          break;
        if (c == '.')
          continue;
        local += c;
      }
      string atDomain = email.substr(email.find('@'));
      normalized.insert(local + atDomain);
    }

    return normalized.size();
  }
};",9,471,0.0,2.0,4.0,4.0,52.333333333333336,10.0,3.93
845.0,"class Solution {
 public:
  int numSubarraysWithSum(vector<int>& nums, int goal) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> count{{0, 1}};

    for (int num : nums) {
      prefix += num;
      if (const auto it = count.find(prefix - goal); it != cend(count))
        ans += it->second;
      ++count[prefix];
    }

    return ans;
  }
};",9,363,0.0,2.0,5.0,2.0,40.333333333333336,10.0,4.95
846.0,"class Solution {
 public:
  int minFallingPathSum(vector<vector<int>>& A) {
    const int n = A.size();

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        int mini = INT_MAX;
        for (int k = max(0, j - 1); k < min(n, j + 2); ++k)
          mini = min(mini, A[i - 1][k]);
        A[i][j] += mini;
      }

    return *min_element(begin(A[n - 1]), end(A[n - 1]));
  }
};",12,399,0.0,3.0,3.0,3.0,33.25,9.0,5.7475000000000005
847.0,"class Solution {
 public:
  vector<int> beautifulArray(int n) {
    vector<int> A(n);
    iota(begin(A), end(A), 1);
    divide(A, 0, n - 1, 1);
    return A;
  }

 private:
  void divide(vector<int>& A, int l, int r, int mask) {
    if (l >= r)
      return;
    const int m = partition(A, l, r, mask);
    divide(A, l, m, mask << 1);
    divide(A, m + 1, r, mask << 1);
  }

  int partition(vector<int>& A, int l, int r, int mask) {
    int nextSwapped = l;
    for (int i = l; i <= r; ++i)
      if (A[i] & mask)
        swap(A[i], A[nextSwapped++]);
    return nextSwapped - 1;
  }
};",14,588,0.0,1.0,4.0,4.0,42.0,18.0,4.12
848.0,"class Solution {
 public:
  int shortestBridge(vector<vector<int>>& grid) {
    markGridTwo(grid);

    for (int color = 2;; ++color)
      for (int i = 0; i < grid.size(); ++i)
        for (int j = 0; j < grid[0].size(); ++j)
          if (grid[i][j] == color)
            if (expand(grid, i + 1, j, color) ||  //
                expand(grid, i - 1, j, color) ||  //
                expand(grid, i, j + 1, color) ||  //
                expand(grid, i, j - 1, color))
              return color - 2;
  }

 private:
  // Mark one group to 2s by DFS
  void markGridTwo(vector<vector<int>>& grid) {
    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == 1) {
          markGridTwo(grid, i, j);
          return;
        }
  }

  void markGridTwo(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] != 1)
      return;

    grid[i][j] = 2;
    markGridTwo(grid, i + 1, j);
    markGridTwo(grid, i - 1, j);
    markGridTwo(grid, i, j + 1);
    markGridTwo(grid, i, j - 1);
  }

  // Expand from colors' group to 1s' group
  bool expand(vector<vector<int>>& grid, int i, int j, int color) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return false;
    if (grid[i][j] == 0)
      grid[i][j] = color + 1;
    return grid[i][j] == 1;  // We touch the 1s' group!
  }
};",25,1440,6.0,7.0,6.0,12.0,57.6,19.0,2.3759999999999994
849.0,"class Solution {
 public:
  int knightDialer(int n) {
    constexpr int kMod = 1'000'000'007;
    const vector<pair<int, int>> dirs = {{-2, 1}, {-1, 2}, {1, 2},   {2, 1},
                                         {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};

    // dp[i][j] := # of ways to stand on (i, j)
    vector<vector<int>> dp(4, vector<int>(3, 1));
    dp[3][0] = dp[3][2] = 0;

    for (int k = 0; k < n - 1; ++k) {
      vector<vector<int>> newDp(4, vector<int>(3));
      for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 3; ++j) {
          if (isNotNumericCell(i, j))
            continue;
          for (const auto& [dx, dy] : dirs) {
            const int x = i + dx;
            const int y = j + dy;
            if (x < 0 || x >= 4 || y < 0 || y >= 3)
              continue;
            if (isNotNumericCell(x, y))
              continue;
            newDp[i][j] = (newDp[i][j] + dp[x][y]) % kMod;
          }
        }
      dp = move(newDp);
    }

    int ans = 0;

    for (const vector<int>& row : dp)
      for (const int a : row)
        ans = (ans + a) % kMod;

    return ans;
  }

 private:
  bool isNotNumericCell(int i, int j) {
    return i == 3 && (j == 0 || j == 2);
  }
};",23,1205,1.0,5.0,15.0,9.0,52.391304347826086,27.0,1.4247826086956508
850.0,"class Solution {
 public:
  vector<int> movesToStamp(string stamp, string target) {
    vector<int> ans;
    // stamped[i] := true if we already stamped target by stamp on index i
    vector<bool> stamped(target.length());
    int stampedCount = 0;  // Out goal is to make stampedCount = target.length()

    while (stampedCount < target.length()) {
      bool isStamped = false;
      // Try to stamp target[i..i + stamp.length()) for each index
      for (int i = 0; i <= target.length() - stamp.length(); ++i) {
        if (stamped[i])
          continue;
        const int stampified = stampify(stamp, target, i);
        if (stampified == 0)
          continue;
        stampedCount += stampified;
        isStamped = true;
        stamped[i] = true;
        ans.push_back(i);
      }
      // After trying stamp each index, we can't find a valid stamp
      if (!isStamped)
        return {};
    }

    reverse(begin(ans), end(ans));
    return ans;
  }

 private:
  // Stamp target[i..i + stamp.length()) and return # of newly stamped chars
  // E.g. stampify(""abc"", ""ababc"", 2) returns 3 because target becomes ""ab***""
  int stampify(const string& stamp, string& target, int s) {
    int stampified = stamp.length();

    for (int i = 0; i < stamp.length(); ++i)
      if (target[s + i] == '*')  // Already stamped
        --stampified;
      else if (target[s + i] != stamp[i])
        return 0;  // We can't stamp on index i

    if (stampified > 0)
      fill(begin(target) + s, begin(target) + s + stamp.length(), '*');

    return stampified;
  }
};",24,1563,8.0,6.0,6.0,21.0,65.125,18.0,1.9387500000000009
851.0,"class Solution {
 public:
  vector<string> reorderLogFiles(vector<string>& logs) {
    vector<string> ans;
    vector<string> digitLogs;
    vector<pair<string, string>> letterLogs;

    for (const string& log : logs) {
      const int i = log.find_first_of(' ');
      if (isdigit(log[i + 1]))
        digitLogs.push_back(log);
      else
        letterLogs.emplace_back(log.substr(0, i), log.substr(i + 1));
    }

    sort(begin(letterLogs), end(letterLogs), [](const auto& a, const auto& b) {
      return a.second == b.second ? a.first < b.first : a.second < b.second;
    });

    for (const auto& [identifier, letters] : letterLogs)
      ans.push_back(identifier + ' ' + letters);

    for (const string& digitLog : digitLogs)
      ans.push_back(digitLog);

    return ans;
  }
};",12,789,0.0,4.0,4.0,6.0,65.75,16.0,2.0024999999999995
852.0,"class Solution {
 public:
  int rangeSumBST(TreeNode* root, int L, int R) {
    if (root == nullptr)
      return 0;
    if (root->val < L)
      return rangeSumBST(root->right, L, R);
    if (root->val > R)
      return rangeSumBST(root->left, L, R);
    return root->val + rangeSumBST(root->left, L, R) +
           rangeSumBST(root->right, L, R);
  }
};",5,356,0.0,0.0,2.0,3.0,71.2,4.0,3.071999999999999
853.0,"class Solution {
 public:
  int minAreaRect(vector<vector<int>>& points) {
    int ans = INT_MAX;
    unordered_map<int, unordered_set<int>> xToYs;

    for (const vector<int>& p : points)
      xToYs[p[0]].insert(p[1]);

    for (int i = 1; i < points.size(); ++i)
      for (int j = 0; j < i; ++j) {
        const vector<int>& p = points[i];
        const vector<int>& q = points[j];
        if (p[0] == q[0] || p[1] == q[1])
          continue;
        if (xToYs[p[0]].count(q[1]) && xToYs[q[0]].count(p[1]))
          ans = min(ans, abs(p[0] - q[0]) * abs(p[1] - q[1]));
      }

    return ans == INT_MAX ? 0 : ans;
  }
};",13,627,0.0,4.0,3.0,5.0,48.23076923076923,14.0,3.839230769230769
854.0,"class Solution {
 public:
  int distinctSubseqII(string s) {
    constexpr int kMod = 1'000'000'007;
    // endsWith[i] := # of subseqs ends with 'a' + i
    vector<long> endsWith(26);

    for (const char c : s)
      endsWith[c - 'a'] = accumulate(begin(endsWith), end(endsWith), 1L) % kMod;

    return accumulate(begin(endsWith), end(endsWith), 0L) % kMod;
  }
};",5,367,1.0,1.0,2.0,1.0,73.4,6.0,2.654000000000001
855.0,"class Solution {
 public:
  bool validMountainArray(vector<int>& arr) {
    if (arr.size() < 3)
      return false;

    int l = 0;
    int r = arr.size() - 1;

    while (l + 1 < arr.size() && arr[l] < arr[l + 1])
      ++l;
    while (r > 0 && arr[r] < arr[r - 1])
      --r;

    return l > 0 && r < arr.size() - 1 && l == r;
  }
};",7,335,0.0,2.0,2.0,3.0,47.85714285714285,5.0,4.952857142857143
856.0,"class Solution {
 public:
  vector<int> diStringMatch(string s) {
    vector<int> ans;
    int min = 0;
    int max = s.length();

    for (const char c : s)
      ans.push_back(c == 'I' ? min++ : max--);
    ans.push_back(min);

    return ans;
  }
};",7,252,0.0,1.0,2.0,1.0,36.0,8.0,5.78
857.0,"class Solution {
 public:
  string shortestSuperstring(vector<string>& A) {
    const int n = A.size();
    // cost[i][j] := cost to append A[j] after A[i]
    vector<vector<int>> cost(n, vector<int>(n));

    // GetCost(a, b) := cost to append b after a
    auto getCost = [](const string& a, const string& b) {
      int cost = b.length();
      const int minLength = min(a.length(), b.length());
      for (int k = 1; k <= minLength; ++k)
        if (a.substr(a.length() - k) == b.substr(0, k))
          cost = b.length() - k;
      return cost;
    };

    // Pre-calculate cost array to save time
    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        cost[i][j] = getCost(A[i], A[j]);
        cost[j][i] = getCost(A[j], A[i]);
      }

    vector<int> bestPath;
    int minLength = n * 20;  // Given by problem

    dfs(A, cost, {}, bestPath, 0, 0, 0, minLength);

    string ans = A[bestPath[0]];

    for (int k = 1; k < n; ++k) {
      const int i = bestPath[k - 1];
      const int j = bestPath[k];
      ans += A[j].substr(A[j].length() - cost[i][j]);
    }

    return ans;
  }

 private:
  // Used: i-th bit means A[i] is used or not
  void dfs(const vector<string>& A, const vector<vector<int>>& cost,
           vector<int>&& path, vector<int>& bestPath, int used, int depth,
           int currLength, int& minLength) {
    if (currLength >= minLength)
      return;
    if (depth == A.size()) {
      minLength = currLength;
      bestPath = path;
      return;
    }

    for (int i = 0; i < A.size(); ++i) {
      if (1 << i & used)
        continue;
      path.push_back(i);
      const int newLength =
          depth == 0 ? A[i].length() : currLength + cost[path[depth - 1]][i];
      dfs(A, cost, move(path), bestPath, used | 1 << i, depth + 1, newLength,
          minLength);
      path.pop_back();
    }
  }
};",37,1862,5.0,5.0,9.0,9.0,50.32432432432432,39.0,0.9308108108108116
858.0,"class Solution {
 public:
  int minDeletionSize(vector<string>& A) {
    const int n = A[0].length();
    int ans = 0;

    for (int j = 0; j < n; ++j)
      for (int i = 0; i + 1 < A.size(); ++i)
        if (A[i][j] > A[i + 1][j]) {
          ++ans;
          break;
        }

    return ans;
  }
};",10,301,0.0,2.0,3.0,3.0,30.1,8.0,6.190999999999999
859.0,"class Solution {
 public:
  int minIncrementForUnique(vector<int>& nums) {
    int ans = 0;
    int minAvailable = 0;

    sort(begin(nums), end(nums));

    for (const int num : nums) {
      ans += max(minAvailable - num, 0);
      minAvailable = max(minAvailable, num) + 1;
    }

    return ans;
  }
};",7,306,0.0,1.0,3.0,2.0,43.71428571428572,7.0,5.125714285714286
860.0,"class Solution {
 public:
  bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
    stack<int> stack;
    int i = 0;  // popped's index

    for (const int x : pushed) {
      stack.push(x);
      while (!stack.empty() && stack.top() == popped[i]) {
        stack.pop();
        ++i;
      }
    }

    return stack.empty();
  }
};",7,351,1.0,2.0,4.0,2.0,50.142857142857146,8.0,4.3671428571428565
861.0,"class Solution {
 public:
  int removeStones(vector<vector<int>>& stones) {
    int numOfIslands = 0;
    vector<vector<int>> graph(stones.size());
    unordered_set<int> seen;

    for (int i = 0; i < stones.size(); ++i)
      for (int j = i + 1; j < stones.size(); ++j)
        if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
          graph[i].push_back(j);
          graph[j].push_back(i);
        }

    for (int i = 0; i < stones.size(); ++i)
      if (seen.insert(i).second) {
        dfs(graph, i, seen);
        ++numOfIslands;
      }

    return stones.size() - numOfIslands;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {
    for (const int v : graph[u])
      if (seen.insert(v).second)
        dfs(graph, v, seen);
  }
};",16,803,0.0,7.0,5.0,7.0,50.1875,16.0,3.163125
862.0,"class Solution {
 public:
  int bagOfTokensScore(vector<int>& tokens, int power) {
    int ans = 0;
    int score = 0;
    int i = 0;                  // Index of smallest token
    int j = tokens.size() - 1;  // Index of largest token

    sort(begin(tokens), end(tokens));

    while (i <= j && (power >= tokens[i] || score)) {
      while (i <= j && power >= tokens[i]) {
        // Play the smallest face up
        power -= tokens[i++];
        ++score;
      }
      ans = max(ans, score);
      if (i <= j && score) {
        // Play the largest face down
        power += tokens[j--];
        --score;
      }
    }

    return ans;
  }
};",12,647,4.0,3.0,5.0,3.0,53.91666666666666,8.0,4.027500000000001
863.0,"class Solution {
 public:
  string largestTimeFromDigits(vector<int>& arr) {
    string ans;

    for (int i = 0; i < 4; ++i)
      for (int j = 0; j < 4; ++j)
        for (int k = 0; k < 4; ++k) {
          if (i == j || i == k || j == k)
            continue;
          const string hours = to_string(arr[i]) + to_string(arr[j]);
          const string minutes =
              to_string(arr[k]) + to_string(arr[6 - i - j - k]);
          if (hours < ""24"" && minutes < ""60"")
            ans = max(ans, hours + ':' + minutes);
        }

    return ans;
  }
};",13,560,0.0,4.0,3.0,5.0,43.07692307692308,11.0,4.603076923076923
864.0,"class Solution {
 public:
  vector<int> deckRevealedIncreasing(vector<int>& deck) {
    sort(begin(deck), end(deck), greater<int>());

    deque<int> q{deck[0]};

    for (int i = 1; i < deck.size(); ++i) {
      q.push_front(q.back());
      q.pop_back();
      q.push_front(deck[i]);
    }

    return {begin(q), end(q)};
  }
};",9,330,0.0,1.0,5.0,1.0,36.66666666666666,6.0,5.74
865.0,"class Solution {
 public:
  bool flipEquiv(TreeNode* root1, TreeNode* root2) {
    if (root1 == nullptr)
      return root2 == nullptr;
    if (root2 == nullptr)
      return root1 == nullptr;
    if (root1->val != root2->val)
      return false;
    return flipEquiv(root1->left, root2->left) &&
               flipEquiv(root1->right, root2->right) ||
           flipEquiv(root1->left, root2->right) &&
               flipEquiv(root1->right, root2->left);
  }
};",5,463,0.0,0.0,2.0,3.0,92.6,2.0,1.346000000000002
866.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int largestComponentSize(vector<int>& nums) {
    const int n = *max_element(begin(nums), end(nums));
    int ans = 0;
    UnionFind uf(n + 1);
    unordered_map<int, int> count;

    for (const int num : nums)
      for (int x = 2; x <= sqrt(num); ++x)
        if (num % x == 0) {
          uf.unionByRank(num, x);
          uf.unionByRank(num, num / x);
        }

    for (const int num : nums)
      ans = max(ans, ++count[uf.find(num)]);

    return ans;
  }
};",23,1011,0.0,7.0,10.0,7.0,43.95652173913044,26.0,2.4239130434782616
867.0,"class Solution {
 public:
  bool isAlienSorted(vector<string>& words, const string& order) {
    vector<char> map(26);  // Order = ""bca"" -> map = ['c', 'a', 'b']

    for (int i = 0; i < 26; ++i)
      map[order[i] - 'a'] = i + 'a';

    for (string& word : words)
      for (char& c : word)
        c = map[c - 'a'];

    return is_sorted(begin(words), end(words));
  }
};",7,373,1.0,3.0,2.0,3.0,53.285714285714285,9.0,4.0442857142857145
868.0,"class Solution {
 public:
  bool canReorderDoubled(vector<int>& arr) {
    unordered_map<int, int> count;

    for (const int a : arr)
      ++count[a];

    sort(arr.begin(), arr.end(),
         [](const int a, const int b) { return abs(a) < abs(b); });

    for (const int a : arr) {
      if (count[a] == 0)
        continue;
      if (count[2 * a] == 0)
        return false;
      --count[a];
      --count[2 * a];
    }

    return true;
  }
};",10,450,0.0,1.0,4.0,4.0,45.0,13.0,4.3500000000000005
869.0,"class Solution {
 public:
  int minDeletionSize(vector<string>& A) {
    const int n = A[0].length();
    int ans = 0;
    // sorted[i] := true if A[i] < A[i + 1]
    vector<bool> sorted(A.size() - 1);

    for (int j = 0; j < n; ++j) {
      int i;
      for (i = 0; i + 1 < A.size(); ++i)
        if (!sorted[i] && A[i][j] > A[i + 1][j]) {
          ++ans;
          break;
        }
      // Already compared each pair, update the sorted array if needed
      if (i + 1 == A.size())
        for (i = 0; i + 1 < A.size(); ++i)
          sorted[i] = sorted[i] || A[i][j] < A[i + 1][j];
    }

    return ans;
  }
};",15,616,2.0,6.0,4.0,7.0,41.06666666666667,9.0,4.884
870.0,"class Solution {
 public:
  int tallestBillboard(vector<int>& rods) {
    const int n = rods.size();
    const int sum = accumulate(begin(rods), end(rods), 0);
    // dp[i][j] := max min-height of using rods[0..i) to pile two piles that
    // Have height difference j
    vector<vector<int>> dp(n + 1, vector<int>(sum + 1, -1));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i) {
      const int h = rods[i - 1];
      for (int j = 0; j <= sum - h; ++j) {
        if (dp[i - 1][j] < 0)
          continue;
        // don't use rods[i - 1]
        dp[i][j] = max(dp[i][j], dp[i - 1][j]);
        // Put on the taller pile
        dp[i][j + h] = max(dp[i][j + h], dp[i - 1][j]);
        // Put on the shorter pile
        dp[i][abs(j - h)] = max(dp[i][abs(j - h)], dp[i - 1][j] + min(j, h));
      }
    }

    return dp[n][0];
  }
};",15,836,5.0,2.0,4.0,4.0,55.73333333333333,13.0,3.524
871.0,"class Solution {
 public:
  vector<int> prisonAfterNDays(vector<int>& cells, int n) {
    vector<int> firstDayCells;
    vector<int> nextDayCells(cells.size());

    for (int day = 0; n-- > 0; cells = nextDayCells, ++day) {
      for (int i = 1; i + 1 < cells.size(); ++i)
        nextDayCells[i] = cells[i - 1] == cells[i + 1];
      if (day == 0)
        firstDayCells = nextDayCells;
      else if (nextDayCells == firstDayCells)
        n %= day;
    }

    return cells;
  }
};",11,482,0.0,5.0,3.0,4.0,43.81818181818182,8.0,4.776363636363636
872.0,"class Solution {
 public:
  bool isCompleteTree(TreeNode* root) {
    if (root == nullptr)
      return true;

    queue<TreeNode*> q{{root}};

    while (q.front() != nullptr) {
      TreeNode* node = q.front();
      q.pop();
      q.push(node->left);
      q.push(node->right);
    }

    while (!q.empty() && q.front() == nullptr)
      q.pop();

    return q.empty();
  }
};",9,379,0.0,2.0,5.0,3.0,42.11111111111112,2.0,5.59
873.0,"class Solution {
 public:
  int regionsBySlashes(vector<string>& grid) {
    const int n = grid.size();
    // G := upscaled grid
    vector<vector<int>> g(n * 3, vector<int>(n * 3));

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == '/') {
          g[i * 3][j * 3 + 2] = 1;
          g[i * 3 + 1][j * 3 + 1] = 1;
          g[i * 3 + 2][j * 3] = 1;
        } else if (grid[i][j] == '\\') {
          g[i * 3][j * 3] = 1;
          g[i * 3 + 1][j * 3 + 1] = 1;
          g[i * 3 + 2][j * 3 + 2] = 1;
        }

    int ans = 0;

    for (int i = 0; i < n * 3; ++i)
      for (int j = 0; j < n * 3; ++j)
        if (g[i][j] == 0) {
          dfs(g, i, j);
          ++ans;
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& g, int i, int j) {
    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())
      return;
    if (g[i][j] != 0)
      return;

    g[i][j] = 2;  // Mark 2 as visited
    dfs(g, i + 1, j);
    dfs(g, i - 1, j);
    dfs(g, i, j + 1);
    dfs(g, i, j - 1);
  }
};",28,1053,2.0,8.0,6.0,9.0,37.60714285714285,16.0,4.255357142857143
874.0,"class Solution {
 public:
  int minDeletionSize(vector<string>& A) {
    const int n = A[0].length();
    // dp[i] := LIS ending at A[*][i]
    vector<int> dp(n, 1);

    for (int i = 1; i < n; ++i)
      for (int j = 0; j < i; ++j)
        if (all_of(begin(A), end(A),
                   [&](const string& a) { return a[j] <= a[i]; }))
          dp[i] = max(dp[i], dp[j] + 1);

    return n - *max_element(begin(dp), end(dp));
  }
};",10,434,1.0,2.0,3.0,3.0,43.4,10.0,4.8340000000000005
875.0,"class Solution {
 public:
  int repeatedNTimes(vector<int>& nums) {
    for (int i = 0; i + 2 < nums.size(); ++i)
      if (nums[i] == nums[i + 1] || nums[i] == nums[i + 2])
        return nums[i];
    return nums.back();
  }
};",5,228,0.0,1.0,2.0,2.0,45.6,4.0,5.316
876.0,"class Solution {
 public:
  int maxWidthRamp(vector<int>& nums) {
    int ans = 0;
    stack<int> stack;

    for (int i = 0; i < nums.size(); ++i)
      if (stack.empty() || nums[i] < nums[stack.top()])
        stack.push(i);

    for (int i = nums.size() - 1; i > ans; --i)
      while (!stack.empty() && nums[i] >= nums[stack.top()])
        ans = max(ans, i - stack.top()), stack.pop();

    return ans;
  }
};",10,414,0.0,4.0,2.0,4.0,41.4,7.0,5.214
877.0,"class Solution {
 public:
  double minAreaFreeRect(vector<vector<int>>& points) {
    long long ans = LLONG_MAX;
    // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}
    unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;

    for (const vector<int>& A : points)
      for (const vector<int>& B : points) {
        const int center = hash(A, B);
        centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);
      }

    // For all pair points ""that share the same center""
    for (const auto& [_, points] : centerToPoints)
      for (const auto& [ax, ay, bx, by] : points)
        for (const auto& [cx, cy, dx, dy] : points)
          // AC is perpendicular to AD
          // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0
          if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {
            const long long squaredArea =
                dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);
            if (squaredArea > 0)
              ans = min(ans, squaredArea);
          }

    return ans == LLONG_MAX ? 0 : sqrt(ans);
  }

 private:
  int hash(const vector<int>& p, const vector<int>& q) {
    return ((long long)(p[0] + q[0]) << 16) + (p[1] + q[1]);
  }

  long long dist(int px, int py, int qx, int qy) {
    return (px - qx) * (px - qx) + (py - qy) * (py - qy);
  }
};",10,1332,4.0,5.0,7.0,9.0,133.2,27.0,-5.247999999999999
878.0,"class Solution {
 public:
  int leastOpsExpressTarget(int x, int target) {
    return dfs(x, target, {});
  }

 private:
  int dfs(int x, int target, unordered_map<int, int>&& memo) {
    if (const auto it = memo.find(target); it != cend(memo))
      return it->second;
    if (x > target)
      return min(2 * target - 1, 2 * (x - target));
    if (x == target)
      return 0;

    long prod = x;
    int n = 0;
    while (prod < target) {
      prod *= x;
      ++n;
    }
    if (prod == target)
      return memo[target] = n;

    int ans = dfs(x, target - prod / x, move(memo)) + n;
    if (prod < 2 * target)
      ans = min(ans, dfs(x, prod - target, move(memo)) + n + 1);
    return memo[target] = ans;
  }
};",14,718,0.0,1.0,5.0,6.0,51.285714285714285,12.0,3.8242857142857134
879.0,"class Solution {
 public:
  vector<string> spellchecker(vector<string>& wordlist,
                              vector<string>& queries) {
    vector<string> ans;
    unordered_map<string, string> dict;

    for (const string& word : wordlist) {
      dict.insert({word, word});
      dict.insert({lowerKey(word), word});
      dict.insert({vowelKey(word), word});
    }

    for (const string& query : queries)
      if (const auto it = dict.find(query); it != cend(dict))
        ans.push_back(it->second);
      else if (const auto it = dict.find(lowerKey(query)); it != cend(dict))
        ans.push_back(it->second);
      else if (const auto it = dict.find(vowelKey(query)); it != cend(dict))
        ans.push_back(it->second);
      else
        ans.push_back("""");

    return ans;
  }

 private:
  string lowerKey(const string& word) {
    string s{""$""};
    for (char c : word)
      s += tolower(c);
    return s;
  }

  string vowelKey(const string& word) {
    string s;
    for (char c : word)
      s += string(""aeiou"").find(tolower(c)) != string::npos ? '*' : tolower(c);
    return s;
  }
};",20,1106,0.0,8.0,9.0,7.0,55.3,26.0,1.4029999999999987
880.0,"class Solution {
 public:
  vector<int> numsSameConsecDiff(int n, int k) {
    if (n == 1)
      return {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    vector<int> ans;

    if (k == 0) {
      for (char c = '1'; c <= '9'; ++c)
        ans.push_back(stoi(string(n, c)));
      return ans;
    }

    for (int num = 1; num <= 9; ++num)
      dfs(n - 1, k, num, ans);

    return ans;
  }

 private:
  void dfs(int n, int k, int num, vector<int>& ans) {
    if (n == 0) {
      ans.push_back(num);
      return;
    }

    const int lastDigit = num % 10;

    for (const int nextDigit : {lastDigit - k, lastDigit + k})
      if (0 <= nextDigit && nextDigit <= 9)
        dfs(n - 1, k, num * 10 + nextDigit, ans);
  }
};",15,706,0.0,4.0,7.0,8.0,47.06666666666667,17.0,3.404
881.0,"class Solution {
 public:
  int minCameraCover(TreeNode* root) {
    vector<int> ans = dfs(root);
    return min(ans[1], ans[2]);
  }

 private:
  // 0 := all nodes below root are covered except root
  // 1 := all nodes below and including root are covered w/o camera here
  // 2 := all nodes below and including root are covered w/ camera here
  vector<int> dfs(TreeNode* root) {
    if (root == nullptr)
      return {0, 0, 1000};

    vector<int> l = dfs(root->left);
    vector<int> r = dfs(root->right);

    const int s0 = l[1] + r[1];
    const int s1 = min(l[2] + min(r[1], r[2]),  //
                       r[2] + min(l[1], l[2]));
    const int s2 = min({l[0], l[1], l[2]}) +  //
                   min({r[0], r[1], r[2]}) + 1;
    return {s0, s1, s2};
  }
};",10,769,5.0,-1.0,7.0,1.0,76.9,12.0,1.7189999999999994
882.0,"class Solution {
 public:
  vector<int> pancakeSort(vector<int>& arr) {
    vector<int> ans;

    for (int target = arr.size(); target >= 1; --target) {
      int index = find(arr, target);
      reverse(begin(arr), begin(arr) + index + 1);
      reverse(begin(arr), begin(arr) + target);
      ans.push_back(index + 1);
      ans.push_back(target);
    }

    return ans;
  }

 private:
  int find(vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i)
      if (arr[i] == target)
        return i;
    throw;
  }
};",14,535,0.0,1.0,4.0,3.0,38.21428571428572,10.0,5.260714285714286
883.0,"class Solution {
 public:
  vector<int> powerfulIntegers(int x, int y, int bound) {
    unordered_set<int> ans;

    for (int i = 1; i < bound; i *= x) {
      for (int j = 1; i + j <= bound; j *= y) {
        ans.insert(i + j);
        if (y == 1)
          break;
      }
      if (x == 1)
        break;
    }

    return {begin(ans), end(ans)};
  }
};",10,355,0.0,2.0,5.0,4.0,35.5,8.0,5.585
884.0,"class Solution {
 public:
  vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
    vector<int> ans;
    dfs(root, 0, voyage, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int&& i, const vector<int>& voyage,
           vector<int>& ans) {
    if (root == nullptr)
      return;
    if (root->val != voyage[i++]) {
      ans.clear();
      ans.push_back(-1);
      return;
    }

    if (i < voyage.size() && root->left && root->left->val != voyage[i]) {
      // Flip root
      ans.push_back(root->val);
      dfs(root->right, move(i), voyage, ans);
      dfs(root->left, move(i), voyage, ans);
    } else {
      dfs(root->left, move(i), voyage, ans);
      dfs(root->right, move(i), voyage, ans);
    }
  }
};",13,745,1.0,2.0,6.0,3.0,57.30769230769231,9.0,3.502307692307692
885.0,"class Solution {
 public:
  bool isRationalEqual(string s, string t) {
    return abs(valueOf(s) - valueOf(t)) < 1e-9;
  }

 private:
  const static vector<double> ratios{1.0, 1.0 / 9, 1.0 / 99, 1.0 / 999,
                                     1.0 / 9999};

  double valueOf(const string& s) {
    if (s.find('(') == string::npos)
      return stod(s);

    // Get indices.
    const int leftParenIndex = s.find_first_of('(');
    const int rightParenIndex = s.find_first_of(')');
    const int dotIndex = s.find_first_of('.');

    // integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>
    const double integerAndNonRepeating = stod(s.substr(0, leftParenIndex));
    const int nonRepeatingLength = leftParenIndex - dotIndex - 1;

    // repeating := <RepeatingPart>
    const int repeating = stoi(s.substr(leftParenIndex + 1, rightParenIndex));
    const int repeatingLength = rightParenIndex - leftParenIndex - 1;
    return integerAndNonRepeating +
           repeating * pow(0.1, nonRepeatingLength) * ratios[repeatingLength];
  }
};",12,1046,3.0,-1.0,4.0,1.0,87.16666666666667,24.0,-0.3050000000000015
886.0,"class Solution {
 public:
  vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
    vector<vector<int>> ans;
    auto compare = [&](const vector<int>& a, const vector<int>& b) {
      return squareDist(a) < squareDist(b);
    };
    priority_queue<vector<int>, vector<vector<int>>, decltype(compare)> maxHeap(
        compare);

    for (const vector<int>& point : points) {
      maxHeap.push(point);
      if (maxHeap.size() > k)
        maxHeap.pop();
    }

    while (!maxHeap.empty())
      ans.push_back(maxHeap.top()), maxHeap.pop();

    return ans;
  };

 private:
  int squareDist(const vector<int>& p) {
    return p[0] * p[0] + p[1] * p[1];
  }
};",11,675,0.0,1.0,5.0,3.0,61.36363636363637,16.0,2.517272727272728
887.0,"class Solution {
 public:
  int subarraysDivByK(vector<int>& nums, int k) {
    int ans = 0;
    int prefix = 0;
    vector<int> count(k);
    count[0] = 1;

    for (const int num : nums) {
      prefix = (prefix + num % k + k) % k;
      ans += count[prefix];
      ++count[prefix];
    }

    return ans;
  }
};",9,314,0.0,1.0,3.0,1.0,34.888888888888886,9.0,5.720000000000001
888.0,"class Solution {
 public:
  int oddEvenJumps(vector<int>& arr) {
    const int n = arr.size();
    map<int, int> map;    // {num: min index}
    vector<bool> inc(n);  // inc[i] := can reach arr[n - 1] from i w/ inc jump
    vector<bool> dec(n);  // dec[i] := can reach arr[n - 1] from i w/ dec jump

    map[arr[n - 1]] = n - 1;
    inc.back() = true;
    dec.back() = true;

    for (int i = n - 2; i >= 0; --i) {
      const auto lo = map.lower_bound(arr[i]);  // Min val >= arr[i]
      const auto hi = map.upper_bound(arr[i]);  // Min val > arr[i]
      if (lo != cend(map))
        inc[i] = dec[lo->second];
      if (hi != cbegin(map))
        dec[i] = inc[prev(hi)->second];
      map[arr[i]] = i;
    }

    return count(begin(inc), end(inc), true);
  }
};",16,764,5.0,3.0,4.0,3.0,47.75,12.0,4.282500000000001
889.0,"class Solution {
 public:
  int largestPerimeter(vector<int>& nums) {
    sort(begin(nums), end(nums));

    for (int i = nums.size() - 1; i > 1; --i)
      if (nums[i - 2] + nums[i - 1] > nums[i])
        return nums[i - 2] + nums[i - 1] + nums[i];

    return 0;
  }
};",6,271,0.0,1.0,2.0,2.0,45.16666666666666,4.0,5.355
890.0,"class Solution {
 public:
  vector<int> sortedSquares(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);
    int i = n - 1;

    for (int l = 0, r = n - 1; l <= r;)
      if (abs(nums[l]) > abs(nums[r]))
        ans[i--] = nums[l] * nums[l++];
      else
        ans[i--] = nums[r] * nums[r--];

    return ans;
  }
};",9,343,0.0,3.0,2.0,2.0,38.11111111111112,8.0,5.47
891.0,"class Solution {
 public:
  int maxTurbulenceSize(vector<int>& arr) {
    int ans = 1;
    int increasing = 1;
    int decreasing = 1;

    for (int i = 1; i < arr.size(); ++i) {
      if (arr[i] > arr[i - 1]) {
        increasing = decreasing + 1;
        decreasing = 1;
      } else if (arr[i] < arr[i - 1]) {
        decreasing = increasing + 1;
        increasing = 1;
      } else {
        increasing = 1;
        decreasing = 1;
      }
      ans = max({ans, increasing, decreasing});
    }

    return ans;
  }
};",14,522,0.0,5.0,7.0,3.0,37.285714285714285,7.0,5.224285714285715
892.0,"class Solution {
 public:
  int distributeCoins(TreeNode* root) {
    int ans = 0;
    dfs(root, ans);
    return ans;
  }

  // Returns how many coins I can give (positive) / take (negative)
 private:
  int dfs(TreeNode* root, int& ans) {
    if (root == nullptr)
      return 0;

    const int l = dfs(root->left, ans);
    const int r = dfs(root->right, ans);
    ans += abs(l) + abs(r);
    return (root->val - 1) + l + r;
  }
};",9,433,1.0,-1.0,3.0,1.0,48.11111111111112,9.0,4.69
893.0,"class Solution {
 public:
  int uniquePathsIII(vector<vector<int>>& grid) {
    int ans = 0;
    int empty = 1;
    int sx;
    int sy;
    int ex;
    int ey;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] == 0) {
          ++empty;
        } else if (grid[i][j] == 1) {
          sx = i;
          sy = j;
        } else if (grid[i][j] == 2) {
          ex = i;
          ey = j;
        }

    dfs(grid, empty, sx, sy, ex, ey, ans);

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& grid, int empty, int i, int j, int ex, int ey,
           int& ans) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] < 0)
      return;
    if (i == ex && j == ey) {
      if (empty == 0)
        ++ans;
      return;
    }

    grid[i][j] = -2;
    dfs(grid, empty - 1, i + 1, j, ex, ey, ans);
    dfs(grid, empty - 1, i - 1, j, ex, ey, ans);
    dfs(grid, empty - 1, i, j + 1, ex, ey, ans);
    dfs(grid, empty - 1, i, j - 1, ex, ey, ans);
    grid[i][j] = 0;
  }
};",28,1086,0.0,8.0,7.0,9.0,38.785714285714285,19.0,3.7092857142857145
894.0,"class Solution {
 public:
  int countTriplets(vector<int>& nums) {
    constexpr int kMax = 1 << 16;
    int ans = 0;
    vector<int> count(kMax);  // {nums[i] & nums[j]: times}

    for (const int a : nums)
      for (const int b : nums)
        ++count[a & b];

    for (const int num : nums)
      for (int i = 0; i < kMax; ++i)
        if ((num & i) == 0)
          ans += count[i];

    return ans;
  }
};",9,410,1.0,5.0,3.0,5.0,45.55555555555556,13.0,4.160000000000001
895.0,"class Solution {
 public:
  int mincostTickets(vector<int>& days, vector<int>& costs) {
    int ans = 0;
    queue<pair<int, int>> last7;
    queue<pair<int, int>> last30;

    for (int day : days) {
      while (!last7.empty() && last7.front().first + 7 <= day)
        last7.pop();
      while (!last30.empty() && last30.front().first + 30 <= day)
        last30.pop();
      last7.emplace(day, ans + costs[1]);
      last30.emplace(day, ans + costs[2]);
      ans = min({ans + costs[0], last7.front().second, last30.front().second});
    }

    return ans;
  }
};",10,566,0.0,3.0,4.0,3.0,56.6,10.0,3.486
896.0,"class Solution {
 public:
  string strWithout3a3b(int A, int B, char a = 'a', char b = 'b') {
    if (A < B)
      return strWithout3a3b(B, A, b, a);
    if (B == 0)
      return string(min(A, 2), a);

    const int useA = min(A, 2);
    const int useB = (A - useA >= B) ? 1 : 0;
    return string(useA, a) + string(useB, b) +
           strWithout3a3b(A - useA, B - useB, a, b);
  }
};",6,386,0.0,0.0,2.0,2.0,64.33333333333333,13.0,2.790000000000001
897.0,"class Solution {
 public:
  vector<int> sumEvenAfterQueries(vector<int>& nums,
                                  vector<vector<int>>& queries) {
    vector<int> ans;
    int sum = accumulate(begin(nums), end(nums), 0, [](int subtotal, int num) {
      return subtotal + (num % 2 == 0 ? num : 0);
    });

    for (const vector<int>& query : queries) {
      const int val = query[0];
      const int index = query[1];
      if (nums[index] % 2 == 0)
        sum -= nums[index];
      nums[index] += val;
      if (nums[index] % 2 == 0)
        sum += nums[index];
      ans.push_back(sum);
    }

    return ans;
  }
};",11,619,0.0,2.0,4.0,3.0,56.27272727272727,14.0,3.175454545454545
898.0,"class Solution {
 public:
  vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList,
                                           vector<vector<int>>& secondList) {
    vector<vector<int>> ans;
    short i = 0;
    short j = 0;

    while (i < firstList.size() && j < secondList.size()) {
      // Lo := the start of the intersection
      // Hi := the end of the intersection
      const int lo = max(firstList[i][0], secondList[j][0]);
      const int hi = min(firstList[i][1], secondList[j][1]);
      if (lo <= hi)
        ans.push_back({lo, hi});
      firstList[i][1] < secondList[j][1] ? ++i : ++j;
    }

    return ans;
  }
};",9,649,2.0,2.0,4.0,2.0,72.11111111111111,9.0,2.329999999999999
899.0,"class Solution {
 public:
  vector<vector<int>> verticalTraversal(TreeNode* root) {
    vector<vector<int>> ans;
    map<int, multiset<pair<int, int>>> xToSortedPairs;  // {x: {(-y, val)}}

    dfs(root, 0, 0, xToSortedPairs);

    for (const auto& [_, pairs] : xToSortedPairs) {
      vector<int> vals;
      for (const pair<int, int>& pair : pairs)
        vals.push_back(pair.second);
      ans.push_back(vals);
    }

    return ans;
  }

 private:
  void dfs(TreeNode* root, int x, int y,
           map<int, multiset<pair<int, int>>>& xToSortedPairs) {
    if (root == nullptr)
      return;

    xToSortedPairs[x].emplace(y, root->val);
    dfs(root->left, x - 1, y + 1, xToSortedPairs);
    dfs(root->right, x + 1, y + 1, xToSortedPairs);
  }
};",12,753,1.0,2.0,6.0,3.0,62.75,17.0,2.2124999999999995
900.0,"class Solution {
 public:
  string smallestFromLeaf(TreeNode* root) {
    string ans;
    dfs(root, """", ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, string&& path, string& ans) {
    if (root == nullptr)
      return;

    path.push_back(root->val + 'a');

    if (root->left == nullptr && root->right == nullptr) {
      reverse(begin(path), end(path));
      if (ans == """" || ans > path)
        ans = path;
      reverse(begin(path), end(path));  // Roll back
    }

    dfs(root->left, move(path), ans);
    dfs(root->right, move(path), ans);
    path.pop_back();
  }
};",12,593,1.0,2.0,4.0,3.0,49.41666666666666,6.0,4.6325
901.0,"class Solution {
 public:
  vector<int> addToArrayForm(vector<int>& num, int k) {
    for (int i = num.size() - 1; i >= 0; --i) {
      num[i] += k;
      k = num[i] / 10;
      num[i] %= 10;
    }

    while (k > 0) {
      num.insert(begin(num), k % 10);
      k /= 10;
    }

    return num;
  }
};",9,301,0.0,2.0,4.0,3.0,33.44444444444444,5.0,6.13
902.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n) {
    iota(begin(id), end(id), 0);
  }

  void union_(int u, int v) {
    id[find(u)] = find(v);
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
};

class Solution {
 public:
  bool equationsPossible(vector<string>& equations) {
    UnionFind uf(26);

    for (const string& e : equations)
      if (e[1] == '=') {
        const int x = e[0] - 'a';
        const int y = e[3] - 'a';
        uf.union_(x, y);
      }

    for (const string& e : equations)
      if (e[1] == '!') {
        const int x = e[0] - 'a';
        const int y = e[3] - 'a';
        if (uf.find(x) == uf.find(y))
          return false;
      }

    return true;
  }
};",14,755,0.0,3.0,8.0,5.0,53.92857142857143,23.0,2.1864285714285714
903.0,"class Solution {
 public:
  int brokenCalc(int X, int Y) {
    int ops = 0;

    while (X < Y) {
      if (Y % 2 == 0)
        Y /= 2;
      else
        Y += 1;
      ++ops;
    }

    return ops + X - Y;
  }
};",6,212,0.0,3.0,3.0,2.0,35.333333333333336,5.0,5.96
904.0,"class Solution {
 public:
  int subarraysWithKDistinct(vector<int>& nums, int k) {
    return subarrayWithAtMostKDistinct(nums, k) -
           subarrayWithAtMostKDistinct(nums, k - 1);
  }

 private:
  int subarrayWithAtMostKDistinct(const vector<int>& nums, int k) {
    int ans = 0;
    vector<int> count(nums.size() + 1);

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (++count[nums[r]] == 1)
        --k;
      while (k == -1)
        if (--count[nums[l++]] == 0)
          ++k;
      ans += r - l + 1;  // nums[l..r], nums[l + 1..r], ..., nums[r]
    }

    return ans;
  }
};",10,596,1.0,3.0,4.0,4.0,59.6,11.0,3.156
905.0,"class Solution {
 public:
  bool isCousins(TreeNode* root, int x, int y) {
    if (root == nullptr)
      return false;

    queue<TreeNode*> queue{{root}};

    while (!queue.empty()) {
      bool isFindX = false;
      bool isFindY = false;
      for (int i = queue.size(); i > 0; --i) {
        root = queue.front(), queue.pop();
        if (root->val == x)
          isFindX = true;
        else if (root->val == y)
          isFindY = true;
        else if (root->left && root->right) {
          if (root->left->val == x && root->right->val == y)
            return false;
          if (root->left->val == y && root->right->val == x)
            return false;
        }
        if (root->left)
          queue.push(root->left);
        if (root->right)
          queue.push(root->right);
      }
      if (isFindX && isFindY)
        return true;
      else if (isFindX || isFindY)
        return false;
    }

    return false;
  }
};",17,941,0.0,10.0,7.0,12.0,55.35294117647059,7.0,3.298235294117648
906.0,"class Solution {
 public:
  int orangesRotting(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};

    auto isNeighborRotten = [&](int i, int j, const vector<vector<int>>& grid) {
      for (int k = 0; k < 4; ++k) {
        const int r = i + dirs[k];
        const int c = j + dirs[k + 1];
        if (r < 0 || r == m || c < 0 || c == n)
          continue;
        if (grid[r][c] == 2)
          return true;
      }
      return false;
    };

    int ans = 0;

    while (true) {
      vector<vector<int>> nextGrid(m, vector<int>(n));
      // Calculate `nextGrid` based on `grid`
      for (int i = 0; i < m; ++i)
        for (int j = 0; j < n; ++j)
          if (grid[i][j] == 1) {  // Fresh
            if (isNeighborRotten(
                    i, j, grid))  // Any of 4-directionally oranges is rotten
              nextGrid[i][j] = 2;
            else
              nextGrid[i][j] = 1;
          } else if (grid[i][j] == 2) {  // Rotten
            nextGrid[i][j] = 2;          // Keep rotten
          }
      if (nextGrid == grid)
        break;
      grid = nextGrid;
      ++ans;
    }

    return any_of(
               begin(grid), end(grid),
               [&](vector<int>& row) {
      return any_of(begin(row), end(row),
                    [&](int orange) { return orange == 1; });
               })
        ? -1
        : ans;
  }
};",27,1439,5.0,6.0,10.0,10.0,53.2962962962963,25.0,1.9433333333333327
907.0,"class Solution {
 public:
  int minKBitFlips(vector<int>& nums, int k) {
    int ans = 0;
    int flippedTime = 0;

    for (int i = 0; i < nums.size(); ++i) {
      if (i >= k && nums[i - k] == 2)
        --flippedTime;
      if (flippedTime % 2 == nums[i]) {
        if (i + k > nums.size())
          return -1;
        ++ans;
        ++flippedTime;
        nums[i] = 2;
      }
    }

    return ans;
  }
};",11,411,0.0,3.0,4.0,4.0,37.36363636363637,7.0,5.517272727272728
908.0,"class Solution {
 public:
  int numSquarefulPerms(vector<int>& nums) {
    int ans = 0;
    sort(begin(nums), end(nums));
    dfs(nums, vector<bool>(nums.size()), {}, ans);
    return ans;
  }

 private:
  void dfs(vector<int>& nums, vector<bool>&& used, vector<int>&& path,
           int& ans) {
    if (path.size() > 1 && !isSquare(path.back() + path[path.size() - 2]))
      return;
    if (path.size() == nums.size()) {
      ++ans;
      return;
    }

    for (int i = 0; i < nums.size(); ++i) {
      if (used[i])
        continue;
      if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])
        continue;
      used[i] = true;
      path.push_back(nums[i]);
      dfs(nums, move(used), move(path), ans);
      path.pop_back();
      used[i] = false;
    }
  }

  bool isSquare(int num) {
    const int root = sqrt(num);
    return root * root == num;
  }
};",19,869,0.0,0.0,7.0,5.0,45.73684210526316,15.0,3.963684210526316
909.0,"class Solution {
 public:
  int findJudge(int n, vector<vector<int>>& trust) {
    vector<int> count(n + 1);

    for (vector<int>& t : trust) {
      --count[t[0]];
      ++count[t[1]];
    }

    for (int i = 1; i < n + 1; ++i)
      if (count[i] == n - 1)
        return i;

    return -1;
  }
};",8,299,0.0,2.0,3.0,3.0,37.375,7.0,5.63625
910.0,"class Solution {
 public:
  TreeNode* insertIntoMaxTree(TreeNode* root, int val) {
    if (root == nullptr)
      return new TreeNode(val);
    if (root->val < val)
      return new TreeNode(val, root, nullptr);
    root->right = insertIntoMaxTree(root->right, val);
    return root;
  }
};",5,290,0.0,0.0,2.0,2.0,58.0,2.0,4.46
911.0,"class Solution {
 public:
  int numRookCaptures(vector<vector<char>>& board) {
    int ans = 0;
    int i0 = 0;
    int j0 = 0;

    for (int i = 0; i < 8; ++i)
      for (int j = 0; j < 8; ++j)
        if (board[i][j] == 'R') {
          i0 = i;
          j0 = j;
        }

    for (const vector<int>& d :
         vector<vector<int>>({{1, 0}, {0, 1}, {-1, 0}, {0, -1}}))
      for (int i = i0 + d[0], j = j0 + d[1]; 0 <= i && i < 8 && 0 <= j && j < 8;
           i += d[0], j += d[1]) {
        if (board[i][j] == 'p')
          ++ans;
        if (board[i][j] != '.')
          break;
      }

    return ans;
  }
};",15,619,0.0,6.0,9.0,7.0,41.266666666666666,12.0,4.186
912.0,"class Solution {
 public:
  int mergeStones(vector<int>& stones, int K) {
    const int n = stones.size();
    this->K = K;

    // dp[i][j][k] := min cost to merge stones[i..j] into k piles
    dp.resize(n, vector<vector<int>>(n, vector<int>(K + 1, kMax)));
    prefix.resize(n + 1);

    partial_sum(begin(stones), end(stones), begin(prefix) + 1);

    const int cost = mergeStones(stones, 0, n - 1, 1);
    return cost == kMax ? -1 : cost;
  }

 private:
  static constexpr int kMax = 1'000'000'000;
  int K;
  vector<vector<vector<int>>> dp;
  vector<int> prefix;

  int mergeStones(const vector<int>& stones, int i, int j, int k) {
    if ((j - i + 1 - k) % (K - 1))
      return kMax;
    if (i == j)
      return k == 1 ? 0 : kMax;
    if (dp[i][j][k] != kMax)
      return dp[i][j][k];
    if (k == 1)
      return mergeStones(stones, i, j, K) + prefix[j + 1] - prefix[i];

    for (int m = i; m < j; m += K - 1)
      dp[i][j][k] = min(dp[i][j][k], mergeStones(stones, i, m, 1) +
                                         mergeStones(stones, m + 1, j, k - 1));

    return dp[i][j][k];
  }
};",20,1100,1.0,0.0,3.0,5.0,55.0,21.0,2.81
913.0,"class Solution {
 public:
  vector<int> gridIllumination(int n, vector<vector<int>>& lamps,
                               vector<vector<int>>& queries) {
    vector<int> ans;
    unordered_map<int, int> rows;
    unordered_map<int, int> cols;
    unordered_map<int, int> diag1;
    unordered_map<int, int> diag2;
    unordered_set<pair<int, int>, pairHash> lampsSet;

    for (vector<int>& lamp : lamps) {
      int i = lamp[0];
      int j = lamp[1];
      if (lampsSet.insert({i, j}).second) {
        ++rows[i];
        ++cols[j];
        ++diag1[i + j];
        ++diag2[i - j];
      }
    }

    for (const vector<int>& query : queries) {
      int i = query[0];
      int j = query[1];
      if (rows[i] || cols[j] || diag1[i + j] || diag2[i - j]) {
        ans.push_back(1);
        for (int y = max(0, i - 1); y < min(n, i + 2); ++y)
          for (int x = max(0, j - 1); x < min(n, j + 2); ++x)
            if (lampsSet.erase({y, x})) {
              --rows[y];
              --cols[x];
              --diag1[y + x];
              --diag2[y - x];
            }
      } else {
        ans.push_back(0);
      }
    }

    return ans;
  }

 private:
  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };
};",28,1279,0.0,7.0,12.0,7.0,45.67857142857143,30.0,1.7489285714285714
914.0,"class Solution {
 public:
  vector<string> commonChars(vector<string>& A) {
    vector<string> ans;
    vector<int> commonCount(26, INT_MAX);

    for (const string& a : A) {
      vector<int> count(26);
      for (char c : a)
        ++count[c - 'a'];
      for (int i = 0; i < 26; ++i)
        commonCount[i] = min(commonCount[i], count[i]);
    }

    for (char c = 'a'; c <= 'z'; ++c)
      for (int i = 0; i < commonCount[c - 'a']; ++i)
        ans.push_back(string(1, c));

    return ans;
  }
};",14,502,0.0,5.0,3.0,5.0,35.857142857142854,13.0,4.992857142857144
915.0,"class Solution {
 public:
  bool isValid(string s) {
    stack<char> stack;

    for (const char c : s)
      if (c == 'c') {
        if (stack.size() < 2)
          return false;
        if (stack.top() != 'b')
          return false;
        stack.pop();
        if (stack.top() != 'a')
          return false;
        stack.pop();
      } else {
        stack.push(c);
      }

    return stack.empty();
  }
};",9,413,0.0,3.0,4.0,5.0,45.888888888888886,6.0,4.85
916.0,"class Solution {
 public:
  int longestOnes(vector<int>& nums, int k) {
    int ans = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        --k;
      while (k < 0)
        if (nums[l++] == 0)
          ++k;
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",8,303,0.0,4.0,3.0,4.0,37.875,6.0,5.57125
917.0,"class Solution {
 public:
  int largestSumAfterKNegations(vector<int>& nums, int k) {
    sort(begin(nums), end(nums));

    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] > 0 || k == 0)
        break;
      nums[i] = -nums[i];
      --k;
    }

    return accumulate(begin(nums), end(nums), 0) -
           (k % 2) * *min_element(begin(nums), end(nums)) * 2;
  }
};",8,377,0.0,1.0,3.0,2.0,47.125,5.0,5.018750000000001
918.0,"class Solution {
 public:
  int clumsy(int n) {
    if (n == 1)
      return 1;
    if (n == 2)
      return 2;
    if (n == 3)
      return 6;
    if (n == 4)
      return 7;
    if (n % 4 == 1)
      return n + 2;
    if (n % 4 == 2)
      return n + 2;
    if (n % 4 == 3)
      return n - 1;
    return n + 1;
  }
};",9,320,0.0,0.0,2.0,7.0,35.55555555555556,3.0,6.38
919.0,"class Solution {
 public:
  int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {
    const int n = tops.size();
    vector<int> countTops(7);
    vector<int> countBottoms(7);
    vector<int> countBoth(7);

    for (int i = 0; i < n; ++i) {
      ++countTops[tops[i]];
      ++countBottoms[bottoms[i]];
      if (tops[i] == bottoms[i])
        ++countBoth[tops[i]];
    }

    for (int i = 1; i <= 6; ++i)
      if (countTops[i] + countBottoms[i] - countBoth[i] == n)
        return n - max(countTops[i], countBottoms[i]);

    return -1;
  }
};",14,557,0.0,3.0,3.0,4.0,39.785714285714285,11.0,4.9592857142857145
920.0,"class Solution {
 public:
  TreeNode* bstFromPreorder(vector<int>& preorder) {
    TreeNode* root = new TreeNode(preorder[0]);
    stack<TreeNode*> stack{{root}};

    for (int i = 1; i < preorder.size(); ++i) {
      TreeNode* parent = stack.top();
      TreeNode* child = new TreeNode(preorder[i]);
      // Adjust parent
      while (!stack.empty() && stack.top()->val < child->val)
        parent = stack.top(), stack.pop();
      // Create parent-child link according to BST property
      if (parent->val > child->val)
        parent->left = child;
      else
        parent->right = child;
      stack.push(child);
    }

    return root;
  }
};",12,652,2.0,4.0,5.0,3.0,54.333333333333336,3.0,4.3500000000000005
921.0,"class Solution {
 public:
  int bitwiseComplement(int n) {
    int mask = 1;
    while (mask < n)
      mask = (mask << 1) + 1;
    return mask ^ n;
  }
};",4,155,0.0,1.0,2.0,1.0,38.75,4.0,5.932500000000001
922.0,"class Solution {
 public:
  int numPairsDivisibleBy60(vector<int>& time) {
    int ans = 0;
    vector<int> count(60);

    for (int t : time) {
      t %= 60;
      ans += count[(60 - t) % 60];
      ++count[t];
    }

    return ans;
  }
};",7,242,0.0,1.0,3.0,1.0,34.57142857142857,6.0,6.048571428571428
923.0,"class Solution {
 public:
  int shipWithinDays(vector<int>& weights, int days) {
    int l = *max_element(begin(weights), end(weights));
    int r = accumulate(begin(weights), end(weights), 0);

    while (l < r) {
      const int m = (l + r) / 2;
      if (shipDays(weights, m) <= days)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int shipDays(const vector<int>& weights, int shipCapacity) {
    int days = 1;
    int capacity = 0;
    for (const int weight : weights)
      if (capacity + weight > shipCapacity) {
        ++days;
        capacity = weight;
      } else {
        capacity += weight;
      }
    return days;
  };
};",14,673,0.0,5.0,6.0,4.0,48.07142857142857,16.0,3.4135714285714283
924.0,"class Solution {
 public:
  int numDupDigitsAtMostN(int n) {
    return n - countSpecialNumbers(n);
  }

 private:
  // Same as 2376. Count Special Integers
  int countSpecialNumbers(int n) {
    const int digitSize = log10(n) + 1;
    // dp[i][j][k] := # of special integers that belong to the interval
    // [0, 10^i] with `usedMask` j, where k is 0/1 tight constraint
    dp.resize(digitSize + 1, vector<vector<int>>(1 << 10, vector<int>(2, -1)));
    return count(to_string(n), digitSize, 0, true) - 1;  // - 0;
  }

  vector<vector<vector<int>>> dp;

  int count(const string& s, int digitSize, int usedMask, bool isTight) {
    if (digitSize == 0)
      return 1;
    if (dp[digitSize][usedMask][isTight] != -1)
      return dp[digitSize][usedMask][isTight];

    int ans = 0;
    const int maxDigit = isTight ? s[s.length() - digitSize] - '0' : 9;

    for (int digit = 0; digit <= maxDigit; ++digit) {
      // `digit` is used
      if (usedMask >> digit & 1)
        continue;
      // Use `digit` now
      const bool nextIsTight = isTight && (digit == maxDigit);
      if (usedMask == 0 && digit == 0)  // don't count leading 0s as used
        ans += count(s, digitSize - 1, usedMask, nextIsTight);
      else
        ans += count(s, digitSize - 1, usedMask | 1 << digit, nextIsTight);
    }

    return dp[digitSize][usedMask][isTight] = ans;
  }
};",18,1363,7.0,1.0,5.0,5.0,75.72222222222223,22.0,0.9049999999999976
925.0,"class Solution {
 public:
  bool canThreePartsEqualSum(vector<int>& arr) {
    const int sum = accumulate(begin(arr), end(arr), 0);
    if (sum % 3 != 0)
      return false;

    const int average = sum / 3;
    int partCount = 0;
    int partSum = 0;

    for (const int a : arr) {
      partSum += a;
      if (partSum == average) {
        ++partCount;
        partSum = 0;
      }
    }

    // Edge case: arr = [0, 0, 0, 0] -> partCount = 4.
    return partCount >= 3;
  }
};",10,480,1.0,3.0,4.0,3.0,48.0,11.0,4.2
926.0,"class Solution {
 public:
  int maxScoreSightseeingPair(vector<int>& values) {
    int ans = 0;
    int bestPrev = 0;

    for (const int value : values) {
      ans = max(ans, value + bestPrev);
      bestPrev = max(bestPrev, value) - 1;
    }

    return ans;
  }
};",6,268,0.0,1.0,3.0,1.0,44.66666666666666,7.0,5.040000000000001
927.0,"class Solution {
 public:
  int smallestRepunitDivByK(int k) {
    if (k % 10 != 1 && k % 10 != 3 && k % 10 != 7 && k % 10 != 9)
      return -1;

    unordered_set<int> seen;
    int n = 0;

    for (int length = 1; length <= k; ++length) {
      n = (n * 10 + 1) % k;
      if (n == 0)
        return length;
      if (seen.count(n))
        return -1;
      seen.insert(n);
    }

    return -1;
  }
};",11,405,0.0,1.0,3.0,4.0,36.81818181818182,6.0,5.846363636363637
928.0,"class Solution {
 public:
  bool queryString(string s, int n) {
    if (n > 1511)
      return false;

    for (int i = n; i > n / 2; --i) {
      string binary = bitset<32>(i).to_string();
      binary = binary.substr(binary.find(""1""));
      if (s.find(binary) == string::npos)
        return false;
    }

    return true;
  }
};",8,332,0.0,1.0,3.0,3.0,41.5,7.0,5.325000000000001
929.0,"class Solution {
 public:
  string baseNeg2(int n) {
    string ans;

    while (n != 0) {
      ans += to_string(n & 1);
      n = -(n >> 1);
    }

    return ans.empty() ? ""0"" : string{rbegin(ans), rend(ans)};
  }
};",5,219,0.0,1.0,4.0,1.0,43.8,5.0,5.258
930.0,"class Solution {
 public:
  vector<bool> prefixesDivBy5(vector<int>& nums) {
    vector<bool> ans;
    int curr = 0;

    for (const int num : nums) {
      curr = (curr * 2 + num) % 5;
      ans.push_back(curr % 5 == 0);
    }

    return ans;
  }
};",6,251,0.0,1.0,3.0,1.0,41.833333333333336,7.0,5.295000000000001
931.0,"class Solution {
 public:
  vector<int> nextLargerNodes(ListNode* head) {
    vector<int> ans;
    stack<int> stack;

    for (; head; head = head->next) {
      while (!stack.empty() && head->val > ans[stack.top()]) {
        int index = stack.top();
        stack.pop();
        ans[index] = head->val;
      }
      stack.push(ans.size());
      ans.push_back(head->val);
    }

    for (; !stack.empty(); stack.pop())
      ans[stack.top()] = 0;

    return ans;
  }
};",14,473,0.0,3.0,4.0,3.0,33.785714285714285,5.0,6.039285714285715
932.0,"class Solution {
 public:
  int numEnclaves(vector<vector<int>>& A) {
    const int m = A.size();
    const int n = A[0].size();

    // Remove lands connected to edge
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (A[i][j] == 1)
            dfs(A, i, j);

    return accumulate(begin(A), end(A), 0, [](int s, vector<int>& row) {
      return s + accumulate(begin(row), end(row), 0);
    });
  }

 private:
  void dfs(vector<vector<int>>& A, int i, int j) {
    if (i < 0 || i == A.size() || j < 0 || j == A[0].size())
      return;
    if (A[i][j] == 0)
      return;

    A[i][j] = 0;
    dfs(A, i + 1, j);
    dfs(A, i - 1, j);
    dfs(A, i, j + 1);
    dfs(A, i, j - 1);
  };
};",18,766,1.0,3.0,4.0,6.0,42.55555555555556,15.0,4.29
933.0,"class Solution {
 public:
  vector<bool> camelMatch(vector<string>& queries, string pattern) {
    vector<bool> ans;
    for (const string& query : queries)
      ans.push_back(isMatch(query, pattern));
    return ans;
  }

 private:
  bool isMatch(const string& query, const string& pattern) {
    int j = 0;
    for (const char c : query)
      if (j < pattern.length() && c == pattern[j])
        ++j;
      else if (isupper(c))
        return false;
    return j == pattern.length();
  }
};",8,494,0.0,3.0,3.0,4.0,61.75,15.0,2.5825000000000005
934.0,"class Solution {
 public:
  int videoStitching(vector<vector<int>>& clips, int time) {
    int ans = 0;
    int end = 0;
    int farthest = 0;

    sort(std::begin(clips), std::end(clips));

    int i = 0;
    while (farthest < time) {
      while (i < clips.size() && clips[i][0] <= end)
        farthest = max(farthest, clips[i++][1]);
      if (end == farthest)
        return -1;
      ++ans;
      end = farthest;
    }

    return ans;
  }
};",11,448,0.0,2.0,3.0,3.0,40.72727272727273,8.0,5.234545454545455
935.0,"class Solution {
 public:
  bool divisorGame(int n) {
    return n % 2 == 0;
  }
};",2,83,0.0,0.0,2.0,0.0,41.5,3.0,5.845
936.0,"class Solution {
 public:
  int maxAncestorDiff(TreeNode* root) {
    return maxAncestorDiff(root, root->val, root->val);
  }

 private:
  // Returns |max - min| of the tree w/ root
  int maxAncestorDiff(TreeNode* root, int mini, int maxi) {
    if (root == nullptr)
      return 0;

    mini = min(mini, root->val);
    maxi = max(maxi, root->val);
    const int l = maxAncestorDiff(root->left, mini, maxi);
    const int r = maxAncestorDiff(root->right, mini, maxi);
    return max({maxi - mini, l, r});
  }
};",8,512,1.0,-1.0,4.0,6.0,64.0,9.0,3.2
937.0,"class Solution {
 public:
  int longestArithSeqLength(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // dp[i][k] := length of the longest arithmetic subseq ofnums
    // nums[0..i] with k = diff + 500
    vector<vector<int>> dp(n, vector<int>(1001));

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j) {
        const int k = nums[i] - nums[j] + 500;
        dp[i][k] = max(2, dp[j][k] + 1);
        ans = max(ans, dp[i][k]);
      }

    return ans;
  }
};",12,499,2.0,2.0,3.0,3.0,41.583333333333336,12.0,4.8375
938.0,"class Solution {
 public:
  TreeNode* recoverFromPreorder(string traversal) {
    int i = 0;
    return recoverFromPreorder(traversal, 0, i);
  }

 private:
  TreeNode* recoverFromPreorder(const string& traversal, int depth, int& i) {
    int nDashes = 0;
    while (i + nDashes < traversal.length() && traversal[i + nDashes] == '-')
      ++nDashes;
    if (nDashes != depth)
      return nullptr;

    i += depth;
    const int start = i;
    while (i < traversal.length() && isdigit(traversal[i]))
      ++i;

    return new TreeNode(stoi(traversal.substr(start, i - start)),
                        recoverFromPreorder(traversal, depth + 1, i),
                        recoverFromPreorder(traversal, depth + 1, i));
  }
};",10,726,0.0,1.0,3.0,3.0,72.6,10.0,2.2260000000000018
939.0,"class Solution {
 public:
  int twoCitySchedCost(vector<vector<int>>& costs) {
    const int n = costs.size() / 2;
    int ans = 0;

    // How much money can we save if we fly a person to A instead of B?
    // To save money, we should
    //   1) fly the person with the max saving to A
    //   2) fly the person with the min saving to B
    sort(begin(costs), end(costs), [](const auto& a, const auto& b) {
      // Sort in descending order by the money saved
      // If we fly a person to A instead of B
      return a[1] - a[0] > b[1] - b[0];
    });

    for (int i = 0; i < n; ++i)
      ans += costs[i][0] + costs[i + n][1];

    return ans;
  }
};",9,658,6.0,1.0,3.0,3.0,73.11111111111111,9.0,2.5200000000000005
940.0,"class Solution {
 public:
  int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {
    return max(helper(nums, firstLen, secondLen),
               helper(nums, secondLen, firstLen));
  }

 private:
  int helper(vector<int>& A, int l, int r) {
    const int n = A.size();
    vector<int> left(n);
    int sum = 0;

    for (int i = 0; i < n; ++i) {
      sum += A[i];
      if (i >= l)
        sum -= A[i - l];
      if (i >= l - 1)
        left[i] = i > 0 ? max(left[i - 1], sum) : sum;
    }

    vector<int> right(n);
    sum = 0;

    for (int i = n - 1; i >= 0; --i) {
      sum += A[i];
      if (i <= n - r - 1)
        sum -= A[i + r];
      if (i <= n - r)
        right[i] = i < n - 1 ? max(right[i + 1], sum) : sum;
    }

    int ans = 0;

    for (int i = 0; i < n - 1; ++i)
      ans = max(ans, left[i] + right[i + 1]);

    return ans;
  }
};",22,875,0.0,6.0,5.0,7.0,39.77272727272727,18.0,3.960454545454545
941.0,"class Solution {
 public:
  vector<int> numMovesStones(int a, int b, int c) {
    vector<int> nums = {a, b, c};

    sort(begin(nums), end(nums));

    if (nums[2] - nums[0] == 2)
      return {0, 0};
    return {min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 ? 1 : 2,
            nums[2] - nums[0] - 2};
  }
};",5,311,0.0,0.0,5.0,1.0,62.2,6.0,3.502
942.0,"class Solution {
 public:
  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,
                                  int color) {
    dfs(grid, r0, c0, grid[r0][c0]);

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        if (grid[i][j] < 0)
          grid[i][j] = color;

    return grid;
  }

 private:
  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] != startColor)
      return;

    grid[i][j] = -startColor;  // Mark
    dfs(grid, i + 1, j, startColor);
    dfs(grid, i - 1, j, startColor);
    dfs(grid, i, j + 1, startColor);
    dfs(grid, i, j - 1, startColor);

    // If this cell already on the boarder, it must be painted later
    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)
      return;

    if (abs(grid[i + 1][j]) == startColor &&  //
        abs(grid[i - 1][j]) == startColor &&  //
        abs(grid[i][j + 1]) == startColor &&  //
        abs(grid[i][j - 1]) == startColor)
      grid[i][j] = startColor;
  }
};",17,1144,5.0,4.0,3.0,8.0,67.29411764705883,13.0,2.423529411764706
943.0,"class Solution {
 public:
  int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        dp[i][j] = nums1[i - 1] == nums2[j - 1]
                       ? dp[i - 1][j - 1] + 1
                       : max(dp[i - 1][j], dp[i][j - 1]);

    return dp[m][n];
  }
};",10,460,0.0,2.0,2.0,2.0,46.0,12.0,4.42
944.0,"class Solution {
 public:
  bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source,
                        vector<int>& target) {
    unordered_set<long> blockedSet;
    for (const vector<int>& b : blocked)
      blockedSet.insert(hash(b[0], b[1]));

    return dfs(blockedSet, source[0], source[1], hash(target[0], target[1]),
               {}) &&
           dfs(blockedSet, target[0], target[1], hash(source[0], source[1]),
               {});
  }

 private:
  bool dfs(unordered_set<long>& blockedSet, int i, int j, long target,
           unordered_set<long>&& visited) {
    if (i < 0 || i >= 1e6 || j < 0 || j >= 1e6 ||
        blockedSet.count(hash(i, j)) || visited.count(hash(i, j)))
      return false;

    visited.insert(hash(i, j));
    if (visited.size() > (1 + 199) * 199 / 2 || hash(i, j) == target)
      return true;
    return dfs(blockedSet, i + 1, j, target, move(visited)) ||
           dfs(blockedSet, i - 1, j, target, move(visited)) ||
           dfs(blockedSet, i, j + 1, target, move(visited)) ||
           dfs(blockedSet, i, j - 1, target, move(visited));
  }

  long hash(int i, int j) {
    return (static_cast<long>(i) << 16) + j;
  }
};",9,1188,0.0,-1.0,6.0,3.0,132.0,12.0,-3.379999999999997
945.0,"class Solution {
 public:
  bool isBoomerang(vector<vector<int>>& points) {
    return (points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=
           (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]);
  }
};",2,232,0.0,0.0,2.0,0.0,116.0,3.0,-0.8599999999999994
946.0,"class Solution {
 public:
  TreeNode* bstToGst(TreeNode* root) {
    int prefix = 0;

    function<void(TreeNode*)> reversedInorder = [&](TreeNode* root) {
      if (root == nullptr)
        return;

      reversedInorder(root->right);

      root->val += prefix;
      prefix = root->val;

      reversedInorder(root->left);
    };

    reversedInorder(root);
    return root;
  }
};",10,384,0.0,0.0,3.0,1.0,38.4,3.0,6.064
947.0,"class Solution {
 public:
  int minScoreTriangulation(vector<int>& values) {
    const int n = values.size();
    vector<vector<int>> dp(n, vector<int>(n));

    for (int j = 2; j < n; ++j)
      for (int i = j - 2; i >= 0; --i) {
        dp[i][j] = INT_MAX;
        for (int k = i + 1; k < j; ++k)
          dp[i][j] =
              min(dp[i][j],
                  dp[i][k] + values[i] * values[k] * values[j] + dp[k][j]);
      }

    return dp[0][n - 1];
  }
};",12,464,0.0,3.0,3.0,3.0,38.66666666666666,10.0,5.160000000000001
948.0,"class Solution {
 public:
  vector<int> numMovesStonesII(vector<int>& stones) {
    const int n = stones.size();
    int minMoves = n;

    sort(begin(stones), end(stones));

    for (int l = 0, r = 0; r < n; ++r) {
      while (stones[r] - stones[l] + 1 > n)
        ++l;
      int alreadyStored = r - l + 1;
      if (alreadyStored == n - 1 && stones[r] - stones[l] + 1 == n - 1)
        minMoves = min(minMoves, 2);
      else
        minMoves = min(minMoves, n - alreadyStored);
    }

    return {minMoves, max(stones[n - 1] - stones[1] - n + 2,
                          stones[n - 2] - stones[0] - n + 2)};
  }
};",11,620,0.0,4.0,4.0,3.0,56.36363636363637,8.0,3.647272727272727
949.0,"class Solution {
 public:
  bool isRobotBounded(string instructions) {
    int x = 0;
    int y = 0;
    int d = 0;
    vector<vector<int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    for (char instruction : instructions) {
      if (instruction == 'G') {
        x += directions[d][0];
        y += directions[d][1];
      } else if (instruction == 'L')
        d = (d + 3) % 4;
      else
        d = (d + 1) % 4;
    }

    return x == 0 && y == 0 || d > 0;
  }
};",10,474,0.0,5.0,9.0,3.0,47.4,8.0,4.094
950.0,"class Solution {
 public:
  vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {
    vector<int> ans(n);  // ans[i] := 1, 2, 3, or 4
    vector<vector<int>> graph(n);

    for (const vector<int>& p : paths) {
      const int u = p[0] - 1;
      const int v = p[1] - 1;
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    for (int i = 0; i < n; ++i) {
      vector<bool> used(5);
      for (const int v : graph[i])
        used[ans[v]] = true;
      for (int type = 1; type < 5; ++type)
        if (!used[type]) {
          ans[i] = type;
          break;
        }
    }

    return ans;
  }
};",16,619,1.0,4.0,5.0,5.0,38.6875,17.0,4.318125
951.0,"class Solution {
 public:
  int maxSumAfterPartitioning(vector<int>& arr, int k) {
    const int n = arr.size();
    vector<int> dp(n + 1);

    for (int i = 1; i <= n; ++i) {
      int mini = INT_MIN;
      for (int j = 1; j <= min(i, k); ++j) {
        min = max(min, arr[i - j]);
        dp[i] = max(dp[i], dp[i - j] + mini * j);
      }
    }

    return dp[n];
  }
};",11,372,0.0,2.0,4.0,2.0,33.81818181818182,10.0,5.596363636363636
952.0,"class Solution {
 public:
  string longestDupSubstring(string s) {
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    vector<int> pows(n, 1);
    int bestStart = -1;
    int l = 1;
    int r = n;

    for (int i = 1; i < n; ++i)
      pows[i] = (pows[i - 1] * 26L) % kMod;

    while (l < r) {
      const int m = (l + r) / 2;
      const int start = getStart(s, m, pows, kMod);
      if (start == -1) {
        r = m;
      } else {
        bestStart = start;
        l = m + 1;
      }
    }

    if (bestStart == -1)
      return """";
    if (getStart(s, l, pows, kMod) == -1)
      return s.substr(bestStart, l - 1);
    return s.substr(bestStart, l);
  }

 private:
  // k := length of hashed substring
  int getStart(const string& s, int k, const vector<int>& pows,
               const int& kMod) {
    unordered_map<int, vector<int>> hashedToStarts;
    long long h = 0;

    // Compute hash value of s[:k].
    for (int i = 0; i < k; ++i)
      h = ((h * 26) % kMod + val(s[i])) % kMod;
    hashedToStarts[h].push_back(0);

    // Compute rolling hash by Rabin Karp.
    for (int i = k; i < s.length(); ++i) {
      const int startIndex = i - k + 1;
      h = ((h - static_cast<long long>(pows[k - 1]) * val(s[i - k])) % kMod +
           kMod) %
          kMod;
      h = (h * 26 + val(s[i])) % kMod;
      if (const auto it = hashedToStarts.find(h); it != cend(hashedToStarts)) {
        const string currSub = s.substr(startIndex, k);
        for (const int start : it->second)
          if (s.substr(start, k) == currSub)
            return startIndex;
      }
      hashedToStarts[h].push_back(startIndex);
    }

    return -1;
  }

  constexpr int val(char c) {
    return c - 'a';
  }
};",35,1726,3.0,6.0,9.0,10.0,49.31428571428572,36.0,1.1817142857142835
953.0,"class Solution {
 public:
  string removeDuplicates(const string& S) {
    string ans;

    for (const char c : S)
      if (!ans.empty() && ans.back() == c)
        ans.pop_back();
      else
        ans.push_back(c);

    return ans;
  }
};",5,242,0.0,3.0,2.0,2.0,48.4,7.0,4.644
954.0,"class Solution {
 public:
  int longestStrChain(vector<string>& words) {
    const unordered_set<string> wordsSet{begin(words), end(words)};
    int ans = 0;

    for (const string& word : words)
      ans = max(ans, longestStrChain(word, wordsSet));

    return ans;
  }

 private:
  // dp[s] := longest string chain where s is the last word
  unordered_map<string, int> dp;

  int longestStrChain(const string& s, const unordered_set<string>& wordsSet) {
    if (const auto it = dp.find(s); it != cend(dp))
      return it->second;

    int ans = 1;

    for (int i = 0; i < s.length(); ++i) {
      const string pred = s.substr(0, i) + s.substr(i + 1);
      if (wordsSet.count(pred))
        ans = max(ans, longestStrChain(pred, wordsSet) + 1);
    }

    return dp[s] = ans;
  }
};",14,786,1.0,2.0,5.0,4.0,56.142857142857146,21.0,2.467142857142856
955.0,"class Solution {
 public:
  int lastStoneWeightII(vector<int>& stones) {
    const int sum = accumulate(begin(stones), end(stones), 0);
    vector<bool> dp(sum + 1);
    dp[0] = true;
    int s = 0;

    for (int stone : stones)
      for (int w = sum / 2; w > 0; --w) {
        if (w >= stone)
          dp[w] = dp[w] || dp[w - stone];
        if (dp[w])
          s = max(s, w);
      }

    return sum - 2 * s;
  }
};",10,420,0.0,4.0,3.0,4.0,42.0,9.0,4.9
956.0,"class Solution {
 public:
  int heightChecker(vector<int>& heights) {
    int ans = 0;
    int currentHeight = 1;
    vector<int> count(101);

    for (int height : heights)
      ++count[height];

    for (int height : heights) {
      while (count[currentHeight] == 0)
        ++currentHeight;
      if (height != currentHeight)
        ++ans;
      --count[currentHeight];
    }

    return ans;
  }
};",9,405,0.0,4.0,3.0,4.0,45.0,8.0,4.73
957.0,"class Solution {
 public:
  int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {
    int satisfied = 0;
    int madeSatisfied = 0;
    int windowSatisfied = 0;

    for (int i = 0; i < customers.size(); ++i) {
      if (grumpy[i] == 0)
        satisfied += customers[i];
      else
        windowSatisfied += customers[i];
      if (i >= X && grumpy[i - X] == 1)
        windowSatisfied -= customers[i - X];
      madeSatisfied = max(madeSatisfied, windowSatisfied);
    }

    return satisfied + madeSatisfied;
  }
};",11,536,0.0,4.0,3.0,3.0,48.72727272727273,9.0,4.294545454545455
958.0,"class Solution {
 public:
  vector<int> prevPermOpt1(vector<int>& arr) {
    const int n = arr.size();
    int l = n - 2;
    int r = n - 1;

    while (l >= 0 && arr[l] <= arr[l + 1])
      l--;
    if (l < 0)
      return arr;
    while (arr[r] >= arr[l] || arr[r] == arr[r - 1])
      r--;
    swap(arr[l], arr[r]);

    return arr;
  }
};",9,342,0.0,2.0,2.0,3.0,38.0,7.0,5.64
959.0,"class Solution {
 public:
  vector<int> rearrangeBarcodes(vector<int>& barcodes) {
    vector<int> ans(barcodes.size());
    vector<int> count(10001);
    int i = 0;  // ans' index

    for (const int b : barcodes)
      ++count[b];

    const auto maxIt = max_element(begin(count), end(count));
    const int maxNum = maxIt - begin(count);

    auto fillAns = [&](int num) {
      while (count[num]-- > 0) {
        ans[i] = num;
        i = i + 2 < barcodes.size() ? i + 2 : 1;
      }
    };

    fillAns(maxNum);
    for (int num = 1; num < 10001; ++num)
      fillAns(num);

    return ans;
  }
};",15,602,1.0,3.0,4.0,3.0,40.13333333333333,13.0,4.708
960.0,"class Solution {
 public:
  int shortestWay(string source, string target) {
    int ans = 0;

    for (int i = 0; i < target.length();) {
      const int prevIndex = i;
      for (int j = 0; j < source.length(); ++j)
        if (i < target.length() && source[j] == target[i])
          ++i;
      // All chars in source didn't match target[i]
      if (i == prevIndex)
        return -1;
      ++ans;
    }

    return ans;
  }
};",11,430,1.0,3.0,3.0,4.0,39.09090909090909,9.0,5.261818181818183
961.0,"class Solution {
 public:
  vector<int> assignBikes(vector<vector<int>>& workers,
                          vector<vector<int>>& bikes) {
    const int n = workers.size();
    const int m = bikes.size();
    vector<int> ans(n, -1);
    vector<bool> usedBikes(m);
    // buckets[k] := (i, j), where k = dist(workers[i], bikes[j])
    vector<vector<pair<int, int>>> buckets(2001);

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < m; ++j)
        buckets[dist(workers[i], bikes[j])].emplace_back(i, j);

    for (int k = 0; k < 2001; ++k)
      for (const auto& [i, j] : buckets[k])
        if (ans[i] == -1 && !usedBikes[j]) {
          ans[i] = j;
          usedBikes[j] = true;
        }

    return ans;
  }

 private:
  int dist(const vector<int>& p1, const vector<int>& p2) {
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);
  }
};",17,847,1.0,4.0,4.0,5.0,49.8235294117647,21.0,2.975882352941176
962.0,"class Solution {
 public:
  string minimizeError(vector<string>& prices, int target) {
    // A[i] := (costCeil - costFloor, costCeil, costFloor)
    // The lower the costCeil - costFloor, the cheaper to ceil it
    vector<tuple<double, double, double>> A;
    int sumFloored = 0;
    int sumCeiled = 0;

    for (const string& p : prices) {
      const double price = stod(p);
      const int floored = floor(price);
      const int ceiled = ceil(price);
      sumFloored += floored;
      sumCeiled += ceiled;
      const double costFloor = price - static_cast<double>(floored);
      const double costCeil = static_cast<double>(ceiled) - price;
      A.emplace_back(costCeil - costFloor, costCeil, costFloor);
    }

    if (sumFloored > target || sumCeiled < target)
      return ""-1"";

    sort(begin(A), end(A));

    double sumError = 0.0;
    const int nCeiled = target - sumFloored;
    for (int i = 0; i < nCeiled; ++i)
      sumError += get<1>(A[i]);
    for (int i = nCeiled; i < A.size(); ++i)
      sumError += get<2>(A[i]);

    stringstream ss;
    ss << std::fixed << std::setprecision(3) << sumError;
    return ss.str();
  }
};",25,1146,2.0,3.0,3.0,4.0,45.84,28.0,2.7944
963.0,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  bool leadsToDestination(int n, vector<vector<int>>& edges, int source,
                          int destination) {
    vector<vector<int>> graph(n);
    vector<State> state(n);

    for (const vector<int>& edge : edges)
      graph[e[0]].push_back(e[1]);

    return acyclic(graph, source, destination, state);
  }

 private:
  bool acyclic(const vector<vector<int>>& graph, int u, int dest,
               vector<State>& state) {
    if (graph[u].empty())
      return u == dest;
    if (state[u] == State::kVisiting)
      return false;
    if (state[u] == State::kVisited)
      return true;

    state[u] = State::kVisiting;
    for (const int v : graph[u])
      if (!acyclic(graph, v, dest, state))
        return false;
    state[u] = State::kVisited;

    return true;
  }
};",13,862,0.0,1.0,4.0,6.0,66.3076923076923,17.0,2.0323076923076924
964.0,"class Solution {
 public:
  int missingElement(vector<int>& nums, int k) {
    int l = 0;
    int r = nums.size();

    // # of missing numbers in [nums[0], nums[i]]
    auto nMissing = [&](int i) { return nums[i] - nums[0] - i; };

    // Find the first index l s.t. nMissing(l) >= k
    while (l < r) {
      const int m = (l + r) / 2;
      if (nMissing(m) >= k)
        r = m;
      else
        l = m + 1;
    }

    return nums[l - 1] + (k - nMissing(l - 1));
  }
};",9,472,2.0,2.0,4.0,2.0,52.44444444444444,9.0,4.1
965.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n) {
    iota(begin(id), end(id), 0);
  }

  void union_(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i > j)
      id[i] = j;
    else
      id[j] = i;
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
};

class Solution {
 public:
  string smallestEquivalentString(string s1, string s2, string baseStr) {
    string ans;
    UnionFind uf(26);

    for (int i = 0; i < s1.length(); ++i)
      uf.union_(s1[i] - 'a', s2[i] - 'a');

    for (const char c : baseStr)
      ans += 'a' + uf.find(c - 'a');

    return ans;
  }
};",16,665,0.0,3.0,6.0,3.0,41.5625,21.0,3.6193750000000007
966.0,"class Solution {
 public:
  int longestRepeatingSubstring(string s) {
    const int n = s.length();
    int ans = 0;
    // dp[i][j] := # of repeating chars of s[0..i) and s[0..j)
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    for (int i = 1; i <= n; ++i)
      for (int j = i + 1; j <= n; ++j)
        if (s[i - 1] == s[j - 1]) {
          dp[i][j] = 1 + dp[i - 1][j - 1];
          ans = max(ans, dp[i][j]);
        }

    return ans;
  }
};",11,456,1.0,3.0,3.0,3.0,41.45454545454545,10.0,4.94909090909091
967.0,"class Solution {
 public:
  int validSubarrays(vector<int>& nums) {
    // For each num in nums, each element x in the stack can be the leftmost
    // element s.t. [x, num] forms a valid subarray, so the stack.size() is
    // the # of valid subarrays ending at curr num.
    //
    // E.g. nums = [1, 3, 2]
    // num = 1, stack = [1] -> valid subarray is [1]
    // num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]
    // num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]
    int ans = 0;
    stack<int> stack;

    for (const int num : nums) {
      while (!stack.empty() && stack.top() > num)
        stack.pop();
      stack.push(num);
      ans += stack.size();
    }

    return ans;
  }
};",7,720,8.0,2.0,3.0,4.0,102.85714285714286,7.0,0.062857142857144
968.0,"class Solution {
 public:
  int assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {
    // dp[i] := min dist to assign bikes j (bitmask)
    dp.resize(1 << bikes.size());
    return assignBikes(workers, bikes, 0, 0);
  }

 private:
  vector<int> dp;

  int assignBikes(const vector<vector<int>>& workers,
                  const vector<vector<int>>& bikes, int s, int bikeUsed) {
    if (s == workers.size())
      return 0;
    if (dp[bikeUsed])
      return dp[bikeUsed];

    int ans = INT_MAX;

    for (int i = 0; i < bikes.size(); ++i) {
      if (bikeUsed >> i & 1)
        continue;
      ans = min(ans, dist(workers[s], bikes[i]) +
                         assignBikes(workers, bikes, s + 1, bikeUsed | 1 << i));
    }

    return dp[bikeUsed] = ans;
  }

  int dist(const vector<int>& p1, const vector<int>& p2) {
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]);
  }
};",13,902,1.0,-1.0,5.0,4.0,69.38461538461539,19.0,1.655384615384614
969.0,"class Solution {
 public:
  int digitsCount(int d, int low, int high) {
    return countDigit(high, d) - countDigit(low - 1, d);
  }

 private:
  int countDigit(int n, int d) {
    int count = 0;

    for (int pow10 = 1; pow10 <= n; pow10 *= 10) {
      const int divisor = pow10 * 10;
      const int quotient = n / divisor;
      const int remainder = n % divisor;
      if (quotient > 0)
        count += quotient * pow10;
      if (d == 0)
        count -= pow10;
      if (remainder >= d * pow10)
        count += min(remainder - d * pow10 + 1, pow10);
    }

    return count;
  }
};",12,589,0.0,3.0,4.0,4.0,49.083333333333336,16.0,3.5625
970.0,"class Solution {
 public:
  string gcdOfStrings(string str1, string str2) {
    if (str1.length() < str2.length())
      return gcdOfStrings(str2, str1);
    if (str1.find(str2) == string::npos)
      return """";
    if (str2.empty())
      return str1;
    return gcdOfStrings(str2, mod(str1, str2));
  }

 private:
  string mod(string& s1, const string& s2) {
    while (s1.find(s2) == 0)
      s1 = s1.substr(s2.length());
    return s1;
  }
};",7,446,0.0,0.0,3.0,4.0,63.71428571428572,9.0,3.185714285714286
971.0,"class Solution {
 public:
  int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;
    vector<int> flip(n);
    unordered_set<int> seen;

    for (int i = 0; i < m; ++i) {
      if (seen.count(i))
        continue;
      int count = 0;
      for (int j = 0; j < n; ++j)
        flip[j] = 1 ^ matrix[i][j];
      for (int k = 0; k < m; ++k)
        if (matrix[k] == matrix[i] || matrix[k] == flip) {
          seen.insert(k);
          ++count;
        }
      ans = max(ans, count);
    }

    return ans;
  }
};",19,601,0.0,4.0,4.0,5.0,31.63157894736842,14.0,5.273157894736841
972.0,"class Solution {
 public:
  vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
    deque<int> ans;
    int carry = 0;
    int i = arr1.size() - 1;
    int j = arr2.size() - 1;

    while (carry || i >= 0 || j >= 0) {
      if (i >= 0)
        carry += arr1[i--];
      if (j >= 0)
        carry += arr2[j--];
      ans.push_front(carry & 1);
      carry = -(carry >> 1);
    }

    while (ans.size() > 1 && ans.front() == 0)
      ans.pop_front();

    return {begin(ans), end(ans)};
  }
};",11,505,0.0,4.0,4.0,4.0,45.90909090909091,8.0,4.588181818181818
973.0,"class Solution {
 public:
  int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    int ans = 0;

    // Transfer each row of matrix to prefix sum
    for (auto& row : matrix)
      for (int i = 1; i < n; ++i)
        row[i] += row[i - 1];

    for (int baseCol = 0; baseCol < n; ++baseCol)
      for (int j = baseCol; j < n; ++j) {
        unordered_map<int, int> prefixCount{{0, 1}};
        int sum = 0;
        for (int i = 0; i < m; ++i) {
          if (baseCol > 0)
            sum -= matrix[i][baseCol - 1];
          sum += matrix[i][j];
          if (const auto it = prefixCount.find(sum - target);
              it != cend(prefixCount))
            ans += it->second;
          ++prefixCount[sum];
        }
      }

    return ans;
  }
};",21,835,1.0,7.0,6.0,7.0,39.76190476190476,17.0,3.9814285714285713
974.0,"class Solution {
 public:
  vector<string> findOcurrences(string text, string first, string second) {
    vector<string> ans;
    stringstream ss(text);

    for (string prev2, prev, word; ss >> word;) {
      if (prev2 == first && prev == second)
        ans.push_back(word);
      prev2 = prev;
      prev = word;
    }

    return ans;
  }
};",9,345,0.0,2.0,3.0,2.0,38.333333333333336,7.0,5.55
975.0,"class Solution {
 public:
  int numTilePossibilities(string tiles) {
    vector<int> count(26);

    for (const char t : tiles)
      ++count[t - 'A'];

    return dfs(count);
  }

 private:
  int dfs(vector<int>& count) {
    int possibleSequences = 0;

    for (int& c : count) {
      if (c == 0)
        continue;
      // Put c in the current position. We only care about the # of possible
      // sequences of letters but don't care about the actual combination.
      --c;
      possibleSequences += 1 + dfs(count);
      ++c;
    }

    return possibleSequences;
  }
};",10,578,2.0,1.0,4.0,3.0,57.8,10.0,3.5780000000000003
976.0,"class Solution {
 public:
  TreeNode* sufficientSubset(TreeNode* root, int limit) {
    if (root == nullptr)
      return nullptr;
    if (root->left == nullptr && root->right == nullptr)
      return root->val < limit ? nullptr : root;

    root->left = sufficientSubset(root->left, limit - root->val);
    root->right = sufficientSubset(root->right, limit - root->val);

    // Both children are nullptr
    return root->left == root->right ? nullptr : root;
  }
};",6,467,1.0,0.0,2.0,2.0,77.83333333333333,2.0,2.7150000000000007
977.0,"class Solution {
 public:
  string smallestSubsequence(string text) {
    string ans;
    vector<int> count(128);
    vector<bool> used(128);

    for (const char c : text)
      ++count[c];

    for (const char c : text) {
      --count[c];
      if (used[c])
        continue;
      while (!ans.empty() && ans.back() > c && count[ans.back()] > 0) {
        used[ans.back()] = false;
        ans.pop_back();
      }
      used[c] = true;
      ans.push_back(c);
    }

    return ans;
  }
};",12,492,0.0,3.0,4.0,4.0,41.0,10.0,4.890000000000001
978.0,"class Solution {
 public:
  vector<string> expand(string s) {
    vector<string> ans;
    string path;
    dfs(s, 0, path, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int i, string& path, vector<string>& ans) {
    if (i == s.length()) {
      ans.push_back(path);
      return;
    }
    if (s[i] == '{') {
      const int nextRightBraceIndex = s.find_first_of('}', i);
      for (const char c :
           split(s.substr(i + 1, nextRightBraceIndex - i - 1), ',')) {
        path.push_back(c);
        dfs(s, nextRightBraceIndex + 1, path, ans);
        path.pop_back();
      }
    } else {  // s[i] != '{'
      path.push_back(s[i]);
      dfs(s, i + 1, path, ans);
      path.pop_back();
    }
  }

  vector<char> split(const string& s, char delimiter) {
    vector<char> splitted;
    for (const char c : s)
      if (c != delimiter)
        splitted.push_back(c);
    return splitted;
  }
};",17,918,1.0,4.0,10.0,5.0,54.0,22.0,2.140000000000001
979.0,"class Solution {
 public:
  int confusingNumberII(int n) {
    return dfs(n, 0, 0, 1);
  }

 private:
  vector<pair<int, int>> digitToRotated{{0, 0}, {1, 1}, {6, 9}, {8, 8}, {9, 6}};

  int dfs(int n, long num, long rotatedNum, long unit) {
    int ans = num != rotatedNum;
    // Add one more digit
    for (const auto& [digit, rotated] : digitToRotated) {
      if (digit == 0 && num == 0)
        continue;
      const long nextNum = num * 10 + digit;
      if (nextNum > n)
        break;
      ans += dfs(n, nextNum, rotated * unit + rotatedNum, unit * 10);
    }
    return ans;
  }
};",9,591,1.0,0.0,10.0,3.0,65.66666666666667,10.0,2.53
980.0,"class Solution {
 public:
  void duplicateZeros(vector<int>& arr) {
    int zeros = count_if(begin(arr), end(arr), [](int a) { return a == 0; });

    for (int i = arr.size() - 1, j = arr.size() + zeros - 1; i < j; --i, --j) {
      if (j < arr.size())
        arr[j] = arr[i];
      if (arr[i] == 0)
        if (--j < arr.size())
          arr[j] = arr[i];
    }
  }
};",7,370,0.0,4.0,4.0,5.0,52.85714285714285,6.0,4.162857142857142
981.0,"class Solution {
 public:
  int largestValsFromLabels(vector<int>& values, vector<int>& labels,
                            int num_wanted, int use_limit) {
    const int n = values.size();
    int ans = 0;
    vector<pair<int, int>> items(n);
    unordered_map<int, int> labelsUsed;

    for (int i = 0; i < n; ++i)
      items[i] = make_pair(values[i], labels[i]);

    sort(begin(items), end(items),
         [](const auto& a, const auto& b) { return a.first > b.first; });

    for (auto&& [value, label] : items) {
      if (labelsUsed[label] < use_limit) {
        ans += value;
        ++labelsUsed[label];
        if (--num_wanted == 0)
          break;
      }
    }

    return ans;
  }
};",14,699,0.0,2.0,5.0,4.0,49.92857142857143,16.0,3.486428571428572
982.0,"class Solution {
 public:
  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
    const int n = grid.size();
    if (grid[0][0] == 0 && n == 1)
      return 1;
    if (grid[0][0] == 1 || grid.back().back() == 1)
      return -1;

    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};

    int ans = 0;
    queue<pair<int, int>> q{{{0, 0}}};
    vector<vector<bool>> seen(n, vector<bool>(n));
    seen[0][0] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (x < 0 || x == n || y < 0 || y == n)
            continue;
          if (grid[x][y] != 0 || seen[x][y])
            continue;
          if (x == n - 1 && y == n - 1)
            return ans + 1;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    }

    return -1;
  }
};",22,1076,0.0,3.0,17.0,8.0,48.90909090909091,20.0,2.3981818181818184
983.0,"class Solution {
 public:
  string shortestCommonSupersequence(string str1, string str2) {
    string ans;
    int i = 0;  // str1's index
    int j = 0;  // str2's index

    for (const char c : lcs(str1, str2)) {
      // Append chars that are not part of the LCS
      while (str1[i] != c)
        ans += str1[i++];
      while (str2[j] != c)
        ans += str2[j++];
      // Append the char of the LCS and match str1 and str2
      ans += c;
      ++i;
      ++j;
    }

    // Append remaining chars
    return ans + str1.substr(i) + str2.substr(j);
  }

 private:
  string lcs(const string& A, const string& B) {
    const int m = A.length();
    const int n = B.length();
    // dp[i][j] := LCS of A[0..i) and B[0..j)
    vector<vector<string>> dp(m + 1, vector<string>(n + 1));

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j)
        if (A[i - 1] == B[j - 1])
          dp[i][j] = dp[i - 1][j - 1] + A[i - 1];
        else
          dp[i][j] = dp[i - 1][j].length() > dp[i][j - 1].length()
                         ? dp[i - 1][j]
                         : dp[i][j - 1];

    return dp[m][n];
  }
};",20,1130,6.0,6.0,4.0,6.0,56.5,23.0,2.255
984.0,"class Solution {
 public:
  vector<double> sampleStats(vector<int>& count) {
    const int n = accumulate(begin(count), end(count), 0);
    const double mode = max_element(begin(count), end(count)) - begin(count);
    return {
        getMinimum(count),
        getMaximum(count),
        getMean(count, n),
        (getLeftMedian(count, n) + getRightMedian(count, n)) / 2.0,
        mode,
    };
  }

 private:
  double getMinimum(const vector<int>& count) {
    for (int i = 0; i < count.size(); ++i)
      if (count[i])
        return i;
    return -1;
  }

  double getMaximum(const vector<int>& count) {
    for (int i = count.size() - 1; i >= 0; --i)
      if (count[i])
        return i;
    return -1;
  }

  double getMean(const vector<int>& count, double n) {
    double mean = 0;
    for (long i = 0; i < count.size(); ++i)
      mean += (i * count[i]) / n;
    return mean;
  }

  double getLeftMedian(const vector<int>& count, double n) {
    int numCount = 0;
    for (int i = 0; i < count.size(); ++i) {
      numCount += count[i];
      if (numCount >= n / 2)
        return i;
    }
    return -1;
  }

  double getRightMedian(const vector<int>& count, double n) {
    int numCount = 0;
    for (int i = count.size() - 1; i >= 0; --i) {
      numCount += count[i];
      if (numCount >= n / 2)
        return i;
    }
    return -1;
  }
};",29,1356,0.0,0.0,10.0,9.0,46.75862068965517,32.0,1.991724137931033
985.0,"class Solution {
 public:
  bool carPooling(vector<vector<int>>& trips, int capacity) {
    int currentPassengers = 0;
    map<int, int> timeline;

    for (const vector<int>& trip : trips) {
      const int nPassengers = trip[0];
      const int start = trip[1];
      const int end = trip[2];
      timeline[start] += nPassengers;
      timeline[end] -= nPassengers;
    }

    for (const auto [_, passengerChange] : timeline) {
      currentPassengers += passengerChange;
      if (currentPassengers > capacity)
        return false;
    }

    return true;
  }
};",11,567,0.0,2.0,4.0,3.0,51.54545454545455,16.0,3.400909090909092
986.0,"/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * class MountainArray {
 *  public:
 *   int get(int index);
 *   int length();
 * };
 */

class Solution {
 public:
  int findInMountainArray(int target, MountainArray& mountainArr) {
    const int n = mountainArr.length();
    const int peakIndex = peakIndexInMountainArray(mountainArr, 0, n - 1);

    const int leftIndex = searchLeft(mountainArr, target, 0, peakIndex);
    if (mountainArr.get(leftIndex) == target)
      return leftIndex;

    const int rightIndex =
        searchRight(mountainArr, target, peakIndex + 1, n - 1);
    if (mountainArr.get(rightIndex) == target)
      return rightIndex;

    return -1;
  }

 private:
  // 852. Peak Index in a Mountain Array
  int peakIndexInMountainArray(MountainArray& A, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) < A.get(m + 1))
        l = m + 1;
      else
        r = m;
    }
    return l;
  }

  int searchLeft(MountainArray& A, int target, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) < target)
        l = m + 1;
      else
        r = m;
    }
    return l;
  }

  int searchRight(MountainArray& A, int target, int l, int r) {
    while (l < r) {
      const int m = (l + r) / 2;
      if (A.get(m) > target)
        l = m + 1;
      else
        r = m;
    }
    return l;
  }
};",23,1462,2.0,6.0,9.0,8.0,63.56521739130435,32.0,0.2591304347826106
987.0,"class Solution {
 public:
  vector<string> braceExpansionII(string expression) {
    return dfs(expression, 0, expression.length() - 1);
  }

 private:
  vector<string> dfs(const string& expression, int s, int e) {
    set<string> ans;
    vector<vector<string>> groups{{}};
    int layer = 0;
    int left = 0;

    for (int i = s; i <= e; ++i)
      if (expression[i] == '{' && ++layer == 1)
        left = i + 1;
      else if (expression[i] == '}' && --layer == 0)
        merge(groups, dfs(expression, left, i - 1));
      else if (expression[i] == ',' && layer == 0)
        groups.push_back({});
      else if (layer == 0)
        merge(groups, {string(1, expression[i])});

    for (const vector<string>& group : groups)
      for (const string& word : group)
        ans.insert(word);

    return {begin(ans), end(ans)};
  }

  void merge(vector<vector<string>>& groups, const vector<string> group) {
    if (groups.back().empty()) {
      groups[groups.size() - 1] = group;
      return;
    }

    vector<string> mergedGroup;

    for (auto& word1 : groups.back())
      for (auto& word2 : group)
        mergedGroup.push_back(word1 + word2);

    groups[groups.size() - 1] = mergedGroup;
  }
};",19,1206,0.0,11.0,11.0,10.0,63.47368421052632,23.0,0.6673684210526307
988.0,"class Solution {
 public:
  int twoSumLessThanK(vector<int>& nums, int k) {
    if (nums.size() < 2)
      return -1;

    int ans = -1;  // Note the constraint that nums[i] > 0.
    int l = 0;
    int r = nums.size() - 1;

    sort(begin(nums), end(nums));

    while (l < r)
      if (nums[l] + nums[r] < k) {
        ans = max(ans, nums[l] + nums[r]);
        ++l;
      } else {
        --r;
      }

    return ans;
  }
};",10,427,1.0,3.0,4.0,3.0,42.7,7.0,5.077
989.0,"class Solution {
 public:
  int numKLenSubstrNoRepeats(string s, int k) {
    int ans = 0;
    int unique = 0;
    vector<int> count(26);

    for (int i = 0; i < s.length(); ++i) {
      if (++count[s[i] - 'a'] == 1)
        ++unique;
      if (i >= k && --count[s[i - k] - 'a'] == 0)
        --unique;
      if (unique == k)
        ++ans;
    }

    return ans;
  }
};",10,371,0.0,4.0,3.0,4.0,37.1,8.0,5.441
990.0,"class UnionFind {
 public:
  UnionFind(int n) : count(n), id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
    --count;
  }

  int getCount() const {
    return count;
  }

 private:
  int count;
  vector<int> id;
  vector<int> rank;

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }
};

class Solution {
 public:
  int earliestAcq(vector<vector<int>>& logs, int n) {
    UnionFind uf(n);

    // Sort `logs` by timestamp.
    sort(
        begin(logs), end(logs),
        [](const vector<int>& a, const vector<int>& b) { return a[0] < b[0]; });

    for (const vector<int>& log : logs) {
      const int timestamp = log[0];
      const int x = log[1];
      const int y = log[2];
      uf.unionByRank(x, y);
      if (uf.getCount() == 1)
        return timestamp;
    }

    return -1;
  }
};",25,1106,1.0,2.0,12.0,5.0,44.24,32.0,2.0184
991.0,"struct T {
  int i;
  int j;
  int val;
  T(int i, int j, int val) : i(i), j(j), val(val) {}
};

class Solution {
 public:
  int maximumMinimumPath(vector<vector<int>>& A) {
    const int m = A.size();
    const int n = A[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = A[0][0];
    vector<vector<bool>> seen(m, vector<bool>(n));
    auto compare = [](const T& a, const T& b) { return a.val < b.val; };
    priority_queue<T, vector<T>, decltype(compare)> maxHeap(compare);

    maxHeap.emplace(0, 0, A[0][0]);

    while (!maxHeap.empty()) {
      const auto [i, j, val] = maxHeap.top();
      maxHeap.pop();
      ans = min(ans, val);
      if (i == m - 1 && j == n - 1)
        return ans;
      seen[i][j] = true;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        maxHeap.emplace(x, y, A[x][y]);
      }
    }

    throw;
  }
};",27,1032,0.0,1.0,8.0,5.0,38.22222222222222,27.0,3.3199999999999994
992.0,"class Solution {
 public:
  vector<int> distributeCandies(int candies, long n) {
    vector<int> ans(n);
    int rows = (-n + sqrt(n * n + 8 * n * n * candies)) / (2 * n * n);
    int accumN = rows * (rows - 1) * n / 2;

    for (int i = 0; i < n; ++i)
      ans[i] = accumN + rows * (i + 1);

    int givenCandies = (n * n * rows * rows + n * rows) / 2;
    candies -= givenCandies;

    for (int i = 0, lastGiven = rows * n + 1; candies > 0; ++i, ++lastGiven) {
      int actualGiven = min(lastGiven, candies);
      candies -= actualGiven;
      ans[i] += actualGiven;
    }

    return ans;
  }
};",15,601,0.0,2.0,3.0,2.0,40.06666666666667,10.0,5.094
993.0,"class Solution {
 public:
  vector<int> pathInZigZagTree(int label) {
    deque<int> ans;
    int level;

    for (int l = 0; l < 21; ++l)
      if (pow(2, l) > label) {
        level = l - 1;
        break;
      }

    if (level & 1)
      label = boundarySum(level) - label;

    for (int l = level; l >= 0; --l) {
      ans.push_front(l & 1 ? boundarySum(l) - label : label);
      label /= 2;
    }

    return {begin(ans), end(ans)};
  }

 private:
  int boundarySum(int level) {
    return pow(2, level) + pow(2, level + 1) - 1;
  }
};",14,542,0.0,2.0,6.0,4.0,38.71428571428572,9.0,5.135714285714285
994.0,"class Solution {
 public:
  int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
    // dp[i] := min height to place the first i books
    vector<int> dp(books.size() + 1, INT_MAX);
    dp[0] = 0;

    for (int i = 0; i < books.size(); ++i) {
      int sumThickness = 0;
      int maxHeight = 0;
      // Place books[j..i] on a new shelf.
      for (int j = i; j >= 0; --j) {
        const int thickness = books[j][0];
        const int height = books[j][1];
        sumThickness += thickness;
        if (sumThickness > shelfWidth)
          break;
        maxHeight = max(maxHeight, height);
        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight);
      }
    }

    return dp.back();
  }
};",16,706,2.0,2.0,4.0,3.0,44.125,13.0,4.44875
995.0,"class Solution {
 public:
  bool parseBoolExpr(string expression) {
    int i = 0;
    return parse(expression, i);
  }

 private:
  bool parse(const string& exp, int& i) {
    if (exp[i] == 't') {
      ++i;
      return true;
    }
    if (exp[i] == 'f') {
      ++i;
      return false;
    }
    if (exp[i] == '!') {
      i += 2;
      bool ans = !parse(exp, i);
      ++i;
      return ans;
    }

    bool isAnd = exp[i] == '&';
    bool ans = isAnd;
    i += 2;
    while (exp[i] != ')') {
      bool parsed = parse(exp, i);
      if (isAnd)
        ans &= parsed;
      else
        ans |= parsed;
      if (exp[i] == ',')
        ++i;
    }
    ++i;
    return ans;
  }
};",20,682,0.0,3.0,7.0,6.0,34.1,12.0,5.131
996.0,"class Solution {
 public:
  string defangIPaddr(string address) {
    return regex_replace(address, regex(""[.]""), ""[.]"");
  }
};",2,128,0.0,0.0,2.0,0.0,64.0,3.0,3.82
997.0,"class Solution {
 public:
  vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
    vector<int> ans(n);

    for (vector<int>& booking : bookings) {
      ans[booking[0] - 1] += booking[2];
      if (booking[1] < n)
        ans[booking[1]] -= booking[2];
    }

    for (int i = 1; i < n; ++i)
      ans[i] += ans[i - 1];

    return ans;
  }
};",8,364,0.0,3.0,3.0,3.0,45.5,7.0,4.845000000000001
998.0,"class Solution {
 public:
  vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
    vector<TreeNode*> ans;
    dfs(root, {begin(to_delete), end(to_delete)}, true, ans);
    return ans;
  }

 private:
  TreeNode* dfs(TreeNode*& root, const unordered_set<int>&& toDeleteSet,
                bool isRoot, vector<TreeNode*>& ans) {
    if (root == nullptr)
      return nullptr;

    const bool deleted = toDeleteSet.count(root->val);
    if (isRoot && !deleted)
      ans.push_back(root);

    // If root is deleted, both children have the possibility to be a new root
    root->left = dfs(root->left, move(toDeleteSet), deleted, ans);
    root->right = dfs(root->right, move(toDeleteSet), deleted, ans);
    return deleted ? nullptr : root;
  }
};",10,762,1.0,0.0,4.0,3.0,76.2,7.0,2.242
999.0,"class Solution {
 public:
  vector<int> maxDepthAfterSplit(string seq) {
    vector<int> ans;
    int depth = 1;

    // Put all odd-depth parentheses in one group and even-depth parentheses in
    // the other group.
    for (const char c : seq)
      if (c == '(')
        ans.push_back(++depth % 2);
      else
        ans.push_back(depth-- % 2);

    return ans;
  }
};",6,373,2.0,3.0,2.0,2.0,62.16666666666666,7.0,3.4850000000000003
1000.0,"class Foo {
 public:
  Foo() {
    firstDone.lock();
    secondDone.lock();
  }

  void first(function<void()> printFirst) {
    printFirst();
    firstDone.unlock();
  }

  void second(function<void()> printSecond) {
    firstDone.lock();
    printSecond();
    secondDone.unlock();
  }

  void third(function<void()> printThird) {
    secondDone.lock();
    printThird();
  }

 private:
  mutex firstDone;
  mutex secondDone;
};",12,430,0.0,1.0,5.0,0.0,35.833333333333336,7.0,5.715
1001.0,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class FooBar {
 public:
  FooBar(int n) : n(n) {
    sem_init(&fooSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&barSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~FooBar() {
    sem_destroy(&fooSemaphore);
    sem_destroy(&barSemaphore);
  }

  void foo(function<void()> printFoo) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&fooSemaphore);
      printFoo();
      sem_post(&barSemaphore);
    }
  }

  void bar(function<void()> printBar) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&barSemaphore);
      printBar();
      sem_post(&fooSemaphore);
    }
  }

 private:
  const int n;
  sem_t fooSemaphore;
  sem_t barSemaphore;
};",18,780,6.0,3.0,7.0,2.0,43.333333333333336,10.0,4.74
1002.0,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class ZeroEvenOdd {
 public:
  ZeroEvenOdd(int n) : n(n) {
    sem_init(&zeroSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&evenSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&oddSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~ZeroEvenOdd() {
    sem_destroy(&zeroSemaphore);
    sem_destroy(&evenSemaphore);
    sem_destroy(&oddSemaphore);
  }

  // printNumber(x) outputs ""x"", where x is an integer.
  void zero(function<void(int)> printNumber) {
    for (int i = 0; i < n; ++i) {
      sem_wait(&zeroSemaphore);
      printNumber(0);
      sem_post(&(i % 2 == 0 ? oddSemaphore : evenSemaphore));
    }
  }

  void even(function<void(int)> printNumber) {
    for (int i = 2; i <= n; i += 2) {
      sem_wait(&evenSemaphore);
      printNumber(i);
      sem_post(&zeroSemaphore);
    }
  }

  void odd(function<void(int)> printNumber) {
    for (int i = 1; i <= n; i += 2) {
      sem_wait(&oddSemaphore);
      printNumber(i);
      sem_post(&zeroSemaphore);
    }
  }

 private:
  const int n;
  sem_t zeroSemaphore;
  sem_t evenSemaphore;
  sem_t oddSemaphore;
};",26,1208,9.0,4.0,9.0,3.0,46.46153846153846,16.0,3.798461538461538
1003.0,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class H2O {
 public:
  H2O() {
    sem_init(&hSemaphore, /*pshared=*/0, /*value=*/1);
    sem_init(&oSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~H2O() {
    sem_destroy(&hSemaphore);
    sem_destroy(&oSemaphore);
  }

  void hydrogen(function<void()> releaseHydrogen) {
    sem_wait(&hSemaphore);
    ++h;
    // releaseHydrogen() outputs ""H"". Do not change or remove this line.
    releaseHydrogen();
    if (h % 2 == 0)
      sem_post(&oSemaphore);
    else
      sem_post(&hSemaphore);
  }

  void oxygen(function<void()> releaseOxygen) {
    sem_wait(&oSemaphore);
    // releaseOxygen() outputs ""O"". Do not change or remove this line.
    releaseOxygen();
    sem_post(&hSemaphore);
  }

 private:
  sem_t hSemaphore;
  sem_t oSemaphore;
  int h = 0;
};",16,890,8.0,3.0,5.0,1.0,55.625,6.0,4.2337500000000015
1004.0,"struct T {
  int sum;
  int count;
  double maxAverage;
};

class Solution {
 public:
  double maximumAverageSubtree(TreeNode* root) {
    return maximumAverage(root).maxAverage;
  }

 private:
  T maximumAverage(TreeNode* root) {
    if (root == nullptr)
      return {0, 0, 0.0};

    const T left = maximumAverage(root->left);
    const T right = maximumAverage(root->right);

    const int sum = root->val + left.sum + right.sum;
    const int count = 1 + left.count + right.count;
    const double maxAverage =
        max({sum / (double)count, left.maxAverage, right.maxAverage});
    return {sum, count, maxAverage};
  }
};",13,630,0.0,-1.0,7.0,1.0,48.46153846153846,15.0,3.7784615384615385
1005.0,"class Solution {
 public:
  bool canDivideIntoSubsequences(vector<int>& nums, int k) {
    // Find the number with the maxFreq, we need at least maxFreq * k elements
    // E.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to
    // Split nums into two subseqs say k = 3, the minimum length of nums is 2 x
    // 3 = 6, which is impossible if nums.size() = 5
    const int n = nums.size();
    int freq = 1;
    int maxFreq = 1;

    for (int i = 1; i < n; ++i) {
      freq = nums[i - 1] < nums[i] ? 1 : ++freq;
      maxFreq = max(maxFreq, freq);
    }

    return n >= maxFreq * k;
  }
};",9,611,4.0,2.0,3.0,2.0,67.88888888888889,9.0,2.8500000000000005
1006.0,"class Solution {
 public:
  vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
    vector<int> ans;
    vector<int> count(1001);

    for (int a : arr1)
      ++count[a];

    for (int a : arr2)
      while (count[a]-- > 0)
        ans.push_back(a);

    for (int num = 0; num < 1001; ++num)
      while (count[num]-- > 0)
        ans.push_back(num);

    return ans;
  }
};",9,393,0.0,5.0,2.0,5.0,43.66666666666666,9.0,4.75
1007.0,"struct T {
  TreeNode* lca;
  int depth;
};

class Solution {
 public:
  TreeNode* lcaDeepestLeaves(TreeNode* root) {
    return dfs(root).lca;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {nullptr, 0};
    const T left = dfs(root->left);
    const T right = dfs(root->right);
    if (left.depth > right.depth)
      return {left.lca, left.depth + 1};
    if (left.depth < right.depth)
      return {right.lca, right.depth + 1};
    return {root, left.depth + 1};
  }
};",11,504,0.0,-1.0,8.0,3.0,45.81818181818182,5.0,4.956363636363636
1008.0,"class Solution {
 public:
  int longestWPI(vector<int>& hours) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> map;

    for (int i = 0; i < hours.size(); ++i) {
      prefix += hours[i] > 8 ? 1 : -1;
      if (prefix > 0) {
        ans = i + 1;
      } else {
        if (!map.count(prefix))
          map[prefix] = i;
        if (const auto it = map.find(prefix - 1); it != cend(map))
          ans = max(ans, i - it->second);
      }
    }

    return ans;
  }
};",12,485,0.0,5.0,5.0,4.0,40.41666666666666,9.0,4.862500000000001
1009.0,"class Solution {
 public:
  vector<int> smallestSufficientTeam(vector<string>& req_skills,
                                     vector<vector<string>>& people) {
    const int n = req_skills.size();
    const int nSkills = 1 << n;
    unordered_map<string, int> skillToId;
    // dp[i] := min people's indices to cover skillset of mask i
    unordered_map<int, vector<int>> dp;
    dp.reserve(nSkills);  // Avoid rehash
    dp[0] = {};

    for (int i = 0; i < n; ++i)
      skillToId[req_skills[i]] = i;

    auto getSkill = [&](const vector<string>& person) {
      int mask = 0;
      for (const string& skill : person)
        if (const auto it = skillToId.find(skill); it != cend(skillToId))
          mask |= 1 << it->second;
      return mask;
    };

    for (int i = 0; i < people.size(); ++i) {
      const int currSkill = getSkill(people[i]);
      for (const auto& [mask, indices] : dp) {
        const int newSkillSet = mask | currSkill;
        if (newSkillSet == mask)  // Adding people[i] doesn't increase skill set
          continue;
        if (!dp.count(newSkillSet) ||
            dp[newSkillSet].size() > indices.size() + 1) {
          dp[newSkillSet] = indices;
          dp[newSkillSet].push_back(i);
        }
      }
    }

    return dp[nSkills - 1];
  }
};",23,1285,3.0,5.0,7.0,7.0,55.869565217391305,25.0,1.8717391304347828
1010.0,"class Solution {
 public:
  int numEquivDominoPairs(vector<vector<int>>& dominoes) {
    int ans = 0;
    unordered_map<int, int> count;

    for (vector<int>& domino : dominoes) {
      int key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1]);
      ans += count[key];
      ++count[key];
    }

    return ans;
  }
};",7,331,0.0,1.0,3.0,1.0,47.285714285714285,8.0,4.704285714285716
1011.0,"enum class Color { kInit, kRed, kBlue };

class Solution {
 public:
  vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges,
                                       vector<vector<int>>& blueEdges) {
    vector<int> ans(n, -1);
    vector<vector<pair<int, Color>>> graph(n);  // graph[u] := [(v, edgeColor)]
    queue<pair<int, Color>> q{{{0, Color::kInit}}};  // [(u, prevColor)]

    for (const vector<int>& edge : redEdges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace_back(v, Color::kRed);
    }

    for (const vector<int>& edge : blueEdges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].emplace_back(v, Color::kBlue);
    }

    for (int step = 0; !q.empty(); ++step)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [u, prevColor] = q.front();
        q.pop();
        ans[u] = ans[u] == -1 ? step : ans[u];
        for (auto& [v, edgeColor] : graph[u]) {
          if (v == -1 || edgeColor == prevColor)
            continue;
          q.emplace(v, edgeColor);
          v = -1;  // Mark (u, v) as used.
        }
      }

    return ans;
  }
};",22,1154,3.0,5.0,10.0,6.0,52.45454545454545,24.0,2.0990909090909096
1012.0,"class Solution {
 public:
  int mctFromLeafValues(vector<int>& arr) {
    const int n = arr.size();
    // dp[i][j] := min cost of arr[i..j]
    vector<vector<int>> dp(n, vector<int>(n));
    // maxVal[i][j] := max value of arr[i..j]
    vector<vector<int>> maxVal(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      maxVal[i][i] = arr[i];

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j]);
      }

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        dp[i][j] = INT_MAX;
        for (int k = i; k < j; ++k)
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +
                                       maxVal[i][k] * maxVal[k + 1][j]);
      }

    return dp[0].back();
  }
};",23,861,2.0,6.0,4.0,6.0,37.43478260869565,19.0,4.210869565217391
1013.0,"class Solution {
 public:
  int maxAbsValExpr(vector<int>& arr1, vector<int>& arr2) {
    const int n = arr1.size();
    vector<int> a(n);
    vector<int> b(n);
    vector<int> c(n);
    vector<int> d(n);

    for (int i = 0; i < n; ++i) {
      a[i] = arr1[i] + arr2[i] + i;
      b[i] = arr1[i] + arr2[i] - i;
      c[i] = arr1[i] - arr2[i] + i;
      d[i] = arr1[i] - arr2[i] - i;
    }

    return max(max(diff(a), diff(b)), max(diff(c), diff(d)));
  }

 private:
  int diff(vector<int>& nums) {
    const int min = *min_element(begin(nums), end(nums));
    const int max = *max_element(begin(nums), end(nums));
    return max - min;
  }
};",16,644,0.0,0.0,4.0,6.0,40.25,17.0,4.4375
1014.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  int minimumCost(int n, vector<vector<int>>& connections) {
    int ans = 0;
    UnionFind uf(n + 1);

    // Sort by cost.
    sort(
        begin(connections), end(connections),
        [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; });

    for (const vector<int>& c : connections) {
      const int u = c[0];
      const int v = c[1];
      const int cost = c[2];
      if (uf.find(u) == uf.find(v))
        continue;
      uf.unionByRank(u, v);
      ans += cost;
    }

    const int root = uf.find(1);
    for (int i = 1; i <= n; ++i)
      if (uf.find(i) != root)
        return -1;

    return ans;
  }
};",28,1180,1.0,4.0,11.0,7.0,42.142857142857146,33.0,2.0471428571428563
1015.0,"enum class State { kInit, kVisiting, kVisited };

class Solution {
 public:
  int minimumSemesters(int n, vector<vector<int>>& relations) {
    vector<vector<int>> graph(n);
    vector<State> state(n);
    vector<int> depth(n, 1);

    for (const vector<int>& relation : relations) {
      const int u = relation[0] - 1;
      const int v = relation[1] - 1;
      graph[u].push_back(v);
    }

    for (int i = 0; i < n; ++i)
      if (hasCycle(graph, i, state, depth))
        return -1;

    return *max_element(begin(depth), end(depth));
  }

 private:
  bool hasCycle(const vector<vector<int>>& graph, int u, vector<State>& state,
                vector<int>& depth) {
    if (state[u] == State::kVisiting)
      return true;
    if (state[u] == State::kVisited)
      return false;

    state[u] = State::kVisiting;
    for (const int v : graph[u]) {
      if (hasCycle(graph, v, state, depth))
        return true;
      depth[u] = max(depth[u], 1 + depth[v]);
    }
    state[u] = State::kVisited;

    return false;
  }
};",19,1030,0.0,2.0,6.0,7.0,54.21052631578947,21.0,2.541052631578948
1016.0,"class Solution {
 public:
  string alphabetBoardPath(string target) {
    string ans;
    int x = 0;
    int y = 0;

    for (char c : target) {
      int newX = (c - 'a') % 5;
      int newY = (c - 'a') / 5;
      ans += string(max(0, y - newY), 'U') + string(max(0, newX - x), 'R') +
             string(max(0, x - newX), 'L') + string(max(0, newY - y), 'D') +
             '!';
      x = newX;
      y = newY;
    }

    return ans;
  }
};",10,442,0.0,1.0,3.0,1.0,44.2,13.0,4.482
1017.0,"class Solution {
 public:
  int largest1BorderedSquare(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    // leftOnes[i][j] := consecutive 1s in the left of grid[i][j]
    vector<vector<int>> leftOnes(m, vector<int>(n));
    // topOnes[i][j] := consecutive 1s in the top of grid[i][j]
    vector<vector<int>> topOnes(m, vector<int>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1) {
          leftOnes[i][j] = j == 0 ? 1 : 1 + leftOnes[i][j - 1];
          topOnes[i][j] = i == 0 ? 1 : 1 + topOnes[i - 1][j];
        }

    for (int sz = min(m, n); sz > 0; --sz)
      for (int i = 0; i + sz - 1 < m; ++i)
        for (int j = 0; j + sz - 1 < n; ++j) {
          const int x = i + sz - 1;
          const int y = j + sz - 1;
          // If grid[i..x][j..y] has all 1s on its border.
          if (min(leftOnes[i][y], leftOnes[x][y]) >= sz &&
              min(topOnes[x][j], topOnes[x][y]) >= sz)
            return sz * sz;
        }

    return 0;
  }
};",21,1057,3.0,6.0,4.0,8.0,50.333333333333336,20.0,2.99
1018.0,"class Solution {
 public:
  int stoneGameII(vector<int>& piles) {
    const int n = piles.size();
    // dp[i][j] := max # of stones Alice can get w/ piles[i:] and M = j
    dp.resize(n, vector<int>(n));
    // suffixSum[i] := sum of piles[i:]
    suffixSum = piles;

    for (int i = n - 2; i >= 0; --i)
      suffixSum[i] += suffixSum[i + 1];

    return stoneGameII(0, 1);
  }

 private:
  vector<vector<int>> dp;
  vector<int> suffixSum;

  int stoneGameII(int i, int M) {
    if (i + 2 * M >= dp.size())
      return suffixSum[i];
    if (dp[i][M])
      return dp[i][M];

    int opponent = suffixSum[i];

    for (int X = 1; X <= 2 * M; ++X)
      opponent = min(opponent, stoneGameII(i + X, max(M, X)));

    return dp[i][M] = suffixSum[i] - opponent;
  }
};",17,766,2.0,1.0,3.0,4.0,45.05882352941177,14.0,4.384705882352941
1019.0,"class Solution {
 public:
  int longestCommonSubsequence(string text1, string text2) {
    const int m = text1.length();
    const int n = text2.length();
    // dp[i][j] := LCS's length of text1[0..i) and text2[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        dp[i + 1][j + 1] = text1[i] == text2[j]
                               ? 1 + dp[i][j]
                               : max(dp[i][j + 1], dp[i + 1][j]);

    return dp[m][n];
  }
};",10,528,1.0,2.0,2.0,2.0,52.8,12.0,3.848
1020.0,"class Solution {
 public:
  int movesToMakeZigzag(vector<int>& nums) {
    vector<int> decreasing(2);

    for (int i = 0; i < nums.size(); ++i) {
      int l = i > 0 ? nums[i - 1] : 1001;
      int r = i + 1 < nums.size() ? nums[i + 1] : 1001;
      decreasing[i % 2] += max(0, nums[i] - min(l, r) + 1);
    }

    return min(decreasing[0], decreasing[1]);
  }
};",8,364,0.0,1.0,3.0,1.0,45.5,7.0,4.965000000000001
1021.0,"class Solution {
 public:
  bool btreeGameWinningMove(TreeNode* root, int n, int x) {
    count(root, x);
    return max({leftCount, rightCount, n - leftCount - rightCount - 1}) > n / 2;
  }

 private:
  int leftCount;   // # of nodes of n's left
  int rightCount;  // # of nodes of n's right

  int count(TreeNode* root, int x) {
    if (root == nullptr)
      return 0;

    const int l = count(root->left, x);
    const int r = count(root->right, x);

    if (root->val == x) {
      leftCount = l;
      rightCount = r;
    }

    return 1 + l + r;
  }
};",11,559,2.0,0.0,5.0,2.0,50.81818181818182,12.0,4.006363636363637
1022.0,"class Solution {
 public:
  int longestDecomposition(string text) {
    int count = 0;
    int l = 0;

    for (int r = 1; 2 * r <= text.length(); ++r)
      if (equal(begin(text) + l, begin(text) + r, end(text) - r)) {
        count += 2;
        l = r;
      }

    return count + (2 * l < text.length());
  }
};",8,314,0.0,2.0,3.0,2.0,39.25,6.0,5.5675
1023.0,"class Solution {
 public:
  int minSwaps(vector<int>& data) {
    const int k = count(begin(data), end(data), 1);
    int ones = 0;     // Ones in window
    int maxOnes = 0;  // Max ones in window

    for (int i = 0; i < data.size(); ++i) {
      if (i >= k && data[i - k])
        --ones;
      if (data[i])
        ++ones;
      maxOnes = max(maxOnes, ones);
    }

    return k - maxOnes;
  }
};",10,400,2.0,3.0,3.0,3.0,40.0,8.0,5.320000000000001
1024.0,"class Solution {
 public:
  bool canConvert(string str1, string str2) {
    if (str1 == str2)
      return true;

    vector<int> mappings(128);

    // No char in str1 can be mapped to > 1 char in str2
    for (int i = 0; i < str1.length(); ++i) {
      const int a = str1[i];
      const int b = str2[i];
      if (mappings[a] != 0 && mappings[a] != b)
        return false;
      mappings[a] = b;
    }

    // No char in str1 maps to > 1 char in str2 and
    // There is at lest one temp char can break any loops
    return unordered_set<char>(begin(str2), end(str2)).size() < 26;
  }
};",10,591,3.0,0.0,3.0,3.0,59.1,16.0,3.021
1025.0,"class Solution {
 public:
  int dayOfYear(string date) {
    int year = stoi(date.substr(0, 4));
    int month = stoi(date.substr(5, 2));
    int day = stoi(date.substr(8));
    vector<int> days = {
        31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    return accumulate(begin(days), begin(days) + month - 1, 0) + day;
  }

 private:
  bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
  }
};",7,468,0.0,-1.0,4.0,0.0,66.85714285714286,9.0,2.902857142857142
1026.0,"class Solution {
 public:
  int numRollsToTarget(int n, int k, int target) {
    constexpr int kMod = 1'000'000'007;
    vector<int> dp(target + 1);
    dp[0] = 1;

    while (n--) {  // N dices
      vector<int> newDp(target + 1);
      for (int i = 1; i <= k; ++i)           // Number 1, 2, ..., f
        for (int t = i; t <= target; ++t) {  // Possible targets
          newDp[t] += dp[t - i];
          newDp[t] %= kMod;
        }
      dp = move(newDp);
    }

    return dp[target];
  }
};",13,496,3.0,3.0,4.0,3.0,38.15384615384615,10.0,5.266153846153847
1027.0,"class Solution {
 public:
  int maxRepOpt1(string text) {
    int ans = 0;
    vector<int> count(26);
    vector<pair<char, int>> groups{{text[0], 1}};

    for (char c : text)
      ++count[c - 'a'];

    for (int i = 1; i < text.length(); ++i)
      if (text[i] == text[i - 1])
        ++groups[groups.size() - 1].second;
      else
        groups.emplace_back(text[i], 1);

    for (const auto& [c, length] : groups)
      ans = max(ans, min(length + 1, count[c - 'a']));

    for (int i = 1; i + 1 < groups.size(); ++i)
      if (groups[i - 1].first == groups[i + 1].first && groups[i].second == 1)
        ans = max(ans, min(groups[i - 1].second + groups[i + 1].second + 1,
                           count[groups[i - 1].first - 'a']));

    return ans;
  }
};",14,765,0.0,7.0,4.0,6.0,54.642857142857146,11.0,3.322142857142857
1028.0,"class Solution {
 public:
  int countCharacters(vector<string>& words, string chars) {
    int ans = 0;
    vector<int> count(26);

    for (const char c : chars)
      ++count[c - 'a'];

    for (const string& word : words) {
      vector<int> tempCount(count);
      for (const char c : word)
        if (--tempCount[c - 'a'] < 0) {
          ans -= word.length();
          break;
        }
      ans += word.length();
    }

    return ans;
  }
};",9,451,0.0,3.0,4.0,4.0,50.11111111111112,13.0,3.770000000000001
1029.0,"class Solution {
 public:
  int maxLevelSum(TreeNode* root) {
    int ans = 1;
    int maxLevelSum = INT_MIN;
    queue<TreeNode*> q{{root}};

    for (int level = 1; !q.empty(); ++level) {
      int levelSum = 0;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        levelSum += node->val;
        if (node->left != nullptr)
          q.push(node->left);
        if (node->right != nullptr)
          q.push(node->right);
      }
      if (maxLevelSum < levelSum) {
        maxLevelSum = levelSum;
        ans = level;
      }
    }

    return ans;
  }
};",17,610,0.0,5.0,7.0,5.0,35.88235294117647,7.0,5.350588235294118
1030.0,"class Solution {
 public:
  int maxDistance(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<pair<int, int>> q;
    int water = 0;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0)
          ++water;
        else
          q.emplace(i, j);

    if (water == 0 || water == m * n)
      return -1;

    int ans = 0;

    for (int d = 0; !q.empty(); ++d)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        ans = d;
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (grid[x][y] > 0)
            continue;
          q.emplace(x, y);
          grid[x][y] = 2;  // Mark as visited.
        }
      }

    return ans;
  }
};",30,971,1.0,7.0,5.0,9.0,32.36666666666667,23.0,4.107
1031.0,"class Solution {
 public:
  string lastSubstring(string s) {
    int i = 0;
    int j = 1;
    int k = 0;  // Number of same characters of s[i:] and s[j:]

    while (j + k < s.length()) {
      if (s[i + k] == s[j + k]) {
        ++k;
      } else if (s[i + k] > s[j + k]) {
        // Now s[i:i + k] == s[j:j + k] and s[i + k] > s[j + k] means that
        // We should start from s[j + k] to find a possible larger substring
        j += k + 1;
        k = 0;
      } else {
        // Now s[i:i + k] == s[j:j + k] and s[i + k] < s[j + k] means that
        // Either starting from s[i + k + 1] or s[j] has a larger substring
        i = max(i + k + 1, j);
        j = i + 1;
        k = 0;
      }
    }

    return s.substr(i);
  }
};",11,739,5.0,5.0,6.0,3.0,67.18181818181819,6.0,2.893636363636364
1032.0,"class Solution {
 public:
  int connectSticks(vector<int>& sticks) {
    int ans = 0;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int stick : sticks)
      minHeap.push(stick);

    while (minHeap.size() > 1) {
      const int x = minHeap.top();
      minHeap.pop();
      const int y = minHeap.top();
      minHeap.pop();
      ans += x + y;
      minHeap.push(x + y);
    }

    return ans;
  }
};",11,428,0.0,2.0,3.0,2.0,38.90909090909091,12.0,4.998181818181819
1033.0,"class Solution {
 public:
  int minCostToSupplyWater(int n, vector<int>& wells,
                           vector<vector<int>>& pipes) {
    int ans = 0;
    using P = pair<int, int>;
    vector<vector<P>> graph(n + 1);
    priority_queue<P, vector<P>, greater<>> minHeap;  // (d, u)

    for (const vector<int>& pipe : pipes) {
      const int u = pipe[0];
      const int v = pipe[1];
      const int w = pipe[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    // Connect virtual 0 with node 1 to n.
    for (int i = 0; i < n; ++i) {
      graph[0].emplace_back(i + 1, wells[i]);
      minHeap.emplace(wells[i], i + 1);
    }

    unordered_set<int> mst{{0}};

    while (mst.size() < n + 1) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (mst.count(u))
        continue;
      // Add the new vertex.
      mst.insert(u);
      ans += d;
      // Expand if possible.
      for (const auto [v, w] : graph[u])
        if (!mst.count(v))
          minHeap.emplace(w, v);
    }

    return ans;
  }
};",22,1059,4.0,6.0,7.0,7.0,48.13636363636363,20.0,3.047727272727273
1034.0,"struct Trans {
  string name;
  int time;
  int amount;
  string city;
};

class Solution {
 public:
  vector<string> invalidTransactions(vector<string>& transactions) {
    vector<string> ans;
    unordered_map<string, vector<Trans>> nameToTranses;

    for (const string& t : transactions) {
      const Trans trans = getTrans(t);
      nameToTranses[trans.name].push_back(trans);
    }

    for (const string& t : transactions) {
      const Trans currTrans = getTrans(t);
      if (currTrans.amount > 1000) {
        ans.push_back(t);
      } else if (const auto it = nameToTranses.find(currTrans.name);
                 it != cend(nameToTranses)) {
        // Iterate through all transactions w/ the same name,
        // Check if within 60 minutes in a different city
        for (Trans trans : it->second)
          if (abs(trans.time - currTrans.time) <= 60 &&
              trans.city != currTrans.city) {
            ans.push_back(t);
            break;
          }
      }
    }

    return ans;
  }

 private:
  Trans getTrans(const string& t) {
    istringstream iss(t);
    vector<string> s(4, """");
    for (int i = 0; getline(iss, s[i++], ',');)
      ;
    return {s[0], stoi(s[1]), stoi(s[2]), s[3]};
  }
};",22,1224,2.0,7.0,10.0,9.0,55.63636363636363,21.0,1.952727272727273
1035.0,"class Solution {
 public:
  vector<int> numSmallerByFrequency(vector<string>& queries,
                                    vector<string>& words) {
    vector<int> ans;
    vector<int> wordsFreq;

    for (const string& word : words)
      wordsFreq.push_back(f(word));
    sort(begin(wordsFreq), end(wordsFreq));

    for (const string& query : queries) {
      const int freq = f(query);
      ans.push_back(end(wordsFreq) -
                    upper_bound(begin(wordsFreq), end(wordsFreq), freq));
    }

    return ans;
  }

 private:
  int f(const string& word) {
    int count = 0;
    char currentChar = 'z' + 1;

    for (const char c : word)
      if (c < currentChar) {
        currentChar = c;
        count = 1;
      } else if (c == currentChar) {
        ++count;
      }

    return count;
  }
};",14,811,0.0,5.0,6.0,5.0,57.92857142857143,19.0,2.2264285714285705
1036.0,"class Solution {
 public:
  ListNode* removeZeroSumSublists(ListNode* head) {
    ListNode dummy(0, head);
    int prefix = 0;
    unordered_map<int, ListNode*> prefixToNode;
    prefixToNode[0] = &dummy;

    for (; head; head = head->next) {
      prefix += head->val;
      prefixToNode[prefix] = head;
    }

    prefix = 0;

    for (head = &dummy; head; head = head->next) {
      prefix += head->val;
      head->next = prefixToNode[prefix]->next;
    }

    return dummy.next;
  }
};",15,491,0.0,2.0,4.0,2.0,32.733333333333334,3.0,6.393999999999999
1037.0,"class Solution {
 public:
  int numPrimeArrangements(int n) {
    constexpr int kMod = 1'000'000'007;
    const int count = countPrimes(n);
    return (factorial(count, kMod) * factorial(n - count, kMod)) % kMod;
  }

 private:
  int countPrimes(int n) {
    vector<bool> prime(n + 1, true);
    prime[0] = false;
    prime[1] = false;

    for (int i = 0; i <= sqrt(n); ++i)
      if (prime[i])
        for (int j = i * i; j <= n; j += i)
          prime[j] = false;

    return count(begin(prime), end(prime), true);
  }

  long factorial(int n, const int kMod) {
    long fact = 1;
    for (int i = 1; i <= n; ++i)
      fact = fact * i % kMod;
    return fact;
  }
};",18,671,0.0,2.0,4.0,4.0,37.27777777777778,15.0,4.784999999999999
1038.0,"class Solution {
 public:
  vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {
    vector<bool> ans;
    vector<int> dp(s.length() + 1);

    for (int i = 1; i <= s.length(); ++i)
      dp[i] = dp[i - 1] ^ 1 << s[i - 1] - 'a';

    for (const vector<int>& query : queries) {
      const int odds = __builtin_popcount(dp[query[1] + 1] ^ dp[query[0]]);
      ans.push_back(odds / 2 <= query[2]);
    }

    return ans;
  }
};",9,446,0.0,2.0,3.0,2.0,49.55555555555556,11.0,4.14
1039.0,"class Solution {
 public:
  vector<int> findNumOfValidWords(vector<string>& words,
                                  vector<string>& puzzles) {
    vector<int> ans;
    unordered_map<int, int> binaryCount;

    for (const string& word : words) {
      int mask = 0;
      for (char c : word)
        mask |= 1 << c - 'a';
      ++binaryCount[mask];
    }

    for (const string& puzzle : puzzles) {
      int valid = 0;
      const int n = puzzle.length() - 1;
      for (int i = 0; i < (1 << n); ++i) {
        int mask = 1 << puzzle[0] - 'a';
        for (int j = 0; j < n; ++j)
          if (i & 1 << j)
            mask |= 1 << puzzle[j + 1] - 'a';
        if (const auto it = binaryCount.find(mask); it != cend(binaryCount))
          valid += it->second;
      }
      ans.push_back(valid);
    }

    return ans;
  }
};",18,826,0.0,7.0,5.0,7.0,45.888888888888886,20.0,3.1500000000000004
1040.0,"class Solution {
 public:
  vector<string> beforeAndAfterPuzzles(vector<string>& phrases) {
    set<string> ans;
    unordered_map<string, set<string>> firstWordToLasts;
    unordered_map<string, set<string>> lastWordToFirsts;

    for (const string& phrase : phrases) {
      const int firstSpaceIndex = phrase.find(' ');
      const int lastSpaceIndex = phrase.rfind(' ');
      // Index after firstWord.
      const int i =
          firstSpaceIndex == string::npos ? phrase.length() : firstSpaceIndex;
      // Index of lastWord.
      const int j = lastSpaceIndex == string::npos ? 0 : lastSpaceIndex + 1;
      const string firstWord = phrase.substr(0, i);
      const string lastWord = phrase.substr(j);

      // Concatenate `phrase` w/ `last` having the same `firstWord`.
      if (const auto it = firstWordToLasts.find(lastWord);
          it != cend(firstWordToLasts))
        for (const string& last : it->second)
          ans.insert(phrase + last);

      // Concatenate `first` having the same `lastWord` w/ `phrase`.
      if (const auto it = lastWordToFirsts.find(firstWord);
          it != cend(lastWordToFirsts))
        for (const string& first : it->second)
          ans.insert(first + phrase);

      // e.g. ""a b c"" -> {""a"": "" b c""}
      //          ""a"" -> {""a"": """"}
      firstWordToLasts[firstWord].insert(phrase.substr(i));

      // e.g. ""a b c"" -> {""c"": ""a b ""}
      //          ""a"" -> {""a"": """"}
      lastWordToFirsts[lastWord].insert(phrase.substr(0, j));
    }

    return {begin(ans), end(ans)};
  }
};",17,1538,8.0,5.0,8.0,6.0,90.47058823529412,30.0,-1.6023529411764716
1041.0,"class Solution {
 public:
  vector<int> shortestDistanceColor(vector<int>& colors,
                                    vector<vector<int>>& queries) {
    constexpr int kNumColor = 3;
    const int n = colors.size();
    vector<int> ans;
    // left[i][c] := closest index of color c in index i to the left.
    vector<vector<int>> left(n, vector<int>(kNumColor + 1));
    // right[i][c] := closest index of color c in index i to the right.
    vector<vector<int>> right(n, vector<int>(kNumColor + 1));

    vector<int> colorToClosestIndex{0, -1, -1, -1};  // 0-indexed, -1 means N/A
    for (int i = 0; i < n; ++i) {
      colorToClosestIndex[colors[i]] = i;
      for (int c = 1; c <= kNumColor; ++c)
        left[i][c] = colorToClosestIndex[c];
    }

    colorToClosestIndex = {0, -1, -1, -1};  // Reset.
    for (int i = n - 1; i >= 0; --i) {
      colorToClosestIndex[colors[i]] = i;
      for (int c = 1; c <= kNumColor; ++c)
        right[i][c] = colorToClosestIndex[c];
    }

    for (const vector<int>& query : queries) {
      const int i = query[0];
      const int c = query[1];
      const int leftDist = left[i][c] == -1 ? INT_MAX : i - left[i][c];
      const int rightDist = right[i][c] == -1 ? INT_MAX : right[i][c] - i;
      const int minDist = min(leftDist, rightDist);
      ans.push_back(minDist == INT_MAX ? -1 : minDist);
    }

    return ans;
  }
};",27,1377,4.0,5.0,7.0,5.0,51.0,29.0,1.9499999999999995
1042.0,"class Solution {
 public:
  int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {
    int ans = 0;
    vector<vector<int>> submatrix(sideLength, vector<int>(sideLength));
    priority_queue<int> maxHeap;

    for (int i = 0; i < width; ++i)
      for (int j = 0; j < height; ++j)
        ++submatrix[i % sideLength][j % sideLength];

    for (const vector<int>& row : submatrix)
      for (const int a : row)
        maxHeap.push(a);

    for (int i = 0; i < maxOnes; ++i)
      ans += maxHeap.top(), maxHeap.pop();

    return ans;
  }
};",14,563,0.0,5.0,2.0,5.0,40.21428571428572,17.0,4.260714285714286
1043.0,"class Solution {
 public:
  int distanceBetweenBusStops(vector<int>& distance, int start,
                              int destination) {
    int clockwise = 0;
    int counterclockwise = 0;

    if (start > destination)
      swap(start, destination);

    for (int i = 0; i < distance.size(); ++i) {
      if (i >= start && i < destination)
        clockwise += distance[i];
      else
        counterclockwise += distance[i];
    }

    return min(clockwise, counterclockwise);
  }
};",9,488,0.0,4.0,3.0,3.0,54.22222222222222,8.0,3.9
1044.0,"class Solution {
 public:
  string dayOfTheWeek(int day, int month, int year) {
    vector<string> week = {""Sunday"",   ""Monday"", ""Tuesday"", ""Wednesday"",
                           ""Thursday"", ""Friday"", ""Saturday""};
    vector<int> days = {
        31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int count = 0;

    for (int i = 1971; i < year; ++i)
      count += i % 4 == 0 ? 366 : 365;
    for (int i = 0; i < month - 1; ++i)
      count += days[i];
    count += day;

    return week[(count + 4) % 7];
  }

 private:
  bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
  }
};",13,652,0.0,1.0,5.0,2.0,50.15384615384615,12.0,3.926153846153847
1045.0,"class Solution {
 public:
  // Very similar to 53. Maximum Subarray
  int maximumSum(vector<int>& arr) {
    // dp[0][i] := max sum subarray ending w/ i (no deletion)
    // dp[1][i] := max sum subarray ending w/ i (at most 1 deletion)
    vector<vector<int>> dp(2, vector<int>(arr.size()));

    dp[0][0] = arr[0];
    dp[1][0] = arr[0];
    for (int i = 1; i < arr.size(); ++i) {
      dp[0][i] = max(arr[i], dp[0][i - 1] + arr[i]);
      dp[1][i] =
          max({arr[i], dp[1][i - 1] + arr[i], dp[0][i - 1] /*delete arr[i]*/});
    }

    return *max_element(begin(dp[1]), end(dp[1]));
  }
};",9,596,4.0,1.0,4.0,1.0,66.22222222222223,6.0,3.3
1046.0,"class Solution {
 public:
  int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {
    // dp[i] := min steps to reach i at previous round
    unordered_map<int, int> dp{{-1, 0}};

    sort(begin(arr2), end(arr2));

    for (const int a : arr1) {
      unordered_map<int, int> nextDp;
      for (const auto& [val, steps] : dp) {
        // it's possible to use the value in arr1
        if (a > val)
          nextDp[a] = min(nextDp.count(a) ? nextDp[a] : INT_MAX, steps);
        // Also try the value in arr2
        if (const auto it = upper_bound(begin(arr2), end(arr2), val);
            it != cend(arr2))
          nextDp[*it] =
              min(nextDp.count(*it) ? nextDp[*it] : INT_MAX, steps + 1);
      }
      if (nextDp.empty())
        return -1;
      dp = move(nextDp);
    }

    int ans = INT_MAX;
    for (const auto& [_, steps] : dp)
      ans = min(ans, steps);
    return ans;
  }
};",12,913,3.0,6.0,6.0,6.0,76.08333333333333,14.0,1.1525000000000016
1047.0,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class BoundedBlockingQueue {
 public:
  BoundedBlockingQueue(int capacity) {
    sem_init(&enqueueSemaphore, /*pshared=*/0, /*value=*/capacity);
    sem_init(&dequeueSemaphore, /*pshared=*/0, /*value=*/0);
  }

  ~BoundedBlockingQueue() {
    sem_destroy(&enqueueSemaphore);
    sem_destroy(&dequeueSemaphore);
  }

  void enqueue(int element) {
    sem_wait(&enqueueSemaphore);
    q.push(element);
    sem_post(&dequeueSemaphore);
  }

  int dequeue() {
    sem_wait(&dequeueSemaphore);
    const int element = q.front();
    q.pop();
    sem_post(&enqueueSemaphore);
    return element;
  }

  int size() {
    return q.size();
  }

 private:
  queue<int> q;
  sem_t enqueueSemaphore;
  sem_t dequeueSemaphore;
};",17,844,6.0,-1.0,6.0,0.0,49.64705882352941,9.0,4.5717647058823525
1048.0,"class Solution {
 public:
  int maxNumberOfBalloons(string text) {
    int ans = INT_MAX;
    vector<int> count(26);

    for (char c : text)
      ++count[c - 'a'];

    for (char c : string(""ban""))
      ans = min(ans, count[c - 'a']);

    for (char c : string(""lo""))
      ans = min(ans, count[c - 'a'] / 2);

    return ans;
  }
};",7,336,0.0,3.0,2.0,3.0,48.0,10.0,4.38
1049.0,"class Solution {
 public:
  string reverseParentheses(string s) {
    stack<int> stack;
    string ans;

    for (const char c : s)
      if (c == '(') {
        stack.push(ans.length());
      } else if (c == ')') {
        // Reverse the corresponding substring between ().
        const int j = stack.top();
        stack.pop();
        reverse(begin(ans) + j, end(ans));
      } else {
        ans += c;
      }

    return ans;
  }
};",9,439,1.0,5.0,5.0,3.0,48.77777777777778,9.0,4.15
1050.0,"class Solution {
 public:
  int kConcatenationMaxSum(vector<int>& arr, int k) {
    constexpr int kMod = 1'000'000'007;
    const int sz = arr.size() * (k == 1 ? 1 : 2);
    const int sum = accumulate(begin(arr), end(arr), 0);
    // The concatenated array will be [arr1, arr2, ..., arrk].
    // If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.
    // Equivalently, maxSubarraySum is from arr1 and arrk.
    return (sum > 0 && k > 2 ? kadane(arr, sz) + sum * static_cast<long>(k - 2)
                             : kadane(arr, sz)) %
           kMod;
  }

 private:
  int kadane(const vector<int>& A, int sz) {
    int ans = 0;
    int sum = 0;
    for (int i = 0; i < sz; ++i) {
      const int a = A[i % A.size()];
      sum = max(a, sum + a);
      ans = max(ans, sum);
    }
    return ans;
  }
};",13,827,3.0,0.0,4.0,2.0,63.61538461538461,18.0,2.3546153846153848
1051.0,"class Solution {
 public:
  vector<vector<int>> criticalConnections(int n,
                                          vector<vector<int>>& connections) {
    vector<vector<int>> ans;
    vector<vector<int>> graph(n);

    for (const vector<int>& connection : connections) {
      const int u = connection[0];
      const int v = connection[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    // rank[i] := min node that node i can reach w/ forward edges
    // Initialize w/ NO_RANK = -2 to indicate not visited.
    getRank(graph, 0, 0, vector<int>(n, NO_RANK), ans);
    return ans;
  }

 private:
  static constexpr int NO_RANK = -2;

  // Gets the min rank that u can reach w/ forward edges.
  int getRank(const vector<vector<int>>& graph, int u, int currRank,
              vector<int>&& rank, vector<vector<int>>& ans) {
    if (rank[u] != NO_RANK)  // The rank is already determined.
      return rank[u];

    rank[u] = currRank;
    int minRank = currRank;

    for (const int v : graph[u]) {
      // visited || parent (that's why NO_RANK = -2 instead of -1)
      if (rank[u] == rank.size() || rank[v] == currRank - 1)
        continue;
      const int nextRank = getRank(graph, v, currRank + 1, move(rank), ans);
      // (u, v) is the only way for u go to v.
      if (nextRank == currRank + 1)
        ans.push_back({u, v});
      minRank = min(minRank, nextRank);
    }

    rank[u] = rank.size();  // Mark as visited
    return minRank;
  }
};",19,1479,7.0,3.0,6.0,8.0,77.84210526315789,26.0,0.1342105263157904
1052.0,"// LeetCode doesn't support C++20 yet, so we don't have std::counting_semaphore
// or binary_semaphore.
#include <semaphore.h>

class FizzBuzz {
 public:
  FizzBuzz(int n) : n(n) {
    sem_init(&fizzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&buzzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&fizzbuzzSemaphore, /*pshared=*/0, /*value=*/0);
    sem_init(&numberSemaphore, /*pshared=*/0, /*value=*/1);
  }

  ~FizzBuzz() {
    sem_destroy(&fizzSemaphore);
    sem_destroy(&buzzSemaphore);
    sem_destroy(&fizzbuzzSemaphore);
    sem_destroy(&numberSemaphore);
  }

  // printFizz() outputs ""fizz"".
  void fizz(function<void()> printFizz) {
    for (int i = 1; i <= n; ++i)
      if (i % 3 == 0 && i % 15 != 0) {
        sem_wait(&fizzSemaphore);
        printFizz();
        sem_post(&numberSemaphore);
      }
  }

  // printBuzz() outputs ""buzz"".
  void buzz(function<void()> printBuzz) {
    for (int i = 1; i <= n; ++i)
      if (i % 5 == 0 && i % 15 != 0) {
        sem_wait(&buzzSemaphore);
        printBuzz();
        sem_post(&numberSemaphore);
      }
  }

  // printFizzBuzz() outputs ""fizzbuzz"".
  void fizzbuzz(function<void()> printFizzBuzz) {
    for (int i = 1; i <= n; ++i)
      if (i % 15 == 0) {
        sem_wait(&fizzbuzzSemaphore);
        printFizzBuzz();
        sem_post(&numberSemaphore);
      }
  }

  // printNumber(x) outputs ""x"", where x is an integer.
  void number(function<void(int)> printNumber) {
    for (int i = 1; i <= n; ++i) {
      sem_wait(&numberSemaphore);
      if (i % 15 == 0)
        sem_post(&fizzbuzzSemaphore);
      else if (i % 3 == 0)
        sem_post(&fizzSemaphore);
      else if (i % 5 == 0)
        sem_post(&buzzSemaphore);
      else {
        printNumber(i);
        sem_post(&numberSemaphore);
      }
    }
  }

 private:
  const int n;
  sem_t fizzSemaphore;
  sem_t buzzSemaphore;
  sem_t fizzbuzzSemaphore;
  sem_t numberSemaphore;
};",37,1920,14.0,14.0,12.0,10.0,51.891891891891895,17.0,2.62972972972973
1053.0,"class Solution {
 public:
  int minKnightMoves(int x, int y) {
    return dp(abs(x), abs(y));
  }

 private:
  struct pairHash {
    size_t operator()(const pair<int, int>& p) const {
      return p.first ^ p.second;
    }
  };

  unordered_map<pair<int, int>, int, pairHash> memo;

  int dp(int x, int y) {
    if (x + y == 0)  // (0, 0)
      return 0;
    if (x + y == 2)  // (0, 2), (1, 1), (2, 0)
      return 2;
    if (const auto it = memo.find({x, y}); it != cend(memo))
      return it->second;

    return memo[{x, y}] = 1 + min(dp(abs(x - 2), abs(y - 1)),  //
                                  dp(abs(x - 1), abs(y - 2)));
  }
};",10,640,3.0,-2.0,7.0,3.0,64.0,16.0,2.460000000000001
1054.0,"class Solution {
 public:
  int smallestCommonElement(vector<vector<int>>& mat) {
    constexpr int kMax = 10000;
    vector<int> count(kMax + 1);

    for (const vector<int>& row : mat)
      for (const int a : row)
        if (++count[a] == mat.size())
          return a;

    return -1;
  }
};",5,297,0.0,2.0,2.0,3.0,59.4,9.0,3.514
1055.0,"class Solution {
 public:
  int minBuildTime(vector<int>& blocks, int split) {
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int block : blocks)
      minHeap.push(block);

    while (minHeap.size() > 1) {
      minHeap.pop();                // Smallest
      const int x = minHeap.top();  // 2nd smallest
      minHeap.pop();
      minHeap.push(x + split);
    }

    return minHeap.top();
  }
};",8,424,2.0,2.0,3.0,2.0,53.0,10.0,4.010000000000001
1056.0,"class Solution {
 public:
  vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
    vector<vector<int>> ans;
    int min = INT_MAX;

    sort(begin(arr), end(arr));

    for (int i = 0; i + 1 < arr.size(); ++i) {
      int diff = arr[i + 1] - arr[i];
      if (diff < min) {
        min = diff;
        ans.clear();
      }
      if (diff == min)
        ans.push_back({arr[i], arr[i + 1]});
    }

    return ans;
  }
};",11,430,0.0,3.0,5.0,8.0,39.09090909090909,7.0,5.301818181818183
1057.0,"class Solution {
 public:
  int nthUglyNumber(int n, long a, long b, long c) {
    const long ab = a * b / __gcd(a, b);
    const long ac = a * c / __gcd(a, c);
    const long bc = b * c / __gcd(b, c);
    const long abc = a * bc / __gcd(a, bc);
    int l = 1;
    int r = 2'000'000'000;

    while (l < r) {
      const int m = l + (r - l) / 2;
      if (m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc >= n)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }
};",11,493,0.0,3.0,3.0,2.0,44.81818181818182,11.0,4.506363636363638
1058.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

struct compare {
  bool operator()(const char a, const char b) {
    return a > b;
  }
};

class Solution {
 public:
  string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
    string ans;
    UnionFind uf(s.length());
    unordered_map<int, priority_queue<char, vector<char>, compare>> map;

    for (const vector<int>& pair : pairs)
      uf.unionByRank(pair[0], pair[1]);

    for (int i = 0; i < s.length(); ++i)
      map[uf.find(i)].push(s[i]);

    for (int i = 0; i < s.length(); ++i)
      ans += map[uf.find(i)].top(), map[uf.find(i)].pop();

    return ans;
  }
};",26,1109,0.0,5.0,11.0,6.0,42.65384615384615,31.0,2.1011538461538466
1059.0,"class Solution {
 public:
  vector<int> sortItems(int n, int m, vector<int>& group,
                        vector<vector<int>>& beforeItems) {
    vector<vector<int>> graph(n + m);
    vector<int> inDegree(n + m);

    // Build graph by remapping k-th group to k + n imaginary node
    for (int i = 0; i < group.size(); ++i) {
      if (group[i] == -1)
        continue;
      graph[group[i] + n].push_back(i);
      ++inDegree[i];
    }

    for (int i = 0; i < beforeItems.size(); ++i)
      for (const int b : beforeItems[i]) {
        const int u = group[b] == -1 ? b : group[b] + n;
        const int v = group[i] == -1 ? i : group[i] + n;
        if (u == v) {  // Already in the same group
          graph[b].push_back(i);
          ++inDegree[i];
        } else {
          graph[u].push_back(v);
          ++inDegree[v];
        }
      }

    // Topology
    vector<int> ans;

    for (int i = 0; i < n + m; ++i)
      if (inDegree[i] == 0)  // inDegree[i] == -1 means visited
        dfs(graph, i, inDegree, n, ans);

    return ans.size() == n ? ans : vector<int>();
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, vector<int>& inDegree,
           int n, vector<int>& ans) {
    if (u < n)
      ans.push_back(u);

    inDegree[u] = -1;  // Mark as visited

    for (const int v : graph[u])
      if (--inDegree[v] == 0)
        dfs(graph, v, inDegree, n, ans);
  }
};",24,1401,5.0,10.0,7.0,13.0,58.375,28.0,1.1262499999999989
1060.0,"class Solution {
 public:
  bool uniqueOccurrences(vector<int>& arr) {
    unordered_map<int, int> count;
    unordered_set<int> occurrences;

    for (const int a : arr)
      ++count[a];

    for (const auto& [_, value] : count)
      if (!occurrences.insert(value).second)
        return false;

    return true;
  }
};",6,322,0.0,2.0,2.0,3.0,53.66666666666666,9.0,4.03
1061.0,"class Solution {
 public:
  int equalSubstring(string s, string t, int maxCost) {
    int j = 0;
    for (int i = 0; i < s.length(); ++i) {
      maxCost -= abs(s[i] - t[i]);
      if (maxCost < 0)
        maxCost += abs(s[j] - t[j++]);
    }

    return s.length() - j;
  }
};",7,277,0.0,2.0,3.0,2.0,39.57142857142857,7.0,5.4385714285714295
1062.0,"class Solution {
 public:
  string removeDuplicates(const string& s, int k) {
    string ans;
    vector<pair<char, int>> stack;

    for (const char c : s)
      if (stack.empty() || stack.back().first != c)
        stack.emplace_back(c, 1);
      else if (++stack.back().second == k)  // Stack.back() == c
        stack.pop_back();

    for (const auto& [c, count] : stack)
      ans.append(count, c);

    return ans;
  }
};",7,427,1.0,5.0,2.0,4.0,61.0,11.0,3.03
1063.0,"enum class Pos { kHorizontal, kVertical };

class Solution {
 public:
  int minimumMoves(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    // State of (x, y, pos)
    // Pos := 0 (horizontal) / 1 (vertical)
    queue<tuple<int, int, Pos>> q{{{0, 0, Pos::kHorizontal}}};
    vector<vector<vector<bool>>> seen(n,
                                      vector<vector<bool>>(n, vector<bool>(2)));
    seen[0][0][static_cast<int>(Pos::kHorizontal)] = true;

    auto canMoveRight = [&](int x, int y, Pos pos) -> bool {
      if (pos == Pos::kHorizontal)
        return y + 2 < n && !grid[x][y + 2];
      return y + 1 < n && !grid[x][y + 1] && !grid[x + 1][y + 1];
    };

    auto canMoveDown = [&](int x, int y, Pos pos) -> bool {
      if (pos == Pos::kVertical)
        return x + 2 < n && !grid[x + 2][y];
      return x + 1 < n && !grid[x + 1][y] && !grid[x + 1][y + 1];
    };

    auto canRotateClockwise = [&](int x, int y, Pos pos) -> bool {
      return pos == Pos::kHorizontal && x + 1 < n && !grid[x + 1][y + 1] &&
             !grid[x + 1][y];
    };

    auto canRotateCounterclockwise = [&](int x, int y, Pos pos) -> bool {
      return pos == Pos::kVertical && y + 1 < n && !grid[x + 1][y + 1] &&
             !grid[x][y + 1];
    };

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [x, y, pos] = q.front();
        q.pop();
        if (x == n - 1 && y == n - 2 && pos == Pos::kHorizontal)
          return ans;
        if (canMoveRight(x, y, pos) && !seen[x][y + 1][static_cast<int>(pos)]) {
          q.emplace(x, y + 1, pos);
          seen[x][y + 1][static_cast<int>(pos)] = true;
        }
        if (canMoveDown(x, y, pos) && !seen[x + 1][y][static_cast<int>(pos)]) {
          q.emplace(x + 1, y, pos);
          seen[x + 1][y][static_cast<int>(pos)] = true;
        }
        const Pos newPos =
            pos == Pos::kHorizontal ? Pos::kVertical : Pos::kHorizontal;
        if ((canRotateClockwise(x, y, pos) ||
             canRotateCounterclockwise(x, y, pos)) &&
            !seen[x][y][static_cast<int>(newPos)]) {
          q.emplace(x, y, newPos);
          seen[x][y][static_cast<int>(newPos)] = true;
        }
      }
      ++ans;
    }

    return -1;
  }
};",31,2263,2.0,1.0,15.0,8.0,73.0,34.0,-0.8499999999999996
1064.0,"class Solution {
 public:
  vector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2,
                                 vector<int>& arr3) {
    vector<int> ans;
    int i = 0;
    int j = 0;
    int k = 0;

    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {
      const int mini = min({arr1[i], arr2[j], arr3[k]});
      if (arr1[i] == mini && arr2[j] == mini && arr3[k] == mini) {
        ans.push_back(mini);
        ++i;
        ++j;
        ++k;
      } else if (arr1[i] == mini) {
        ++i;
      } else if (arr2[j] == mini) {
        ++j;
      } else {
        ++k;
      }
    }

    return ans;
  }
};",14,641,0.0,7.0,8.0,4.0,45.785714285714285,11.0,3.8792857142857136
1065.0,"class BSTIterator {
 public:
  BSTIterator(TreeNode* root, bool leftToRight) : leftToRight(leftToRight) {
    pushUntilNull(root);
  }

  bool hasNext() {
    return !stack.empty();
  }

  int next() {
    TreeNode* root = stack.top();
    stack.pop();
    pushUntilNull(leftToRight ? root->right : root->left);
    return root->val;
  }

 private:
  stack<TreeNode*> stack;
  bool leftToRight;

  void pushUntilNull(TreeNode* root) {
    while (root != nullptr) {
      stack.push(root);
      root = leftToRight ? root->left : root->right;
    }
  }
};

class Solution {
 public:
  bool twoSumBSTs(TreeNode* root1, TreeNode* root2, int target) {
    BSTIterator bst1(root1, true);
    BSTIterator bst2(root2, false);

    for (int l = bst1.next(), r = bst2.next(); true;) {
      const int sum = l + r;
      if (sum == target)
        return true;
      if (sum < target) {
        if (!bst1.hasNext())
          return false;
        l = bst1.next();
      } else {
        if (!bst2.hasNext())
          return false;
        r = bst2.next();
      }
    }
  }
};",22,1068,0.0,3.0,11.0,6.0,48.54545454545455,12.0,3.590909090909091
1066.0,"class Solution {
 public:
  vector<int> countSteppingNumbers(int low, int high) {
    vector<int> ans;
    if (low == 0)
      ans.push_back(0);

    queue<long> q;

    for (int i = 1; i <= 9; ++i)
      q.push(i);

    while (!q.empty()) {
      const long curr = q.front();
      q.pop();
      if (curr > high)
        continue;
      if (curr >= low)
        ans.push_back(curr);
      const int lastDigit = curr % 10;
      if (lastDigit > 0)
        q.push(curr * 10 + lastDigit - 1);
      if (lastDigit < 9)
        q.push(curr * 10 + lastDigit + 1);
    }

    return ans;
  }
};",15,589,0.0,6.0,3.0,7.0,39.266666666666666,9.0,5.026
1067.0,"class Solution {
 public:
  bool isValidPalindrome(string s, int k) {
    return s.length() - longestPalindromeSubseq(s) <= k;
  }

 private:
  // Same as 516. Longest Palindromic Subsequence
  int longestPalindromeSubseq(const string& s) {
    const int n = s.length();
    // dp[i][j] := LPS's length in s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j])
          dp[i][j] = 2 + dp[i + 1][j - 1];
        else
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
      }

    return dp[0][n - 1];
  }
};",15,692,2.0,4.0,4.0,4.0,46.13333333333333,16.0,3.847999999999999
1068.0,"class Solution {
 public:
  int minCostToMoveChips(vector<int>& chips) {
    vector<int> count(2);

    for (int chip : chips)
      ++count[chip % 2];

    return min(count[0], count[1]);
  }
};",4,195,0.0,1.0,2.0,1.0,48.75,5.0,4.9325
1069.0,"class Solution {
 public:
  int longestSubsequence(vector<int>& arr, int difference) {
    int ans = 0;
    unordered_map<int, int> lengthAt;

    for (const int a : arr) {
      if (const auto it = lengthAt.find(a - difference); it != cend(lengthAt))
        lengthAt[a] = it->second + 1;
      else
        lengthAt[a] = 1;
      ans = max(ans, lengthAt[a]);
    }

    return ans;
  }
};",8,390,0.0,3.0,3.0,4.0,48.75,10.0,4.2525
1070.0,"class Solution {
 public:
  int getMaximumGold(vector<vector<int>>& grid) {
    int ans = 0;

    for (int i = 0; i < grid.size(); ++i)
      for (int j = 0; j < grid[0].size(); ++j)
        ans = max(ans, dfs(grid, i, j));

    return ans;
  }

 private:
  int dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || j < 0 || i == grid.size() || j == grid[0].size())
      return 0;
    if (grid[i][j] == 0)
      return 0;

    const int gold = grid[i][j];
    grid[i][j] = 0;  // Mark as visited.
    const int maxPath = max({dfs(grid, i + 1, j), dfs(grid, i - 1, j),
                             dfs(grid, i, j + 1), dfs(grid, i, j - 1)});
    grid[i][j] = gold;
    return gold + maxPath;
  }
};",15,708,1.0,1.0,4.0,4.0,47.2,14.0,4.092
1071.0,"class Solution {
 public:
  int balancedStringSplit(string s) {
    int ans = 0;
    int count = 0;

    for (const char c : s) {
      count += c == 'L' ? 1 : -1;
      if (count == 0)
        ++ans;
    }

    return ans;
  }
};",6,230,0.0,2.0,3.0,2.0,38.333333333333336,7.0,5.55
1072.0,"class Solution {
 public:
  vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens,
                                          vector<int>& king) {
    vector<vector<int>> ans;
    unordered_set<int> queensSet;

    for (vector<int>& queen : queens)
      queensSet.insert(hash(queen[0], queen[1]));

    vector<vector<int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};
    for (vector<int> d : directions)
      for (int i = king[0] + d[0], j = king[1] + d[1];
           0 <= i && i < 8 && 0 <= j && j < 8; i += d[0], j += d[1])
        if (queensSet.count(hash(i, j))) {
          ans.push_back({i, j});
          break;
        }

    return ans;
  }

 private:
  int hash(int i, int j) {
    return i * 8 + j;
  }
};",11,814,0.0,2.0,14.0,4.0,74.0,13.0,1.08
1073.0,"class Solution {
 public:
  int maxEqualFreq(vector<int>& nums) {
    int ans = 0;
    int maxFreq = 0;
    unordered_map<int, int> count;
    unordered_map<int, int> freq;

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i];
      --freq[count[num]];
      ++count[num];
      ++freq[count[num]];
      maxFreq = max(maxFreq, count[num]);
      if (maxFreq == 1 || maxFreq * freq[maxFreq] == i ||
          (maxFreq - 1) * (freq[maxFreq - 1] + 1) == i)
        ans = i + 1;
    }

    return ans;
  }
};",14,527,0.0,2.0,3.0,2.0,37.642857142857146,12.0,5.1121428571428575
1074.0,"class Solution {
 public:
  double nthPersonGetsNthSeat(int n) {
    return n == 1 ? 1 : 0.5;
  }
};",2,100,0.0,0.0,2.0,0.0,50.0,3.0,5.08
1075.0,"class Solution {
 public:
  vector<int> minAvailableDuration(vector<vector<int>>& slots1,
                                   vector<vector<int>>& slots2, int duration) {
    sort(begin(slots1), end(slots1));
    sort(begin(slots2), end(slots2));

    int i = 0;  // slots1's index
    int j = 0;  // slots2's index

    while (i < slots1.size() && j < slots2.size()) {
      const int start = max(slots1[i][0], slots2[j][0]);
      const int end = min(slots1[i][1], slots2[j][1]);
      if (start + duration <= end)
        return {start, start + duration};
      if (slots1[i][1] < slots2[j][1])
        ++i;
      else
        ++j;
    }

    return {};
  }
};",11,662,2.0,3.0,5.0,3.0,60.18181818181818,11.0,3.083636363636365
1076.0,"class Solution {
 public:
  double probabilityOfHeads(vector<double>& prob, int target) {
    // dp[i][j] := probability of tossing first i coins with j heads
    vector<vector<double>> dp(prob.size() + 1, vector<double>(target + 1));
    dp[0][0] = 1.0;

    for (int i = 1; i <= prob.size(); ++i)
      for (int j = 0; j <= target; ++j)
        dp[i][j] = (j > 0 ? dp[i - 1][j - 1] * prob[i - 1] : 0) +
                   dp[i - 1][j] * (1 - prob[i - 1]);

    return dp[prob.size()][target];
  }
};",9,501,1.0,2.0,2.0,2.0,55.66666666666666,8.0,3.99
1077.0,"class Solution {
 public:
  int maximizeSweetness(vector<int>& sweetness, int k) {
    int l = sweetness.size() / (k + 1);
    int r = accumulate(begin(sweetness), end(sweetness), 0) / (k + 1);

    while (l < r) {
      const int m = (l + r) / 2;
      if (canEat(sweetness, k, m))
        l = m + 1;
      else
        r = m;
    }

    return canEat(sweetness, k, l) ? l : l - 1;
  }

 private:
  // Returns true if can eat m sweetness (min sweetness of each piece).
  bool canEat(const vector<int>& sweetness, int k, int m) {
    int pieces = 0;
    int sum = 0;  // Running sum

    for (const int s : sweetness) {
      sum += s;
      if (sum >= m) {
        if (++pieces > k)
          return true;
        sum = 0;
      }
    }

    return false;
  };
};",14,764,2.0,5.0,6.0,6.0,54.57142857142857,17.0,2.8085714285714287
1078.0,"class Solution {
 public:
  bool checkStraightLine(vector<vector<int>>& coordinates) {
    int x0 = coordinates[0][0];
    int y0 = coordinates[0][1];
    int x1 = coordinates[1][0];
    int y1 = coordinates[1][1];
    int dx = x1 - x0;
    int dy = y1 - y0;

    for (int i = 2; i < coordinates.size(); ++i) {
      int x = coordinates[i][0];
      int y = coordinates[i][1];
      if ((x - x0) * dy != (y - y0) * dx)
        return false;
    }

    return true;
  }
};",13,471,0.0,1.0,3.0,2.0,36.23076923076923,12.0,5.299230769230769
1079.0,"class Solution {
 public:
  vector<string> removeSubfolders(vector<string>& folder) {
    vector<string> ans;
    string prev;

    sort(begin(folder), end(folder));

    for (const string& f : folder) {
      if (!prev.empty() && f.find(prev) == 0 && f[prev.length()] == '/')
        continue;
      ans.push_back(f);
      prev = f;
    }

    return ans;
  }
};",8,364,0.0,1.0,3.0,2.0,45.5,7.0,4.965000000000001
1080.0,"class Solution {
 public:
  int balancedString(string s) {
    const int n = s.length();
    const int k = n / 4;
    int ans = n;
    vector<int> count(128);

    for (const char c : s)
      ++count[c];

    for (int i = 0, j = 0; i < n; ++i) {
      --count[s[i]];
      while (j < n && count['Q'] <= k && count['W'] <= k && count['E'] <= k &&
             count['R'] <= k) {
        ans = min(ans, i - j + 1);
        ++count[s[j]];
        ++j;
      }
    }

    return ans;
  }
};",13,487,0.0,3.0,4.0,3.0,37.46153846153846,12.0,5.008461538461539
1081.0,"struct Job {
  int startTime;
  int endTime;
  int profit;
  Job(int startTime, int endTime, int profit)
      : startTime(startTime), endTime(endTime), profit(profit) {}
};

class Solution {
 public:
  int jobScheduling(vector<int>& startTime, vector<int>& endTime,
                    vector<int>& profit) {
    const int n = startTime.size();
    // dp[i] := max profit to schedule jobs[i:]
    dp.resize(n + 1);
    vector<Job> jobs;

    for (int i = 0; i < n; ++i)
      jobs.emplace_back(startTime[i], endTime[i], profit[i]);

    sort(begin(jobs), end(jobs), [](const auto& a, const auto& b) {
      return a.startTime < b.startTime;
    });

    // Will use binary search to find the first available startTime
    for (int i = 0; i < n; ++i)
      startTime[i] = jobs[i].startTime;

    return jobScheduling(jobs, startTime, 0);
  }

 private:
  vector<int> dp;

  int jobScheduling(const vector<Job>& jobs, const vector<int>& startTime,
                    int i) {
    if (i == jobs.size())
      return 0;
    if (dp[i] > 0)
      return dp[i];

    const int j = firstGreaterEqual(startTime, i + 1, jobs[i].endTime);
    const int pick = jobs[i].profit + jobScheduling(jobs, startTime, j);
    const int skip = jobScheduling(jobs, startTime, i + 1);
    return dp[i] = max(pick, skip);
  }

  int firstGreaterEqual(const vector<int>& A, int startFrom, int target) {
    return lower_bound(begin(A) + startFrom, end(A), target) - begin(A);
  }
};",25,1458,2.0,-1.0,7.0,4.0,58.32,35.0,0.9712000000000014
1082.0,"/**
 * // This is the HtmlParser's API interface.
 * // You should not implement it, or speculate about its implementation
 * class HtmlParser {
 *  public:
 *   vector<string> getUrls(string url);
 * };
 */

class Solution {
 public:
  vector<string> crawl(string startUrl, HtmlParser htmlParser) {
    queue<string> q{{startUrl}};
    unordered_set<string> seen{{startUrl}};
    const string& hostname = getHostname(startUrl);

    while (!q.empty()) {
      const string currUrl = q.front();
      q.pop();
      for (const string& url : htmlParser.getUrls(currUrl)) {
        if (seen.count(url))
          continue;
        if (url.find(hostname) != string::npos) {
          q.push(url);
          seen.insert(url);
        }
      }
    }

    return {begin(seen), end(seen)};
  }

 private:
  string getHostname(const string& url) {
    const int firstSlash = url.find_first_of('/');
    const int thirdSlash = url.find_first_of('/', firstSlash + 2);
    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);
  }
};",15,1033,1.0,2.0,12.0,4.0,68.86666666666666,22.0,0.8019999999999996
1083.0,"class Solution {
 public:
  vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {
    vector<vector<int>> ans;
    int x = 1;
    int y = 1000;

    while (x <= 1000 && y >= 1) {
      int f = customfunction.f(x, y);
      if (f < z)
        ++x;
      else if (f > z)
        --y;
      else
        ans.push_back({x++, y--});
    }

    return ans;
  }
};",9,377,0.0,5.0,4.0,3.0,41.888888888888886,7.0,4.99
1084.0,"class Solution {
 public:
  vector<int> circularPermutation(int n, int start) {
    vector<int> ans;

    for (int i = 0; i < 1 << n; ++i)
      ans.push_back(start ^ i ^ i >> 1);

    return ans;
  }
};",6,203,0.0,1.0,2.0,1.0,33.833333333333336,6.0,6.175
1085.0,"class Solution {
 public:
  int maxLength(vector<string>& arr) {
    vector<int> masks;

    for (const string& s : arr) {
      const int mask = getMask(s);
      if (mask != -1)
        masks.push_back(mask);
    }

    return dfs(masks, 0, /*usedMask=*/0);
  }

 private:
  int dfs(const vector<int>& masks, int s, int usedMask) {
    int res = __builtin_popcount(usedMask);
    for (int i = s; i < masks.size(); ++i)
      if ((usedMask & masks[i]) == 0)
        res = max(res, dfs(masks, i + 1, usedMask | masks[i]));
    return res;
  }

  int getMask(const string& s) {
    int mask = 0;
    for (const char c : s) {
      const int i = c - 'a';
      if ((mask & (1 << i)) != 0)
        return -1;
      mask |= 1 << i;
    }
    return mask;
  }
};",15,757,1.0,3.0,6.0,6.0,50.46666666666667,23.0,2.6579999999999995
1086.0,"class Solution {
 public:
  int tilingRectangle(int n, int m) {
    return tilingRectangle(n, m, 0, vector<int>(m));
  }

 private:
  static constexpr int kBase = 13;
  unordered_map<long, int> dp;

  int tilingRectangle(int n, int m, long hashedHeights, vector<int>&& heights) {
    if (const auto it = dp.find(hashedHeights); it != cend(dp))
      return it->second;

    const auto it = min_element(begin(heights), end(heights));
    const int minHeight = *it;
    if (minHeight == n)  // All filled
      return 0;

    int ans = m * n;
    const int start = it - begin(heights);
    // Try to put square of different size that doesn't exceed the width/height
    for (int sz = 1; sz <= min(m - start, n - minHeight); ++sz) {
      // heights[start:start + sz] must has the same height
      if (heights[start + sz - 1] != minHeight)
        break;
      // Put a square of size `sz` to cover heights[start:start + sz]
      for (int i = start; i < start + sz; ++i)
        heights[i] += sz;
      ans = min(ans, tilingRectangle(n, m, hash(heights), move(heights)));
      for (int i = start; i < start + sz; ++i)
        heights[i] -= sz;
    }

    return dp[hashedHeights] = 1 + ans;
  }

  long hash(const vector<int>& heights) {
    long hashed = 0;
    for (int i = heights.size() - 1; i >= 0; --i)
      hashed = hashed * kBase + heights[i];
    return hashed;
  }
};",27,1378,4.0,2.0,5.0,8.0,51.03703703703704,24.0,2.746666666666667
1087.0,"/**
 * // This is the HtmlParser's API interface.
 * // You should not implement it, or speculate about its implementation
 * class HtmlParser {
 *  public:
 *   vector<string> getUrls(string url);
 * };
 */

class Solution {
 public:
  vector<string> crawl(string startUrl, HtmlParser htmlParser) {
    queue<string> q{{startUrl}};
    unordered_set<string> seen{{startUrl}};
    const string& hostname = getHostname(startUrl);

    // Threading
    const int nThreads = std::thread::hardware_concurrency();
    vector<thread> threads;
    std::mutex mtx;
    std::condition_variable cv;

    auto t = [&]() {
      while (true) {
        unique_lock<mutex> lock(mtx);
        cv.wait_for(lock, 30ms, [&]() { return q.size(); });

        if (q.empty())
          return;

        auto cur = q.front();
        q.pop();

        lock.unlock();

        const vector<string> urls = htmlParser.getUrls(cur);

        lock.lock();
        for (const string& url : urls) {
          if (seen.count(url))
            continue;
          if (url.find(hostname) != string::npos) {
            q.push(url);
            seen.insert(url);
          }
        }
        lock.unlock();
        cv.notify_all();
      }
    };

    for (int i = 0; i < nThreads; ++i)
      threads.emplace_back(t);

    for (std::thread& t : threads)
      t.join();

    return {begin(seen), end(seen)};
  }

 private:
  string getHostname(const string& url) {
    const int firstSlash = url.find_first_of('/');
    const int thirdSlash = url.find_first_of('/', firstSlash + 2);
    return url.substr(firstSlash + 2, thirdSlash - firstSlash - 2);
  }
};",33,1625,2.0,3.0,14.0,9.0,49.24242424242424,25.0,2.128181818181819
1088.0,"class Solution {
 public:
  int treeDiameter(vector<vector<int>>& edges) {
    const int n = edges.size();
    int ans = 0;
    vector<vector<int>> tree(n + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    maxDepth(tree, 0, -1, ans);
    return ans;
  }

 private:
  int maxDepth(const vector<vector<int>>& tree, int u, int parent, int& ans) {
    int maxDepth1 = 0;   // The max depth
    int maxDepth2 = -1;  // The 2nd max depth

    for (const int v : tree[u]) {
      if (v == parent)
        continue;
      const int depth = maxDepth(tree, v, u, ans);
      if (depth > maxDepth1) {
        maxDepth2 = maxDepth1;
        maxDepth1 = depth;
      } else if (depth > maxDepth2) {
        maxDepth2 = depth;
      }
    }

    ans = max(ans, maxDepth1 + maxDepth2);
    return 1 + maxDepth1;
  }
};",19,928,2.0,4.0,7.0,5.0,48.8421052631579,25.0,2.524210526315789
1089.0,"class Solution {
 public:
  int minimumMoves(vector<int>& arr) {
    const int n = arr.size();
    // dp[i][j] := min # of moves to remove all numbers from arr[i..j]
    vector<vector<int>> dp(n, vector<int>(n, n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int i = 0; i + 1 < n; ++i)
      dp[i][i + 1] = arr[i] == arr[i + 1] ? 1 : 2;

    for (int d = 2; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        // Remove arr[i] and arr[j] within the move of
        // Removing arr[i + 1..j - 1]
        if (arr[i] == arr[j])
          dp[i][j] = dp[i + 1][j - 1];
        // Try all possible partitions
        for (int k = i; k < j; ++k)
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
      }

    return dp[0][n - 1];
  }
};",19,797,4.0,6.0,3.0,6.0,41.94736842105263,14.0,4.444736842105264
1090.0,"class Solution {
 public:
  int minimumSwap(string s1, string s2) {
    // (""xx"", ""yy"") = (2 ""xy""s) -> 1 swap
    // (""yy"", ""xx"") = (2 ""yx""s) -> 1 swap
    // (""xy"", ""yx"") = (1 ""xy"" and 1 ""yx"") -> 2 swaps
    int xy = 0;  // # of index i s.t. s1[i] = 'x' and s2[i] 'y'
    int yx = 0;  // # of index i s.t. s1[i] = 'y' and s2[i] 'x'

    for (int i = 0; i < s1.length(); ++i) {
      if (s1[i] == s2[i])
        continue;
      if (s1[i] == 'x')
        ++xy;
      else
        ++yx;
    }

    if ((xy + yx) % 2 == 1)
      return -1;
    return xy / 2 + yx / 2 + (xy % 2 == 1 ? 2 : 0);
  }
};",10,595,5.0,3.0,3.0,4.0,59.5,7.0,3.785000000000001
1091.0,"class Solution {
 public:
  int numberOfSubarrays(vector<int>& nums, int k) {
    return numberOfSubarraysAtMost(nums, k) -
           numberOfSubarraysAtMost(nums, k - 1);
  }

 private:
  int numberOfSubarraysAtMost(vector<int>& nums, int k) {
    int ans = 0;

    for (int l = 0, r = 0; r <= nums.size();)
      if (k >= 0) {
        ans += r - l;
        if (r == nums.size())
          break;
        if (nums[r] & 1)
          --k;
        ++r;
      } else {
        if (nums[l] & 1)
          ++k;
        ++l;
      }

    return ans;
  }
};",12,551,0.0,4.0,5.0,5.0,45.91666666666666,9.0,4.4275
1092.0,"class Solution {
 public:
  string minRemoveToMakeValid(string s) {
    stack<int> stack;  // Unpaired '(' indices

    for (int i = 0; i < s.length(); ++i)
      if (s[i] == '(') {
        stack.push(i);  // Record unpaired '(' index
      } else if (s[i] == ')') {
        if (stack.empty())
          s[i] = '*';  // Mark unpaired ')' as '*'
        else
          stack.pop();  // Find a pair!
      }

    // Mark unpaired '(' as '*'
    while (!stack.empty())
      s[stack.top()] = '*', stack.pop();

    s.erase(remove(begin(s), end(s), '*'), end(s));
    return s;
  }
};",10,580,5.0,7.0,4.0,5.0,58.0,5.0,3.82
1093.0,"class Solution {
 public:
  bool isGoodArray(vector<int>& nums) {
    int g = nums[0];

    for (const int num : nums)
      g = __gcd(g, num);

    return g == 1;
  }
};",4,170,0.0,1.0,2.0,1.0,42.5,6.0,5.3950000000000005
1094.0,"class Solution {
 public:
  int oddCells(int m, int n, vector<vector<int>>& indices) {
    int ans = 0;
    // rows[i] and cols[i] :=
    //   true (flipped even times) / false (flipped odd times)
    vector<bool> rows(m);
    vector<bool> cols(n);

    for (const vector<int>& index : indices) {
      rows[index[0]] = rows[index[0]] ^ true;
      cols[index[1]] = cols[index[1]] ^ true;
    }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        ans += rows[i] ^ cols[j];

    return ans;
  }
};",12,519,2.0,3.0,3.0,3.0,43.25,12.0,4.6275
1095.0,"class Solution {
 public:
  vector<vector<int>> reconstructMatrix(int upper, int lower,
                                        vector<int>& colsum) {
    if (upper + lower != accumulate(begin(colsum), end(colsum), 0))
      return {};
    if (min(upper, lower) <
        count_if(begin(colsum), end(colsum), [](int c) { return c == 2; }))
      return {};

    vector<vector<int>> ans(2, vector<int>(colsum.size()));

    for (int j = 0; j < colsum.size(); ++j)
      if (colsum[j] == 2) {
        ans[0][j] = 1;
        ans[1][j] = 1;
        --upper;
        --lower;
      }

    for (int j = 0; j < colsum.size(); ++j) {
      if (colsum[j] == 1 && upper > 0) {
        ans[0][j] = 1;
        --colsum[j];
        --upper;
      }

      if (colsum[j] == 1 && lower > 0) {
        ans[1][j] = 1;
        --lower;
      }
    }

    return ans;
  }
};",19,855,0.0,4.0,9.0,8.0,45.0,10.0,4.17
1096.0,"class Solution {
 public:
  int closedIsland(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();

    // Remove lands connected to edge
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (i * j == 0 || i == m - 1 || j == n - 1)
          if (grid[i][j] == 0)
            dfs(grid, i, j);

    int ans = 0;

    // Reduce to 200. Number of Islands
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 0) {
          dfs(grid, i, j);
          ++ans;
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& grid, int i, int j) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (grid[i][j] == 1)
      return;

    grid[i][j] = 1;
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
  };
};",24,900,2.0,7.0,4.0,9.0,37.5,16.0,4.445
1097.0,"class Solution {
 public:
  int maxScoreWords(vector<string>& words, vector<char>& letters,
                    vector<int>& score) {
    vector<int> count(26);
    for (const char c : letters)
      ++count[c - 'a'];
    return dfs(words, 0, count, score);
  }

 private:
  // Max score you can get from words[s:]
  int dfs(const vector<string>& words, int s, vector<int>& count,
          const vector<int>& score) {
    int ans = 0;
    for (int i = s; i < words.size(); ++i) {
      const int earned = useWord(words, i, count, score);
      if (earned > 0)
        ans = max(ans, earned + dfs(words, i + 1, count, score));
      unuseWord(words, i, count);
    }
    return ans;
  }

  int useWord(const vector<string>& words, int i, vector<int>& count,
              const vector<int>& score) {
    bool isValid = true;
    int earned = 0;
    for (const char c : words[i]) {
      if (--count[c - 'a'] < 0)
        isValid = false;
      earned += score[c - 'a'];
    }
    return isValid ? earned : -1;
  }

  void unuseWord(const vector<string>& words, int i, vector<int>& count) {
    for (const char c : words[i])
      ++count[c - 'a'];
  }
};",17,1154,1.0,4.0,7.0,6.0,67.88235294117646,37.0,-0.4294117647058826
1098.0,"class Solution {
 public:
  string encode(int num) {
    string binaryStr = bitset<30>(num + 1).to_string();
    binaryStr.erase(0, binaryStr.find_first_not_of('0'));
    return binaryStr.substr(1);
  }
};",4,205,0.0,0.0,2.0,0.0,51.25,4.0,4.8675
1099.0,"class Solution {
 public:
  string findSmallestRegion(vector<vector<string>>& regions, string region1,
                            string region2) {
    unordered_map<string, string> parent;
    unordered_set<string> ancestors;  // region1's ancestors

    for (const vector<string>& region : regions)
      for (int i = 1; i < region.size(); ++i)
        parent[region[i]] = region[0];

    // Insert all of region1's ancestors
    while (region1 != """") {
      ancestors.insert(region1);
      region1 = parent[region1];  // Region1 becomes """" in the end
    }

    // Go up from region2 until meet any of region1's ancestors
    while (!ancestors.count(region2))
      region2 = parent[region2];

    return region2;
  }
};",10,726,4.0,4.0,3.0,4.0,72.6,11.0,2.1060000000000016
1100.0,"class Solution {
 public:
  vector<string> generateSentences(vector<vector<string>>& synonyms,
                                   string text) {
    set<string> ans;
    unordered_map<string, vector<string>> graph;
    queue<string> q{{text}};

    for (const vector<string>& synonym : synonyms) {
      const string& s = synonym[0];
      const string& t = synonym[1];
      graph[s].push_back(t);
      graph[t].push_back(s);
    }

    while (!q.empty()) {
      const string u = q.front();
      q.pop();
      ans.insert(u);
      vector<string> words = split(u);
      for (string& word : words) {
        const auto it = graph.find(word);
        if (it == cend(graph))
          continue;
        for (const string& synonym : it->second) {
          // Replace words[i] with its synonym.
          word = synonym;
          const string newText = join(words, ' ');
          if (!ans.count(newText))
            q.push(newText);
        }
      }
    }

    return {begin(ans), end(ans)};
  }

 private:
  vector<string> split(const string& s) {
    vector<string> words;
    istringstream iss(s);
    for (string token; iss >> token;)
      words.push_back(token);
    return words;
  }

  string join(const vector<string>& words, char c) {
    string joined;
    for (int i = 0; i < words.size(); ++i) {
      joined += words[i];
      if (i != words.size() - 1)
        joined += c;
    }
    return joined;
  }
};",30,1425,1.0,6.0,12.0,9.0,47.5,34.0,1.285
1101.0,"class Solution {
 public:
  int numberOfWays(int numPeople) {
    constexpr int kMod = 1'000'000'007;
    // dp[i] := # of ways i handshakes pair w/o crossing
    vector<long> dp(numPeople / 2 + 1);
    dp[0] = 1;

    for (int i = 1; i <= numPeople / 2; ++i)
      for (int j = 0; j < i; ++j) {
        dp[i] += dp[j] * dp[i - 1 - j];
        dp[i] %= kMod;
      }

    return dp[numPeople / 2];
  }
};",11,404,1.0,2.0,3.0,2.0,36.72727272727273,6.0,5.834545454545455
1102.0,"class Solution {
 public:
  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<int>> ans(m, vector<int>(n));

    k %= m * n;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        int index = (i * n + j + k) % (m * n);
        int x = index / n;
        int y = index % n;
        ans[x][y] = grid[i][j];
      }

    return ans;
  }
};",14,457,0.0,2.0,3.0,3.0,32.642857142857146,15.0,5.262142857142857
1103.0,"class FindElements {
 public:
  FindElements(TreeNode* root) {
    dfs(root, 0);
  }

  bool find(int target) {
    return vals.count(target);
  }

 private:
  unordered_set<int> vals;

  void dfs(TreeNode* root, int val) {
    if (root == nullptr)
      return;

    root->val = val;
    vals.insert(val);
    dfs(root->left, val * 2 + 1);
    dfs(root->right, val * 2 + 2);
  }
};",9,382,0.0,0.0,4.0,1.0,42.44444444444444,6.0,5.34
1104.0,"class Solution {
 public:
  int maxSumDivThree(vector<int>& nums) {
    vector<int> dp(3);  // dp[i] := max sum so far s.t. sum % 3 == i

    for (const int num : nums)
      for (const int sum : vector<int>(dp))
        dp[(sum + num) % 3] = max(dp[(sum + num) % 3], sum + num);

    return dp[0];
  }
};",4,305,1.0,2.0,2.0,2.0,76.25,9.0,2.0375
1105.0,"class Solution {
 public:
  int minPushBox(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<int> box;
    vector<int> player;
    vector<int> target;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 'B')
          box = {i, j};
        else if (grid[i][j] == 'S')
          player = {i, j};
        else if (grid[i][j] == 'T')
          target = {i, j};

    int ans = 0;
    // (boxX, boxY, playerX, playerY)
    queue<tuple<int, int, int, int>> q{
        {{box[0], box[1], player[0], player[1]}}};
    vector<vector<vector<vector<bool>>>> seen(
        m, vector<vector<vector<bool>>>(
               n, vector<vector<bool>>(m, vector<bool>(n))));
    seen[box[0]][box[1]][player[0]][player[1]] = true;

    while (!q.empty()) {
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [boxX, boxY, playerX, playerY] = q.front();
        q.pop();
        if (boxX == target[0] && boxY == target[1])
          return ans;
        for (int k = 0; k < 4; ++k) {
          const int nextBoxX = boxX + dirs[k];
          const int nextBoxY = boxY + dirs[k + 1];
          if (isInvalid(grid, nextBoxX, nextBoxY))
            continue;
          if (seen[nextBoxX][nextBoxY][boxX][boxY])
            continue;
          const int fromX = boxX + dirs[(k + 2) % 4];
          const int fromY = boxY + dirs[(k + 3) % 4];
          if (isInvalid(grid, fromX, fromY))
            continue;
          if (canGoTo(grid, playerX, playerY, fromX, fromY, boxX, boxY)) {
            seen[nextBoxX][nextBoxY][boxX][boxY] = true;
            q.emplace(nextBoxX, nextBoxY, boxX, boxY);
          }
        }
      }
      ++ans;
    }

    return -1;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  // Returns true if (playerX, playerY) can go to (fromX, fromY).
  bool canGoTo(const vector<vector<char>>& grid, int playerX, int playerY,
               int fromX, int fromY, int boxX, int boxY) {
    queue<pair<int, int>> q{{{playerX, playerY}}};
    vector<vector<bool>> seen(grid.size(), vector<bool>(grid[0].size()));
    seen[playerX][playerY] = true;

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      if (i == fromX && j == fromY)
        return true;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (isInvalid(grid, x, y))
          continue;
        if (seen[x][y])
          continue;
        if (x == boxX && y == boxY)
          continue;
        q.emplace(x, y);
        seen[x][y] = true;
      }
    }

    return false;
  }

  bool isInvalid(const vector<vector<char>>& grid, int playerX, int playerY) {
    return playerX < 0 || playerX == grid.size() || playerY < 0 ||
           playerY == grid[0].size() || grid[playerX][playerY] == '#';
  }
};",53,2874,2.0,12.0,20.0,20.0,54.22641509433962,58.0,-2.520377358490567
1106.0,"/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation.
 * class ImmutableListNode {
 *  public:
 *   void printValue(); // Print the value of the node.
 *   ImmutableListNode* getNext(); // Returns the next node.
 * };
 */

class Solution {
 public:
  void printLinkedListInReverse(ImmutableListNode* head) {
    if (head == nullptr)
      return;

    printLinkedListInReverse(head->getNext());
    head->printValue();
  }
};",7,502,1.0,1.0,3.0,1.0,71.71428571428571,4.0,2.9457142857142866
1107.0,"class Solution {
 public:
  int minTimeToVisitAllPoints(vector<vector<int>>& points) {
    int ans = 0;

    for (int i = 1; i < points.size(); ++i)
      ans += max(abs(points[i][0] - points[i - 1][0]),
                 abs(points[i][1] - points[i - 1][1]));

    return ans;
  }
};",6,283,0.0,1.0,2.0,1.0,47.16666666666666,5.0,5.075000000000001
1108.0,"class Solution {
 public:
  int countServers(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    vector<int> rows(m);
    vector<int> cols(n);

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1) {
          ++rows[i];
          ++cols[j];
        }

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (grid[i][j] == 1 && (rows[i] > 1 || cols[j] > 1))
          ++ans;

    return ans;
  }
};",18,524,0.0,6.0,3.0,6.0,29.11111111111111,14.0,5.44
1109.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  const string* word = nullptr;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  vector<vector<string>> suggestedProducts(vector<string>& products,
                                           string searchWord) {
    vector<vector<string>> ans;

    for (const string& product : products)
      insert(product);

    shared_ptr<TrieNode> node = root;

    for (const char c : searchWord) {
      if (node == nullptr || node->children[c - 'a'] == nullptr) {
        node = nullptr;
        ans.push_back({});
        continue;
      }
      node = node->children[c - 'a'];
      ans.push_back(search(node));
    }

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->word = &word;
  }

  vector<string> search(shared_ptr<TrieNode> node) {
    vector<string> res;
    dfs(node, res);
    return res;
  }

  void dfs(shared_ptr<TrieNode> node, vector<string>& ans) {
    if (ans.size() == 3)
      return;
    if (node == nullptr)
      return;
    if (node->word != nullptr)
      ans.push_back(*node->word);
    for (shared_ptr<TrieNode> child : node->children)
      dfs(child, ans);
  }
};",26,1473,0.0,5.0,11.0,9.0,56.65384615384615,23.0,1.6411538461538449
1110.0,"class Solution {
 public:
  int numWays(int steps, int arrLen) {
    constexpr int kMod = 1'000'000'007;
    const int n = min(arrLen, steps / 2 + 1);
    // dp[i] := # of ways to stay on index i
    vector<long> dp(n);
    dp[0] = 1;

    while (steps--) {
      vector<long> newDp(n);
      for (int i = 0; i < n; ++i) {
        newDp[i] = dp[i];
        if (i - 1 >= 0)
          newDp[i] += dp[i - 1];
        if (i + 1 < n)
          newDp[i] += dp[i + 1];
        newDp[i] %= kMod;
      }
      dp = move(newDp);
    }

    return dp[0];
  }
};",14,551,1.0,4.0,4.0,4.0,39.35714285714285,8.0,5.217857142857143
1111.0,"class Solution {
 public:
  vector<vector<int>> removeInterval(vector<vector<int>>& intervals,
                                     vector<int>& toBeRemoved) {
    vector<vector<int>> ans;

    for (const vector<int>& interval : intervals) {
      const int a = interval[0];
      const int b = interval[1];
      if (a >= toBeRemoved[1] || b <= toBeRemoved[0]) {
        ans.push_back(interval);
      } else {  // a < toBeRemoved[1] && b > toBeRemoved[0]
        if (a < toBeRemoved[0])
          ans.push_back({a, toBeRemoved[0]});
        if (b > toBeRemoved[1])
          ans.push_back({toBeRemoved[1], b});
      }
    }

    return ans;
  }
};",8,650,1.0,5.0,7.0,4.0,81.25,11.0,0.9074999999999988
1112.0,"struct T {
  int sum;
  int count;
};

class Solution {
 public:
  int deleteTreeNodes(int nodes, vector<int>& parent, vector<int>& value) {
    vector<vector<int>> graph(nodes);

    for (int i = 1; i < parent.size(); ++i)
      graph[parent[i]].push_back(i);

    return dfs(graph, 0, value).count;
  }

 private:
  T dfs(const vector<vector<int>>& graph, int u, const vector<int>& value) {
    int sum = value[u];  // Root value
    int count = 1;       // This root

    for (const int v : graph[u]) {
      const T t = dfs(graph, v, value);
      sum += t.sum;
      count += t.count;
    }

    if (sum == 0)     // Delete this u
      return {0, 0};  // So its count = 0
    return {sum, count};
  }
};",16,709,4.0,1.0,7.0,3.0,44.3125,20.0,3.691875000000001
1113.0,"/**
 * // This is Sea's API interface.
 * // You should not implement it, or speculate about its implementation
 * class Sea {
 *  public:
 *   bool hasShips(vector<int> topRight, vector<int> bottomLeft);
 * };
 */

class Solution {
 public:
  int countShips(Sea sea, vector<int> topRight, vector<int> bottomLeft) {
    if (topRight[0] < bottomLeft[0] || topRight[1] < bottomLeft[1])
      return 0;
    if (!sea.hasShips(topRight, bottomLeft))
      return 0;

    // Sea.hashShips(topRight, bottomLeft) == true
    if (topRight[0] == bottomLeft[0] && topRight[1] == bottomLeft[1])
      return 1;

    const int mx = (topRight[0] + bottomLeft[0]) / 2;
    const int my = (topRight[1] + bottomLeft[1]) / 2;
    int ans = 0;
    // Top right
    ans += countShips(sea, topRight, {mx + 1, my + 1});
    // Bottom right
    ans += countShips(sea, {topRight[0], my}, {mx + 1, bottomLeft[1]});
    // Top left
    ans += countShips(sea, {mx, topRight[1]}, {bottomLeft[0], my + 1});
    // Bottom left
    ans += countShips(sea, {mx, my}, bottomLeft);
    return ans;
  }
};",14,1069,6.0,0.0,9.0,3.0,76.35714285714286,13.0,1.527857142857142
1114.0,"class Solution {
 public:
  string tictactoe(vector<vector<int>>& moves) {
    vector<vector<int>> row(2, vector<int>(3));
    vector<vector<int>> col(2, vector<int>(3));
    vector<int> diag1(2);
    vector<int> diag2(2);

    for (int i = 0; i < moves.size(); ++i) {
      int r = moves[i][0];
      int c = moves[i][1];
      int j = i % 2;
      if (++row[j][r] == 3 || ++col[j][c] == 3 || r == c && ++diag1[j] == 3 ||
          r + c == 2 && ++diag2[j] == 3)
        return j == 0 ? ""A"" : ""B"";
    }

    return moves.size() == 9 ? ""Draw"" : ""Pending"";
  }
};",12,563,0.0,1.0,3.0,2.0,46.91666666666666,13.0,4.237500000000002
1115.0,"class Solution {
 public:
  vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {
    if (tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices ||
        tomatoSlices > cheeseSlices * 4)
      return {};

    int jumboBurgers = (tomatoSlices - 2 * cheeseSlices) / 2;

    return {jumboBurgers, cheeseSlices - jumboBurgers};
  }
};",4,343,0.0,0.0,4.0,1.0,85.75,5.0,1.5425000000000004
1116.0,"class Solution {
 public:
  int countSquares(vector<vector<int>>& matrix) {
    for (int i = 0; i < matrix.size(); ++i)
      for (int j = 0; j < matrix[0].size(); ++j)
        if (matrix[i][j] == 1 && i > 0 && j > 0)
          matrix[i][j] +=
              min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1]});
    return accumulate(begin(matrix), end(matrix), 0, [](int a, const auto& A) {
      return a + accumulate(begin(A), end(A), 0);
    });
  }
};",8,467,0.0,2.0,4.0,3.0,58.375,7.0,3.68625
1117.0,"class Solution {
 public:
  int palindromePartition(string s, int k) {
    const int n = s.length();
    // dp[i][k] := min cost to make k palindromes by s[0..i)
    dp.resize(n + 1, vector<int>(k + 1, n));
    // cost[i][j] := min cost to make s[i..j] palindrome
    cost.resize(n, vector<int>(n));

    for (int d = 1; d < n; ++d)
      for (int i = 0, j = d; j < n; ++i, ++j)
        cost[i][j] = (s[i] != s[j]) + cost[i + 1][j - 1];

    return palindromePartition(n, k);
  }

 private:
  vector<vector<int>> dp;
  vector<vector<int>> cost;

  int palindromePartition(int n, int k) {
    if (k == 1)
      return cost[0][n - 1];
    int& ans = dp[n][k];
    if (ans < n)
      return ans;

    // Try all possible partitions
    for (int i = k - 1; i < n; ++i)
      ans = min(ans, palindromePartition(i, k - 1) + cost[i][n - 1]);

    return ans;
  }
};",19,858,3.0,2.0,3.0,5.0,45.1578947368421,17.0,4.055789473684211
1118.0,"class Solution {
 public:
  int subtractProductAndSum(int n) {
    int prod = 1;
    int summ = 0;

    for (; n > 0; n /= 10) {
      prod *= n % 10;
      summ += n % 10;
    }

    return prod - summ;
  }
};",8,210,0.0,1.0,3.0,1.0,26.25,5.0,6.8975
1119.0,"class Solution {
 public:
  vector<vector<int>> groupThePeople(vector<int>& groupSizes) {
    vector<vector<int>> ans;
    unordered_map<int, vector<int>> groupSizeToIndices;

    for (int i = 0; i < groupSizes.size(); ++i)
      groupSizeToIndices[groupSizes[i]].push_back(i);

    for (const auto& [groupSize, indices] : groupSizeToIndices) {
      vector<int> groupIndices;
      for (const int index : indices) {
        groupIndices.push_back(index);
        if (groupIndices.size() == groupSize) {
          ans.push_back(groupIndices);
          groupIndices.clear();
        }
      }
    }

    return ans;
  }
};",11,622,0.0,4.0,5.0,4.0,56.54545454545455,11.0,3.2709090909090905
1120.0,"class Solution {
 public:
  int smallestDivisor(vector<int>& nums, int threshold) {
    int l = 1;
    int r = *max_element(begin(nums), end(nums));

    while (l < r) {
      const int m = (l + r) / 2;
      if (sumDivision(nums, m) <= threshold)
        r = m;
      else
        l = m + 1;
    }

    return l;
  }

 private:
  int sumDivision(const vector<int>& nums, int m) {
    int sum = 0;
    for (const int num : nums)
      sum += (num - 1) / m + 1;
    return sum;
  }
};",10,483,0.0,3.0,4.0,3.0,48.3,15.0,3.733000000000001
1121.0,"class Solution {
 public:
  int minFlips(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    const int hashed = hash(mat, m, n);
    if (hashed == 0)
      return 0;

    const vector<int> dirs{0, 1, 0, -1, 0};
    queue<int> q{{hashed}};
    unordered_set<int> seen{hashed};

    for (int step = 1; !q.empty(); ++step) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int curr = q.front();
        q.pop();
        for (int i = 0; i < m; ++i) {
          for (int j = 0; j < n; ++j) {
            int next = curr ^ 1 << (i * n + j);
            // Flip four neighbors
            for (int k = 0; k < 4; ++k) {
              const int x = i + dirs[k];
              const int y = j + dirs[k + 1];
              if (x < 0 || x == m || y < 0 || y == n)
                continue;
              next ^= 1 << (x * n + y);
            }
            if (next == 0)
              return step;
            if (seen.count(next))
              continue;
            q.push(next);
            seen.insert(next);
          }
        }
      }
    }

    return -1;
  }

 private:
  int hash(const vector<vector<int>>& mat, int m, int n) {
    int hashed = 0;
    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (mat[i][j])
          hashed |= 1 << (i * n + j);
    return hashed;
  }
};",37,1354,1.0,7.0,12.0,12.0,36.5945945945946,33.0,2.3064864864864862
1122.0,"class CombinationIterator {
  public CombinationIterator(String characters, int combinationLength) {
    final int n = characters.length();
    final int k = combinationLength;

    // generate bitmasks from 0..00 to 1..11
    for (int bitmask = 0; bitmask < 1 << n; bitmask++) {
      // use bitmasks with k 1-bits
      if (Integer.bitCount(bitmask) == k) {
        // convert bitmask into combination
        // 111 --> ""abc"", 000 --> """"
        // 110 --> ""ab"", 101 --> ""ac"", 011 --> ""bc""
        StringBuilder curr = new StringBuilder();
        for (int j = 0; j < n; j++) {
          if ((bitmask & (1 << n - j - 1)) != 0) {
            curr.append(characters.charAt(j));
          }
        }
        combinations.push(curr.toString());
      }
    }
  }

  public String next() {
    return combinations.pop();
  }

  public boolean hasNext() {
    return (!combinations.isEmpty());
  }

  private Deque<String> combinations = new ArrayDeque<String>();
}",12,963,5.0,3.0,8.0,4.0,80.25,6.0,1.7174999999999994
1123.0,"class Solution {
 public:
  int findSpecialInteger(vector<int>& arr) {
    const int n = arr.size();
    const int quarter = n / 4;

    for (int i = 0; i < n - quarter; ++i)
      if (arr[i] == arr[i + quarter]) return arr[i];

    throw;
  }
};",7,246,0.0,1.0,2.0,2.0,35.142857142857146,8.0,5.857142857142858
1124.0,"class Solution {
 public:
  int removeCoveredIntervals(vector<vector<int>>& intervals) {
    // If two intervals have the same start, put the one with larger end first.
    sort(begin(intervals), end(intervals),
         [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];
    });

    int ans = 0;
    int prevEnd = 0;

    for (const vector<int>& interval : intervals)
      // Current interval is not covered by the previous one.
      if (prevEnd < interval[1]) {
        ++ans;
        prevEnd = interval[1];
      }

    return ans;
  }
};",8,597,2.0,1.0,4.0,3.0,74.625,11.0,1.9637499999999992
1125.0,"class Solution {
 public:
  int minFallingPathSum(vector<vector<int>>& grid) {
    const int n = grid.size();

    for (int i = 1; i < n; ++i) {
      const vector<pair<int, int>> twoMinNumAndIndexs =
          getTwoMinNumAndIndexs(grid[i - 1]);
      const auto& [firstMinNum, firstMinIndex] = twoMinNumAndIndexs[0];
      const auto& [secondMinNum, _] = twoMinNumAndIndexs[1];
      for (int j = 0; j < n; ++j)
        if (j == firstMinIndex)
          grid[i][j] += secondMinNum;
        else
          grid[i][j] += firstMinNum;
    }

    return *min_element(begin(grid.back()), end(grid.back()));
  }

 private:
  vector<pair<int, int>> getTwoMinNumAndIndexs(const vector<int>& A) {
    vector<pair<int, int>> numAndIndexs;

    for (int i = 0; i < A.size(); ++i)
      numAndIndexs.emplace_back(A[i], i);

    sort(begin(numAndIndexs), end(numAndIndexs));
    return {numAndIndexs[0], numAndIndexs[1]};
  }
};",18,917,0.0,4.0,5.0,4.0,50.94444444444444,19.0,2.975
1126.0,"class Solution {
 public:
  int getDecimalValue(ListNode* head) {
    int ans = 0;

    for (; head; head = head->next)
      ans = ans * 2 + head->val;

    return ans;
  }
};",6,176,0.0,1.0,2.0,1.0,29.33333333333333,3.0,6.880000000000001
1127.0,"class Solution {
 public:
  vector<int> sequentialDigits(int low, int high) {
    vector<int> ans;
    queue<int> q{{1, 2, 3, 4, 5, 6, 7, 8, 9}};

    while (!q.empty()) {
      const int num = q.front();
      q.pop();
      if (num > high)
        return ans;
      if (low <= num && num <= high)
        ans.push_back(num);
      const int lastDigit = num % 10;
      if (lastDigit < 9)
        q.push(num * 10 + lastDigit + 1);
    }

    return ans;
  }
};",10,461,0.0,3.0,5.0,4.0,46.1,10.0,4.371
1128.0,"class Solution {
 public:
  int maxSideLength(vector<vector<int>>& mat, int threshold) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        for (int length = ans; length < min(m - i, n - j); ++length) {
          if (squareSum(prefix, i, j, i + length, j + length) > threshold)
            break;
          ans = max(ans, length + 1);
        }

    return ans;
  }

 private:
  int squareSum(vector<vector<int>>& prefix, int r1, int c1, int r2, int c2) {
    return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] +
           prefix[r1][c1];
  }
};",20,904,0.0,4.0,4.0,6.0,45.2,22.0,3.251999999999999
1129.0,"class Solution {
 public:
  int shortestPath(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    if (m == 1 && n == 1)
      return 0;

    const vector<int> dirs{0, 1, 0, -1, 0};
    int steps = 0;
    queue<tuple<int, int, int>> q{{{0, 0, k}}};  // (i, j, eliminate)
    vector<vector<vector<bool>>> seen(
        m, vector<vector<bool>>(n, vector<bool>(k + 1)));
    seen[0][0][k] = true;

    while (!q.empty()) {
      ++steps;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j, eliminate] = q.front();
        q.pop();
        for (int l = 0; l < 4; ++l) {
          const int x = i + dirs[l];
          const int y = j + dirs[l + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (x == m - 1 && y == n - 1)
            return steps;
          if (grid[x][y] == 1 && eliminate == 0)
            continue;
          const int newEliminate = eliminate - grid[x][y];
          if (seen[x][y][newEliminate])
            continue;
          q.emplace(x, y, newEliminate);
          seen[x][y][newEliminate] = true;
        }
      }
    }

    return -1;
  }
};",26,1175,1.0,3.0,9.0,8.0,45.19230769230769,26.0,2.6526923076923072
1130.0,"class Solution {
 public:
  int findNumbers(vector<int>& nums) {
    int ans = 0;

    for (int num : nums)
      if (9 < num && num < 100 || 999 < num && num < 10000 || num == 100000)
        ++ans;

    return ans;
  }
};",4,223,0.0,2.0,2.0,2.0,55.75,5.0,4.2425
1131.0,"class Solution {
 public:
  bool isPossibleDivide(vector<int>& nums, int k) {
    map<int, int> count;

    for (const int num : nums)
      ++count[num];

    for (const auto& [start, _] : count) {
      const int value = count[start];
      if (value > 0)
        for (int i = start; i < start + k; ++i) {
          count[i] -= value;
          if (count[i] < 0)
            return false;
        }
    }

    return true;
  }
};",9,431,0.0,4.0,4.0,5.0,47.888888888888886,12.0,4.01
1132.0,"class Solution {
 public:
  int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
    // Greedily consider strings with `minSize`, so ignore `maxSize`.
    int ans = 0;
    int letters = 0;
    vector<int> count(26);
    unordered_map<string, int> substringCount;

    for (int l = 0, r = 0; r < s.length(); ++r) {
      if (++count[s[r] - 'a'] == 1)
        ++letters;
      while (letters > maxLetters || r - l + 1 > minSize)
        if (--count[s[l++] - 'a'] == 0)
          --letters;
      if (r - l + 1 == minSize)
        ans = max(ans, ++substringCount[s.substr(l, minSize)]);
    }

    return ans;
  }
};",11,626,1.0,5.0,3.0,5.0,56.90909090909091,12.0,3.238181818181819
1133.0,"class Solution {
 public:
  int maxCandies(vector<int>& status, vector<int>& candies,
                 vector<vector<int>>& keys, vector<vector<int>>& containedBoxes,
                 vector<int>& initialBoxes) {
    int ans = 0;
    queue<int> q;
    vector<bool> reachedClosedBoxes(status.size());

    auto pushBoxesIfPossible =
        [&status, &q, &reachedClosedBoxes](const vector<int>& boxes) {
      for (const int box : boxes)
        if (status[box])
          q.push(box);
        else
          reachedClosedBoxes[box] = true;
    };

    pushBoxesIfPossible(initialBoxes);

    while (!q.empty()) {
      const int currBox = q.front();
      q.pop();

      // Add candies
      ans += candies[currBox];

      // Push `reachedClosedBoxes` by `key` obtained this turn and change their
      // Statuses
      for (const int key : keys[currBox]) {
        if (!status[key] && reachedClosedBoxes[key])
          q.push(key);
        status[key] = 1;  // boxes[key] is now open
      }

      // Push boxes contained in `currBox`
      pushBoxesIfPossible(containedBoxes[currBox]);
    }

    return ans;
  }
};",15,1122,5.0,6.0,5.0,8.0,74.8,18.0,1.0079999999999991
1134.0,"class Solution {
 public:
  vector<int> replaceElements(vector<int>& arr) {
    int maxOfRight = -1;
    for (int i = arr.size() - 1; i >= 0; --i)
      maxOfRight = max(maxOfRight, exchange(arr[i], maxOfRight));
    return arr;
  }
};",6,235,0.0,1.0,2.0,1.0,39.16666666666666,5.0,5.795000000000001
1135.0,"class Solution {
 public:
  int findBestValue(vector<int>& arr, int target) {
    const int n = arr.size();
    const double err = 1e-9;

    int prefix = 0;

    sort(begin(arr), end(arr));

    for (int i = 0; i < n; ++i) {
      int ans = round((target - prefix - err) / (double)(n - i));
      if (ans <= arr[i])
        return ans;
      prefix += arr[i];
    }

    return arr.back();
  }
};",11,397,0.0,1.0,3.0,2.0,36.09090909090909,12.0,5.3118181818181816
1136.0,"class Solution {
 public:
  vector<int> pathsWithMaxScore(vector<string>& board) {
    constexpr int kMod = 1'000'000'007;
    const int n = board.size();
    const vector<pair<int, int>> dirs{{0, 1}, {1, 0}, {1, 1}};
    // dp[i][j] := max sum from (n - 1, n - 1) -> (i, j)
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));
    // count[i][j] := # of paths to get dp[i][j] from (n - 1, n - 1) -> (i, j)
    vector<vector<int>> count(n + 1, vector<int>(n + 1));

    dp[0][0] = 0;
    dp[n - 1][n - 1] = 0;
    count[n - 1][n - 1] = 1;

    for (int i = n - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j) {
        if (board[i][j] == 'S' || board[i][j] == 'X')
          continue;
        for (const auto& [dx, dy] : dirs) {
          const int x = i + dx;
          const int y = j + dy;
          if (dp[i][j] < dp[x][y]) {
            dp[i][j] = dp[x][y];
            count[i][j] = count[x][y];
          } else if (dp[i][j] == dp[x][y]) {
            count[i][j] += count[x][y];
            count[i][j] %= kMod;
          }
        }
        // If there's path(s) from 'S' to (i, j)
        // And the cell is not 'E'
        if (dp[i][j] != -1 && board[i][j] != 'E') {
          dp[i][j] += board[i][j] - '0';
          dp[i][j] %= kMod;
        }
      }

    return {dp[0][0], count[0][0]};
  }
};",23,1321,4.0,7.0,12.0,8.0,57.43478260869565,20.0,1.8508695652173923
1137.0,"class Solution {
 public:
  int deepestLeavesSum(TreeNode* root) {
    int ans = 0;
    queue<TreeNode*> q{{root}};

    while (!q.empty()) {
      ans = 0;
      for (int sz = q.size(); sz > 0; --sz) {
        TreeNode* node = q.front();
        q.pop();
        ans += node->val;
        if (node->left)
          q.push(node->left);
        if (node->right)
          q.push(node->right);
      }
    }

    return ans;
  }
};",12,429,0.0,4.0,6.0,4.0,35.75,4.0,5.782500000000001
1138.0,"class Solution {
 public:
  vector<int> sumZero(int n) {
    vector<int> ans(n);

    for (int i = 0; i < n; ++i)
      ans[i] = i * 2 - n + 1;

    return ans;
  }
};",6,167,0.0,1.0,2.0,1.0,27.83333333333333,5.0,6.815
1139.0,"class BSTIterator {
 public:
  BSTIterator(TreeNode* root) {
    pushLeftsUntilNull(root);
  }

  int peek() {
    return stack.top()->val;
  }

  void next() {
    TreeNode* node = stack.top();
    stack.pop();
    pushLeftsUntilNull(node->right);
  }

  bool hasNext() {
    return !stack.empty();
  }

 private:
  stack<TreeNode*> stack;

  void pushLeftsUntilNull(TreeNode* node) {
    while (node) {
      stack.push(node);
      node = node->left;
    }
  }
};

class Solution {
 public:
  vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
    vector<int> ans;
    BSTIterator bstIterator1(root1);
    BSTIterator bstIterator2(root2);

    while (bstIterator1.hasNext() && bstIterator2.hasNext())
      if (bstIterator1.peek() < bstIterator2.peek()) {
        ans.push_back(bstIterator1.peek());
        bstIterator1.next();
      } else {
        ans.push_back(bstIterator2.peek());
        bstIterator2.next();
      }

    while (bstIterator1.hasNext()) {
      ans.push_back(bstIterator1.peek());
      bstIterator1.next();
    }

    while (bstIterator2.hasNext()) {
      ans.push_back(bstIterator2.peek());
      bstIterator2.next();
    }

    return ans;
  }
};",23,1189,0.0,4.0,13.0,5.0,51.69565217391305,8.0,3.5273913043478258
1140.0,"class Solution {
 public:
  bool canReach(vector<int>& arr, int start) {
    const int n = arr.size();
    queue<int> q{{start}};
    vector<bool> seen(n);

    while (!q.empty()) {
      const int node = q.front();
      q.pop();

      if (arr[node] == 0)
        return true;
      if (seen[node])
        continue;

      // Check available next steps
      if (node - arr[node] >= 0)
        q.push(node - arr[node]);
      if (node + arr[node] < n)
        q.push(node + arr[node]);

      seen[node] = true;
    }

    return false;
  }
};",12,546,1.0,3.0,5.0,5.0,45.5,10.0,4.465000000000001
1141.0,"class Solution {
 public:
  bool isSolvable(vector<string>& words, string result) {
    usedDigit = vector<bool>(10);
    words.push_back(result);
    rows = words.size();
    for (const string& word : words)
      cols = max(cols, static_cast<int>(word.length()));
    return dfs(words, 0, 0, 0);
  }

 private:
  unordered_map<char, int> letterToDigit;
  vector<bool> usedDigit;
  int rows;
  int cols;

  bool dfs(vector<string>& words, int row, int col, int sum) {
    if (col == cols)
      return sum == 0;
    if (row == rows)
      return sum % 10 == 0 && dfs(words, 0, col + 1, sum / 10);

    string word = words[row];
    if (col >= word.length())
      return dfs(words, row + 1, col, sum);

    char letter = word[word.length() - col - 1];
    int sign = row == rows - 1 ? -1 : 1;

    if (const auto it = letterToDigit.find(letter);
        it != cend(letterToDigit) &&
        (it->second > 0 || col < word.length() - 1))
      return dfs(words, row + 1, col, sum + sign * letterToDigit[letter]);

    for (int digit = 0; digit < 10; ++digit)
      if (!usedDigit[digit] && (digit > 0 || col + 1 < word.length())) {
        letterToDigit[letter] = digit;
        usedDigit[digit] = true;
        if (dfs(words, row + 1, col, sum + sign * digit))
          return true;
        usedDigit[digit] = false;
        letterToDigit.erase(letter);
      }

    return false;
  }
};",26,1388,0.0,2.0,4.0,8.0,53.38461538461539,23.0,2.535384615384614
1142.0,"class Solution {
 public:
  string freqAlphabets(string s) {
    string ans;

    for (int i = 0; i < s.length();) {
      if (i + 2 < s.length() && s[i + 2] == '#') {
        ans += stoi(s.substr(i, 2)) + 'a' - 1;
        i += 3;
      } else {
        ans += (s[i] - '0') + 'a' - 1;
        i += 1;
      }
    }

    return ans;
  }
};",9,338,0.0,3.0,5.0,2.0,37.55555555555556,5.0,5.640000000000001
1143.0,"class Solution {
 public:
  vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
    vector<int> ans;
    vector<int> xors(arr.size() + 1);

    for (int i = 0; i < arr.size(); ++i)
      xors[i + 1] ^= xors[i] ^ arr[i];

    for (const vector<int>& query : queries)
      ans.push_back(xors[query[0]] ^ xors[query[1] + 1]);

    return ans;
  }
};",8,368,0.0,2.0,2.0,2.0,46.0,9.0,4.72
1144.0,"class Solution {
 public:
  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos,
                                        vector<vector<int>>& friends, int id,
                                        int level) {
    vector<string> ans;
    vector<bool> visited(friends.size());
    visited[id] = true;
    queue<int> queue{{id}};
    unordered_map<string, int> count;
    set<pair<int, string>> freqAndVideo;

    for (int i = 0; i < level; ++i)
      for (int j = queue.size(); j > 0; --j) {
        for (int f : friends[queue.front()])
          if (visited[f] == false) {
            visited[f] = true;
            queue.push(f);
          }
        queue.pop();
      }

    for (int i = queue.size(); i > 0; --i) {
      for (const string& video : watchedVideos[queue.front()])
        ++count[video];
      queue.pop();
    }

    for (const auto& [video, freq] : count)
      freqAndVideo.insert({freq, video});

    for (const auto& [_, video] : freqAndVideo)
      ans.push_back(video);

    return ans;
  }
};",21,1043,0.0,8.0,8.0,8.0,49.66666666666666,21.0,2.469999999999999
1145.0,"class Solution {
 public:
  int minInsertions(string s) {
    return s.length() - longestPalindromeSubseq(s);
  }

 private:
  // Same as 516. Longest Palindromic Subsequence
  int longestPalindromeSubseq(const string& s) {
    const int n = s.length();
    // dp[i][j] := LPS's length in s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j])
          dp[i][j] = 2 + dp[i + 1][j - 1];
        else
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
      }

    return dp[0][n - 1];
  }
};",15,675,2.0,4.0,4.0,4.0,45.0,15.0,4.05
1146.0,"class Solution {
 public:
  vector<int> decompressRLElist(vector<int>& nums) {
    vector<int> ans;

    for (int i = 0; i < nums.size(); i += 2)
      ans.insert(end(ans), nums[i], nums[i + 1]);

    return ans;
  }
};",6,219,0.0,1.0,2.0,1.0,36.5,5.0,6.035
1147.0,"class Solution {
 public:
  vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
    const int m = mat.size();
    const int n = mat[0].size();
    vector<vector<int>> ans(m, vector<int>(n));
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        prefix[i + 1][j + 1] =
            mat[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        const int r1 = max(0, i - k) + 1;
        const int c1 = max(0, j - k) + 1;
        const int r2 = min(m - 1, i + k) + 1;
        const int c2 = min(n - 1, j + k) + 1;
        ans[i][j] = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] +
                    prefix[r1 - 1][c1 - 1];
      }

    return ans;
  }
};",20,841,0.0,4.0,3.0,4.0,42.05,24.0,3.3955
1148.0,"class Solution {
 public:
  int sumEvenGrandparent(TreeNode* root) {
    return dfs(root, 1, 1);  // Parent and grandparent are odd at first.
  }

 private:
  int dfs(TreeNode* root, int p, int gp) {
    if (root == nullptr)
      return 0;
    return (gp % 2 == 0 ? root->val : 0) +  //
           dfs(root->left, root->val, p) +  //
           dfs(root->right, root->val, p);
  }
};",4,384,3.0,-1.0,3.0,1.0,96.0,5.0,0.8599999999999994
1149.0,"class Solution {
 public:
  int distinctEchoSubstrings(string text) {
    unordered_set<string> seen;

    for (int k = 1; k <= text.length() / 2; ++k) {  // Target length
      int same = 0;
      for (int l = 0, r = k; r < text.length(); ++l, ++r) {
        if (text[l] == text[r])
          ++same;
        else
          same = 0;
        if (same == k) {
          seen.insert(text.substr(l - k + 1, k));
          // Move the window thus leaving a char behind,
          // So we need to decrease the counter
          --same;
        }
      }
    }

    return seen.size();
  }
};",12,588,3.0,5.0,5.0,4.0,49.0,8.0,4.3100000000000005
1150.0,"class Solution {
 public:
  vector<int> getNoZeroIntegers(int n) {
    for (int A = 1; A < n; ++A) {
      int B = n - A;
      if (to_string(A).find('0') == string::npos &&
          to_string(B).find('0') == string::npos)
        return {A, B};
    }

    throw;
  }
};",6,271,0.0,1.0,4.0,2.0,45.16666666666666,7.0,4.9350000000000005
1151.0,"class Solution {
 public:
  int minFlips(int a, int b, int c) {
    constexpr int kMaxBit = 30;
    int ans = 0;

    for (int i = 0; i < kMaxBit; ++i)
      if ((c >> i & 1) == 1)
        ans += (a >> i & 1) == 0 && (b >> i & 1) == 0;
      else  // (c >> i & 1) == 0
        ans += ((a >> i & 1) == 1) + ((b >> i & 1) == 1);

    return ans;
  }
};",8,350,1.0,3.0,2.0,2.0,43.75,8.0,5.0025
1152.0,"class Solution {
 public:
  int makeConnected(int n, vector<vector<int>>& connections) {
    // To connect n nodes, we need at least n - 1 edges
    if (connections.size() < n - 1)
      return -1;

    int numOfConnected = 0;
    vector<vector<int>> graph(n);
    unordered_set<int> seen;

    for (const vector<int>& conn : connections) {
      graph[conn[0]].push_back(conn[1]);
      graph[conn[1]].push_back(conn[0]);
    }

    for (int i = 0; i < n; ++i)
      if (seen.insert(i).second) {
        dfs(graph, i, seen);
        ++numOfConnected;
      }

    return numOfConnected - 1;
  }

 private:
  void dfs(const vector<vector<int>>& graph, int u, unordered_set<int>& seen) {
    for (const int v : graph[u])
      if (seen.insert(v).second)
        dfs(graph, v, seen);
  }
};",13,788,1.0,5.0,5.0,6.0,60.61538461538461,17.0,2.2846153846153854
1153.0,"class Solution {
 public:
  int minimumDistance(string word) {
    // dp[i][j][k] := min distance with left finger on i-th char and right
    // Finger on j-th char that already have written k first words
    dp.resize(27, vector<vector<int>>(27, vector<int>(word.length(), -1)));
    return minimumDistance(word, 26, 26, 0);
  }

 private:
  vector<vector<vector<int>>> dp;

  int minimumDistance(const string& word, int i, int j, int k) {
    if (k == word.length())
      return 0;
    if (dp[i][j][k] != -1)
      return dp[i][j][k];
    const int next = word[k] - 'A';
    const int moveLeft = dist(i, next) + minimumDistance(word, next, j, k + 1);
    const int moveRight = dist(j, next) + minimumDistance(word, i, next, k + 1);
    return dp[i][j][k] = min(moveLeft, moveRight);
  }

  int dist(int a, int b) {
    if (a == 26)  // First hovering state
      return 0;
    const int x1 = a / 6;
    const int y1 = a % 6;
    const int x2 = b / 6;
    const int y2 = b % 6;
    return abs(x1 - x2) + abs(y1 - y2);
  }
};",16,1026,3.0,-2.0,4.0,3.0,64.125,31.0,1.1287499999999984
1154.0,"class Solution {
 public:
  int maximum69Number(int num) {
    string ans = to_string(num);

    for (char& c : ans)
      if (c == '6') {
        c = '9';
        break;
      }

    return stoi(ans);
  }
};",5,208,0.0,1.0,3.0,2.0,41.6,5.0,5.516000000000001
1155.0,"class Solution {
 public:
  vector<string> printVertically(string s) {
    vector<string> ans;
    vector<string> words = split(s);
    size_t maxLength = 0;

    for (const string& word : words)
      maxLength = max(maxLength, word.length());

    for (size_t i = 0; i < maxLength; ++i) {
      string row;
      for (const string& word : words)
        row += i < word.length() ? word[i] : ' ';
      while (row.back() == ' ')
        row.pop_back();
      ans.push_back(row);
    }

    return ans;
  }

 private:
  vector<string> split(const string& s) {
    vector<string> words;
    istringstream iss(s);
    for (string token; iss >> token;)
      words.push_back(token);
    return words;
  }
};",18,704,0.0,4.0,4.0,5.0,39.11111111111112,15.0,4.5
1156.0,"class Solution {
 public:
  TreeNode* removeLeafNodes(TreeNode* root, int target) {
    if (root == nullptr)
      return nullptr;
    root->left = removeLeafNodes(root->left, target);
    root->right = removeLeafNodes(root->right, target);
    return isLeaf(root) && root->val == target ? nullptr : root;
  }

 private:
  bool isLeaf(TreeNode* root) {
    return root->left == nullptr && root->right == nullptr;
  }
};",6,419,0.0,-1.0,3.0,1.0,69.83333333333333,3.0,3.295000000000001
1157.0,"class Solution {
 public:
  int minTaps(int n, vector<int>& ranges) {
    vector<int> nums(n + 1);

    for (int i = 0; i <= n; ++i) {
      int l = max(0, i - ranges[i]);
      int r = min(n, i + ranges[i]);
      nums[l] = max(nums[l], r - l);
    }

    int ans = 0;
    int end = 0;
    int farthest = 0;

    for (int i = 0; i < n; i++) {
      farthest = max(farthest, i + nums[i]);
      if (i == end) {
        ++ans;
        end = farthest;
      }
    }

    return end == n ? ans : -1;
  }
};",16,503,0.0,3.0,5.0,3.0,31.4375,12.0,5.4906250000000005
1158.0,"class Solution {
 public:
  string breakPalindrome(string palindrome) {
    if (palindrome.length() == 1)
      return """";

    for (int i = 0; i < palindrome.length() / 2; ++i)
      if (palindrome[i] != 'a') {
        palindrome[i] = 'a';
        return palindrome;
      }

    palindrome.back() = 'b';
    return palindrome;
  }
};",8,335,0.0,1.0,3.0,3.0,41.875,4.0,5.5912500000000005
1159.0,"class Solution {
 public:
  vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();

    unordered_map<int, priority_queue<int>> count;

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        count[i - j].push(mat[i][j]);

    for (int i = m - 1; i >= 0; --i)
      for (int j = n - 1; j >= 0; --j)
        mat[i][j] = count[i - j].top(), count[i - j].pop();

    return mat;
  }
};",15,469,0.0,4.0,2.0,4.0,31.266666666666666,13.0,5.526
1160.0,"class Solution {
 public:
  int maxValueAfterReverse(vector<int>& nums) {
    int total = 0;
    int min = INT_MAX;
    int max = INT_MIN;

    for (int i = 0; i + 1 < nums.size(); ++i) {
      int a = nums[i];
      int b = nums[i + 1];
      total += abs(a - b);
      min = std::min(min, std::max(a, b));
      max = std::max(max, std::min(a, b));
    }
    int diff = std::max(0, (max - min) * 2);

    for (int i = 0; i + 1 < nums.size(); ++i) {
      int a = nums[i];
      int b = nums[i + 1];
      int headDiff = -abs(a - b) + abs(nums.front() - b);
      int tailDiff = -abs(a - b) + abs(nums.back() - a);
      diff = std::max({diff, headDiff, tailDiff});
    }

    return total + diff;
  }
};",20,705,0.0,2.0,5.0,10.0,35.25,15.0,4.907500000000001
1161.0,"class Solution {
 public:
  vector<int> arrayRankTransform(vector<int>& arr) {
    vector<int> sortedArr(arr);
    unordered_map<int, int> rank;

    sort(begin(sortedArr), end(sortedArr));

    for (const int a : sortedArr)
      if (!rank.count(a))
        rank[a] = rank.size() + 1;

    for (int& a : arr)
      a = rank[a];

    return arr;
  }
};",7,352,0.0,3.0,2.0,4.0,50.285714285714285,9.0,4.274285714285714
1162.0,"class Solution {
 public:
  vector<int> filterRestaurants(vector<vector<int>>& restaurants,
                                int veganFriendly, int maxPrice,
                                int maxDistance) {
    vector<int> ans;
    vector<vector<int>> filtered;

    for (vector<int>& restaurant : restaurants)
      if (restaurant[2] >= veganFriendly && restaurant[3] <= maxPrice &&
          restaurant[4] <= maxDistance)
        filtered.push_back(restaurant);

    sort(begin(filtered), end(filtered), [](const auto& a, const auto& b) {
      return a[1] == b[1] ? a[0] > b[0] : a[1] > b[1];
    });

    for (const vector<int>& f : filtered)
      ans.push_back(f[0]);

    return ans;
  }
};",8,698,0.0,2.0,3.0,3.0,87.25,13.0,0.5475000000000012
1163.0,"class Solution {
 public:
  int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
    int ans = -1;
    int minCitiesCount = n;
    const vector<vector<int>> dist = floydWarshall(n, edges, distanceThreshold);

    for (int i = 0; i < n; ++i) {
      int citiesCount = 0;
      for (int j = 0; j < n; ++j)
        if (dist[i][j] <= distanceThreshold)
          ++citiesCount;
      if (citiesCount <= minCitiesCount) {
        ans = i;
        minCitiesCount = citiesCount;
      }
    }

    return ans;
  }

 private:
  vector<vector<int>> floydWarshall(int n, const vector<vector<int>>& edges,
                                    int distanceThreshold) {
    vector<vector<int>> dist(n, vector<int>(n, distanceThreshold + 1));

    for (int i = 0; i < n; ++i)
      dist[i][i] = 0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      dist[u][v] = w;
      dist[v][u] = w;
    }

    for (int k = 0; k < n; ++k)
      for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

    return dist;
  }
};",30,1180,0.0,8.0,6.0,9.0,39.333333333333336,31.0,2.52
1164.0,"class Solution {
 public:
  int minDifficulty(vector<int>& jobDifficulty, int d) {
    const int n = jobDifficulty.size();
    if (n < d)
      return -1;

    // dp[i][k] := min difficulty to schedule the first i jobs in k days
    vector<vector<int>> dp(n + 1, vector<int>(d + 1, INT_MAX / 2));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i)
      for (int k = 1; k <= d; ++k) {
        int maxDifficulty = 0;                  // Max(job[j + 1..i])
        for (int j = i - 1; j >= k - 1; --j) {  // 1-based
          maxDifficulty = max(maxDifficulty, jobDifficulty[j]);  // 0-based
          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty);
        }
      }

    return dp[n][d];
  }
};",15,703,4.0,3.0,4.0,13.0,46.86666666666667,12.0,4.322
1165.0,"class Solution {
 public:
  vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
    vector<int> ans;
    vector<vector<int>> rowSum;

    for (int i = 0; i < mat.size(); ++i)
      rowSum.push_back({accumulate(begin(mat[i]), end(mat[i]), 0), i});

    sort(begin(rowSum), end(rowSum), [](const auto& a, const auto& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0];
    });

    for (int i = 0; i < k; ++i)
      ans.push_back(rowSum[i][1]);

    return ans;
  }
};",12,482,0.0,1.0,4.0,2.0,40.16666666666666,10.0,5.085
1166.0,"class Solution {
 public:
  int minSetSize(vector<int>& arr) {
    const int n = arr.size();
    int sum = 0;
    unordered_map<int, int> map;
    vector<pair<int, int>> count;

    for (const int a : arr)
      ++map[a];

    for (const auto& [a, freq] : map)
      count.push_back(make_pair(a, freq));

    sort(begin(count), end(count),
         [](const auto& a, const auto& b) { return a.second > b.second; });

    for (int i = 0; i < count.size(); ++i) {
      sum += count[i].second;
      if (sum >= n / 2)
        return i + 1;
    }

    throw;
  }
};",14,562,0.0,2.0,4.0,4.0,40.142857142857146,16.0,4.427142857142857
1167.0,"class Solution {
 public:
  int maxProduct(TreeNode* root) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    vector<int> allSums;
    const long totalSum = treeSum(root, allSums);

    for (const long sum : allSums)
      ans = max(ans, sum * (totalSum - sum));

    return ans % kMod;
  }

 private:
  int treeSum(TreeNode* root, vector<int>& allSums) {
    if (root == nullptr)
      return 0;

    const int leftSum = treeSum(root->left, allSums);
    const int rightSum = treeSum(root->right, allSums);
    const int sum = root->val + leftSum + rightSum;
    allSums.push_back(sum);
    return sum;
  }
};",13,623,0.0,0.0,3.0,2.0,47.92307692307692,14.0,4.106923076923077
1168.0,"class Solution {
 public:
  int maxJumps(vector<int>& arr, int d) {
    const int n = arr.size();
    // dp[i] := max jumps starting from arr[i]
    vector<int> dp(n, 1);
    // Decreasing stack stores indices
    stack<int> stack;

    for (int i = 0; i <= n; ++i) {
      while (!stack.empty() && (i == n || arr[stack.top()] < arr[i])) {
        vector<int> indices{stack.top()};
        stack.pop();
        while (!stack.empty() && arr[stack.top()] == arr[indices[0]])
          indices.push_back(stack.top()), stack.pop();
        for (const int j : indices) {
          if (i < n && i - j <= d)
            // Can jump from i to j
            dp[i] = max(dp[i], dp[j] + 1);
          if (!stack.empty() && j - stack.top() <= d)
            // Can jump from stack.top() to j
            dp[stack.top()] = max(dp[stack.top()], dp[j] + 1);
        }
      }
      stack.push(i);
    }

    return *max_element(begin(dp), end(dp));
  }
};",13,940,4.0,6.0,6.0,6.0,72.3076923076923,12.0,1.7323076923076923
1169.0,"class Solution {
 public:
  int numOfSubarrays(vector<int>& arr, int k, int threshold) {
    int ans = 0;
    int windowSum = 0;

    for (int i = 0; i < arr.size(); ++i) {
      windowSum += arr[i];
      if (i >= k)
        windowSum -= arr[i - k];
      if (i >= k - 1 && windowSum / k >= threshold)
        ++ans;
    }

    return ans;
  }
};",9,347,0.0,3.0,3.0,3.0,38.55555555555556,8.0,5.37
1170.0,"class Solution {
 public:
  double angleClock(int hour, int minutes) {
    const double hourHand = (hour % 12 + minutes / 60.0) * 30;
    const double minuteHand = minutes * 6;
    const double diff = abs(hourHand - minuteHand);
    return min(diff, 360 - diff);
  }
};",5,269,0.0,0.0,2.0,3.0,53.8,10.0,4.038
1171.0,"class Solution {
 public:
  int minJumps(vector<int>& arr) {
    const int n = arr.size();
    // {a: indices}
    unordered_map<int, vector<int>> graph;
    queue<int> q{{0}};
    vector<bool> seen(n);
    seen[0] = true;

    for (int i = 0; i < n; ++i)
      graph[arr[i]].push_back(i);

    for (int steps = 0; !q.empty(); ++steps) {
      for (int sz = q.size(); sz > 0; --sz) {
        const int i = q.front();
        q.pop();
        if (i == n - 1)
          return steps;
        seen[i] = true;
        const int u = arr[i];
        if (i + 1 < n)
          graph[u].push_back(i + 1);
        if (i - 1 >= 0)
          graph[u].push_back(i - 1);
        for (const int v : graph[u]) {
          if (seen[v])
            continue;
          q.push(v);
        }
        graph[u].clear();
      }
    }

    throw;
  }
};",24,830,1.0,6.0,8.0,8.0,34.583333333333336,18.0,4.2875
1172.0,"class Solution {
 public:
  int minSteps(string s, string t) {
    vector<int> count(26);

    for (const char c : s)
      ++count[c - 'a'];

    for (const char c : t)
      --count[c - 'a'];

    return accumulate(begin(count), end(count), 0,
                      [](int subtotal, int c) { return subtotal + abs(c); }) /
           2;
  }
};",6,345,0.0,1.0,3.0,2.0,57.5,11.0,3.4850000000000003
1173.0,"class Solution {
 public:
  int maxStudents(vector<vector<char>>& seats) {
    return accumulate(
               begin(seats), end(seats), 0,
               [&](int a, const auto& seat) {
      return a + count(begin(seat), end(seat), '.');
               }) -
        hungarian(seats);
  }

 private:
  const vector<pair<int, int>> dirs{{-1, -1}, {0, -1}, {1, -1},
                                    {-1, 1},  {0, 1},  {1, 1}};

  int hungarian(const vector<vector<char>>& seats) {
    const int m = seats.size();
    const int n = seats[0].size();
    int count = 0;
    vector<vector<int>> seen(m, vector<int>(n));
    vector<vector<int>> match(m, vector<int>(n, -1));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        if (seats[i][j] == '.' && match[i][j] == -1) {
          const int sessionId = i * n + j;
          seen[i][j] = sessionId;
          count += dfs(seats, i, j, sessionId, seen, match);
        }

    return count;
  }

  int dfs(const vector<vector<char>>& seats, int i, int j, int sessionId,
          vector<vector<int>>& seen, vector<vector<int>>& match) {
    const int m = seats.size();
    const int n = seats[0].size();

    for (const auto& [dx, dy] : dirs) {
      const int x = i + dx;
      const int y = j + dy;
      if (x < 0 || x == m || y < 0 || y == n)
        continue;
      if (seats[x][y] != '.' || seen[x][y] == sessionId)
        continue;
      seen[x][y] = sessionId;
      if (match[x][y] == -1 || dfs(seats, match[x][y] / n, match[x][y] % n,
                                   sessionId, seen, match)) {
        match[x][y] = i * n + j;
        match[i][j] = x * n + y;
        return 1;
      }
    }

    return 0;
  }
};",28,1698,0.0,1.0,15.0,7.0,60.642857142857146,41.0,-0.5178571428571441
1174.0,"class Solution {
 public:
  int countNegatives(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    int i = m - 1;
    int j = 0;

    while (i >= 0 && j < n) {
      if (grid[i][j] < 0) {
        ans += n - j;
        --i;
      } else {
        ++j;
      }
    }

    return ans;
  }
};",10,351,0.0,3.0,5.0,2.0,35.1,10.0,5.361000000000001
1175.0,"class Solution {
 public:
  int maxEvents(vector<vector<int>>& events) {
    int ans = 0;
    int d = 0;  // Current day
    int i = 0;  // events' index
    priority_queue<int, vector<int>, greater<>> minHeap;

    sort(begin(events), end(events));

    while (!minHeap.empty() || i < events.size()) {
      // If no events are available to attend today, let time flies to the next
      // available event.
      if (minHeap.empty())
        d = events[i][0];
      // All events starting from today are newly available.
      while (i < events.size() && events[i][0] == d)
        minHeap.push(events[i++][1]);
      // Greedily attend the event that'll end the earliest since it has higher
      // chance can't be attended in the future.
      minHeap.pop();
      ++ans;
      ++d;
      // Pop events that can't be attended.
      while (!minHeap.empty() && minHeap.top() < d)
        minHeap.pop();
    }

    return ans;
  }
};",13,936,8.0,4.0,3.0,5.0,72.0,8.0,2.620000000000001
1176.0,"class Solution {
 public:
  bool isPossible(vector<int>& target) {
    if (target.size() == 1)
      return target[0] == 1;

    long sum = accumulate(begin(target), end(target), 0L);
    priority_queue<int> maxHeap;

    for (const int num : target)
      maxHeap.push(num);

    while (maxHeap.top() > 1) {
      const long max = maxHeap.top();
      maxHeap.pop();
      const long restSum = sum - max;
      // Only occurs if n == 2.
      if (restSum == 1)
        return true;
      const long updated = max % restSum;
      // Updated == 0 (invalid) or didn't change.
      if (updated == 0 || updated == max)
        return false;
      maxHeap.push(updated);
      sum = sum - max + updated;
    }

    return true;
  }
};",14,731,2.0,3.0,3.0,6.0,52.21428571428572,9.0,4.120714285714286
1177.0,"class Solution {
 public:
  vector<int> sortByBits(vector<int>& arr) {
    sort(begin(arr), end(arr), [](const int a, int b) {
      const int x = bitset<32>(a).count();
      const int y = bitset<32>(b).count();
      return x == y ? a < b : x < y;
    });
    return arr;
  }
};",6,280,0.0,-1.0,3.0,0.0,46.66666666666666,10.0,4.680000000000001
1178.0,"class Solution {
 public:
  // Similar to 3. Longest Substring Without Repeating Characters
  int numberOfSubstrings(string s) {
    int ans = 0;
    vector<int> count(3);

    int l = 0;
    for (const char c : s) {
      ++count[c - 'a'];
      while (count[0] > 0 && count[1] > 0 && count[2] > 0)
        --count[s[l++] - 'a'];
      // s[0..r], s[1..r], ..., s[l - 1..r] are satified strings.
      ans += l;
    }

    return ans;
  }
};",8,442,2.0,2.0,3.0,3.0,55.25,8.0,4.0075
1179.0,"class Solution {
 public:
  int countOrders(int n) {
    constexpr int kMod = 1'000'000'007;
    long ans = 1;

    for (int i = 1; i <= n; ++i)
      ans = ans * i * (i * 2 - 1) % kMod;

    return ans;
  }
};",7,210,0.0,1.0,2.0,1.0,30.0,5.0,6.62
1180.0,"class Solution {
 public:
  bool validateBinaryTreeNodes(int n, vector<int>& leftChild,
                               vector<int>& rightChild) {
    vector<int> inDegree(n);
    int root = -1;

    // If inDegree of any node > 1, return false
    for (const int child : leftChild)
      if (child != -1 && ++inDegree[child] == 2)
        return false;

    for (const int child : rightChild)
      if (child != -1 && ++inDegree[child] == 2)
        return false;

    // Find the root (node with inDegree == 0)
    for (int i = 0; i < n; ++i)
      if (inDegree[i] == 0)
        if (root == -1)
          root = i;
        else
          return false;  // Multiple roots

    // didn't find the root
    if (root == -1)
      return false;

    return countNodes(root, leftChild, rightChild) == n;
  }

 private:
  int countNodes(int root, const vector<int>& leftChild,
                 const vector<int>& rightChild) {
    if (root == -1)
      return 0;
    return 1 +  //
           countNodes(leftChild[root], leftChild, rightChild) +
           countNodes(rightChild[root], leftChild, rightChild);
  }
};",13,1110,5.0,3.0,3.0,10.0,85.38461538461539,18.0,0.3553846153846152
1181.0,"class Solution {
 public:
  vector<int> closestDivisors(int num) {
    for (int root = sqrt(num + 2); root > 0; --root)
      for (int cand : {num + 1, num + 2})
        if (cand % root == 0)
          return {root, cand / root};

    throw;
  }
};",5,248,0.0,2.0,4.0,3.0,49.6,5.0,4.676
1182.0,"class Solution {
 public:
  string largestMultipleOfThree(vector<int>& digits) {
    string ans;
    vector<int> mod1{1, 4, 7, 2, 5, 8};
    vector<int> mod2{2, 5, 8, 1, 4, 7};
    vector<int> count(10);
    int sum = accumulate(begin(digits), end(digits), 0);

    for (const int digit : digits)
      ++count[digit];

    while (sum % 3 != 0)
      for (int i : sum % 3 == 1 ? mod1 : mod2)
        if (count[i]) {
          --count[i];
          sum -= i;
          break;
        }

    for (int digit = 9; digit >= 0; --digit)
      ans += string(count[digit], '0' + digit);

    return ans.size() && ans[0] == '0' ? ""0"" : ans;
  }
};",14,638,0.0,4.0,5.0,5.0,45.57142857142857,13.0,4.058571428571429
1183.0,"struct Team {
  char name;
  vector<int> rank;
  Team(char name, int teamSize) : name(name), rank(teamSize) {}
};

class Solution {
 public:
  string rankTeams(vector<string>& votes) {
    const int teamSize = votes[0].size();
    string ans;
    vector<Team> teams;

    for (int i = 0; i < 26; ++i)
      teams.push_back(Team('A' + i, teamSize));

    for (const string& vote : votes)
      for (int i = 0; i < teamSize; ++i)
        ++teams[vote[i] - 'A'].rank[i];

    sort(begin(teams), end(teams), [](const Team& a, const Team& b) {
      return a.rank == b.rank ? a.name < b.name : a.rank > b.rank;
    });

    for (int i = 0; i < teamSize; ++i)
      ans += teams[i].name;

    return ans;
  }
};",19,705,0.0,3.0,5.0,4.0,37.10526315789474,18.0,4.380526315789474
1184.0,"class Solution {
 public:
  bool isSubPath(ListNode* head, TreeNode* root) {
    if (root == nullptr)
      return false;
    return isContinuousSubPath(head, root) || isSubPath(head, root->left) ||
           isSubPath(head, root->right);
  }

 private:
  bool isContinuousSubPath(ListNode* head, TreeNode* root) {
    if (head == nullptr)
      return true;
    if (root == nullptr)
      return false;
    return head->val == root->val &&
           (isContinuousSubPath(head->next, root->left) ||
            isContinuousSubPath(head->next, root->right));
  }
};",6,566,0.0,-1.0,3.0,3.0,94.33333333333331,3.0,1.0900000000000016
1185.0,"class Solution {
 public:
  int minCost(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    dp.resize(m, vector<int>(n, -1));
    queue<pair<int, int>> q;

    dfs(grid, 0, 0, /*cost=*/0, q);

    for (int cost = 1; !q.empty(); ++cost)
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (const auto& [dx, dy] : dirs)
          dfs(grid, i + dx, j + dy, cost, q);
      }

    return dp.back().back();
  }

 private:
  const vector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
  vector<vector<int>> dp;

  void dfs(const vector<vector<int>>& grid, int i, int j, int cost,
           queue<pair<int, int>>& q) {
    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())
      return;
    if (dp[i][j] != -1)
      return;

    dp[i][j] = cost;
    q.emplace(i, j);
    const auto [dx, dy] = dirs[grid[i][j] - 1];
    dfs(grid, i + dx, j + dy, cost, q);
  }
};",22,986,1.0,3.0,9.0,5.0,44.81818181818182,27.0,2.586363636363637
1186.0,"class Solution {
 public:
  int findTheLongestSubstring(string s) {
    int ans = 0;
    int prefix = 0;  // Binary prefix
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < s.length(); ++i) {
      const int index = string(""aeiou"").find(s[i]);
      if (index != -1)
        prefix ^= 1 << index;
      if (!prefixToIndex.count(prefix))
        prefixToIndex[prefix] = i;
      ans = max(ans, i - prefixToIndex[prefix]);
    }

    return ans;
  }
};",11,477,1.0,3.0,5.0,3.0,43.36363636363637,11.0,4.557272727272728
1187.0,"struct T {
  int leftMax;
  int rightMax;
  int subtreeMax;
};

class Solution {
 public:
  int longestZigZag(TreeNode* root) {
    return dfs(root).subtreeMax;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return {-1, -1, -1};
    const T left = dfs(root->left);
    const T right = dfs(root->right);
    const int leftZigZag = left.rightMax + 1;
    const int rightZigZag = right.leftMax + 1;
    const int subtreeMax =
        max({leftZigZag, rightZigZag, left.subtreeMax, right.subtreeMax});
    return {leftZigZag, rightZigZag, subtreeMax};
  }
};",13,579,0.0,-1.0,7.0,1.0,44.53846153846154,14.0,4.231538461538461
1188.0,"struct T {
  bool isBST;
  int max;
  int min;
  int sum;
  T() : isBST(false) {}
  T(bool isBST, int max, int min, int sum)
      : isBST(isBST), max(max), min(min), sum(sum) {}
};

class Solution {
 public:
  int maxSumBST(TreeNode* root) {
    int ans = 0;
    traverse(root, ans);
    return ans;
  }

 private:
  T traverse(TreeNode* root, int& ans) {
    if (root == nullptr)
      return T(true, INT_MIN, INT_MAX, 0);

    const T left = traverse(root->left, ans);
    const T right = traverse(root->right, ans);

    if (!left.isBST || !right.isBST)
      return T();
    if (root->val <= left.max || root->val >= right.min)
      return T();

    // Root is a valid BST
    const int sum = root->val + left.sum + right.sum;
    ans = max(ans, sum);
    return T(true, max(root->val, right.max), min(root->val, left.min), sum);
  }
};",17,842,1.0,-1.0,6.0,3.0,49.52941176470589,17.0,3.5823529411764694
1189.0,"class Solution {
 public:
  int numTimesAllBlue(vector<int>& flips) {
    int ans = 0;
    int rightmost = 0;

    for (int i = 0; i < flips.size(); ++i) {
      rightmost = max(rightmost, flips[i]);
      // max(flips[0..i]) = rightmost = i + 1,
      // so flips[0..i] is a permutation of 1, 2, ..., i + 1.
      if (rightmost == i + 1)
        ++ans;
    }

    return ans;
  }
};",8,383,2.0,2.0,3.0,2.0,47.875,6.0,4.871250000000001
1190.0,"class Solution {
 public:
  int numOfMinutes(int n, int headID, vector<int>& manager,
                   vector<int>& informTime) {
    int ans = 0;

    for (int i = 0; i < n; ++i)
      ans = max(ans, dfs(i, headID, manager, informTime, {}));

    return ans;
  }

 private:
  int dfs(int i, int headID, const vector<int>& manager,
          const vector<int>& informTime, unordered_map<int, int>&& memo) {
    if (const auto it = memo.find(i); it != cend(memo))
      return it->second;
    if (i == headID)
      return 0;

    const int parent = manager[i];
    return memo[i] = informTime[parent] +
                     dfs(parent, headID, manager, informTime, move(memo));
  }
};",11,686,0.0,0.0,4.0,8.0,62.36363636363637,20.0,2.1472727272727266
1191.0,"class Solution {
 public:
  double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
    vector<vector<int>> tree(n + 1);
    queue<int> q{{1}};
    vector<bool> seen(n + 1);
    vector<double> prob(n + 1);

    seen[1] = true;
    prob[1] = 1.0;

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    while (!q.empty() && t-- > 0)
      for (int sz = q.size(); sz > 0; --sz) {
        const int a = q.front();
        q.pop();
        const int nChildren = count_if(begin(tree[a]), end(tree[a]),
                                       [&seen](int b) { return !seen[b]; });
        for (const int b : tree[a]) {
          if (seen[b])
            continue;
          seen[b] = true;
          prob[b] = prob[a] / nChildren;
          q.push(b);
        }
        if (nChildren > 0)
          prob[a] = 0.0;
      }

    return prob[target];
  }
};",23,981,0.0,4.0,8.0,7.0,42.65217391304348,24.0,3.0413043478260864
1192.0,"class Solution {
 public:
  TreeNode* balanceBST(TreeNode* root) {
    vector<int> nums;
    inorder(root, nums);
    return build(nums, 0, nums.size() - 1);
  }

 private:
  void inorder(TreeNode* root, vector<int>& nums) {
    if (root == nullptr)
      return;
    inorder(root->left, nums);
    nums.push_back(root->val);
    inorder(root->right, nums);
  }

  // Same as 108. Convert Sorted Array to Binary Search Tree
  TreeNode* build(const vector<int>& nums, int l, int r) {
    if (l > r)
      return nullptr;
    const int m = (l + r) / 2;
    return new TreeNode(nums[m], build(nums, l, m - 1), build(nums, m + 1, r));
  }
};",11,637,1.0,-1.0,4.0,2.0,57.90909090909091,10.0,3.6481818181818175
1193.0,"class Solution {
 public:
  // Similar to 857. Minimum Cost to Hire K Workers
  int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency,
                     int k) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    long speedSum = 0;
    // (efficiency[i], speed[i]) sorted by efficiency[i] in descending order.
    vector<pair<int, int>> A;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (int i = 0; i < n; ++i)
      A.emplace_back(efficiency[i], speed[i]);

    sort(begin(A), end(A), greater<>());

    for (const auto& [e, s] : A) {
      minHeap.push(s);
      speedSum += s;
      if (minHeap.size() > k)
        speedSum -= minHeap.top(), minHeap.pop();
      ans = max(ans, speedSum * e);
    }

    return ans % kMod;
  }
};",15,781,2.0,3.0,3.0,4.0,52.06666666666667,13.0,3.734000000000001
1194.0,"class Solution {
 public:
  int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {
    int ans = 0;
    unordered_map<int, int> rowToSeats;

    for (const vector<int>& reservedSeat : reservedSeats) {
      const int row = reservedSeat[0];
      const int seat = reservedSeat[1];
      rowToSeats[row] |= 1 << (seat - 1);
    }

    for (const auto& [_, seats] : rowToSeats)
      if ((seats & 0b0111111110) == 0)
        // Can fit 2 four-person groups.
        ans += 2;
      else if ((seats & 0b0111100000) == 0 ||  // Left not occupied.
               (seats & 0b0001111000) == 0 ||  // Mid not occupied.
               (seats & 0b0000011110) == 0)    // Right not occupied.
        // Can fit 1 four-person group.
        ans += 1;

    // Any empty rows can fit 2 four-person groups.
    return ans + (n - rowToSeats.size()) * 2;
  }
};",9,857,6.0,5.0,3.0,4.0,95.22222222222224,14.0,-0.2100000000000008
1195.0,"class Solution {
 public:
  int getKth(int lo, int hi, int k) {
    vector<pair<int, int>> powAndVals;  // (pow, val)

    for (int i = lo; i <= hi; ++i)
      powAndVals.emplace_back(getPow(i), i);

    nth_element(begin(powAndVals), begin(powAndVals) + k - 1, end(powAndVals));
    return powAndVals[k - 1].second;
  }

 private:
  int getPow(int n) {
    if (n == 1)
      return 0;
    return 1 + (n % 2 == 0 ? getPow(n / 2) : getPow(n * 3 + 1));
  }
};",9,457,1.0,0.0,3.0,2.0,50.77777777777778,10.0,4.29
1196.0,"class Solution {
 public:
  int sumFourDivisors(vector<int>& nums) {
    int ans = 0;

    for (int num : nums) {
      int divisor = 0;
      for (int i = 2; i * i <= num; ++i)
        if (num % i == 0) {
          if (divisor == 0)
            divisor = i;
          else {
            divisor = 0;
            break;
          }
        }
      if (divisor > 0 && divisor * divisor < num)
        ans += 1 + num + divisor + num / divisor;
    }

    return ans;
  }
};",10,471,0.0,5.0,5.0,5.0,47.1,7.0,4.461
1197.0,"class Solution {
 public:
  bool hasValidPath(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // G := upscaled grid
    vector<vector<bool>> g(m * 3, vector<bool>(n * 3));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        switch (grid[i][j]) {
          case 1:
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            break;
          case 2:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 3:
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 4:
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            g[i * 3 + 2][j * 3 + 1] = true;
            break;
          case 5:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 0] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            break;
          case 6:
            g[i * 3 + 0][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 1] = true;
            g[i * 3 + 1][j * 3 + 2] = true;
            break;
        }

    return dfs(g, 1, 1);
  }

 private:
  bool dfs(vector<vector<bool>>& g, int i, int j) {
    if (i < 0 || i == g.size() || j < 0 || j == g[0].size())
      return false;
    if (!g[i][j])  // No path here
      return false;
    if (i == g.size() - 2 && j == g[0].size() - 2)
      return true;

    g[i][j] = false;  // Mark as visited
    return dfs(g, i + 1, j) || dfs(g, i - 1, j) || dfs(g, i, j + 1) ||
           dfs(g, i, j - 1);
  }
};",38,1790,3.0,2.0,4.0,5.0,47.10526315789474,15.0,4.020526315789473
1198.0,"class Solution {
 public:
  string longestPrefix(string s) {
    constexpr int kBase = 26;
    constexpr int kMod = 1'000'000'007;
    const int n = s.length();
    int maxLength = 0;
    long pow = 1;
    long prefixHash = 0;  // Hash of s[0..i]
    long suffixHash = 0;  // Hash of s[j..n)

    for (int i = 0, j = n - 1; i < n - 1; ++i, --j) {
      prefixHash = (prefixHash * kBase + val(s[i])) % kMod;
      suffixHash = (val(s[j]) * pow + suffixHash) % kMod;
      pow = pow * kBase % kMod;
      if (prefixHash == suffixHash)
        maxLength = i + 1;
    }

    return s.substr(0, maxLength);
  }

 private:
  constexpr int val(char c) {
    return c - 'a';
  }
};",16,673,2.0,1.0,4.0,2.0,42.0625,11.0,4.894375
1199.0,"class Solution {
 public:
  int numTeams(vector<int>& rating) {
    int ans = 0;

    for (int i = 1; i < rating.size() - 1; ++i) {
      // Calculate soldiers on the left with less/greater ratings.
      int leftLess = 0;
      int leftGreater = 0;
      for (int j = 0; j < i; ++j)
        if (rating[j] < rating[i])
          ++leftLess;
        else if (rating[j] > rating[i])
          ++leftGreater;
      // Calculate soldiers on the right with less/greater ratings.
      int rightLess = 0;
      int rightGreater = 0;
      for (int j = i + 1; j < rating.size(); ++j)
        if (rating[j] < rating[i])
          ++rightLess;
        else if (rating[j] > rating[i])
          ++rightGreater;
      ans += leftLess * rightGreater + leftGreater * rightLess;
    }

    return ans;
  }
};",18,794,2.0,9.0,3.0,7.0,44.11111111111112,11.0,4.29
1200.0,"struct CheckIn {
  string stationName;
  int time;
};

struct CheckOut {
  int numTrips;
  int totalTime;
};

class UndergroundSystem {
 public:
  void checkIn(int id, string stationName, int t) {
    checkIns[id] = {stationName, t};
  }

  void checkOut(int id, string stationName, int t) {
    const auto [startStation, startTime] = checkIns[id];
    checkIns.erase(id);
    const string& route = startStation + ""->"" + stationName;
    ++checkOuts[route].numTrips;
    checkOuts[route].totalTime += t - startTime;
  }

  double getAverageTime(string startStation, string endStation) {
    const auto& [numTrips, totalTime] =
        checkOuts[startStation + ""->"" + endStation];
    return totalTime / (double)numTrips;
  }

 private:
  unordered_map<int, CheckIn> checkIns;       // {id: (stationName, time)}
  unordered_map<string, CheckOut> checkOuts;  // {route: (numTrips, totalTime)}
};",17,893,2.0,0.0,9.0,0.0,52.52941176470589,25.0,2.3123529411764707
1201.0,"class Solution {
 public:
  int findGoodStrings(int n, string s1, string s2, string evil) {
    // dp[i][j][k1][k2] := # of good strings for s[i:] and there're already j
    // Matches with `evil`, where k1 is the 0/1 tight constraint for s1 and k2
    // Is the 0/1 tight constraint for s2
    dp.resize(n,
              vector<vector<vector<int>>>(
                  evil.length(), vector<vector<int>>(2, vector<int>(2, -1))));
    // nextMatchedCount[i][j] := # next matched evil count given that there're
    // Already i matches with `evil` and the current char is ('a' + j)
    nextMatchedCount.resize(evil.length(), vector<int>(26, -1));
    return find(s1, s2, evil, 0, 0, true, true, getLPS(evil));
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<vector<vector<int>>>> dp;
  vector<vector<int>> nextMatchedCount;

  int find(const string& s1, const string& s2, const string& evil, int i,
           int matchedEvilCount, bool isS1Prefix, bool isS2Prefix,
           const vector<int>& evilLPS) {
    // s[:i] contains `evil`, so don't consider any ongoing strings
    if (matchedEvilCount == evil.length())
      return 0;
    // Run out of string, contributes one
    if (i == s1.length())
      return 1;
    int& ans = dp[i][matchedEvilCount][isS1Prefix][isS2Prefix];
    if (ans != -1)
      return ans;
    ans = 0;
    const char minChar = isS1Prefix ? s1[i] : 'a';
    const char maxChar = isS2Prefix ? s2[i] : 'z';
    for (char c = minChar; c <= maxChar; ++c) {
      const int nextMatchedEvilCount =
          getNextMatchedEvilCount(evil, matchedEvilCount, c, evilLPS);
      ans += find(s1, s2, evil, i + 1, nextMatchedEvilCount,
                  isS1Prefix && c == s1[i], isS2Prefix && c == s2[i], evilLPS);
      ans %= kMod;
    }
    return ans;
  }

  // Get Longest Prefix also Suffix
  vector<int> getLPS(const string& s) {
    vector<int> lps(s.length());
    for (int i = 1, j = 0; i < s.length(); ++i) {
      while (j > 0 && s[j] != s[i])
        j = lps[j - 1];
      if (s[i] == s[j])
        lps[i] = ++j;
    }
    return lps;
  }

  // J := the next index we're trying to match with `currChar`
  int getNextMatchedEvilCount(const string& evil, int j, char currChar,
                              const vector<int>& evilLPS) {
    int& ans = nextMatchedCount[j][currChar - 'a'];
    if (ans != -1)
      return ans;
    while (j > 0 && evil[j] != currChar)
      j = evilLPS[j - 1];
    return ans = (evil[j] == currChar ? j + 1 : j);
  }
};",30,2506,9.0,5.0,7.0,12.0,83.53333333333333,49.0,-2.7780000000000005
1202.0,"class Solution {
 public:
  bool canConstruct(string s, int k) {
    // If the s.length() < k, we cannot construct k strings from s.
    if (s.length() < k)
      return false;

    bitset<26> odd;

    for (const char c : s)
      odd.flip(c - 'a');

    // If the # of characters that have odd counts is > k, the min # of
    // palindrome strings we can construct is > k.
    return odd.count() <= k;
  }
};",5,410,3.0,1.0,2.0,4.0,82.0,6.0,1.9600000000000009
1203.0,"class Solution {
 public:
  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,
                    int x2, int y2) {
    auto clamp = [&](int center, int mini, int maxi) {
      return max(mini, min(maxi, center));
    };

    // The closest point to the circle within the rectangle
    int closestX = clamp(x_center, x1, x2);
    int closestY = clamp(y_center, y1, y2);

    // The distance between the circle's center and this closest point
    int distanceX = x_center - closestX;
    int distanceY = y_center - closestY;

    // If the distance is less than the circle's radius, an intersection occurs
    return (distanceX * distanceX) + (distanceY * distanceY) <=
           (radius * radius);
  }
};",8,729,3.0,-1.0,3.0,1.0,91.125,16.0,0.1987500000000004
1204.0,"class Solution {
 public:
  int maxSatisfaction(vector<int>& satisfaction) {
    int ans = 0;
    int sumSatisfaction = 0;

    sort(begin(satisfaction), end(satisfaction), greater<>());

    for (const int s : satisfaction) {
      sumSatisfaction += s;
      if (sumSatisfaction <= 0)
        return ans;
      ans += sumSatisfaction;
    }

    return ans;
  }
};",8,366,0.0,1.0,3.0,2.0,45.75,7.0,4.942500000000001
1205.0,"class Solution {
 public:
  int numSteps(string s) {
    int ans = 0;

    // All trailing 0s can be popped by 1 step.
    while (s.back() == '0') {
      s.pop_back();
      ++ans;
    }

    if (s == ""1"")
      return ans;

    // s is now odd, so add 1 to s and cost 1 step.
    ++ans;

    // All 1s will become 0s and be popped by 1 step.
    // All 0s will become 1s and be popped by 2 step (add 1 then divide by 2).
    for (const char c : s)
      ans += c == '1' ? 1 : 2;

    return ans;
  }
};",8,504,4.0,2.0,3.0,3.0,63.0,6.0,3.5900000000000007
1206.0,"class Solution {
 public:
  string longestDiverseString(int a, int b, int c, char A = 'a', char B = 'b',
                              char C = 'c') {
    if (a < b)
      return longestDiverseString(b, a, c, B, A, C);
    if (b < c)
      return longestDiverseString(a, c, b, A, C, B);
    if (b == 0)
      return string(min(a, 2), A);

    const int useA = min(a, 2);
    const int useB = (a - useA >= b) ? 1 : 0;
    return string(useA, A) + string(useB, B) +
           longestDiverseString(a - useA, b - useB, c, A, B, C);
  }
};",7,535,0.0,0.0,2.0,3.0,76.42857142857143,15.0,1.501428571428573
1207.0,"class Solution {
 public:
  string stoneGameIII(vector<int>& stoneValue) {
    // dp[i] := max ""relative score"" Alice can make w/ stoneValue[i:]
    dp.resize(stoneValue.size(), INT_MIN);

    const int score = stoneGameIII(stoneValue, 0);
    return score > 0 ? ""Alice"" : score < 0 ? ""Bob"" : ""Tie"";
  }

 private:
  vector<int> dp;

  int stoneGameIII(const vector<int>& stoneValue, int i) {
    if (i == stoneValue.size())
      return 0;
    if (dp[i] > INT_MIN)
      return dp[i];

    int sum = 0;
    for (int j = i; j < i + 3 && j < stoneValue.size(); ++j) {
      sum += stoneValue[j];
      dp[i] = max(dp[i], sum - stoneGameIII(stoneValue, j + 1));
    }

    return dp[i];
  };
};",14,692,1.0,0.0,4.0,3.0,49.42857142857143,12.0,4.151428571428571
1208.0,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += lowbit(i);
    }
  }

  int get(int i) const {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= lowbit(i);
    }
    return sum;
  }

 private:
  vector<int> sums;

  static inline int lowbit(int i) {
    return i & -i;
  }
};

class Solution {
 public:
  vector<int> processQueries(vector<int>& queries, int m) {
    vector<int> ans;
    // Map [-m, m] to [0, 2 * m].
    FenwickTree tree(2 * m + 1);
    unordered_map<int, int> numToIndex;

    for (int num = 1; num <= m; ++num) {
      numToIndex[num] = num + m;
      tree.update(num + m, 1);
    }

    int nextEmptyIndex = m;  // Map 0 to m.

    for (const int query : queries) {
      const int index = numToIndex[query];
      ans.push_back(tree.get(index - 1));
      // Move `query` from `index` to `nextEmptyIndex`.
      tree.update(index, -1);
      tree.update(nextEmptyIndex, 1);
      numToIndex[query] = nextEmptyIndex--;
    }

    return ans;
  }
};",24,1108,3.0,2.0,11.0,4.0,46.16666666666666,25.0,2.6850000000000005
1209.0,"class Solution {
 public:
  string entityParser(string text) {
    const unordered_map<string, char> entityToChar{
        {""&quot;"", '""'}, {""&apos;"", '\''}, {""&amp;"", '&'},
        {""&gt;"", '>'},   {""&lt;"", '<'},    {""&frasl;"", '/'}};
    string ans;
    int j = 0;  // text[j..ampersandIndex - 1] is the pending substring.
    int ampersandIndex = -1;

    for (int i = 0; i < text.length(); ++i)
      if (text[i] == '&') {
        ampersandIndex = i;
      } else if (text[i] == ';' && ampersandIndex >= j) {
        const string sub = text.substr(ampersandIndex, i - ampersandIndex + 1);
        ans += text.substr(j, ampersandIndex - j);
        ans += getCharIfMatched(text, sub, entityToChar);
        j = i + 1;
      }

    return ans + text.substr(j);
  }

 private:
  string getCharIfMatched(const string& text, const string& sub,
                          const unordered_map<string, char>& entityToChar) {
    for (const auto& [entity, c] : entityToChar)
      if (entity == sub)
        return string(1, c);
    return sub;
  }
};",22,1045,1.0,4.0,12.0,7.0,47.5,22.0,2.6050000000000004
1210.0,"class Solution {
 public:
  int numOfWays(int n) {
    constexpr int kMod = 1'000'000'007;
    long color2 = 6;  // 121, 131, 212, 232, 313, 323
    long color3 = 6;  // 123, 132, 213, 231, 312, 321

    for (int i = 1; i < n; ++i) {
      const long nextColor2 = color2 * 3 + color3 * 2;
      const long nextColor3 = color2 * 2 + color3 * 2;
      color2 = nextColor2 % kMod;
      color3 = nextColor3 % kMod;
    }

    return (color2 + color3) % kMod;
  }
};",11,462,2.0,1.0,3.0,1.0,42.0,7.0,5.360000000000001
1211.0,"class Solution {
 public:
  int findMinFibonacciNumbers(int k) {
    if (k < 2)  // k == 0 || k == 1
      return k;

    int a = 1;  // F_1
    int b = 1;  // F_2

    while (b <= k) {
      //    a, b = F_{i + 1}, F_{i + 2}
      // -> a, b = F_{i + 2}, F_{i + 3}
      const int temp = a;
      a = b;
      b = a + temp;
    }

    return 1 + findMinFibonacciNumbers(k - a);
  }
};",8,385,5.0,1.0,7.0,2.0,48.125,7.0,4.688750000000001
1212.0,"class Solution {
 public:
  string getHappyString(int n, int k) {
    const unordered_map<char, string> nextLetters{
        {'a', ""bc""}, {'b', ""ac""}, {'c', ""ab""}};
    queue<string> q{{{""a"", ""b"", ""c""}}};

    while (q.front().length() != n) {
      const string u = q.front();
      q.pop();
      for (const char nextLetter : nextLetters.at(u.back()))
        q.push(u + nextLetter);
    }

    if (q.size() < k)
      return """";

    for (int i = 0; i < k - 1; ++i)
      q.pop();
    return q.front();
  }
};",11,512,0.0,3.0,10.0,4.0,46.54545454545455,13.0,3.7309090909090914
1213.0,"class Solution {
 public:
  int numberOfArrays(string s, int k) {
    // dp[i] := # of arrays to restore s[i..n) w/ k
    dp.resize(s.length(), -1);
    return numberOfArrays(s, 0, k);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<int> dp;

  int numberOfArrays(const string& s, int i, int k) {
    if (i == s.length())
      return 1;  // Empty string """"""""
    if (s[i] == '0')
      return 0;  // Leading zero
    if (dp[i] >= 0)
      return dp[i];

    int ans = 0;
    long num = 0;

    for (int j = i; j < s.length(); ++j) {
      num = num * 10 + (s[j] - '0');
      if (num > k)
        break;
      ans = (ans + numberOfArrays(s, j + 1, k)) % kMod;
    }

    return dp[i] = ans;
  }
};",16,719,3.0,0.0,4.0,5.0,44.9375,14.0,4.435625
1214.0,"class Solution {
 public:
  vector<vector<string>> displayTable(vector<vector<string>>& orders) {
    vector<vector<string>> ans{{""Table""}};
    unordered_map<string, int> tableNumberToRowIndex;
    unordered_map<string, int> foodItemToColIndex;

    // Create the first row and column of ans.
    for (const vector<string>& order : orders) {
      const string& tableNumber = order[1];
      const string& foodItem = order[2];
      // Init indices with 0.
      tableNumberToRowIndex[tableNumber] = 0;
      foodItemToColIndex[foodItem] = 0;
    }
    for (const auto& [tableNumber, _] : tableNumberToRowIndex)
      ans.push_back({tableNumber});
    for (const auto& [foodItem, _] : foodItemToColIndex)
      ans[0].push_back(foodItem);

    // Sort the first row and column, except ans[0][0].
    sort(begin(ans[0]) + 1, end(ans[0]));
    sort(begin(ans) + 1, end(ans),
         [](const vector<string>& a, const vector<string>& b) {
      return stoi(a[0]) < stoi(b[0]);
    });

    // Set indices after sorting.
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      tableNumberToRowIndex[ans[i + 1][0]] = i;
    for (int i = 0; i < foodItemToColIndex.size(); ++i)
      foodItemToColIndex[ans[0][i + 1]] = i;

    // Get all the counts of each food item in each table.
    vector<vector<int>> count;
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      count.push_back(vector<int>(foodItemToColIndex.size()));
    for (const vector<string>& order : orders) {
      const string& tableNumber = order[1];
      const string& foodItem = order[2];
      const int rowIndex = tableNumberToRowIndex[tableNumber];
      const int colIndex = foodItemToColIndex[foodItem];
      ++count[rowIndex][colIndex];
    }

    // Set the counts to ans.
    for (int i = 0; i < tableNumberToRowIndex.size(); ++i)
      for (int j = 0; j < foodItemToColIndex.size(); ++j)
        ans[i + 1].push_back(to_string(count[i][j]));

    return ans;
  }
};",34,1960,6.0,8.0,8.0,9.0,57.64705882352941,37.0,0.3917647058823519
1215.0,"class Solution {
 public:
  int minNumberOfFrogs(string croakOfFrogs) {
    const string kCroak = ""croak"";
    int ans = 0;
    int frogs = 0;
    vector<int> count(5);

    for (const char c : croakOfFrogs) {
      ++count[kCroak.find(c)];
      for (int i = 1; i < 5; ++i)
        if (count[i] > count[i - 1])
          return -1;
      if (c == 'c')
        ++frogs;
      else if (c == 'k')
        --frogs;
      ans = max(ans, frogs);
    }

    return frogs == 0 ? ans : -1;
  }
};",13,488,0.0,5.0,3.0,5.0,37.53846153846154,11.0,5.041538461538462
1216.0,"class Solution {
 public:
  int numOfArrays(int n, int m, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j][k] := # of ways to build an array of length i, where j is the
    // Max used num and k is the search_cost
    vector<vector<vector<int>>> dp(
        n + 1, vector<vector<int>>(m + 1, vector<int>(k + 1)));

    for (int j = 1; j <= m; ++j)
      dp[1][j][1] = 1;

    for (int i = 2; i <= n; ++i)                 // For each length
      for (int j = 1; j <= m; ++j)               // For each max value
        for (int cost = 1; cost <= k; ++cost) {  // For each cost
          // 1. appending any of [1, j] in i-th position
          //    doesn't change the max and cost
          dp[i][j][cost] = static_cast<long>(j) * dp[i - 1][j][cost] % kMod;
          // 2. appending j in i-th position
          //    make j the new max and cost 1
          for (int prevMax = 1; prevMax < j; ++prevMax) {
            dp[i][j][cost] += dp[i - 1][prevMax][cost - 1];
            dp[i][j][cost] %= kMod;
          }
        }

    int ans = 0;
    for (int j = 1; j <= m; ++j) {
      ans += dp[n][j][k];
      ans %= kMod;
    }
    return ans;
  }
};",23,1168,9.0,6.0,5.0,9.0,50.78260869565217,16.0,3.529565217391304
1217.0,"class Solution {
 public:
  int maxScore(vector<int>& cardPoints, int k) {
    const int n = cardPoints.size();
    const int sum = accumulate(begin(cardPoints), end(cardPoints), 0);
    int windowSum = accumulate(begin(cardPoints), begin(cardPoints) + n - k, 0);
    int ans = sum - windowSum;

    for (int i = 0; i < k; ++i) {
      windowSum -= cardPoints[i];
      windowSum += cardPoints[i + n - k];
      ans = max(ans, sum - windowSum);
    }

    return ans;
  }
};",11,474,0.0,1.0,3.0,1.0,43.09090909090909,11.0,4.781818181818182
1218.0,"class Solution {
 public:
  vector<int> findDiagonalOrder(vector<vector<int>>& nums) {
    vector<int> ans;
    unordered_map<int, vector<int>> keyToNums;  // Key = row + col
    int maxKey = 0;

    for (int i = 0; i < nums.size(); ++i)
      for (int j = 0; j < nums[i].size(); ++j) {
        const int key = i + j;
        keyToNums[key].push_back(nums[i][j]);
        maxKey = max(maxKey, key);
      }

    for (int i = 0; i <= maxKey; ++i)
      for (auto it = rbegin(keyToNums[i]); it != rend(keyToNums[i]); ++it)
        ans.push_back(*it);

    return ans;
  }
};",17,572,1.0,4.0,3.0,4.0,33.64705882352941,12.0,5.391764705882353
1219.0,"class Solution {
 public:
  int constrainedSubsetSum(vector<int>& nums, int k) {
    // dp[i] := max sum of non-empty subsequence in nums[0..i]
    vector<int> dp(nums.size());
    // Q stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0 in
    // Decreasing order
    deque<int> q;

    for (int i = 0; i < nums.size(); ++i) {
      if (q.empty())
        dp[i] = nums[i];
      else
        dp[i] = max(q.front(), 0) + nums[i];
      while (!q.empty() && q.back() < dp[i])
        q.pop_back();
      q.push_back(dp[i]);
      if (i >= k && dp[i - k] == q.front())
        q.pop_front();
    }

    return *max_element(begin(dp), end(dp));
  }
};",11,665,3.0,5.0,3.0,4.0,60.45454545454545,7.0,3.49909090909091
1220.0,"/**
 * // This is the BinaryMatrix's API interface.
 * // You should not implement it, or speculate about its implementation
 * class BinaryMatrix {
 *  public:
 *   int get(int row, int col);
 *   vector<int> dimensions();
 * };
 */

class Solution {
 public:
  int leftMostColumnWithOne(BinaryMatrix& binaryMatrix) {
    const vector<int> dimensions = binaryMatrix.dimensions();
    const int m = dimensions[0];
    const int n = dimensions[1];
    int ans = -1;
    int l = 0;
    int r = n - 1;

    while (l <= r) {
      const int mid = (l + r) / 2;
      if (existOne(binaryMatrix, m, mid)) {
        ans = mid;
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }

    return ans;
  }

 private:
  bool existOne(BinaryMatrix& binaryMatrix, int m, int col) {
    for (int i = 0; i < m; ++i)
      if (binaryMatrix.get(i, col) == 1)
        return true;
    return false;
  }
};",19,902,1.0,3.0,7.0,4.0,47.47368421052632,22.0,2.9673684210526323
1221.0,"class Solution {
 public:
  int maxDiff(int num) {
    const string s = to_string(num);
    int firstNot9 = s.find_first_not_of('9');
    int firstNot01 = s.find_first_not_of(""01"");
    if (firstNot9 == string::npos)
      firstNot9 = 0;
    if (firstNot01 == string::npos)
      firstNot01 = 0;

    string a = s;
    string b = s;
    replace(begin(a), end(a), s[firstNot9], '9');
    replace(begin(b), end(b), s[firstNot01], firstNot01 == 0 ? '1' : '0');
    return stoi(a) - stoi(b);
  }
};",11,494,0.0,2.0,2.0,3.0,44.90909090909091,11.0,4.618181818181819
1222.0,"class Solution {
 public:
  bool checkIfCanBreak(string s1, string s2) {
    vector<int> count1(26);
    vector<int> count2(26);

    for (const char c : s1)
      ++count1[c - 'a'];

    for (const char c : s2)
      ++count2[c - 'a'];

    return canBreak(count1, count2) || canBreak(count2, count1);
  }

 private:
  // Returns True if count1 can break count2.
  bool canBreak(const vector<int>& count1, const vector<int>& count2) {
    int diff = 0;
    for (int i = 0; i < 26; ++i) {
      diff += count2[i] - count1[i];
      // count2 is alphabetically greater than count1.
      if (diff < 0)
        return false;
    }
    return true;
  }
};",12,652,2.0,2.0,4.0,9.0,54.333333333333336,17.0,3.13
1223.0,"class Solution {
 public:
  int numberWays(vector<vector<int>>& hats) {
    constexpr int nHats = 40;
    const int nPeople = hats.size();
    hatToPeople.resize(nHats + 1);
    // dp[i][j] := # of ways to assign hats 1, 2, ..., i to people in mask j
    dp.resize(nHats + 1, vector<int>(1 << nPeople, -1));

    for (int i = 0; i < nPeople; ++i)
      for (const int hat : hats[i])
        hatToPeople[hat].push_back(i);

    return ways(hats, 0, 1);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<int>> hatToPeople;
  vector<vector<int>> dp;

  int ways(const vector<vector<int>>& hats, int assignment, int h) {
    // All people are assigned
    if (assignment == (1 << hats.size()) - 1)
      return 1;
    if (h > 40)
      return 0;
    if (dp[h][assignment] != -1)
      return dp[h][assignment];

    // don't wear hat h
    int ans = ways(hats, assignment, h + 1);

    for (const int p : hatToPeople[h]) {
      // Person p was assigned hat h before
      if (assignment & 1 << p)
        continue;

      // Assigned hat h to person p
      ans += ways(hats, assignment | 1 << p, h + 1);
      ans %= kMod;
    }

    return dp[h][assignment] = ans;
  }
};",20,1196,5.0,2.0,4.0,8.0,59.8,21.0,2.3580000000000005
1224.0,"class Solution {
 public:
  int longestSubarray(vector<int>& nums, int limit) {
    int ans = 1;
    deque<int> minQ;
    deque<int> maxQ;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      while (!minQ.empty() && minQ.back() > nums[r])
        minQ.pop_back();
      minQ.push_back(nums[r]);
      while (!maxQ.empty() && maxQ.back() < nums[r])
        maxQ.pop_back();
      maxQ.push_back(nums[r]);
      while (maxQ.front() - minQ.front() > limit) {
        if (minQ.front() == nums[l])
          minQ.pop_front();
        if (maxQ.front() == nums[l])
          maxQ.pop_front();
        ++l;
      }
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",15,674,0.0,6.0,4.0,6.0,44.93333333333333,8.0,4.556
1225.0,"struct T {
  int i;
  int j;
  int sum;  // nums1[i] + nums2[j]
  T(int i, int j, int sum) : i(i), j(j), sum(sum) {}
};

class Solution {
 public:
  int kthSmallest(vector<vector<int>>& mat, int k) {
    vector<int> row = mat[0];

    for (int i = 1; i < mat.size(); ++i)
      row = kSmallestPairSums(row, mat[i], k);

    return row.back();
  }

 private:
  // Similar to 373. Find K Pairs with Smallest Sums
  vector<int> kSmallestPairSums(vector<int>& nums1, vector<int>& nums2, int k) {
    vector<int> ans;
    auto compare = [&](const T& a, const T& b) { return a.sum > b.sum; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);

    for (int i = 0; i < k && i < nums1.size(); ++i)
      minHeap.emplace(i, 0, nums1[i] + nums2[0]);

    while (!minHeap.empty() && ans.size() < k) {
      const auto [i, j, _] = minHeap.top();
      minHeap.pop();
      ans.push_back(nums1[i] + nums2[j]);
      if (j + 1 < nums2.size())
        minHeap.emplace(i, j + 1, nums1[i] + nums2[j + 1]);
    }

    return ans;
  }
};",22,1038,2.0,2.0,7.0,4.0,47.18181818181818,22.0,3.093636363636364
1226.0,"class Solution {
 public:
  int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
    vector<vector<int>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      graph[v].push_back(u);
    }

    return dfs(graph, 0, vector<bool>(n), hasApple);
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, vector<bool>&& seen,
          const vector<bool>& hasApple) {
    seen[u] = true;
    int totalCost = 0;

    for (const int v : graph[u]) {
      if (seen[v])
        continue;
      const int cost = dfs(graph, v, move(seen), hasApple);
      if (cost > 0 || hasApple[v])
        totalCost += cost + 2;
    }

    return totalCost;
  }
};",13,762,0.0,2.0,5.0,4.0,58.61538461538461,25.0,1.804615384615385
1227.0,"class Solution {
 public:
  int ways(vector<string>& pizza, int k) {
    const int M = pizza.size();
    const int N = pizza[0].size();
    // dp[m][n][k] := # of ways to cut pizza[m:M][n:N] w/ k cuts
    dp.resize(M, vector<vector<int>>(N, vector<int>(k, -1)));
    prefix.resize(M + 1, vector<int>(N + 1));

    for (int i = 0; i < M; ++i)
      for (int j = 0; j < N; ++j)
        prefix[i + 1][j + 1] = (pizza[i][j] == 'A') + prefix[i][j + 1] +
                               prefix[i + 1][j] - prefix[i][j];

    return ways(0, 0, k - 1, M, N);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<vector<int>>> dp;
  vector<vector<int>> prefix;

  // HasApple of pizza[row1..row2)[col1..col2)
  bool hasApple(int row1, int row2, int col1, int col2) {
    return (prefix[row2][col2] - prefix[row1][col2] - prefix[row2][col1] +
            prefix[row1][col1]) > 0;
  };

  int ways(int m, int n, int k, const int M, const int N) {
    if (k == 0)
      return 1;
    if (dp[m][n][k] >= 0)
      return dp[m][n][k];

    dp[m][n][k] = 0;

    for (int i = m + 1; i < M; ++i)  // Cut horizontally
      if (hasApple(m, i, n, N) && hasApple(i, M, n, N))
        dp[m][n][k] = (dp[m][n][k] + ways(i, n, k - 1, M, N)) % kMod;

    for (int j = n + 1; j < N; ++j)  // Cut vertically
      if (hasApple(m, M, n, j) && hasApple(m, M, j, N))
        dp[m][n][k] = (dp[m][n][k] + ways(m, j, k - 1, M, N)) % kMod;

    return dp[m][n][k];
  }
};",26,1461,4.0,4.0,4.0,8.0,56.19230769230769,31.0,1.5226923076923082
1228.0,"class Solution {
 public:
  vector<string> simplifiedFractions(int n) {
    vector<string> ans;
    for (int denominator = 2; denominator <= n; ++denominator)
      for (int numerator = 1; numerator < denominator; ++numerator)
        if (__gcd(denominator, numerator) == 1)
          ans.push_back(to_string(numerator) + ""/"" + to_string(denominator));
    return ans;
  }
};",8,375,0.0,3.0,2.0,4.0,46.875,6.0,4.8812500000000005
1229.0,"class Solution {
 public:
  int goodNodes(TreeNode* root, int maxi = INT_MIN) {
    if (root == nullptr)
      return 0;

    const int newMax = max(maxi, root->val);
    return (root->val >= maxi) +            //
           goodNodes(root->left, newMax) +  //
           goodNodes(root->right, newMax);
  }
};",4,310,2.0,0.0,2.0,1.0,77.5,5.0,2.4850000000000003
1230.0,"class Solution {
 public:
  string largestNumber(vector<int>& cost, int target) {
    // dp[i] := max length that cost i can achieve
    vector<int> dp(target + 1, INT_MIN);
    dp[0] = 0;  // When cost = 0, the best is empty string """"

    for (int i = 1; i <= target; ++i)
      for (int d = 0; d < 9; ++d)
        if (i >= cost[d])
          dp[i] = max(dp[i], dp[i - cost[d]] + 1);

    if (dp[target] < 0)
      return ""0"";

    string ans;

    // Greedily build the ans string
    for (int d = 8; d >= 0; --d)
      while (target >= cost[d] && dp[target] == dp[target - cost[d]] + 1) {
        target -= cost[d];
        ans += '1' + d;
      }

    return ans;
  }
};",15,675,3.0,5.0,3.0,6.0,45.0,11.0,4.49
1231.0,"class Solution {
 public:
  int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
    const int n = startTime.size();
    int ans = 0;

    for (int i = 0; i < n; ++i)
      if (startTime[i] <= queryTime && queryTime <= endTime[i])
        ++ans;

    return ans;
  }
};",7,295,0.0,2.0,2.0,2.0,42.142857142857146,9.0,5.067142857142857
1232.0,"struct Point {
  double x;
  double y;
  Point(double x, double y) : x(x), y(y) {}
};

class Solution {
 public:
  int numPoints(vector<vector<int>>& darts, int r) {
    int ans = 1;
    vector<Point> points = convertToPoints(darts);

    for (int i = 0; i < points.size(); ++i)
      for (int j = i + 1; j < points.size(); ++j)
        for (const Point& c : getCircles(points[i], points[j], r)) {
          int count = 0;
          for (const Point& point : points)
            if (dist(c, point) - r <= kErr)
              ++count;
          ans = max(ans, count);
        }

    return ans;
  }

 private:
  static constexpr double kErr = 1e-6;

  vector<Point> convertToPoints(const vector<vector<int>>& darts) {
    vector<Point> points;
    for (const vector<int>& dart : darts)
      points.emplace_back(dart[0], dart[1]);
    return points;
  }

  vector<Point> getCircles(const Point& p, const Point& q, int r) {
    if (dist(p, q) - 2.0 * r > kErr)
      return {};
    const Point m{(p.x + q.x) / 2, (p.y + q.y) / 2};
    const double distCM = sqrt(pow(r, 2) - pow(dist(p, q) / 2, 2));
    const double alpha = atan2(p.y - q.y, q.x - p.x);
    return {Point{m.x - distCM * sin(alpha), m.y - distCM * cos(alpha)},
            Point{m.x + distCM * sin(alpha), m.y + distCM * cos(alpha)}};
  }

  double dist(const Point& p, const Point& q) {
    return sqrt(pow(p.x - q.x, 2) + pow(p.y - q.y, 2));
  }
};",24,1413,0.0,3.0,13.0,7.0,58.875,31.0,0.6412500000000012
1233.0,"class Solution {
 public:
  int pseudoPalindromicPaths(TreeNode* root) {
    int ans = 0;
    dfs(root, 0, ans);
    return ans;
  }

 private:
  void dfs(TreeNode* root, int path, int& ans) {
    if (root == nullptr)
      return;
    if (root->left == nullptr && root->right == nullptr) {
      path ^= 1 << root->val;
      if ((path & (path - 1)) == 0)
        ++ans;
      return;
    }

    dfs(root->left, path ^ 1 << root->val, ans);
    dfs(root->right, path ^ 1 << root->val, ans);
  }
};",10,498,0.0,1.0,4.0,3.0,49.8,6.0,4.618000000000001
1234.0,"class Solution {
 public:
  int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
    const int m = nums1.size();
    const int n = nums2.size();
    // dp[i][j] := max dot product of two subseqs nums[0..i) and nums2[0..j)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MIN));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j)
        dp[i + 1][j + 1] = max({dp[i][j + 1], dp[i + 1][j],
                                max(0, dp[i][j]) + nums1[i] * nums2[j]});

    return dp[m][n];
  }
};",10,522,1.0,2.0,3.0,2.0,52.2,12.0,3.842
1235.0,"class Solution {
 public:
  bool hasAllCodes(string s, int k) {
    const int n = 1 << k;
    if (s.length() < n)
      return false;

    // used[i] := true if i is a substring of s.
    vector<bool> used(n);

    int window = k == 1 ? 0 : stoi(s.substr(0, k - 1), nullptr, 2);
    for (int i = k - 1; i < s.length(); ++i) {
      // Include s[i].
      window = (window << 1) + (s[i] - '0');
      // Discard s[i - k].
      window &= n - 1;
      used[window] = true;
    }

    return all_of(begin(used), end(used), [](bool u) { return u; });
  }
};",12,553,3.0,1.0,4.0,3.0,46.083333333333336,10.0,4.6725
1236.0,"class Solution {
 public:
  vector<bool> checkIfPrerequisite(int numCourses,
                                   vector<vector<int>>& prerequisites,
                                   vector<vector<int>>& queries) {
    vector<bool> ans;
    vector<vector<int>> graph(numCourses);
    // isPrerequisite[i][j] := true if course i is a prerequisite of course j.
    vector<vector<bool>> isPrerequisite(numCourses, vector<bool>(numCourses));

    for (const vector<int>& prerequisite : prerequisites) {
      const int u = prerequisite[0];
      const int v = prerequisite[1];
      graph[u].push_back(v);
    }

    // DFS from every course.
    for (int i = 0; i < numCourses; ++i)
      dfs(graph, i, isPrerequisite[i]);

    for (const vector<int>& query : queries) {
      const int u = query[0];
      const int v = query[1];
      ans.push_back(isPrerequisite[u][v]);
    }

    return ans;
  }

  void dfs(const vector<vector<int>>& graph, int u, vector<bool>& used) {
    for (const int v : graph[u]) {
      if (used[v])
        continue;
      used[v] = true;
      dfs(graph, v, used);
    }
  }
};",17,1106,2.0,5.0,6.0,7.0,65.05882352941177,29.0,0.6647058823529406
1237.0,"class Solution {
 public:
  int cherryPickup(vector<vector<int>>& grid) {
    this->m = grid.size();
    this->n = grid[0].size();
    // dp[x][y1][y2] := max cherries we can collect w/
    // Robot #1 on (x, y1) and Robot #2 on (x, y2) first
    dp.resize(m, vector<vector<int>>(n, vector<int>(n, -1)));
    return cherryPick(grid, 0, 0, n - 1);
  }

 private:
  int m;
  int n;
  vector<vector<vector<int>>> dp;

  int cherryPick(const vector<vector<int>>& grid, int x, int y1, int y2) {
    if (x == m)
      return 0;
    if (y1 < 0 || y1 == n || y2 < 0 || y2 == n)
      return 0;
    if (dp[x][y1][y2] != -1)
      return dp[x][y1][y2];

    const int currRow = grid[x][y1] + (y1 != y2) * grid[x][y2];

    for (int d1 = -1; d1 <= 1; ++d1)
      for (int d2 = -1; d2 <= 1; ++d2)
        dp[x][y1][y2] = max(
            dp[x][y1][y2], currRow + cherryPick(grid, x + 1, y1 + d1, y2 + d2));

    return dp[x][y1][y2];
  }
};",18,928,2.0,1.0,3.0,5.0,51.55555555555556,18.0,3.400000000000001
1238.0,"class Solution {
 public:
  int minReorder(int n, vector<vector<int>>& connections) {
    vector<vector<int>> graph(n);

    for (const vector<int>& conn : connections) {
      graph[conn[0]].push_back(conn[1]);
      graph[conn[1]].push_back(-conn[0]);  // - := conn[0] -> conn[1]
    }

    return dfs(graph, 0, -1);
  }

 private:
  int dfs(const vector<vector<int>>& graph, int u, int parent) {
    int change = 0;

    for (const int v : graph[u]) {
      if (abs(v) == parent)
        continue;
      if (v > 0)
        ++change;
      change += dfs(graph, abs(v), u);
    }

    return change;
  }
};",10,607,1.0,2.0,5.0,4.0,60.7,15.0,2.657
1239.0,"enum class BoxCase { kEqualBalls, kEqualDistantBalls };

class Solution {
 public:
  double getProbability(vector<int>& balls) {
    const int n = accumulate(begin(balls), end(balls), 0) / 2;
    return cases(balls, 0, 0, 0, 0, 0, n, BoxCase::kEqualDistantBalls) /
           cases(balls, 0, 0, 0, 0, 0, n, BoxCase::kEqualBalls);
  }

 private:
  const vector<int> fact{1, 1, 2, 6, 24, 120, 720};

  // Assume we have two boxes A and B
  double cases(const vector<int>& balls, int i, int ballsCountA,
               int ballsCountB, int colorsCountA, int colorsCountB, int n,
               BoxCase boxCase) {
    if (ballsCountA > n || ballsCountB > n)
      return 0;
    if (i == balls.size())
      return boxCase == BoxCase::kEqualBalls ? 1 : colorsCountA == colorsCountB;

    double ans = 0;

    // Balls taken from A for `balls[i]`
    for (int ballsTakenA = 0; ballsTakenA <= balls[i]; ++ballsTakenA) {
      const int ballsTakenB = balls[i] - ballsTakenA;
      const int newcolorsCountA = colorsCountA + (ballsTakenA > 0);
      const int newcolorsCountB = colorsCountB + (ballsTakenB > 0);
      ans += cases(balls, i + 1, ballsCountA + ballsTakenA,
                   ballsCountB + ballsTakenB, newcolorsCountA, newcolorsCountB,
                   n, boxCase) /
             (fact[ballsTakenA] * fact[ballsTakenB]);
    }

    return ans;
  }
};",15,1359,2.0,1.0,6.0,4.0,90.6,25.0,-0.9939999999999998
1240.0,"class Solution {
 public:
  vector<int> getLonelyNodes(TreeNode* root) {
    vector<int> ans;

    dfs(root, false, ans);

    return ans;
  }

 private:
  void dfs(TreeNode* root, bool isLonely, vector<int>& ans) {
    if (root == nullptr)
      return;
    if (isLonely)
      ans.push_back(root->val);

    dfs(root->left, root->right == nullptr, ans);
    dfs(root->right, root->left == nullptr, ans);
  }
};",8,412,0.0,1.0,3.0,2.0,51.5,6.0,4.525000000000001
1241.0,"class Solution {
 public:
  vector<int> getStrongest(vector<int>& arr, int k) {
    sort(begin(arr), end(arr));

    const int n = arr.size();
    const int median = arr[(n - 1) / 2];
    vector<int> ans;

    for (int l = 0, r = n - 1; k > 0; --k)
      if (median - arr[l] > arr[r] - median)
        ans.push_back(arr[l++]);
      else
        ans.push_back(arr[r--]);

    return ans;
  }
};",10,394,0.0,3.0,2.0,2.0,39.4,10.0,5.154000000000001
1242.0,"class BrowserHistory {
 public:
  BrowserHistory(string homepage) {
    visit(homepage);
  }

  void visit(string url) {
    if (++index < urls.size())
      urls[index] = url;
    else
      urls.push_back(url);
    lastIndex = index;
  }

  string back(int steps) {
    index = max(0, index - steps);
    return urls[index];
  }

  string forward(int steps) {
    index = min(lastIndex, index + steps);
    return urls[index];
  }

 private:
  vector<string> urls;
  int index = -1;
  int lastIndex = -1;
};",12,509,0.0,1.0,5.0,2.0,42.41666666666666,11.0,4.722500000000001
1243.0,"class Solution {
 public:
  int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n,
              int target) {
    // dp[k][i][prevColor] := min cost to paint houses[i..m) to k neighborhoods
    // W/ houses[i - 1]'s color = prevColor
    dp.resize(target + 1, vector<vector<int>>(m, vector<int>(n + 1)));

    // Init: prevColor = 0 (virtual neighbor)
    const int c = minCost(houses, cost, m, n, target, 0, 0);
    return c == kMax ? -1 : c;
  }

 private:
  static constexpr int kMax = 1'000'001;
  vector<vector<vector<int>>> dp;

  int minCost(const vector<int>& houses, const vector<vector<int>>& cost,
              const int& m, const int& n, int k, int i, int prevColor) {
    if (i == m || k < 0)
      return k == 0 ? 0 : kMax;
    if (dp[k][i][prevColor] > 0)
      return dp[k][i][prevColor];
    if (houses[i] > 0)  // Painted last year
      return minCost(houses, cost, m, n, k - (prevColor != houses[i]), i + 1,
                     houses[i]);

    int ans = kMax;

    // Try to paint houses[i] with each color in 1..n
    for (int color = 1; color <= n; ++color)
      ans = min(ans, cost[i][color - 1] + minCost(houses, cost, m, n,
                                                  k - (prevColor != color),
                                                  i + 1, color));

    return dp[k][i][prevColor] = ans;
  }
};",14,1360,5.0,0.0,3.0,4.0,97.14285714285714,27.0,-1.4228571428571437
1244.0,"class Solution {
 public:
  int minSumOfLengths(vector<int>& arr, int target) {
    int ans = INT_MAX;
    int leftLength = INT_MAX;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < arr.size(); ++i) {
      prefix += arr[i];
      prefixToIndex[prefix] = i;
    }

    prefix = 0;

    for (int i = 0; i < arr.size(); ++i) {
      prefix += arr[i];
      if (const auto it = prefixToIndex.find(prefix - target);
          it != cend(prefixToIndex))
        leftLength = min(leftLength, i - it->second);
      if (leftLength < INT_MAX)
        if (const auto it = prefixToIndex.find(prefix + target);
            it != cend(prefixToIndex))
          ans = min(ans, leftLength + it->second - i);
    }

    return ans == INT_MAX ? -1 : ans;
  }
};",18,793,0.0,5.0,6.0,5.0,44.05555555555556,13.0,4.075
1245.0,"class Solution {
 public:
  int minDistance(vector<int>& houses, int k) {
    const int n = houses.size();
    // dp[i][j] := min distance to allocate i mailboxes in houses[j:]
    dp.resize(k + 1, vector<int>(n, INT_MAX));
    // cost[i][j] := minCost to allocate mailbox between houses[i] and houses[j]
    cost.resize(n, vector<int>(n));

    sort(begin(houses), end(houses));

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j) {
        const int median = houses[(i + j) / 2];
        for (int x = i; x <= j; ++x)
          cost[i][j] += abs(houses[x] - median);
      }

    return minDistance(houses, k, 0);
  }

 private:
  static constexpr int kMax = 1'000'000;
  vector<vector<int>> dp;
  vector<vector<int>> cost;

  int minDistance(const vector<int>& houses, int k, int i) {
    if (k == 0 && i == houses.size())
      return 0;
    if (k == 0 || i == houses.size())
      return kMax;
    if (dp[k][i] != INT_MAX)
      return dp[k][i];

    for (int j = i; j < houses.size(); ++j)
      dp[k][i] = min(dp[k][i], cost[i][j] + minDistance(houses, k - 1, j + 1));

    return dp[k][i];
  }
};",24,1122,2.0,3.0,4.0,7.0,46.75,22.0,3.2525000000000004
1246.0,"class Solution {
 public:
  int findLeastNumOfUniqueInts(vector<int>& arr, int k) {
    unordered_map<int, int> count;
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (const int a : arr)
      ++count[a];

    for (const auto& [_, freq] : count)
      minHeap.push(freq);

    // Greedily remove k least frequent nums to have least # of unique integers.
    while (k > 0)
      k -= minHeap.top(), minHeap.pop();

    return minHeap.size() + (k < 0 ? 1 : 0);
  }
};",7,483,1.0,3.0,2.0,3.0,69.0,11.0,2.43
1247.0,"class Solution {
 public:
  int minDays(vector<int>& bloomDay, int m, int k) {
    if (bloomDay.size() < static_cast<long>(m) * k)
      return -1;

    int l = *min_element(begin(bloomDay), end(bloomDay));
    int r = *max_element(begin(bloomDay), end(bloomDay));

    while (l < r) {
      const int mid = (l + r) / 2;
      if (getBouquetCount(bloomDay, k, mid) >= m)
        r = mid;
      else
        l = mid + 1;
    }

    return l;
  }

 private:
  // Returns # of bouquet (k flowers needed) can be made after `waitingDays`.
  int getBouquetCount(const vector<int>& bloomDay, int k, int waitingDays) {
    int bouquetCount = 0;
    int requiredFlowers = k;
    for (const int day : bloomDay)
      if (day > waitingDays) {
        // Reset `requiredFlowers` since there was not enough adjacent flowers.
        requiredFlowers = k;
      } else if (--requiredFlowers == 0) {
        // Use k adjacent flowers to make a bouquet.
        ++bouquetCount;
        requiredFlowers = k;
      }
    return bouquetCount;
  }
};",14,1029,3.0,6.0,6.0,6.0,73.5,18.0,0.9850000000000012
1248.0,"class TreeAncestor {
 public:
  TreeAncestor(int n, vector<int>& parent)
      : maxLevel(32 - __builtin_clz(n)), dp(n, vector<int>(maxLevel)) {
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < maxLevel; ++j)
        if (j == 0)  // Node i's 2^0 ancestor is its direct parent
          dp[i][j] = parent[i];
        else if (dp[i][j - 1] == -1)  // No such ancestor
          dp[i][j] = -1;
        else  // A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1})
          dp[i][j] = dp[dp[i][j - 1]][j - 1];
  }

  int getKthAncestor(int node, int k) {
    for (int j = 0; j < maxLevel && node != -1; ++j)
      if (k & 1 << j)
        node = dp[node][j];
    return node;
  }

 private:
  const int maxLevel;
  vector<vector<int>> dp;  // dp[i][j] := node i's 2^j-th ancestor
};",14,776,4.0,8.0,5.0,6.0,55.42857142857143,13.0,3.0914285714285725
1249.0,"class Solution {
 public:
  NodeCopy* copyRandomBinaryTree(Node* root) {
    if (root == nullptr)
      return nullptr;
    if (const auto it = map.find(root); it != cend(map))
      return it->second;

    NodeCopy* newNode = new NodeCopy(root->val);
    map[root] = newNode;

    newNode->left = copyRandomBinaryTree(root->left);
    newNode->right = copyRandomBinaryTree(root->right);
    newNode->random = copyRandomBinaryTree(root->random);
    return newNode;
  }

 private:
  unordered_map<Node*, NodeCopy*> map;
};",11,522,0.0,0.0,2.0,2.0,47.45454545454545,2.0,5.409090909090909
1250.0,"class Solution {
 public:
  vector<string> getFolderNames(vector<string>& names) {
    vector<string> ans;
    unordered_map<string, int> nameToSuffix;

    for (const string& name : names)
      if (const auto it = nameToSuffix.find(name); it != cend(nameToSuffix)) {
        int suffix = it->second;
        string newName = getName(name, ++suffix);
        while (nameToSuffix.count(newName))
          newName = getName(name, ++suffix);
        nameToSuffix[name] = suffix;
        nameToSuffix[newName] = 0;
        ans.push_back(newName);
      } else {
        nameToSuffix[name] = 0;
        ans.push_back(name);
      }

    return ans;
  }

 private:
  string getName(const string& name, int suffix) {
    return name + ""("" + to_string(suffix) + "")"";
  }
};",14,767,0.0,3.0,5.0,3.0,54.785714285714285,15.0,3.089285714285716
1251.0,"class Solution {
 public:
  vector<int> avoidFlood(vector<int>& rains) {
    vector<int> ans(rains.size(), -1);
    unordered_map<int, int> lakeIdToFullDay;
    set<int> emptyDays;  // indices of rains[i] == 0

    for (int i = 0; i < rains.size(); ++i) {
      const int lakeId = rains[i];
      if (lakeId == 0) {
        emptyDays.insert(i);
        continue;
      }
      if (const auto itFullDay = lakeIdToFullDay.find(lakeId);
          itFullDay != cend(lakeIdToFullDay)) {
        // The lake was full in a previous day. Greedily find the closest day
        // to make the lake empty.
        const auto itEmptyDay = emptyDays.upper_bound(itFullDay->second);
        if (itEmptyDay == cend(emptyDays))  // Not found.
          return {};
        // Empty the lake at this day.
        ans[*itEmptyDay] = lakeId;
        emptyDays.erase(itEmptyDay);
      }
      // Lake with `lakeId` becomes full at day i.
      lakeIdToFullDay[lakeId] = i;
    }

    // Pick a arbitrary lake to empty if there are remaining empty days.
    for (const int emptyDay : emptyDays)
      ans[emptyDay] = 1;

    return ans;
  }
};",17,1122,7.0,4.0,6.0,6.0,66.0,14.0,2.34
1252.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<vector<int>> findCriticalAndPseudoCriticalEdges(
      int n, vector<vector<int>>& edges) {
    vector<int> criticalEdges;
    vector<int> pseudoCriticalEdges;

    // Record the index information, so edges[i] := (u, v, weight, index).
    for (int i = 0; i < edges.size(); ++i)
      edges[i].push_back(i);

    // Sort by weight.
    sort(
        begin(edges), end(edges),
        [](const vector<int>& a, const vector<int>& b) { return a[2] < b[2]; });

    const int mstWeight = getMSTWeight(n, edges, {}, -1);

    for (const vector<int>& edge : edges) {
      const int index = edge[3];
      // Deleting `e` makes the MST weight increase or can't form a MST.
      if (getMSTWeight(n, edges, {}, index) > mstWeight)
        criticalEdges.push_back(index);
      // If an edge can be in any MST, we can always add `edge` to the edge set.
      else if (getMSTWeight(n, edges, edge, -1) == mstWeight)
        pseudoCriticalEdges.push_back(index);
    }

    return {criticalEdges, pseudoCriticalEdges};
  }

 private:
  int getMSTWeight(int n, const vector<vector<int>>& edges,
                   const vector<int>& firstEdge, int deletedEdgeIndex) {
    int mstWeight = 0;
    UnionFind uf(n);

    if (!firstEdge.empty()) {
      uf.unionByRank(firstEdge[0], firstEdge[1]);
      mstWeight += firstEdge[2];
    }

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int weight = edge[2];
      const int index = edge[3];
      if (index == deletedEdgeIndex)
        continue;
      if (uf.find(u) == uf.find(v))
        continue;
      uf.unionByRank(u, v);
      mstWeight += weight;
    }

    const int root = uf.find(0);
    for (int i = 0; i < n; ++i)
      if (uf.find(i) != root)
        return INT_MAX;

    return mstWeight;
  }
};",42,2362,4.0,9.0,17.0,16.0,56.23809523809524,51.0,-1.5614285714285714
1253.0,"class Solution {
 public:
  Node* cloneTree(Node* root) {
    if (root == nullptr)
      return nullptr;
    if (const auto it = map.find(root); it != cend(map))
      return it->second;

    Node* newNode = new Node(root->val);
    map[root] = newNode;

    for (Node* child : root->children)
      newNode->children.push_back(cloneTree(child));

    return newNode;
  }

 private:
  unordered_map<Node*, Node*> map;
};",9,420,0.0,1.0,2.0,3.0,46.66666666666666,2.0,5.420000000000001
1254.0,"class Solution {
 public:
  int kthFactor(int n, int k) {
    // If i is a divisor of n, then n / i is also a divisor of n. So, we can
    // find all the divisors of n by processing the numbers <= sqrt(n).
    int factor = 1;
    int i = 0;  // i-th factor

    for (; factor * factor < n; ++factor)
      if (n % factor == 0 && ++i == k)
        return factor;

    for (factor = n / factor; factor >= 1; --factor)
      if (n % factor == 0 && ++i == k)
        return n / factor;

    return -1;
  }
};",10,505,3.0,2.0,2.0,5.0,50.5,6.0,4.735
1255.0,"class Solution {
 public:
  int longestSubarray(vector<int>& nums) {
    int ans = 0;
    int count0 = 0;

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      if (nums[r] == 0)
        ++count0;
      while (count0 == 2)
        if (nums[l++] == 0)
          --count0;
      ans = max(ans, r - l);
    }

    return ans;
  }
};",9,332,0.0,4.0,3.0,4.0,36.888888888888886,6.0,5.66
1256.0,"class Solution {
 public:
  int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {
    // dp[i] := min # of semesters to take all courses in mask i
    vector<int> dp(1 << n, n);
    // prereq[i] := bit mask of all dependencies of course i
    vector<int> prereq(n);

    for (const vector<int>& r : relations) {
      const int prevCourse = r[0] - 1;
      const int nextCourse = r[1] - 1;
      prereq[nextCourse] |= 1 << prevCourse;
    }

    dp[0] = 0;  // No need time to finish 0 course

    for (int i = 0; i < dp.size(); ++i) {
      // Bit mask of all the courses can be taken.
      int coursesCanBeTaken = 0;
      // Can take course j if i contains all j's prerequisites.
      for (int j = 0; j < n; ++j)
        if (i & prereq[j] == prereq[j])
          coursesCanBeTaken |= 1 << j;
      // Don't take any course which is already taken.
      // (i represents set of courses that are already taken)
      coursesCanBeTaken &= ~i;
      // Enumerate all bit subset of `coursesCanBeTaken`.
      for (int s = coursesCanBeTaken; s; s = (s - 1) & coursesCanBeTaken)
        if (__builtin_popcount(s) <= k)
          // Any combination of courses (if <= k) can be taken now.
          // i | s := combining courses taken with courses can be taken.
          dp[i | s] = min(dp[i | s], dp[i] + 1);
    }

    return dp.back();
  }
};",18,1361,10.0,8.0,4.0,8.0,75.61111111111111,17.0,1.1750000000000007
1257.0,"class Solution {
 public:
  bool isPathCrossing(string path) {
    set<int> seen;

    seen.insert(0);

    int x = 0;
    int y = 0;

    for (const char c : path) {
      switch (c) {
        case 'N':
          ++y;
          break;
        case 'S':
          --y;
          break;
        case 'E':
          ++x;
          break;
        case 'W':
          --x;
          break;
      }
      const int key = x * 20001 + y;
      if (seen.count(key))
        return true;
      seen.insert(key);
    }

    return false;
  }
};",17,534,0.0,2.0,4.0,2.0,31.41176470588235,10.0,5.812941176470589
1258.0,"class Solution {
 public:
  bool canArrange(vector<int>& arr, int k) {
    vector<int> bucket(k);

    for (const int a : arr) {
      int i = a % k;
      if (i < 0)
        i += k;
      ++bucket[i];
    }

    for (int i = 0; i < k; ++i)
      if (i == 0) {
        if (bucket[i] % 2 != 0)
          return false;
      } else if ((bucket[i] + bucket[k - i]) % 2 != 0) {
        return false;
      }

    return true;
  }
};",10,428,0.0,5.0,5.0,6.0,42.8,9.0,4.648000000000001
1259.0,"class Solution {
 public:
  int numSubseq(vector<int>& nums, int target) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    vector<int> pows(n, 1);  // pows[i] = 2^i % kMod

    for (int i = 1; i < n; ++i)
      pows[i] = pows[i - 1] * 2 % kMod;

    sort(begin(nums), end(nums));

    for (int l = 0, r = n - 1; l <= r;)
      if (nums[l] + nums[r] <= target) {
        ans += pows[r - l];
        ans %= kMod;
        ++l;
      } else {
        --r;
      }

    return ans;
  }
};",16,527,1.0,4.0,4.0,3.0,32.9375,11.0,5.495625
1260.0,"class Solution {
 public:
  int findMaxValueOfEquation(vector<vector<int>>& points, int k) {
    int ans = INT_MIN;
    priority_queue<pair<int, int>> maxHeap;  // (y - x, x)

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      while (!maxHeap.empty() && x - maxHeap.top().second > k)
        maxHeap.pop();
      if (!maxHeap.empty())
        ans = max(ans, x + y + maxHeap.top().first);
      maxHeap.emplace(y - x, x);
    }

    return ans;
  }
};",9,499,1.0,3.0,3.0,3.0,55.44444444444444,13.0,3.390000000000001
1261.0,"class Solution {
 public:
  bool canMakeArithmeticProgression(vector<int>& arr) {
    const int n = arr.size();
    const int max = *max_element(begin(arr), end(arr));
    const int min = *min_element(begin(arr), end(arr));
    const int range = max - min;
    if (range % (n - 1) != 0)
      return false;
    const int diff = range / (n - 1);
    if (diff == 0)
      return true;

    unordered_set<int> seen;

    for (const int a : arr) {
      if ((a - min) % diff != 0)
        return false;
      if (!seen.insert(a).second)
        return false;
    }

    return true;
  }
};",12,585,0.0,1.0,3.0,8.0,48.75,16.0,3.7725
1262.0,"class Solution {
 public:
  int getLastMoment(int n, vector<int>& left, vector<int>& right) {
    const int maxLeft = left.empty() ? 0 : *max_element(begin(left), end(left));
    const int minRight =
        right.empty() ? n : *min_element(begin(right), end(right));
    return max(maxLeft, n - minRight);
  }
};",4,313,0.0,0.0,2.0,0.0,78.25,9.0,1.9375
1263.0,"class Solution {
 public:
  int numSubmat(vector<vector<int>>& mat) {
    const int m = mat.size();
    const int n = mat[0].size();
    int ans = 0;

    for (int baseRow = 0; baseRow < m; ++baseRow) {
      vector<int> row(n, 1);
      for (int i = baseRow; i < m; ++i) {
        for (int j = 0; j < n; ++j)
          row[j] &= mat[i][j];
        ans += count(row);
      }
    }

    return ans;
  }

 private:
  int count(vector<int>& row) {
    int ans = 0;
    int length = 0;

    for (const int a : row) {
      length = a == 0 ? 0 : length + 1;
      ans += length;
    }

    return ans;
  }
};",19,604,0.0,3.0,6.0,4.0,31.789473684210527,18.0,4.798947368421053
1264.0,"class FenwickTree {
 public:
  FenwickTree(int n) : sums(n + 1) {}

  void update(int i, int delta) {
    while (i < sums.size()) {
      sums[i] += delta;
      i += i & -i;
    }
  }

  int get(int i) {
    int sum = 0;
    while (i > 0) {
      sum += sums[i];
      i -= i & -i;
    }
    return sum;
  }

 private:
  vector<int> sums;
};

class Solution {
 public:
  string minInteger(string num, int k) {
    const int n = num.length();
    string ans;
    FenwickTree tree(n);
    vector<bool> used(n);
    vector<queue<int>> numToIndices(10);

    for (int i = 0; i < n; ++i)
      numToIndices[num[i] - '0'].push(i);

    while (k > 0 && ans.length() < n)
      for (int d = 0; d < 10; ++d) {
        if (numToIndices[d].empty())
          continue;
        const int i = numToIndices[d].front();
        const int cost = i - tree.get(i);  // Note the offset 1 in FenwickTree
        if (cost > k)
          continue;
        k -= cost;
        ans += '0' + d;
        used[i] = true;
        tree.update(i + 1, 1);
        numToIndices[d].pop();
        break;  // Scan from 0 -> 9 again
      }

    for (int i = 0; i < n; ++i)
      if (!used[i])
        ans += num[i];

    return ans;
  }
};",33,1205,2.0,5.0,9.0,9.0,36.51515151515152,25.0,3.453636363636364
1265.0,"class Solution {
 public:
  int rangeSum(vector<int>& nums, int n, int left, int right) {
    constexpr int kMod = 1'000'000'007;

    auto subarraysAndSumNoGreaterThan = [&](int m) -> pair<int, long> {
      int count = 0;   // # of subarrays <= m
      long total = 0;  // Sum(subarrays)
      int sum = 0;     // Current sum (will be added to `total` in each loop)
      int window = 0;  // Window sum (can be extend and shrink)

      for (int i = 0, j = 0; j < n; ++j) {
        sum += nums[j] * (j - i + 1);
        window += nums[j];  // Extend each subarray ends w/ j
        while (window > m) {
          sum -= window;
          window -= nums[i++];  // Shrink the window
        }
        count += j - i + 1;
        total += sum;
      }

      return {count, total};
    };

    // [L, R] is the possible range of the sum of any subarray
    const int L = *min_element(begin(nums), end(nums));
    const int R = accumulate(begin(nums), end(nums), 0);

    auto firstKSubarraysSum = [&](int k) -> long {
      int l = L;
      int r = R;

      while (l < r) {
        const int m = l + (r - l) / 2;
        if (subarraysAndSumNoGreaterThan(m).first < k)
          l = m + 1;
        else
          r = m;
      }

      const auto& [count, total] = subarraysAndSumNoGreaterThan(l);
      // When count != k, there're subarray(s) have the same sum as l
      return total - l * (count - k);
    };

    return (firstKSubarraysSum(right) - firstKSubarraysSum(left - 1)) % kMod;
  }
};",27,1496,8.0,3.0,8.0,4.0,55.407407407407405,23.0,2.373333333333333
1266.0,"class Solution {
 public:
  int minDifference(vector<int>& nums) {
    const int n = nums.size();
    if (n < 5)
      return 0;

    int ans = INT_MAX;

    sort(begin(nums), end(nums));

    // Change nums[0..i) to nums[i] and
    // Change nums[n - 3 + i..n) to nums[n - 4 + i]
    for (int i = 0; i <= 3; ++i)
      ans = min(ans, nums[n - 4 + i] - nums[i]);

    return ans;
  }
};",9,386,2.0,1.0,2.0,3.0,42.888888888888886,7.0,5.340000000000001
1267.0,"class Solution {
 public:
  bool winnerSquareGame(int n) {
    // dp[i] := the winning result for n = i
    vector<bool> dp(n + 1);

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j * j <= i; ++j)
        if (!dp[i - j * j]) {  // Remove j^2 stones make the opponent lose
          dp[i] = true;        // So we win
          break;
        }

    return dp[n];
  }
};",9,376,3.0,3.0,3.0,4.0,41.77777777777778,6.0,5.400000000000001
1268.0,"class Solution {
 public:
  int numIdenticalPairs(vector<int>& nums) {
    int ans = 0;
    vector<int> count(101);

    for (const int num : nums)
      ans += count[num]++;

    return ans;
  }
};",5,198,0.0,1.0,2.0,1.0,39.6,7.0,5.556
1269.0,"class Solution {
 public:
  int numSub(string s) {
    constexpr int kMod = 1'000'000'007;

    int ans = 0;
    int l = -1;

    for (int i = 0; i < s.length(); ++i) {
      if (s[i] == '0')
        l = i;  // Handle reset value
      ans = (ans + i - l) % kMod;
    }

    return ans;
  }
};",9,293,1.0,2.0,3.0,2.0,32.55555555555556,7.0,6.109999999999999
1270.0,"class Solution {
 public:
  double maxProbability(int n, vector<vector<int>>& edges,
                        vector<double>& succProb, int start, int end) {
    vector<vector<pair<int, double>>> graph(n);  // {a: [(b, prob_ab)]}
    priority_queue<pair<double, int>> maxHeap;   // (prob to reach u, u)
    maxHeap.emplace(1.0, start);
    vector<bool> seen(n);

    for (int i = 0; i < edges.size(); ++i) {
      const int u = edges[i][0];
      const int v = edges[i][1];
      const double prob = succProb[i];
      graph[u].emplace_back(v, prob);
      graph[v].emplace_back(u, prob);
    }

    while (!maxHeap.empty()) {
      const auto [prob, u] = maxHeap.top();
      maxHeap.pop();
      if (u == end)
        return prob;
      if (seen[u])
        continue;
      seen[u] = true;
      for (const auto& [nextNode, edgeProb] : graph[u]) {
        if (seen[nextNode])
          continue;
        maxHeap.emplace(prob * edgeProb, nextNode);
      }
    }

    return 0;
  }
};",20,984,2.0,3.0,6.0,6.0,49.2,21.0,3.012
1271.0,"class Solution {
 public:
  double getMinDistSum(vector<vector<int>>& positions) {
    constexpr double kErr = 1e-6;
    double currX = 50;
    double currY = 50;
    double ans = distSum(positions, currX, currY);
    double step = 1;

    while (step > kErr) {
      bool shouldDecreaseStep = true;
      for (const auto& [dx, dy] : vector<pair<double, double>>{
               {0, step}, {0, -step}, {step, 0}, {-step, 0}}) {
        const double x = currX + dx;
        const double y = currY + dy;
        const double newDistSum = distSum(positions, x, y);
        if (newDistSum < ans) {
          ans = newDistSum;
          currX = x;
          currY = y;
          shouldDecreaseStep = false;
        }
      }
      if (shouldDecreaseStep)
        step /= 10;
    }

    return ans;
  }

 private:
  double distSum(const vector<vector<int>>& positions, double a, double b) {
    double sum = 0;
    for (const vector<int>& p : positions)
      sum += sqrt(pow(a - p[0], 2) + pow(b - p[1], 2));
    return sum;
  }
};",19,1026,0.0,4.0,11.0,5.0,54.0,26.0,1.6400000000000006
1272.0,"class Solution {
 public:
  Node* moveSubTree(Node* root, Node* p, Node* q) {
    if (find(begin(q->children), end(q->children), p) != end(q->children))
      return root;

    // Create a dummy Node for the case when root == p
    Node* dummy = new Node(0, {root});

    // Get each parent of p and q
    Node* pParent = getParent(dummy, p);
    Node* qParent = getParent(p, q);

    // Get p's original index in p's parent
    vector<Node*>& pSiblings = pParent->children;
    const int pIndex =
        find(begin(pSiblings), end(pSiblings), p) - begin(pSiblings);
    pSiblings.erase(begin(pSiblings) + pIndex);

    q->children.push_back(p);

    // If q is in the p's subtree, qParent != nullptr
    if (qParent != nullptr) {
      vector<Node*>& qSiblings = qParent->children;
      qSiblings.erase(remove(begin(qSiblings), end(qSiblings), q),
                      end(qSiblings));
      pSiblings.insert(begin(pSiblings) + pIndex, q);
    }

    return dummy->children[0];
  }

 private:
  Node* getParent(Node* root, Node* target) {
    for (Node* child : root->children) {
      if (child == target)
        return root;
      Node* res = getParent(child, target);
      if (res != nullptr)
        return res;
    }
    return nullptr;
  }
};",17,1254,4.0,3.0,6.0,7.0,73.76470588235294,3.0,2.681176470588236
1273.0,"class Solution {
 public:
  int numWaterBottles(int numBottles, int numExchange) {
    int ans = numBottles;

    while (numBottles >= numExchange) {
      ans += numBottles / numExchange;
      numBottles = numBottles / numExchange + numBottles % numExchange;
    }

    return ans;
  }
};",5,290,0.0,1.0,3.0,1.0,58.0,5.0,4.040000000000001
1274.0,"class Solution {
 public:
  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
    vector<int> ans(n);
    vector<vector<int>> tree(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      tree[u].push_back(v);
      tree[v].push_back(u);
    }

    dfs(tree, 0, -1, labels, ans);
    return ans;
  }

 private:
  vector<int> dfs(const vector<vector<int>>& tree, int u, int parent,
                  const string& labels, vector<int>& ans) {
    // count[i] := # of letters down from 'a' + i
    vector<int> count(26);

    for (const int v : tree[u]) {
      if (v == parent)
        continue;
      vector<int> childCount = dfs(tree, v, u, labels, ans);
      for (int i = 0; i < 26; ++i)
        count[i] += childCount[i];
    }

    ans[u] = ++count[labels[u] - 'a'];  // The u itself
    return count;
  }
};",17,896,2.0,2.0,5.0,4.0,52.70588235294117,26.0,2.316470588235294
1275.0,"class Solution {
 public:
  vector<string> maxNumOfSubstrings(string s) {
    const int n = s.length();
    vector<string> ans;
    vector<int> leftmost(26, n);    // Leftmost index of each letter
    vector<int> rightmost(26, -1);  // Rightmost index of each letter

    for (int i = 0; i < n; ++i) {
      leftmost[s[i] - 'a'] = min(leftmost[s[i] - 'a'], i);
      rightmost[s[i] - 'a'] = i;
    }

    auto getNewRight = [&](int i) {
      int right = rightmost[s[i] - 'a'];
      for (int j = i; j <= right; ++j) {
        if (leftmost[s[j] - 'a'] < i)  // Find a letter's first index < i
          return -1;
        right = max(right, rightmost[s[j] - 'a']);  // Right expands dynamically
      }
      return right;
    };

    int right = -1;  // Last substring's rightmost index
    for (int i = 0; i < n; ++i) {
      if (i == leftmost[s[i] - 'a']) {  // Current index is the first appearance
        const int newRight = getNewRight(i);
        if (newRight == -1)
          continue;  // Find a letter's first index < i
        if (i <= right && !ans.empty())
          ans.back() = s.substr(i, newRight - i + 1);
        else
          ans.push_back(s.substr(i, newRight - i + 1));
        right = newRight;
      }
    }

    return ans;
  }
};",25,1258,7.0,5.0,7.0,7.0,50.32,16.0,3.4312000000000005
1276.0,"class Solution {
 public:
  int closestToTarget(vector<int>& arr, int target) {
    int ans = INT_MAX;
    // S(j) := arr[i] & arr[i + 1] & ... & arr[j] for all 0 <= i <= j (fixed)
    unordered_set<int> s;

    for (const int a : arr) {
      unordered_set<int> s2{a};
      for (const int b : s)
        s2.insert(a & b);
      for (const int c : s = s2)
        ans = min(ans, abs(c - target));
    }

    return ans;
  }
};",7,427,1.0,4.0,4.0,4.0,61.0,13.0,2.77
1277.0,"class Solution {
 public:
  int countOdds(int low, int high) {
    return (high + 1) / 2 - low / 2;
  }
};",2,106,0.0,0.0,2.0,0.0,53.0,4.0,4.71
1278.0,"class Solution {
 public:
  int numOfSubarrays(vector<int>& arr) {
    constexpr int kMod = 1'000'000'007;
    const int n = arr.size();
    long ans = 0;
    // dp0[i] := # of subarrays ends with arr[i - 1] having even sum
    vector<int> dp0(n + 1);
    // dp1[i] := # of subarrays ends with arr[i - 1] having odd sum
    vector<int> dp1(n + 1);

    for (int i = 1; i <= n; ++i) {
      if (arr[i - 1] & 1) {
        dp0[i] = dp1[i - 1];
        dp1[i] = dp0[i - 1] + 1;
      } else {
        dp0[i] = dp0[i - 1] + 1;
        dp1[i] = dp1[i - 1];
      }
      ans = (ans + dp1[i]) % kMod;
    }

    return ans;
  }
};",14,623,2.0,3.0,5.0,2.0,44.5,9.0,4.695
1279.0,"class Solution {
 public:
  int numSplits(string s) {
    const int n = s.length();
    int ans = 0;
    vector<int> prefix(n);  // prefix[i] := of unique letters in s[0..i]
    vector<int> suffix(n);  // suffix[i] := of unique letters in s[i..n)
    unordered_set<int> seen;

    for (int i = 0; i < n; ++i) {
      seen.insert(s[i]);
      prefix[i] = seen.size();
    }

    seen.clear();

    for (int i = n - 1; i >= 0; --i) {
      seen.insert(s[i]);
      suffix[i] = seen.size();
    }

    for (int i = 0; i + 1 < n; ++i)
      if (prefix[i] == suffix[i + 1])
        ++ans;

    return ans;
  }
};",19,607,2.0,4.0,4.0,4.0,31.94736842105263,12.0,5.524736842105263
1280.0,"class Solution {
 public:
  int minNumberOperations(vector<int>& target) {
    int ans = target.front();

    for (int i = 1; i < target.size(); ++i)
      if (target[i] > target[i - 1])
        ans += target[i] - target[i - 1];

    return ans;
  }
};",6,252,0.0,2.0,2.0,2.0,42.0,5.0,5.48
1281.0,"class Solution {
 public:
  string restoreString(string s, vector<int>& indices) {
    string ans(s.length(), '.');

    for (int i = 0; i < indices.size(); ++i)
      ans[indices[i]] = s[i];

    return ans;
  }
};",6,215,0.0,1.0,2.0,1.0,35.833333333333336,6.0,5.995
1282.0,"class Solution {
 public:
  int minFlips(string target) {
    int ans = 0;
    int state = 0;

    for (const char c : target)
      if (c - '0' != state) {
        state = c - '0';
        ++ans;
      }

    return ans;
  }
};",6,228,0.0,2.0,3.0,2.0,38.0,7.0,5.58
1283.0,"class Solution {
 public:
  int countPairs(TreeNode* root, int distance) {
    int ans = 0;

    dfs(root, distance, ans);

    return ans;
  }

 private:
  vector<int> dfs(TreeNode* root, int distance, int& ans) {
    vector<int> d(distance + 1);  // {distance: # of leaf nodes}
    if (root == nullptr)
      return d;
    if (root->left == nullptr && root->right == nullptr) {
      d[0] = 1;
      return d;
    }

    const vector<int> dl = dfs(root->left, distance, ans);
    const vector<int> dr = dfs(root->right, distance, ans);

    for (int i = 0; i < distance; ++i)
      for (int j = 0; j < distance; ++j)
        if (i + j + 2 <= distance)
          ans += dl[i] * dr[j];

    for (int i = 0; i < distance; ++i)
      d[i + 1] = dl[i] + dr[i];

    return d;
  }
};",19,779,1.0,3.0,5.0,6.0,41.0,15.0,4.370000000000001
1284.0,"class Solution {
 public:
  int getLengthOfOptimalCompression(string s, int k) {
    // dp[i][k] := length of optimal compression of s[i:] w/ at most k deletion
    dp.resize(s.length(), vector<int>(k + 1, kMax));
    return compression(s, 0, k);
  }

 private:
  static constexpr int kMax = 101;
  vector<vector<int>> dp;

  int compression(const string& s, int i, int k) {
    if (k < 0)
      return kMax;
    if (i == s.length() || s.length() - i <= k)
      return 0;
    if (dp[i][k] != kMax)
      return dp[i][k];

    int maxFreq = 0;  // Max freq in s[i..j]
    vector<int> count(128);

    // Make chars in s[i..j] be same
    // Keep the char that has max freq in this range and remove other chars
    for (int j = i; j < s.length(); ++j) {
      maxFreq = max(maxFreq, ++count[s[j]]);
      dp[i][k] = min(  //
          dp[i][k],    //
          getLength(maxFreq) +
              compression(s, j + 1, k - (j - i + 1 - maxFreq)));
    }

    return dp[i][k];
  }

  int getLength(int maxFreq) {  // The length to compress `maxFreq`
    if (maxFreq == 1)
      return 1;  // C
    if (maxFreq < 10)
      return 2;  // [1-9]c
    if (maxFreq < 100)
      return 3;  // [1-9][0-9]c
    return 4;    // [1-9][0-9][0-9]c
  }
};",19,1238,11.0,-1.0,5.0,7.0,65.15789473684211,18.0,2.5357894736842104
1285.0,"class Solution {
 public:
  int getWinner(vector<int>& arr, int k) {
    int ans = arr[0];
    int wins = 0;

    for (int i = 1; i < arr.size() && wins < k; ++i)
      if (arr[i] > ans) {
        ans = arr[i];
        wins = 1;
      } else {
        ++wins;
      }

    return ans;
  }
};",9,291,0.0,3.0,4.0,2.0,32.333333333333336,7.0,5.97
1286.0,"class Solution {
 public:
  int minSwaps(vector<vector<int>>& grid) {
    const int n = grid.size();
    int ans = 0;
    // suffixZeros[i] := # of suffix zeros in i-th row
    vector<int> suffixZeros;

    for (const vector<int> row : grid) {
      const auto itLastOne = find(rbegin(row), rend(row), 1);
      const int suffixZeroCount = distance(rbegin(row), itLastOne);
      suffixZeros.push_back(suffixZeroCount);
    }

    for (int i = 0; i < n; ++i) {
      const int neededZeros = n - i - 1;
      // Get the first row w/ suffix zeros >= `neededZeros` in suffixZeros[i:].
      const auto it = find_if(begin(suffixZeros) + i, end(suffixZeros),
                              [&](int count) { return count >= neededZeros; });
      if (it == end(suffixZeros))
        return -1;
      const int j = distance(begin(suffixZeros), it);
      // Move rows[j] to rows[i].
      for (int k = j; k > i; --k)
        suffixZeros[k] = suffixZeros[k - 1];
      ans += j - i;
    }

    return ans;
  }
};",19,1003,3.0,2.0,5.0,5.0,52.78947368421053,20.0,2.948947368421053
1287.0,"class Solution {
 public:
  int maxSum(vector<int>& nums1, vector<int>& nums2) {
    constexpr int kMod = 1'000'000'007;

    // Keep running sum of nums1 and nums2 before next rendezvous
    // Because nums1 and nums2 are increasing, move forward on the smaller one
    // To ensure we don't miss any rendezvous
    // When meet rendezvous, choose the better path
    long ans = 0;
    long sum1 = 0;  // Sum of nums1 in (prev rendezvous, next rendezvous)
    long sum2 = 0;  // Sum of nums2 in (prev rendezvous, next rendezvous)
    int i = 0;      // nums1's index
    int j = 0;      // nums2's index

    while (i < nums1.size() && j < nums2.size())
      if (nums1[i] < nums2[j]) {
        sum1 += nums1[i++];
      } else if (nums1[i] > nums2[j]) {
        sum2 += nums2[j++];
      } else {  // Rendezvous
        ans += max(sum1, sum2) + nums1[i];
        sum1 = 0;
        sum2 = 0;
        ++i;
        ++j;
      }

    while (i < nums1.size())
      sum1 += nums1[i++];

    while (j < nums2.size())
      sum2 += nums2[j++];

    return (ans + max(sum1, sum2)) % kMod;
  }
};",17,1089,9.0,7.0,5.0,7.0,64.05882352941177,7.0,3.1747058823529413
1288.0,"class Solution {
 public:
  int findKthPositive(vector<int>& arr, int k) {
    int l = 0;
    int r = arr.size();

    // Find the first index l s.t. nMissing(l) = A[l] - l - 1 >= k
    while (l < r) {
      const int m = (l + r) / 2;
      if (arr[m] - m - 1 >= k)
        r = m;
      else
        l = m + 1;
    }

    // The k-th missing positive
    // = A[l - 1] + k - nMissing(l - 1)
    // = A[l - 1] + k - (A[l - 1] - (l - 1) - 1)
    // = A[l - 1] + k - (A[l - 1] - l)
    // = l + k
    return l + k;
  }
};",7,518,6.0,3.0,3.0,2.0,74.0,8.0,2.420000000000001
1289.0,"class Solution {
 public:
  bool canConvertString(string s, string t, int k) {
    if (s.length() != t.length())
      return false;

    // E.g. s = ""aab"", t = ""bbc"", so shiftCount[1] = 3
    // For a -> b, need 1 move
    //     a -> b, need 1 + 26 moves
    //     b -> c, need 1 + 26 * 2 moves
    vector<int> shiftCount(26);

    for (int i = 0; i < s.length(); ++i)
      ++shiftCount[(t[i] - s[i] + 26) % 26];

    for (int shift = 1; shift < 26; ++shift)
      if (shift + 26 * (shiftCount[shift] - 1) > k)
        return false;

    return true;
  }
};",10,561,4.0,2.0,2.0,14.0,56.1,8.0,4.071
1290.0,"class Solution {
 public:
  int minInsertions(string s) {
    int neededRight = 0;   // Increment by 2 for each '('.
    int missingLeft = 0;   // Increment by 1 for each missing '('.
    int missingRight = 0;  // Increment by 1 for each missing ')'.

    for (const char c : s)
      if (c == '(') {
        if (neededRight % 2 == 1) {
          // E.g. ""()(...""
          ++missingRight;
          --neededRight;
        }
        neededRight += 2;
      } else if (--neededRight < 0) {  // c == ')'
        // E.g. ""()))...""
        ++missingLeft;
        neededRight += 2;
      }

    return neededRight + missingLeft + missingRight;
  }
};",10,645,6.0,8.0,5.0,7.0,64.5,8.0,2.8550000000000004
1291.0,"class Solution {
 public:
  int longestAwesome(string s) {
    int ans = 0;
    int prefix = 0;  // Binary prefix
    vector<int> prefixToIndex(1024, s.length());
    prefixToIndex[0] = -1;

    for (int i = 0; i < s.length(); ++i) {
      prefix ^= 1 << s[i] - '0';
      ans = max(ans, i - prefixToIndex[prefix]);
      for (int j = 0; j < 10; ++j)
        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j]);
      prefixToIndex[prefix] = min(prefixToIndex[prefix], i);
    }

    return ans;
  }
};",14,501,1.0,2.0,3.0,2.0,35.785714285714285,8.0,5.719285714285714
1292.0,"class Solution {
 public:
  char findKthBit(int n, int k) {
    if (n == 1)
      return '0';
    const int midIndex = pow(2, n - 1);  // 1-indexed
    if (k == midIndex)
      return '1';
    if (k < midIndex)
      return findKthBit(n - 1, k);
    return findKthBit(n - 1, midIndex * 2 - k) == '0' ? '1' : '0';
  }
};",6,319,1.0,0.0,2.0,3.0,53.16666666666666,6.0,4.535
1293.0,"class Solution {
 public:
  int maxNonOverlapping(vector<int>& nums, int target) {
    // Ending the subarray ASAP always has a better result.
    int ans = 0;
    int prefix = 0;
    unordered_set<int> prefixes{0};

    // Greedily find the subarrays that equal to the target.
    for (const int num : nums) {
      // Check if there is a subarray ends here and equals to the target.
      prefix += num;
      if (prefixes.count(prefix - target)) {
        // Find one and discard all the prefixes that have been used.
        ++ans;
        prefix = 0;
        prefixes = {0};
      } else {
        prefixes.insert(prefix);
      }
    }

    return ans;
  }
};",10,665,4.0,4.0,7.0,3.0,66.5,9.0,2.615
1294.0,"class Solution {
 public:
  int minCost(int n, vector<int>& cuts) {
    cuts.push_back(0);
    cuts.push_back(n);
    sort(begin(cuts), end(cuts));

    // dp[i][j] := minCost(cuts[i..j])
    dp.resize(cuts.size(), vector<int>(cuts.size()));
    return minCost(cuts, 0, cuts.size() - 1);
  }

 private:
  vector<vector<int>> dp;

  int minCost(const vector<int>& cuts, int i, int j) {
    if (j - i <= 1)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    dp[i][j] = INT_MAX;

    for (int k = i + 1; k < j; ++k)
      dp[i][j] = min(dp[i][j], cuts[j] - cuts[i] + minCost(cuts, i, k) +
                                   minCost(cuts, k, j));

    return dp[i][j];
  }
};",14,686,1.0,0.0,3.0,3.0,49.0,12.0,4.25
1295.0,"class Solution {
 public:
  vector<int> mostSimilar(int n, vector<vector<int>>& roads,
                          vector<string>& names, vector<string>& targetPath) {
    this->names = names;
    this->targetPath = targetPath;
    // cost[i][j] := min cost to start from names[i] in path[j]
    this->cost.resize(names.size(), vector<int>(targetPath.size(), -1));
    // next[i][j] := best next of names[i] in path[j
    this->next.resize(names.size(), vector<int>(targetPath.size()));
    this->graph.resize(n);

    for (const vector<int>& road : roads) {
      graph[road[0]].push_back(road[1]);
      graph[road[1]].push_back(road[0]);
    }

    int minDist = INT_MAX;
    int start = 0;

    for (int i = 0; i < n; ++i) {
      const int dist = dfs(i, 0);
      if (dist < minDist) {
        minDist = dist;
        start = i;
      }
    }

    vector<int> ans;

    while (ans.size() < targetPath.size()) {
      ans.push_back(start);
      start = next[start][ans.size() - 1];
    }

    return ans;
  }

 private:
  vector<string> names;
  vector<string> targetPath;
  vector<vector<int>> cost;
  vector<vector<int>> next;
  vector<vector<int>> graph;

  int dfs(int nameIndex, int pathIndex) {
    if (cost[nameIndex][pathIndex] != -1)
      return cost[nameIndex][pathIndex];

    const int editDist = names[nameIndex] != targetPath[pathIndex];
    if (pathIndex == targetPath.size() - 1)
      return editDist;

    int minDist = INT_MAX;

    for (const int v : graph[nameIndex]) {
      const int dist = dfs(v, pathIndex + 1);
      if (dist < minDist) {
        minDist = dist;
        next[nameIndex][pathIndex] = v;
      }
    }

    return cost[nameIndex][pathIndex] = editDist + minDist;
  }
};",32,1714,2.0,5.0,9.0,8.0,53.5625,31.0,1.319374999999999
1296.0,"class Solution {
 public:
  int minOperations(int n) {
    //     median := median of arr
    //   diffs[i] := median - arr[i] where i <= i <= n / 2
    //        ans := sum(diffs)
    // E.g.
    // n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]
    //        ans = (4 + 2) * 2 / 2 = 6
    // n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]
    //        ans = (5 + 1) * 3 / 2 = 9
    const int halfSize = n / 2;
    const int median = (arr(n) + arr(1)) / 2;
    const int firstDiff = median - arr(1);
    const int lastDiff = median - arr(halfSize);
    return (firstDiff + lastDiff) * halfSize / 2;
  }

 private:
  // Return i-th element of arr, where 1 <= i <= n.
  int arr(int i) {
    return (i - 1) * 2 + 1;
  }
};",7,724,9.0,-1.0,3.0,8.0,103.42857142857144,13.0,-0.3685714285714283
1297.0,"class Solution {
 public:
  bool containsCycle(vector<vector<char>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    vector<vector<bool>> seen(m, vector<bool>(n));

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (seen[i][j])
          continue;
        if (dfs(grid, i, j, -1, -1, grid[i][j], seen))
          return true;
      }

    return false;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  bool dfs(const vector<vector<char>>& grid, int i, int j, int prevI, int prevJ,
           char c, vector<vector<bool>>& seen) {
    seen[i][j] = true;

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k];
      const int y = j + dirs[k + 1];
      if (x < 0 || x == grid.size() || y < 0 || y == grid[0].size())
        continue;
      if (x == prevI && y == prevJ)
        continue;
      if (grid[x][y] != c)
        continue;
      if (seen[x][y])
        return true;
      if (dfs(grid, x, y, i, j, c, seen))
        return true;
    }

    return false;
  }
};",23,1050,0.0,2.0,6.0,10.0,45.65217391304348,27.0,2.7113043478260863
1298.0,"class Solution {
 public:
  int stoneGameV(vector<int>& stoneValue) {
    const int n = stoneValue.size();
    // dp[i][j] := max score that Alice can obtain from stoneValue[i..j]
    dp.resize(n, vector<int>(n, INT_MIN));
    prefix.resize(n + 1);

    partial_sum(begin(stoneValue), end(stoneValue), begin(prefix) + 1);
    return stoneGameV(stoneValue, 0, n - 1);
  }

 private:
  vector<vector<int>> dp;
  vector<int> prefix;

  int stoneGameV(const vector<int>& stoneValue, int i, int j) {
    if (i == j)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    // Try all possible partitions
    for (int p = i; p < j; ++p) {
      // Sum of stoneValue[i..p]
      const int leftSum = prefix[p + 1] - prefix[i];
      const int throwRight = leftSum + stoneGameV(stoneValue, i, p);
      // Sum of stoneValue[p + 1..j]
      const int rightSum = prefix[j + 1] - prefix[p + 1];
      const int throwLeft = rightSum + stoneGameV(stoneValue, p + 1, j);
      if (leftSum < rightSum)  // Bob throws right row
        dp[i][j] = max(dp[i][j], throwRight);
      else if (leftSum > rightSum)  // Bob throws left row
        dp[i][j] = max(dp[i][j], throwLeft);
      else  // Alice decide which row to throw
        dp[i][j] = max({dp[i][j], throwLeft, throwRight});
    }

    return dp[i][j];
  }
};",20,1310,7.0,3.0,5.0,5.0,65.5,22.0,1.705
1299.0,"class Solution {
 public:
  int numOfWays(vector<int>& nums) {
    comb = generate(nums.size() + 1);
    return ways(nums) - 1;
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  // comb[n][k] := C(n, k)
  vector<vector<int>> comb;

  int ways(const vector<int>& nums) {
    if (nums.size() <= 2)
      return 1;

    vector<int> left;
    vector<int> right;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] < nums[0])
        left.push_back(nums[i]);
      else
        right.push_back(nums[i]);

    long ans = comb[nums.size() - 1][left.size()];
    ans = (ans * ways(left)) % kMod;
    ans = (ans * ways(right)) % kMod;
    return ans;
  }

  // 118. Pascal's Triangle
  vector<vector<int>> generate(int numRows) {
    vector<vector<int>> comb;

    for (int i = 0; i < numRows; ++i)
      comb.push_back(vector<int>(i + 1, 1));

    for (int i = 2; i < numRows; ++i)
      for (int j = 1; j < comb[i].size() - 1; ++j)
        comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % kMod;

    return comb;
  }
};",26,1037,2.0,4.0,4.0,6.0,39.88461538461539,18.0,4.210384615384615
1300.0,"class SparseVector {
 public:
  SparseVector(vector<int>& nums) {
    for (int i = 0; i < nums.size(); ++i)
      if (nums[i])
        indexToNum[i] = nums[i];
  }

  // Return the dotProduct of two sparse vectors
  int dotProduct(SparseVector& vec) {
    if (indexToNum.size() < vec.indexToNum.size())
      return vec.dotProduct(*this);

    int ans = 0;

    for (const auto& [index, num] : vec.indexToNum)
      if (const auto it = indexToNum.find(index); it != cend(indexToNum))
        ans += num * it->second;

    return ans;
  }

 private:
  unordered_map<int, int> indexToNum;  // {index: num}
};",10,606,2.0,4.0,4.0,5.0,60.6,9.0,3.246
1301.0,"class Solution {
 public:
  int unhappyFriends(int n, vector<vector<int>>& preferences,
                     vector<vector<int>>& pairs) {
    int ans = 0;
    vector<int> matches(n);
    vector<unordered_map<int, int>> prefer(n);

    for (const vector<int>& pair : pairs) {
      const int x = pair[0];
      const int y = pair[1];
      matches[x] = y;
      matches[y] = x;
    }

    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n - 1; ++j)
        prefer[i][preferences[i][j]] = j;

    for (int x = 0; x < n; ++x)
      for (const auto& [u, _] : prefer[x]) {
        const int y = matches[x];
        const int v = matches[u];
        if (prefer[x][u] < prefer[x][y] && prefer[u][x] < prefer[u][v]) {
          ++ans;
          break;
        }
      }

    return ans;
  }
};",20,792,0.0,5.0,5.0,6.0,39.6,23.0,3.536
1302.0,"class Solution {
 public:
  string reorderSpaces(string text) {
    const int spaces = count(begin(text), end(text), ' ');
    string ans;
    vector<string> words;

    istringstream iss(text);
    string word;

    while (iss >> word)
      words.push_back(word);

    if (words.size() == 1)
      return word + string(spaces, ' ');

    const int gapSize = spaces / (words.size() - 1);
    const int remains = spaces % (words.size() - 1);

    for (int i = 0; i < words.size() - 1; ++i)
      ans += words[i] + string(gapSize, ' ');
    ans += words.back() + string(remains, ' ');

    return ans;
  }
};",15,607,0.0,2.0,2.0,3.0,40.46666666666667,16.0,4.518
1303.0,"class Solution {
 public:
  int maxUniqueSplit(string s) {
    size_t ans = 0;
    dfs(s, 0, {}, ans);
    return ans;
  }

 private:
  void dfs(const string& s, int start, unordered_set<string>&& seen,
           size_t& ans) {
    if (start == s.length()) {
      ans = max(ans, seen.size());
      return;
    }

    for (int i = 1; start + i <= s.length(); ++i) {
      const string cand = s.substr(start, i);
      if (seen.count(cand))
        continue;
      seen.insert(cand);
      dfs(s, start + i, move(seen), ans);
      seen.erase(cand);
    }
  }
};",13,563,0.0,1.0,6.0,3.0,43.30769230769231,11.0,4.582307692307692
1304.0,"class Solution {
 public:
  int maxProductPath(vector<vector<int>>& grid) {
    constexpr int kMod = 1'000'000'007;
    const int m = grid.size();
    const int n = grid[0].size();
    // dpMin[i][j] := the min product from (0, 0) to (i, j)
    // dpMax[i][j] := the max product from (0, 0) to (i, j)
    vector<vector<long>> dpMin(m, vector<long>(n));
    vector<vector<long>> dpMax(m, vector<long>(n));

    dpMin[0][0] = dpMax[0][0] = grid[0][0];

    for (int i = 1; i < m; ++i)
      dpMin[i][0] = dpMax[i][0] = dpMin[i - 1][0] * grid[i][0];

    for (int j = 1; j < n; ++j)
      dpMin[0][j] = dpMax[0][j] = dpMin[0][j - 1] * grid[0][j];

    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (grid[i][j] < 0) {
          dpMin[i][j] = max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];
          dpMax[i][j] = min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];
        } else {
          dpMin[i][j] = min(dpMin[i - 1][j], dpMin[i][j - 1]) * grid[i][j];
          dpMax[i][j] = max(dpMax[i - 1][j], dpMax[i][j - 1]) * grid[i][j];
        }

    const long maxi = max(dpMin.back().back(), dpMax.back().back());
    return maxi < 0 ? -1 : maxi % kMod;
  }
};",23,1188,2.0,6.0,4.0,5.0,51.65217391304348,13.0,3.5313043478260866
1305.0,"class Solution {
 public:
  Node* expTree(string s) {
    stack<Node*> nodes;  // Stores nodes (new Node(val)).
    stack<char> ops;     // Stores operators and parentheses.

    for (const char c : s)
      if (isdigit(c)) {
        nodes.push(new Node(c));
      } else if (c == '(') {
        ops.push(c);
      } else if (c == ')') {
        while (ops.top() != '(')
          nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));
        ops.pop();  // Remove '('.
      } else if (c == '+' || c == '-' || c == '*' || c == '/') {
        while (!ops.empty() && compare(ops.top(), c))
          nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));
        ops.push(c);
      }

    while (!ops.empty())
      nodes.push(buildNode(pop(ops), pop(nodes), pop(nodes)));

    return nodes.top();
  }

 private:
  Node* buildNode(char op, Node* right, Node* left) {
    return new Node(op, left, right);
  }

  // Returns true if op1 is a operator and priority(op1) >= priority(op2)
  bool compare(char op1, char op2) {
    if (op1 == '(' || op1 == ')')
      return false;
    return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-';
  }

  char pop(stack<char>& ops) {
    const char op = ops.top();
    ops.pop();
    return op;
  }

  Node* pop(stack<Node*>& nodes) {
    Node* node = nodes.top();
    nodes.pop();
    return node;
  }
};",20,1351,4.0,8.0,10.0,10.0,67.55,13.0,1.7005000000000017
1306.0,"class Solution {
 public:
  int minOperations(vector<string>& logs) {
    int ans = 0;

    for (const string& log : logs) {
      if (log == ""./"")
        continue;
      if (log == ""../"")
        ans = max(0, ans - 1);
      else
        ++ans;
    }

    return ans;
  }
};",6,276,0.0,3.0,3.0,3.0,46.0,6.0,4.9
1307.0,"class Solution {
 public:
  int minOperationsMaxProfit(vector<int>& customers, int boardingCost,
                             int runningCost) {
    int waiting = 0;
    int profit = 0;
    int maxProfit = 0;
    int rotate = 0;
    int maxRotate = -1;
    int i = 0;

    while (waiting > 0 || i < customers.size()) {
      if (i < customers.size())
        waiting += customers[i++];
      // Onboard new customers
      const int newOnboard = min(waiting, 4);
      waiting -= newOnboard;
      profit += newOnboard * boardingCost - runningCost;
      ++rotate;
      if (profit > maxProfit) {
        maxProfit = profit;
        maxRotate = rotate;
      }
    }

    return maxRotate;
  }
};",15,696,1.0,3.0,4.0,3.0,46.4,13.0,4.144
1308.0,"class ThroneInheritance {
 public:
  ThroneInheritance(string kingName) : kingName(kingName) {}

  void birth(string parentName, string childName) {
    family[parentName].push_back(childName);
  }

  void death(string name) {
    dead.insert(name);
  }

  vector<string> getInheritanceOrder() {
    vector<string> ans;
    dfs(kingName, ans);
    return ans;
  }

 private:
  unordered_set<string> dead;
  unordered_map<string, vector<string>> family;
  string kingName;

  void dfs(const string& name, vector<string>& ans) {
    if (!dead.count(name))
      ans.push_back(name);
    if (!family.count(name))
      return;

    for (const string& child : family[name])
      dfs(child, ans);
  }
};",12,699,0.0,2.0,6.0,3.0,58.25,19.0,2.3774999999999995
1309.0,"class Solution {
 public:
  int maximumRequests(int n, vector<vector<int>>& requests) {
    int ans = 0;
    vector<int> degree(n);  // degree[i] := degree of building i

    function<void(int, int)> dfs = [&](int i, int processedReqs) {
      if (i == requests.size()) {
        if (all_of(begin(degree), end(degree), [](int d) { return d == 0; }))
          ans = max(ans, processedReqs);
        return;
      }

      // Skip requests[i]
      dfs(i + 1, processedReqs);

      // Process requests[i]
      --degree[requests[i][0]];
      ++degree[requests[i][1]];
      dfs(i + 1, processedReqs + 1);
      --degree[requests[i][1]];
      ++degree[requests[i][0]];
    };

    dfs(0, 0);

    return ans;
  }
};",15,716,3.0,0.0,5.0,2.0,47.73333333333333,12.0,4.324
1310.0,"class ParkingSystem {
 public:
  ParkingSystem(int big, int medium, int small) {
    count = {big, medium, small};
  }

  bool addCar(int carType) {
    return count[carType - 1]-- > 0;
  }

 private:
  vector<int> count;
};",4,224,0.0,0.0,4.0,0.0,56.0,7.0,4.02
1311.0,"class Solution {
 public:
  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
    vector<int> ans;
    vector<int> times(k);
    set<int> idleServers;
    // (endTime, server)
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;

    for (int i = 0; i < k; ++i)
      idleServers.insert(i);

    for (int i = 0; i < arrival.size(); ++i) {
      // Pop all servers that are available now.
      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {
        idleServers.insert(minHeap.top().second);
        minHeap.pop();
      }
      // Get next available server.
      const int server = getNextAvailableServer(idleServers, i, k);
      if (server == -1)
        continue;
      ++times[server];
      minHeap.emplace(arrival[i] + load[i], server);
      idleServers.erase(server);
    }

    const int busiest = *max_element(begin(times), end(times));
    for (int i = 0; i < k; ++i)
      if (times[i] == busiest)
        ans.push_back(i);
    return ans;
  }

 private:
  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,
                             int k) {
    if (idleServers.empty())
      return -1;
    const auto it = idleServers.lower_bound(ithRequest % k);
    return it == cend(idleServers) ? *begin(idleServers) : *it;
  }
};",25,1327,3.0,4.0,5.0,7.0,53.08,25.0,2.3028000000000004
1312.0,"class Solution {
 public:
  int visiblePoints(vector<vector<int>>& points, int angle,
                    vector<int>& location) {
    const int posX = location[0];
    const int posY = location[1];
    int maxVisible = 0;
    int same = 0;
    vector<double> pointAngles;

    for (const vector<int>& p : points) {
      const int x = p[0];
      const int y = p[1];
      if (x == posX && y == posY)
        ++same;
      else
        pointAngles.push_back(getAngle(y - posY, x - posX));
    }

    sort(begin(pointAngles), end(pointAngles));

    const int n = pointAngles.size();
    for (int i = 0; i < n; ++i)
      pointAngles.push_back(pointAngles[i] + 360);

    for (int l = 0, r = 0; r < pointAngles.size(); ++r) {
      while (pointAngles[r] - pointAngles[l] > angle)
        ++l;
      maxVisible = max(maxVisible, r - l + 1);
    }

    return maxVisible + same;
  }

 private:
  double getAngle(int dy, int dx) {
    return atan2(dy, dx) * 180 / M_PI;
  }
};",21,973,0.0,5.0,5.0,5.0,46.333333333333336,25.0,2.7300000000000004
1313.0,"class Solution {
 public:
  string findLexSmallestString(string s, int a, int b) {
    string ans = s;

    dfs(s, a, b, {}, ans);

    return ans;
  }

 private:
  void dfs(string s, int a, int b, unordered_set<string>&& seen, string& ans) {
    if (seen.count(s))
      return;

    seen.insert(s);
    ans = min(ans, s);

    dfs(add(s, a), a, b, move(seen), ans);
    dfs(rotate(s, b), a, b, move(seen), ans);
  }

  string add(string& s, int a) {
    for (int i = 1; i < s.length(); i += 2)
      s[i] = '0' + (s[i] - '0' + a) % 10;
    return s;
  }

  string rotate(const string& s, int b) {
    const int n = s.length();
    return s.substr(n - b, n) + s.substr(0, n - b);
  }
};",15,687,0.0,-1.0,6.0,2.0,45.8,22.0,3.3779999999999992
1314.0,"struct Player {
  int age;
  int score;
  Player(int age, int score) : age(age), score(score) {}
};

class Solution {
 public:
  int bestTeamScore(vector<int>& scores, vector<int>& ages) {
    const int n = scores.size();
    vector<Player> players;
    // dp[i] := max score of choosing players[0..i] w/ players[i] being selected
    vector<int> dp(n);

    for (int i = 0; i < n; ++i)
      players.emplace_back(ages[i], scores[i]);

    sort(begin(players), end(players), [](const auto& a, const auto& b) {
      return a.age == b.age ? a.score > b.score : a.age > b.age;
    });

    for (int i = 0; i < n; ++i) {
      // For each player, we choose it first
      dp[i] = players[i].score;
      // players[j].age >= players[i].age since we sort in descending order
      // So we only have to check that
      // players[j].score >= players[i].score
      for (int j = 0; j < i; ++j)
        if (players[j].score >= players[i].score)
          dp[i] = max(dp[i], dp[j] + players[i].score);
    }

    return *max_element(begin(dp), end(dp));
  }
};",19,1054,5.0,3.0,6.0,5.0,55.47368421052632,17.0,2.9673684210526314
1315.0,"struct T {
  int i;
  int j;
  int d;
  T(int i, int j, int d) : i(i), j(j), d(d) {}
};

class Solution {
 public:
  int minimumEffortPath(vector<vector<int>>& heights) {
    const int m = heights.size();
    const int n = heights[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    auto compare = [](const T& a, const T& b) { return a.d > b.d; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    // diff[i][j] := max absolute difference to reach (i, j).
    vector<vector<int>> diff(m, vector<int>(n, INT_MAX));
    vector<vector<bool>> seen(m, vector<bool>(n));

    minHeap.emplace(0, 0, 0);
    diff[0][0] = 0;

    while (!minHeap.empty()) {
      const auto [i, j, d] = minHeap.top();
      minHeap.pop();
      if (i == m - 1 && j == n - 1)
        return d;
      seen[i][j] = true;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == m || y < 0 || y == n)
          continue;
        if (seen[x][y])
          continue;
        const int newDiff = abs(heights[i][j] - heights[x][y]);
        const int maxDiff = max(diff[i][j], newDiff);
        if (diff[x][y] > maxDiff) {
          diff[x][y] = maxDiff;
          minHeap.emplace(x, y, maxDiff);
        }
      }
    }

    throw;
  }
};",30,1315,1.0,2.0,9.0,20.0,43.833333333333336,32.0,2.2349999999999994
1316.0,"class Solution {
 public:
  int countVowelStrings(int n) {
    // dp[0] := # of lexicographically sorted strings ends with 'a'
    // dp[1] := # of lexicographically sorted strings ends with 'e'
    // dp[2] := # of lexicographically sorted strings ends with 'i'
    // dp[3] := # of lexicographically sorted strings ends with 'o'
    // dp[4] := # of lexicographically sorted strings ends with 'u'
    vector<int> dp(5, 1);

    for (int i = 2; i <= n; ++i) {
      vector<int> newDp(5);
      for (int j = 0; j < 5; ++j)
        for (int k = 0; k <= j; ++k)
          newDp[j] += dp[k];
      dp = move(newDp);
    }

    return accumulate(begin(dp), end(dp), 0);
  }
};",12,672,5.0,3.0,3.0,3.0,56.0,8.0,4.000000000000001
1317.0,"class Solution {
 public:
  int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
    priority_queue<int, vector<int>, greater<int>> minHeap;

    for (int i = 1; i < heights.size(); ++i) {
      const int diff = heights[i] - heights[i - 1];
      if (diff <= 0)
        continue;
      minHeap.push(diff);
      // When we run out of ladders, greedily use as less bricks as possible.
      if (minHeap.size() > ladders)
        bricks -= minHeap.top(), minHeap.pop();
      if (bricks < 0)
        return i - 1;
    }

    return heights.size() - 1;
  }
};",10,573,1.0,2.0,3.0,7.0,57.3,11.0,3.4830000000000005
1318.0,"class Solution {
 public:
  int minDeletions(string s) {
    int ans = 0;
    vector<int> count(26);
    unordered_set<int> usedFreq;

    for (const char c : s)
      ++count[c - 'a'];

    for (int freq : count)
      while (freq > 0 && !usedFreq.insert(freq).second) {
        --freq;  // Delete ('a' + i).
        ++ans;
      }

    return ans;
  }
};",8,356,1.0,3.0,3.0,3.0,44.5,9.0,4.775
1319.0,"class Solution {
 public:
  bool closeStrings(string word1, string word2) {
    if (word1.length() != word2.length())
      return false;

    unordered_map<char, int> count1;
    unordered_map<char, int> count2;
    string s1;           // Unique chars in word1
    string s2;           // Unique chars in word2
    vector<int> freqs1;  // Freqs of unique chars in word1
    vector<int> freqs2;  // Freqs of unique chars in word2

    for (const char c : word1)
      ++count1[c];

    for (const char c : word2)
      ++count2[c];

    for (const auto& [c, freq] : count1) {
      s1 += c;
      freqs1.push_back(freq);
    }

    for (const auto& [c, freq] : count2) {
      s2 += c;
      freqs2.push_back(freq);
    }

    sort(begin(s1), end(s1));
    sort(begin(s2), end(s2));

    if (s1 != s2)
      return false;

    sort(begin(freqs1), end(freqs1));
    sort(begin(freqs2), end(freqs2));
    return freqs1 == freqs2;
  }
};",20,935,4.0,4.0,4.0,6.0,46.75,18.0,3.6725
1320.0,"class Solution {
 public:
  int waysToMakeFair(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    vector<int> even(n + 1);  // Sum of even-indexed nums[0..i)
    vector<int> odd(n + 1);   // Sum of odd-indexed nums[0..i)

    for (int i = 1; i <= n; ++i) {
      odd[i] = odd[i - 1];
      even[i] = even[i - 1];
      if (i % 2 == 0)
        even[i] += nums[i - 1];
      else
        odd[i] += nums[i - 1];
    }

    const int sum = even.back() + odd.back();

    for (int i = 0; i < n; ++i) {
      const int evenSum = even[i] + odd.back() - odd[i + 1];
      const int oddSum = sum - nums[i] - evenSum;
      if (evenSum == oddSum)
        ++ans;
    }

    return ans;
  }
};",18,703,2.0,5.0,4.0,4.0,39.05555555555556,16.0,4.425
1321.0,"class Solution {
 public:
  Node* flipBinaryTree(Node* root, Node* leaf) {
    return reroot(root, leaf, nullptr);
  }

 private:
  Node* reroot(Node* root, Node* node, Node* newParent) {
    Node* oldParent = node->parent;
    node->parent = newParent;

    // Clean up the child if it's the new parent
    if (node->left == newParent)
      node->left = nullptr;
    if (node->right == newParent)
      node->right = nullptr;

    // We meet the original root, so we're done
    if (node == root)
      return node;

    if (node->left)
      node->right = node->left;
    node->left = reroot(root, oldParent, node);

    return node;
  }
};",10,643,2.0,3.0,3.0,5.0,64.3,1.0,3.833000000000001
1322.0,"class Solution {
 public:
  int minimumMountainRemovals(vector<int>& nums) {
    vector<int> l = lengthOfLIS(nums);
    vector<int> r = reversed(lengthOfLIS(reversed(nums)));
    int maxMountainSeq = 0;

    for (int i = 0; i < nums.size(); ++i)
      if (l[i] > 1 && r[i] > 1)
        maxMountainSeq = max(maxMountainSeq, l[i] + r[i] - 1);

    return nums.size() - maxMountainSeq;
  }

 private:
  vector<int> lengthOfLIS(vector<int> nums) {
    // tail[i] := the minimum tail of all increasing subseqs having length i + 1
    // it's easy to see that tail must be an increasing array
    vector<int> tail;

    // dp[i] := Length of LIS ending at nums[i]
    vector<int> dp(nums.size());

    for (int i = 0; i < nums.size(); ++i) {
      const int num = nums[i];
      if (tail.empty() || num > tail.back()) {
        tail.push_back(num);
      } else {
        int l = 0;
        int r = tail.size();
        // Find the first index l in tail s.t. tail[l] >= num
        while (l < r) {
          const int m = (l + r) / 2;
          if (tail[m] >= num)
            r = m;
          else
            l = m + 1;
        }
        tail[l] = num;
      }
      dp[i] = tail.size();
    }

    return dp;
  }

  vector<int> reversed(const vector<int>& nums) {
    return {rbegin(nums), rend(nums)};
  }
};",23,1306,4.0,6.0,9.0,6.0,56.78260869565217,21.0,2.0495652173913044
1323.0,"class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*>& nodes) {
    unordered_set<TreeNode*> nodesSet{begin(nodes), end(nodes)};
    return lca(root, nodesSet);
  }

 private:
  TreeNode* lca(TreeNode* root, unordered_set<TreeNode*>& nodesSet) {
    if (root == nullptr)
      return nullptr;
    if (nodesSet.count(root))
      return root;

    TreeNode* l = lca(root->left, nodesSet);
    TreeNode* r = lca(root->right, nodesSet);

    if (l && r)
      return root;
    return l ? l : r;
  }
};",9,537,0.0,-1.0,4.0,3.0,59.66666666666666,1.0,4.3500000000000005
1324.0,"class Solution {
 public:
  int longestPalindromeSubseq(string s) {
    const int n = s.length();
    // dp[i][j][k] := LPS's length in s[i..j] w/ previous char = 'a' + k
    dp.resize(n, vector<vector<int>>(n, vector<int>(27)));
    return lps(s, 0, n - 1, 26);
  }

 private:
  vector<vector<vector<int>>> dp;

  int lps(const string& s, int i, int j, int k) {
    if (i >= j)
      return 0;
    if (dp[i][j][k] > 0)
      return dp[i][j][k];

    if (s[i] == s[j] && s[i] != 'a' + k)
      dp[i][j][k] = lps(s, i + 1, j - 1, s[i] - 'a') + 2;
    else
      dp[i][j][k] = max(lps(s, i + 1, j, k), lps(s, i, j - 1, k));

    return dp[i][j][k];
  }
};",10,653,1.0,1.0,3.0,3.0,65.3,15.0,2.423000000000001
1325.0,"class Solution {
 public:
  int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {
    const int n = aliceValues.size();
    vector<vector<int>> values;
    int a = 0;
    int b = 0;

    for (int i = 0; i < n; ++i)
      values.push_back({aliceValues[i], bobValues[i]});

    sort(begin(values), end(values), [](const auto& a, const auto& b) {
      return a[0] + a[1] > b[0] + b[1];
    });

    for (int i = 0; i < n; ++i)
      if (i % 2 == 0)
        a += values[i][0];
      else
        b += values[i][1];

    return a > b ? 1 : a < b ? -1 : 0;
  }
};",15,572,0.0,3.0,4.0,3.0,38.13333333333333,13.0,4.848
1326.0,"class Solution {
 public:
  int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes,
                    int maxWeight) {
    const int n = boxes.size();
    // dp[i] := min trips to deliver boxes[0..i) and return to the storage
    vector<int> dp(n + 1);
    int trips = 2;
    int weight = 0;

    for (int l = 0, r = 0; r < n; ++r) {
      weight += boxes[r][1];

      // Current box is different from previous one, need to make one more trip
      if (r > 0 && boxes[r][0] != boxes[r - 1][0])
        ++trips;

      while (r - l + 1 > maxBoxes || weight > maxWeight ||
             // Loading boxes[l] in the previous turn is always no bad than
             // Loading it in this turn
             (l < r && dp[l + 1] == dp[l])) {
        weight -= boxes[l][1];
        if (boxes[l][0] != boxes[l + 1][0])
          --trips;
        ++l;
      }

      //   min trips to deliver boxes[0..r]
      // = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]
      dp[r + 1] = dp[l] + trips;
    }

    return dp[n];
  }
};",14,1055,6.0,3.0,4.0,5.0,75.35714285714286,12.0,1.8378571428571424
1327.0,"class Solution {
 public:
  int stoneGameVII(vector<int>& stones) {
    const int n = stones.size();
    // dp[i][j] := max score you can get more than your opponent in stones[i..j]
    dp.resize(n, vector<int>(n));
    prefix.resize(n + 1);

    partial_sum(begin(stones), end(stones), begin(prefix) + 1);
    return stoneGameVII(stones, 0, n - 1);
  }

 private:
  vector<vector<int>> dp;
  vector<int> prefix;

  int stoneGameVII(const vector<int>& stones, int i, int j) {
    if (i == j)
      return 0;
    if (dp[i][j] > 0)
      return dp[i][j];

    dp[i][j] =
        max({dp[i][j],
             // Remove stones[i], so get sum of stones[i + 1..j]
             prefix[j + 1] - prefix[i + 1] - stoneGameVII(stones, i + 1, j),
             // Remove stones[j], so get sum of stones[i..j - 1]
             prefix[j] - prefix[i] - stoneGameVII(stones, i, j - 1)});

    return dp[i][j];
  }
};",12,898,3.0,-1.0,4.0,2.0,74.83333333333333,13.0,1.905
1328.0,"class Solution {
 public:
  int maxHeight(vector<vector<int>>& cuboids) {
    // For each cuboid, sort it so that c[0] <= c[1] <= c[2]
    for (vector<int>& c : cuboids)
      sort(begin(c), end(c));

    sort(begin(cuboids), end(cuboids));

    // dp[i] := max height w/ cuboids[i] in the bottom
    vector<int> dp(cuboids.size());

    for (int i = 0; i < cuboids.size(); ++i)
      dp[i] = cuboids[i][2];

    for (int i = 1; i < cuboids.size(); ++i)
      for (int j = 0; j < i; ++j)
        if (cuboids[j][0] <= cuboids[i][0] &&  //
            cuboids[j][1] <= cuboids[i][1] &&  //
            cuboids[j][2] <= cuboids[i][2])
          dp[i] = max(dp[i], dp[j] + cuboids[i][2]);

    return *max_element(begin(dp), end(dp));
  }
};",13,737,4.0,5.0,2.0,6.0,56.69230769230769,8.0,3.837692307692308
1329.0,"class Solution {
 public:
  int waysToDistribute(int n, int k) {
    constexpr int kMod = 1'000'000'007;
    // dp[i][j] := # of ways to distribute i candies to j bags
    // dp[i][j] = 0, if i < j
    //          = 1, if i == j
    //          = dp[i - 1][j - 1] (the new candy occupies a bag)
    //          + dp[i - 1][j] * j (the new candy is in any of j bags)
    vector<vector<long>> dp(n + 1, vector<long>(k + 1));

    for (int i = 0; i <= k; ++i)
      dp[i][i] = 1;

    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= k; ++j)
        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * j) % kMod;

    return dp[n][k];
  }
};",12,639,5.0,5.0,2.0,5.0,53.25,8.0,4.187500000000001
1330.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList,
                                         vector<vector<int>>& queries) {
    vector<bool> ans(queries.size());
    UnionFind uf(n);

    for (int i = 0; i < queries.size(); ++i)
      queries[i].push_back(i);

    sort(begin(queries), end(queries),
         [](const auto& a, const auto& b) { return a[2] < b[2]; });
    sort(begin(edgeList), end(edgeList),
         [](const auto& a, const auto& b) { return a[2] < b[2]; });

    int i = 0;  // i := edgeList's index
    for (const vector<int>& query : queries) {
      // Union edges whose distances < limit (query[2])
      while (i < edgeList.size() && edgeList[i][2] < query[2])
        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);
      if (uf.find(query[0]) == uf.find(query[1]))
        ans[q.back()] = true;
    }

    return ans;
  }
};",26,1423,2.0,5.0,12.0,7.0,54.73076923076923,27.0,1.4342307692307674
1331.0,"class Solution {
 public:
  double averageWaitingTime(vector<vector<int>>& customers) {
    double wait = 0;
    double curr = 0;

    for (const vector<int>& c : customers) {
      curr = max(curr, 1.0 * c[0]) + c[1];
      wait += curr - c[0];
    }

    return 1.0 * wait / customers.size();
  }
};",6,301,0.0,1.0,3.0,1.0,50.16666666666666,7.0,4.545000000000001
1332.0,"class Solution {
 public:
  string maximumBinaryString(string binary) {
    //     e.g. binary = ""100110""
    // Do Operation 2 -> ""100011""
    // Do Operation 1 -> ""111011""
    // So, the index of the only '0' is prefixOnes + zeros - 1.
    const int zeros = count(begin(binary), end(binary), '0');
    const int prefixOnes = binary.find('0');

    // Make the entire string as 1s.
    binary.assign(binary.length(), '1');

    // Make the only '0' if necessary.
    if (prefixOnes != string::npos)
      binary[prefixOnes + zeros - 1] = '0';
    return binary;
  }
};",6,569,6.0,2.0,2.0,2.0,94.83333333333331,9.0,0.5650000000000013
1333.0,"class Solution {
 public:
  int minMoves(vector<int>& nums, int k) {
    vector<int> ones;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == 1)
        ones.push_back(i);

    // Returns median index of [i..i + k)
    auto getMedIndex = [&](int i) { return (i + (i + k - 1)) / 2; };

    // Calculate the first group: window[0] = A[0..k)
    const int median = ones[getMedIndex(0)];
    int moves = 0;
    for (int i = 0; i < k; ++i)
      moves += abs(ones[i] - median);

    int ans = moves;

    for (int i = 1; i <= ones.size() - k; ++i) {
      const int oldMedianIndex = ones[getMedIndex(i - 1)];
      const int newMedianIndex = ones[getMedIndex(i)];
      if (k & 1)
        moves += newMedianIndex - oldMedianIndex;
      moves -= newMedianIndex - ones[i - 1];
      moves += ones[i + k - 1] - newMedianIndex;
      ans = min(ans, moves);
    }

    auto nThSum = [&](int n) { return n * (n + 1) / 2; };
    return ans - nThSum((k - 1) / 2) - nThSum(k / 2);
  }
};",24,987,2.0,3.0,5.0,5.0,41.125,18.0,4.098750000000001
1334.0,"class Solution {
 public:
  vector<int> findBall(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    // dp[i] := status of i-th column
    // -1 := empty, 0 := b0, 1 := b1, ...
    vector<int> dp(n);
    // ans[i] := i-th ball's final position
    vector<int> ans(n, -1);

    iota(begin(dp), end(dp), 0);

    for (int i = 0; i < m; ++i) {
      vector<int> newDp(n, -1);
      for (int j = 0; j < n; ++j) {
        // Out of bound
        if (j + grid[i][j] < 0 || j + grid[i][j] == n)
          continue;
        // Stuck
        if (grid[i][j] == 1 && grid[i][j + 1] == -1 ||
            grid[i][j] == -1 && grid[i][j - 1] == 1)
          continue;
        newDp[j + grid[i][j]] = dp[j];
      }
      dp = move(newDp);
    }

    for (int i = 0; i < n; ++i)
      if (dp[i] != -1)
        ans[dp[i]] = i;

    return ans;
  }
};",19,879,5.0,4.0,4.0,6.0,46.26315789473684,13.0,4.2563157894736845
1335.0,"class Solution {
 public:
  int waysToSplit(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int n = nums.size();
    int ans = 0;
    vector<int> prefix(n);

    partial_sum(begin(nums), end(nums), begin(prefix));

    // Find the first index j s.t.
    // Mid = prefix[j] - prefix[i] >= left = prefix[i]
    auto firstGreaterEqual = [&](int i) {
      int l = i + 1;
      int r = n - 1;
      while (l < r) {
        const int m = (l + r) / 2;
        if (prefix[m] - prefix[i] >= prefix[i])
          r = m;
        else
          l = m + 1;
      }
      return l;
    };

    // Find the first index k s.t.
    // Mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]
    auto firstGreater = [&](int i) {
      int l = i + 1;
      int r = n - 1;
      while (l < r) {
        const int m = (l + r) / 2;
        if (prefix[m] - prefix[i] > prefix.back() - prefix[m])
          r = m;
        else
          l = m + 1;
      }
      return l;
    };

    for (int i = 0; i < n - 2; ++i) {
      const int j = firstGreaterEqual(i);
      if (j == n - 1)
        break;
      const int mid = prefix[j] - prefix[i];
      const int right = prefix.back() - prefix[j];
      if (mid > right)
        continue;
      const int k = firstGreater(i);
      ans = (ans + k - j) % kMod;
    }

    return ans;
  }
};",30,1339,4.0,5.0,7.0,7.0,44.63333333333333,27.0,2.7230000000000008
1336.0,"class Solution {
 public:
  int largestSubmatrix(vector<vector<int>>& matrix) {
    const int n = matrix[0].size();
    int ans = 0;
    vector<int> hist(n);

    for (const vector<int>& row : matrix) {
      // Accumulate the histogram if possible
      for (int i = 0; i < n; ++i)
        hist[i] = row[i] == 0 ? 0 : hist[i] + 1;

      // Get sorted histogram
      vector<int> sortedHist(hist);
      sort(begin(sortedHist), end(sortedHist));

      // Greedily calculate the answer
      for (int i = 0; i < n; ++i)
        ans = max(ans, sortedHist[i] * (n - i));
    }

    return ans;
  }
};",13,599,3.0,4.0,3.0,4.0,46.07692307692308,12.0,4.353076923076923
1337.0,"class Solution {
 public:
  bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {
    m = grid.size();
    n = grid[0].size();
    int cat;    // cat's position
    int mouse;  // mouse's position

    for (int i = 0; i < m; ++i)
      for (int j = 0; j < n; ++j) {
        if (grid[i][j] != '#')
          ++nFloors;
        if (grid[i][j] == 'C')
          cat = hash(i, j);
        else if (grid[i][j] == 'M')
          mouse = hash(i, j);
      }

    // dp[i][j][k] := true if mouse can win w/
    // Cat on (i / 8, i % 8), mouse on (j / 8, j % 8), and turns = k
    dp.resize(m * n, vector<vector<int>>(m * n, vector<int>(nFloors * 2, -1)));
    return canMouseWin(grid, cat, mouse, 0, catJump, mouseJump);
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};
  int m;
  int n;
  int nFloors = 0;
  vector<vector<vector<int>>> dp;

  bool canMouseWin(const vector<string>& grid, int cat, int mouse, int turn,
                   const int& catJump, const int& mouseJump) {
    // We already search whole touchable grid
    if (turn == nFloors * 2)
      return false;
    if (dp[cat][mouse][turn] != -1)
      return dp[cat][mouse][turn];

    if (turn % 2 == 0) {
      // mouse's turn
      const int i = mouse / n;
      const int j = mouse % n;
      for (int k = 0; k < 4; ++k) {
        for (int jump = 0; jump <= mouseJump; ++jump) {
          const int x = i + dirs[k] * jump;
          const int y = j + dirs[k + 1] * jump;
          if (x < 0 || x == m || y < 0 || y == n)
            break;
          if (grid[x][y] == '#')
            break;
          if (grid[x][y] == 'F')  // Mouse eats the food, so mouse win
            return dp[cat][mouse][turn] = true;
          if (canMouseWin(grid, cat, hash(x, y), turn + 1, catJump, mouseJump))
            return dp[cat][mouse][turn] = true;
        }
      }
      // Mouse can't win, so mouse lose
      return dp[cat][mouse][turn] = false;
    } else {
      // cat's turn
      const int i = cat / n;
      const int j = cat % n;
      for (int k = 0; k < 4; ++k) {
        for (int jump = 0; jump <= catJump; ++jump) {
          const int x = i + dirs[k] * jump;
          const int y = j + dirs[k + 1] * jump;
          if (x < 0 || x == m || y < 0 || y == n)
            break;
          if (grid[x][y] == '#')
            break;
          if (grid[x][y] == 'F')  // Cat eats the food, so mouse lose
            return dp[cat][mouse][turn] = false;
          const int nextCat = hash(x, y);
          if (nextCat == mouse)  // Cat catches mouse, so mouse lose
            return dp[cat][mouse][turn] = false;
          if (!canMouseWin(grid, nextCat, mouse, turn + 1, catJump, mouseJump))
            return dp[cat][mouse][turn] = false;
        }
      }
      // Cat can't win, so mouse win
      return dp[cat][mouse][turn] = true;
    }
  }

  int hash(int i, int j) {
    return i * n + j;
  }
};",50,2891,12.0,10.0,12.0,22.0,57.82,52.0,-1.2438000000000002
1338.0,"class Solution {
 public:
  int minCharacters(string a, string b) {
    const int m = a.length();
    const int n = b.length();
    vector<int> countA(128);
    vector<int> countB(128);

    for (const char c : a)
      ++countA[c];

    for (const char c : b)
      ++countB[c];

    int ans = INT_MAX;
    int prevA = 0;  // # of chars in a <= c
    int prevB = 0;  // # of chars in b <= c

    for (char c = 'a'; c <= 'z'; ++c) {
      // Condition 3
      ans = min(ans, m + n - countA[c] - countB[c]);
      // Condition 1 and 2
      if (c > 'a')
        ans = min({ans, m - prevA + prevB, n - prevB + prevA});
      prevA += countA[c];
      prevB += countB[c];
    }

    return ans;
  }
};",17,698,4.0,4.0,4.0,4.0,41.05882352941177,18.0,4.184705882352941
1339.0,"class Solution {
 public:
  int kthLargestValue(vector<vector<int>>& matrix, int k) {
    const int m = matrix.size();
    const int n = matrix[0].size();
    vector<vector<int>> xors(m + 1, vector<int>(n + 1));
    priority_queue<int, vector<int>, greater<>> minHeap;

    for (int i = 1; i <= m; ++i)
      for (int j = 1; j <= n; ++j) {
        xors[i][j] = xors[i - 1][j] ^ xors[i][j - 1] ^ xors[i - 1][j - 1] ^
                     matrix[i - 1][j - 1];
        minHeap.push(xors[i][j]);
        if (minHeap.size() > k)
          minHeap.pop();
      }

    return minHeap.top();
  }
};",13,591,0.0,3.0,3.0,3.0,45.46153846153846,14.0,4.148461538461539
1340.0,"class Solution {
 public:
  int minimumBoxes(int n) {
    int nBoxes = 0;
    int nextTouchings = 0;   // J
    int currLevelBoxes = 0;  // 1 + 2 + ... + j

    // Find min j s.t. nBoxes = 1 + (1 + 2) + ... + (1 + 2 + ... + j) >= n
    while (nBoxes < n) {
      ++nextTouchings;
      currLevelBoxes += nextTouchings;
      nBoxes += currLevelBoxes;
    }

    // If nBoxes = n, the answer is currLevelBoxes = 1 + 2 + ... + j
    if (nBoxes == n)
      return currLevelBoxes;

    // Otherwise we need to remove boxes in current level and rebuild it
    nBoxes -= currLevelBoxes;
    currLevelBoxes -= nextTouchings;
    nextTouchings = 0;

    while (nBoxes < n) {
      ++nextTouchings;
      nBoxes += nextTouchings;
    }

    return currLevelBoxes + nextTouchings;
  }
};",14,777,5.0,2.0,4.0,4.0,55.5,6.0,4.244999999999999
1341.0,"class Solution {
 public:
  int findDistance(TreeNode* root, int p, int q) {
    TreeNode* lca = getLCA(root, p, q);
    return dist(lca, p) + dist(lca, q);
  }

 private:
  TreeNode* getLCA(TreeNode* root, int p, int q) {
    if (root == nullptr || root->val == p || root->val == q)
      return root;

    TreeNode* l = getLCA(root->left, p, q);
    TreeNode* r = getLCA(root->right, p, q);

    if (l && r)
      return root;
    return l ? l : r;
  }

  int dist(TreeNode* lca, int target) {
    if (lca == nullptr)
      return 10000;
    if (lca->val == target)
      return 0;
    return 1 + min(dist(lca->left, target), dist(lca->right, target));
  }
};",11,661,0.0,-2.0,4.0,4.0,60.09090909090909,8.0,3.671818181818182
1342.0,"class Solution {
 public:
  vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
    vector<int> ans;
    unordered_map<int, vector<int>> numToAdjs;

    for (const vector<int>& pair : adjacentPairs) {
      const int u = pair[0];
      const int v = pair[1];
      numToAdjs[u].push_back(v);
      numToAdjs[v].push_back(u);
    }

    for (const auto& [num, adjs] : numToAdjs)
      if (adjs.size() == 1) {
        ans.push_back(num);
        ans.push_back(adjs[0]);
        break;
      }

    while (ans.size() < adjacentPairs.size() + 1) {
      const int tail = ans.back();
      const int prev = ans[ans.size() - 2];
      const vector<int>& adjs = numToAdjs[tail];
      if (adjs[0] == prev)
        ans.push_back(adjs[1]);
      else
        ans.push_back(adjs[0]);
    }

    return ans;
  }
};",16,814,0.0,5.0,5.0,5.0,50.875,19.0,2.921250000000001
1343.0,"class Solution {
 public:
  vector<bool> canEat(vector<int>& candiesCount, vector<vector<int>>& queries) {
    const int n = candiesCount.size();
    vector<bool> ans;
    vector<long> prefix{0};

    for (int i = 0; i < n; ++i)
      prefix.push_back(prefix.back() + candiesCount[i]);

    for (const vector<int>& query : queries) {
      const int type = query[0];
      const int day = query[1];
      const int cap = query[2];
      // Min/max day required to eat
      const long minDay = prefix[type] / cap;
      const long maxDay = prefix[type + 1] - 1;
      ans.push_back(minDay <= day && day <= maxDay);
    }

    return ans;
  }
};",14,644,1.0,2.0,4.0,2.0,46.0,18.0,3.74
1344.0,"class Solution {
 public:
  bool checkPartitioning(string s) {
    const int n = s.length();
    // dp[i][j] := true if s[i..j] is palindrome
    dp.resize(n, vector<int>(n, -1));

    for (int i = 0; i < n; ++i)
      for (int j = i + 1; j < n; ++j)
        if (isPalindrome(s, 0, i) && isPalindrome(s, i + 1, j) &&
            isPalindrome(s, j + 1, n - 1))
          return true;

    return false;
  }

 private:
  vector<vector<int>> dp;

  // Returns 0 if s[i..j] is not a palindrome
  // Returns 1 if s[i..j] is a palindrome
  int isPalindrome(const string& s, int i, int j) {
    if (i > j)
      return 1;
    if (dp[i][j] != -1)
      return dp[i][j];
    if (s[i] == s[j])
      return dp[i][j] = isPalindrome(s, i + 1, j - 1);
    return dp[i][j] = 0;
  }
};",14,770,3.0,4.0,3.0,9.0,55.0,14.0,3.35
1345.0,"class Solution {
 public:
  int maxValue(vector<vector<int>>& events, int k) {
    // dp[i][k] := max sum of events[i:] w/ max k # of attendance
    dp.resize(events.size(), vector<int>(k + 1, -1));
    sort(begin(events), end(events));
    return maxValue(events, 0, k);
  }

 private:
  vector<vector<int>> dp;

  int maxValue(const vector<vector<int>>& e, int i, int k) {
    if (k == 0 || i == e.size())
      return 0;
    if (dp[i][k] != -1)
      return dp[i][k];

    // Binary search events to find the first index j s.t. e[j][0] > e[i][1]
    const auto it =
        upper_bound(begin(e) + i, end(e), e[i][1],
                    [](int end, const auto& a) { return a[0] > end; });
    const int j = distance(begin(e), it);
    return dp[i][k] =
               max(e[i][2] + maxValue(e, j, k - 1), maxValue(e, i + 1, k));
  }
};",11,838,2.0,-2.0,4.0,2.0,76.18181818181819,16.0,1.503636363636362
1346.0,"class Solution {
 public:
  bool check(vector<int>& nums) {
    const int n = nums.size();
    int rotates = 0;

    for (int i = 0; i < n; ++i)
      if (nums[i] > nums[(i + 1) % n] && ++rotates > 1)
        return false;

    return true;
  }
};",7,247,0.0,1.0,2.0,2.0,35.285714285714285,7.0,5.944285714285714
1347.0,"class Solution {
 public:
  int maximumScore(int a, int b, int c) {
    // Max <= min + mid
    const int x = (a + b + c) / 2;
    // Max > min + mid
    const int y = a + b + c - max({a, b, c});
    return min(x, y);
  }
};",4,224,2.0,0.0,3.0,0.0,56.0,9.0,3.96
1348.0,"class Solution {
 public:
  int minAbsDifference(vector<int>& nums, int goal) {
    const int n = nums.size() / 2;
    const vector<int> lNums(begin(nums), begin(nums) + n);
    const vector<int> rNums(begin(nums) + n, end(nums));
    int ans = INT_MAX;
    vector<int> lSums;
    vector<int> rSums;

    dfs(lNums, 0, 0, lSums);
    dfs(rNums, 0, 0, rSums);
    sort(begin(rSums), end(rSums));

    for (const int lSum : lSums) {
      const int i = firstGreaterEqual(rSums, goal - lSum);
      if (i < rSums.size())  // 2^n
        ans = min(ans, abs(goal - lSum - rSums[i]));
      if (i > 0)
        ans = min(ans, abs(goal - lSum - rSums[i - 1]));
    }

    return ans;
  }

 private:
  void dfs(const vector<int>& A, int i, int path, vector<int>& sums) {
    if (i == A.size()) {
      sums.push_back(path);
      return;
    }
    dfs(A, i + 1, path + A[i], sums);
    dfs(A, i + 1, path, sums);
  }

  int firstGreaterEqual(const vector<int>& A, int target) {
    return lower_bound(begin(A), end(A), target) - begin(A);
  }
};",19,1036,1.0,2.0,6.0,5.0,54.526315789473685,27.0,1.9526315789473685
1349.0,"class Solution {
 public:
  vector<int> findBuildings(vector<int>& heights) {
    vector<int> stack;

    for (int i = 0; i < heights.size(); ++i) {
      while (!stack.empty() && heights[stack.back()] <= heights[i])
        stack.pop_back();
      stack.push_back(i);
    }

    return stack;
  }
};",7,300,0.0,2.0,3.0,2.0,42.85714285714285,5.0,5.342857142857143
1350.0,"class Solution {
 public:
  string mergeAlternately(string word1, string word2) {
    const int n = min(word1.length(), word2.length());
    string prefix;

    for (int i = 0; i < n; ++i) {
      prefix += word1[i];
      prefix += word2[i];
    }

    return prefix + word1.substr(n) + word2.substr(n);
  }
};",8,311,0.0,1.0,3.0,1.0,38.875,8.0,5.461250000000001
1351.0,"class Solution {
 public:
  vector<int> minOperations(string boxes) {
    vector<int> ans(boxes.length());

    for (int i = 0, count = 0, moves = 0; i < boxes.length(); ++i) {
      ans[i] += moves;
      count += boxes[i] - '0';
      moves += count;
    }

    for (int i = boxes.length() - 1, count = 0, moves = 0; i >= 0; --i) {
      ans[i] += moves;
      count += boxes[i] - '0';
      moves += count;
    }

    return ans;
  }
};",13,439,0.0,2.0,4.0,2.0,33.76923076923077,6.0,6.000769230769231
1352.0,"class Solution {
 public:
  int maximumScore(vector<int>& nums, vector<int>& multipliers) {
    // dp[s][i] := max score of nums[s..e] and multipliers[i],
    dp.resize(multipliers.size(), vector<int>(multipliers.size(), -1));
    return maximumScore(nums, 0, multipliers, 0);
  }

 private:
  vector<vector<int>> dp;

  int maximumScore(const vector<int>& nums, int s,
                   const vector<int>& multipliers, int i) {
    if (i == multipliers.size())
      return 0;
    if (dp[s][i] != -1)
      return dp[s][i];

    // # of nums picked on the start side = s,
    // # of nums picked on the end side = i - s,
    // So e = n - (i - s) - 1
    const int e = nums.size() - (i - s) - 1;
    const int pickStart = nums[s] * multipliers[i] +
                          maximumScore(nums, s + 1, multipliers, i + 1);
    const int pickEnd = nums[e] * multipliers[i] +  //
                        maximumScore(nums, s, multipliers, i + 1);
    return dp[s][i] = max(pickStart, pickEnd);
  }
};",10,999,5.0,-1.0,3.0,2.0,99.9,19.0,-0.8109999999999999
1353.0,"class Solution {
 public:
  int longestPalindrome(string word1, string word2) {
    const string& s = word1 + word2;
    const int n = s.length();
    int ans = 0;
    // dp[i][j] := LPS's length in s[i..j]
    vector<vector<int>> dp(n, vector<int>(n));

    for (int i = 0; i < n; ++i)
      dp[i][i] = 1;

    for (int d = 1; d < n; ++d)
      for (int i = 0; i + d < n; ++i) {
        const int j = i + d;
        if (s[i] == s[j]) {
          dp[i][j] = 2 + dp[i + 1][j - 1];
          if (i < word1.length() && j >= word1.length())
            ans = max(ans, dp[i][j]);
        } else {
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
      }

    return ans;
  }
};",17,687,1.0,6.0,5.0,5.0,40.41176470588236,16.0,4.142941176470588
1354.0,"class Solution {
 public:
  vector<string> sortFeatures(vector<string>& features,
                              vector<string>& responses) {
    vector<string> ans;
    vector<pair<int, int>> featCount;  // {i: count[features[i]]}
    unordered_map<string, int> count;

    for (const string& res : responses) {
      istringstream iss(res);
      unordered_set<string> seen;
      for (string token; getline(iss, token, ' ');)
        seen.insert(token);
      for (const string& token : seen)
        ++count[token];
    }

    for (int i = 0; i < features.size(); ++i)
      featCount.emplace_back(i, count[features[i]]);

    sort(begin(featCount), end(featCount), [](const auto& a, const auto& b) {
      return a.second == b.second ? a.first < b.first : a.second > b.second;
    });

    for (const auto& [i, count] : featCount)
      ans.push_back(features[i]);

    return ans;
  }
};",17,892,1.0,4.0,5.0,5.0,52.47058823529412,19.0,2.8776470588235297
1355.0,"class Solution {
 public:
  int countMatches(vector<vector<string>>& items, string ruleKey,
                   string ruleValue) {
    const int index = ruleKey == ""type"" ? 0 : ruleKey == ""color"" ? 1 : 2;
    return count_if(begin(items), end(items),
                    [index, &ruleValue](const auto& item) {
      return item[index] == ruleValue;
    });
  }
};",4,364,0.0,-1.0,3.0,1.0,91.0,8.0,0.8900000000000006
1356.0,"class Solution {
 public:
  int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts,
                  int target) {
    int ans = INT_MAX;

    for (const int baseCost : baseCosts)
      dfs(toppingCosts, 0, target, baseCost, ans);

    return ans;
  }

 private:
  void dfs(const vector<int>& toppingCosts, int i, int target, int currCost,
           int& ans) {
    if (abs(currCost - target) < abs(ans - target))
      ans = currCost;
    if (i == toppingCosts.size() || currCost >= target)
      return;

    for (int k = 0; k < 3; ++k)
      dfs(toppingCosts, i + 1, target, currCost + k * toppingCosts[i], ans);
  }
};",9,635,0.0,3.0,3.0,4.0,70.55555555555556,16.0,1.6900000000000013
1357.0,"class Solution {
 public:
  int minOperations(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() * 6 < nums2.size() || nums2.size() * 6 < nums1.size())
      return -1;

    int sum1 = accumulate(begin(nums1), end(nums1), 0);
    int sum2 = accumulate(begin(nums2), end(nums2), 0);
    if (sum1 > sum2)
      return minOperations(nums2, nums1);

    int ans = 0;
    // Increases in nums1 & decreases in nums2
    vector<int> count(6);

    for (const int num : nums1)
      ++count[6 - num];

    for (const int num : nums2)
      ++count[num - 1];

    for (int i = 5; sum2 > sum1;) {
      while (count[i] == 0)
        --i;
      sum1 += i;
      --count[i];
      ++ans;
    }

    return ans;
  }
};",16,717,1.0,4.0,3.0,6.0,44.8125,13.0,4.286875
1358.0,"struct Car {
  int pos;
  int speed;
  double collisionTime;
  Car(int pos, int speed, double collisionTime)
      : pos(pos), speed(speed), collisionTime(collisionTime) {}
};

class Solution {
 public:
  vector<double> getCollisionTimes(vector<vector<int>>& cars) {
    vector<double> ans(cars.size());
    stack<Car> stack;

    for (int i = cars.size() - 1; i >= 0; --i) {
      const int pos = cars[i][0];
      const int speed = cars[i][1];
      while (!stack.empty() && (speed <= stack.top().speed ||
                                getCollisionTime(stack.top(), pos, speed) >=
                                    stack.top().collisionTime))
        stack.pop();
      if (stack.empty()) {
        stack.emplace(pos, speed, INT_MAX);
        ans[i] = -1;
      } else {
        const double collisionTime = getCollisionTime(stack.top(), pos, speed);
        stack.emplace(pos, speed, collisionTime);
        ans[i] = collisionTime;
      }
    }

    return ans;
  }

 private:
  double getCollisionTime(const Car& car, int pos, int speed) {
    return (car.pos - pos) / (double)(speed - car.speed);
  }
};",19,1113,0.0,3.0,8.0,3.0,58.578947368421055,23.0,1.7678947368421056
1359.0,"/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *  public:
 *   bool canMove(char direction);
 *   void move(char direction);
 *   boolean isTarget();
 * };
 */

enum class Grid { kUnvisited, kStart, kTarget, kBlocked, kEmpty };

class Solution {
 public:
  int findShortestPath(GridMaster& master) {
    constexpr int m = 500;
    constexpr int startX = m;
    constexpr int startY = m;
    vector<vector<Grid>> grid(m * 2, vector<Grid>(m * 2, Grid::kUnvisited));

    // Build the grid information by dfs
    dfs(master, grid, startX, startY);

    int ans = 0;
    queue<pair<int, int>> q{{{startX, startY}}};
    grid[startX][startY] = Grid::kBlocked;

    // Find the steps by bfs
    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (grid[x][y] == Grid::kTarget)
            return ans;
          if (grid[x][y] == Grid::kBlocked)
            continue;
          grid[x][y] = Grid::kBlocked;
          q.emplace(x, y);
        }
      }
    }

    return -1;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};
  const vector<char> charTable{'R', 'D', 'L', 'U'};

  void dfs(GridMaster& master, vector<vector<Grid>>& grid, int i, int j) {
    if (grid[i][j] != Grid::kUnvisited)
      return;
    if (master.isTarget())
      grid[i][j] = Grid::kTarget;
    else
      grid[i][j] = Grid::kEmpty;

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k];
      const int y = j + dirs[k + 1];
      const char d = charTable[k];
      const char undoD = charTable[(k + 2) % 4];
      if (master.canMove(d)) {
        master.move(d);
        dfs(master, grid, x, y);
        master.move(undoD);
      } else {
        grid[x][y] = Grid::kBlocked;
      }
    }
  }
};",43,1998,3.0,8.0,16.0,10.0,46.46511627906977,37.0,0.7981395348837186
1360.0,"class Solution {
 public:
  int nearestValidPoint(int x, int y, vector<vector<int>>& points) {
    int ans = -1;
    int minDist = INT_MAX;

    for (int i = 0; i < points.size(); ++i) {
      const int dx = x - points[i][0];
      const int dy = y - points[i][1];
      if (dx == 0 || dy == 0) {
        const int dist = abs(dx + dy);
        if (dist < minDist) {
          minDist = dist;
          ans = i;
        }
      }
    }

    return ans;
  }
};",11,458,0.0,3.0,5.0,3.0,41.63636363636363,14.0,4.372727272727274
1361.0,"class Solution {
 public:
  bool checkPowersOfThree(int n) {
    while (n > 1) {
      const int r = n % 3;
      if (r == 2)
        return false;
      n /= 3;
    }

    return true;
  }
};",5,192,0.0,1.0,3.0,2.0,38.4,5.0,5.804
1362.0,"class Solution {
 public:
  int beautySum(string s) {
    int ans = 0;

    for (int i = 0; i < s.length(); ++i) {
      vector<int> count(26);
      for (int j = i; j < s.length(); ++j) {
        ++count[s[j] - 'a'];
        ans += *max_element(begin(count), end(count)) - getMin(count);
      }
    }

    return ans;
  }

 private:
  int getMin(const vector<int>& count) {
    int mini = INT_MAX;
    for (const int c : count)
      if (c > 0)
        mini = min(mini, c);
    return mini;
  }
};",13,499,0.0,3.0,5.0,4.0,38.38461538461539,13.0,4.765384615384615
1363.0,"class Solution {
 public:
  vector<int> countPairs(int n, vector<vector<int>>& edges,
                         vector<int>& queries) {
    vector<int> ans(queries.size());

    // count[i] := # of edges of node i
    vector<int> count(n + 1);

    // shared[i][j] := # of edges incident to i or j, where i < j
    vector<unordered_map<int, int>> shared(n + 1);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      ++count[u];
      ++count[v];
      ++shared[min(u, v)][max(u, v)];
    }

    vector<int> sortedCount(count);
    sort(begin(sortedCount), end(sortedCount));

    int k = 0;
    for (const int query : queries) {
      for (int i = 1, j = n; i < j;)
        if (sortedCount[i] + sortedCount[j] > query)
          // sortedCount[i] + sortedCount[j] > query
          // sortedCount[i + 1] + sortedCount[j] > query
          // ...
          // sortedCount[j - 1] + sortedCount[j] > query
          // So, there are (j - 1) - i + 1 = j - i pairs > query
          ans[k] += (j--) - i;
        else
          ++i;
      for (int i = 1; i <= n; ++i)
        for (const auto& [j, sh] : shared[i])
          if (count[i] + count[j] > query && count[i] + count[j] - sh <= query)
            --ans[k];
      ++k;
    }

    return ans;
  }
};",21,1304,7.0,8.0,4.0,7.0,62.095238095238095,22.0,1.7714285714285722
1364.0,"class Solution {
 public:
  bool checkOnesSegment(string s) {
    return s.find(""01"") == string::npos;
  }
};",2,109,0.0,0.0,2.0,0.0,54.5,4.0,4.574999999999999
1365.0,"class Solution {
 public:
  int minElements(vector<int>& nums, int limit, int goal) {
    const long sum = accumulate(begin(nums), end(nums), 0L);
    const double diff = abs(goal - sum);
    return ceil(diff / limit);
  }
};",4,225,0.0,0.0,2.0,2.0,56.25,8.0,4.0175
1366.0,"class Solution {
 public:
  int countRestrictedPaths(int n, vector<vector<int>>& edges) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0] - 1;
      const int v = edge[1] - 1;
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {
    constexpr int kMod = 1'000'000'007;
    // dist[i] := distanceToLastNode(i)
    vector<long long> dist(graph.size(), LLONG_MAX);
    // ways[i] := # of restricted path from i -> n
    vector<long long> ways(graph.size());
    using P = pair<long long, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[dst] = 0;
    ways[dst] = 1;
    minHeap.emplace(dist[dst], dst);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (d > dist[u])
        continue;
      for (const auto& [v, w] : graph[u]) {
        if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(dist[v], v);
        }
        if (dist[v] < dist[u]) {
          ways[u] += ways[v];
          ways[u] %= kMod;
        }
      }
    }

    return ways[src];
  }
};",24,1316,3.0,4.0,8.0,6.0,54.833333333333336,24.0,2.0650000000000004
1367.0,"class Solution {
 public:
  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
    constexpr int kMod = 1'000'000'007;
    int ans = 0;
    priority_queue<vector<int>> buysMaxHeap;
    priority_queue<vector<int>, vector<vector<int>>, greater<>> sellsMinHeap;

    for (const vector<int>& order : orders) {
      if (order[2] == 0)
        buysMaxHeap.push(order);
      else
        sellsMinHeap.push(order);
      while (!buysMaxHeap.empty() && !sellsMinHeap.empty() &&
             buysMaxHeap.top()[0] >= sellsMinHeap.top()[0]) {
        const int minAmount = min(buysMaxHeap.top()[1], sellsMinHeap.top()[1]);
        vector<int> buysMaxHeapTop = buysMaxHeap.top();
        buysMaxHeap.pop();
        buysMaxHeapTop[1] -= minAmount;
        if (buysMaxHeapTop[1] > 0)
          buysMaxHeap.push(buysMaxHeapTop);

        vector<int> sellsMinHeapTop = sellsMinHeap.top();
        sellsMinHeap.pop();
        sellsMinHeapTop[1] -= minAmount;
        if (sellsMinHeapTop[1] > 0)
          sellsMinHeap.push(sellsMinHeapTop);
      }
    }

    while (!buysMaxHeap.empty()) {
      ans += buysMaxHeap.top()[1], buysMaxHeap.pop();
      ans %= kMod;
    }

    while (!sellsMinHeap.empty()) {
      ans += sellsMinHeap.top()[1], sellsMinHeap.pop();
      ans %= kMod;
    }

    return ans;
  }
};",21,1304,0.0,8.0,6.0,7.0,62.095238095238095,14.0,2.171428571428571
1368.0,"class Solution {
 public:
  int maxValue(int n, int index, int maxSum) {
    maxSum -= n;

    int l = 0;
    int r = maxSum;

    // Find the first value x s.t. if A[index] = x
    // Sum(A) >= maxSum
    while (l < r) {
      const int m = (l + r) / 2;
      if (getSum(n, index, m) >= maxSum)
        r = m;
      else
        l = m + 1;
    }

    return getSum(n, index, l) > maxSum ? l : l + 1;
  }

 private:
  // Minimum sum if nums[index] = x
  long getSum(int n, int index, int x) {
    long l = min(index, x - 1);
    long r = min(n - index, x);
    long lSum = ((x - 1) + (x - 1 - l + 1)) * l / 2;
    long rSum = (x + (x - r + 1)) * r / 2;
    return lSum + rSum;
  }
};",13,683,3.0,4.0,4.0,4.0,52.53846153846154,12.0,3.711538461538461
1369.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(2) {}
};

class Solution {
 public:
  int countPairs(vector<int>& nums, int low, int high) {
    int ans = 0;

    for (const int num : nums) {
      ans += getCount(num, high + 1) - getCount(num, low);
      insert(num);
    }

    return ans;
  }

 private:
  static constexpr int kHeight = 14;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(int num) {
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = num >> i & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
      ++node->count;
    }
  }

  // # of nums < limit
  int getCount(int num, int limit) {
    int count = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = num >> i & 1;
      const int bitLimit = limit >> i & 1;
      if (bitLimit == 1) {
        if (node->children[bit] != nullptr)
          count += node->children[bit]->count;
        node = node->children[bit ^ 1];
      } else {
        node = node->children[bit];
      }
      if (node == nullptr)
        break;
    }
    return count;
  }
};",28,1282,1.0,6.0,11.0,7.0,45.785714285714285,25.0,2.399285714285714
1370.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int prefixCount = 0;
  int wordCount = 0;
  TrieNode() : children(26) {}
};

class Trie {
 public:
  void insert(string word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
      ++node->prefixCount;
    }
    ++node->wordCount;
  }

  int countWordsEqualTo(string word) {
    shared_ptr<TrieNode> node = find(word);
    return node ? node->wordCount : 0;
  }

  int countWordsStartingWith(string prefix) {
    shared_ptr<TrieNode> node = find(prefix);
    return node ? node->prefixCount : 0;
  }

  void erase(string word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      node = node->children[i];
      --node->prefixCount;
    }
    --node->wordCount;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  shared_ptr<TrieNode> find(const string& s) {
    shared_ptr<TrieNode> node = root;
    for (const char c : s) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        return nullptr;
      node = node->children[i];
    }
    return node;
  }
};",26,1293,0.0,2.0,11.0,5.0,49.73076923076923,26.0,2.144230769230769
1371.0,"class Solution {
 public:
  int reinitializePermutation(int n) {
    int ans = 0;
    int i = 1;

    do {
      if (i < n / 2)
        i = i * 2;
      else
        i = (i - n / 2) * 2 + 1;
      ++ans;
    } while (i != 1);

    return ans;
  }
};",8,249,0.0,3.0,3.0,2.0,31.125,5.0,6.338749999999999
1372.0,"class Solution {
 public:
  string evaluate(string s, vector<vector<string>>& knowledge) {
    string ans;
    unordered_map<string, string> map;

    for (const vector<string>& list : knowledge)
      map[""("" + list[0] + "")""] = list[1];

    for (int i = 0; i < s.length(); ++i) {
      const char c = s[i];
      if (c == '(') {
        const int j = s.find_first_of(')', i);
        const string& key = s.substr(i, j - i + 1);
        ans += map.count(key) ? map[key] : ""?"";
        i = j;
      } else {
        ans += c;
      }
    }

    return ans;
  }
};",13,563,0.0,4.0,5.0,3.0,43.30769230769231,16.0,3.962307692307692
1373.0,"class Solution {
 public:
  int maxNiceDivisors(int primeFactors) {
    if (primeFactors <= 3)
      return primeFactors;
    if (primeFactors % 3 == 0)
      return myPow(3, primeFactors / 3) % kMod;
    if (primeFactors % 3 == 1)
      return 4L * myPow(3, (primeFactors - 4) / 3) % kMod;
    return 2L * myPow(3, (primeFactors - 2) / 3) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  int myPow(long x, int n) {
    if (n == 0)
      return 1;
    if (n & 1)
      return x * myPow(x, n - 1) % kMod;
    return myPow(x * x % kMod, n / 2);
  }
};",9,571,0.0,-1.0,3.0,5.0,63.44444444444444,6.0,3.5699999999999994
1374.0,"/**
 * // This is the GridMaster's API interface.
 * // You should not implement it, or speculate about its implementation
 * class GridMaster {
 *  public:
 *   bool canMove(char direction);
 *   int move(char direction);
 *   boolean isTarget();
 * };
 */

class Solution {
 public:
  int findShortestPath(GridMaster& master) {
    constexpr int m = 100;
    constexpr int startX = m;
    constexpr int startY = m;

    vector<int> target{m * 2, m * 2};
    vector<vector<int>> grid(m * 2, vector<int>(m * 2, -1));
    vector<vector<bool>> seen(m * 2, vector<bool>(m * 2));

    // Build the grid information by DFS.
    dfs(master, grid, startX, startY, target);

    priority_queue<vector<int>, vector<vector<int>>, greater<>> minHeap;
    minHeap.push({0, startX, startY});

    // Find the steps by BFS.
    while (!minHeap.empty()) {
      const vector<int> tuple = minHeap.top();
      const int cost = tuple[0];
      const int i = tuple[1];
      const int j = tuple[2];
      minHeap.pop();
      if (i == target[0] && j == target[1])
        return cost;
      if (seen[i][j])
        continue;
      seen[i][j] = true;
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == 2 * m || y < 0 || y == 2 * m)
          continue;
        if (seen[x][y] || grid[x][y] == -1)
          continue;
        const int nextCost = cost + grid[x][y];
        minHeap.push({nextCost, x, y});
      }
    }

    return -1;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};
  const vector<char> charTable{'R', 'D', 'L', 'U'};

  void dfs(GridMaster& master, vector<vector<int>>& grid, int i, int j,
           vector<int>& target) {
    if (master.isTarget()) {
      target[0] = i;
      target[1] = j;
    }

    for (int k = 0; k < 4; ++k) {
      const int x = i + dirs[k];
      const int y = j + dirs[k + 1];
      const char d = charTable[k];
      const char undoD = charTable[(k + 2) % 4];
      if (master.canMove(d) && grid[x][y] == -1) {
        grid[x][y] = master.move(d);
        dfs(master, grid, x, y, target);
        master.move(undoD);
      }
    }
  }
};",44,2159,3.0,5.0,14.0,10.0,49.06818181818182,50.0,-0.4361363636363649
1375.0,"class Solution {
 public:
  bool areSentencesSimilar(string sentence1, string sentence2) {
    if (sentence1.length() == sentence2.length())
      return sentence1 == sentence2;

    vector<string> words1 = split(sentence1);
    vector<string> words2 = split(sentence2);
    const int m = words1.size();
    const int n = words2.size();
    if (m > n)
      return areSentencesSimilar(sentence2, sentence1);

    int i = 0;  // words1's index
    while (i < m && words1[i] == words2[i])
      ++i;
    while (i < m && words1[i] == words2[i + n - m])
      ++i;

    return i == m;
  }

 private:
  vector<string> split(const string& sentence) {
    vector<string> words;
    istringstream iss(sentence);

    for (string s; iss >> s;)
      words.push_back(s);

    return words;
  }
};",17,786,1.0,2.0,3.0,5.0,46.23529411764706,16.0,3.978823529411765
1376.0,"class Solution {
 public:
  int countNicePairs(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    unordered_map<int, long> count;

    for (const int num : nums)
      ++count[num - rev(num)];

    for (const auto& [_, freq] : count) {
      ans += freq * (freq - 1) / 2;
      ans %= kMod;
    }

    return ans;
  }

 private:
  int rev(int n) {
    int x = 0;
    while (n) {
      x = x * 10 + (n % 10);
      n /= 10;
    }
    return x;
  }
};",12,481,0.0,2.0,5.0,3.0,40.083333333333336,11.0,4.8725000000000005
1377.0,"class Solution {
 public:
  int maxHappyGroups(int batchSize, vector<int>& groups) {
    int happy = 0;
    vector<int> freq(batchSize);

    for (int g : groups) {
      g %= batchSize;
      if (g == 0) {
        ++happy;
      } else if (freq[batchSize - g]) {
        --freq[batchSize - g];
        ++happy;
      } else {
        ++freq[g];
      }
    }

    return happy + dp(freq, 0, batchSize);
  }

 private:
  map<vector<int>, int> memo;

  // Max # of partitions you can form given
  // Current freq and current remainder r
  int dp(const vector<int>& freq, int r, const int& batchSize) {
    if (const auto it = memo.find(freq); it != cend(memo))
      return it->second;

    int ans = 0;

    if (any_of(begin(freq), end(freq), [](int f) { return f != 0; })) {
      for (int i = 0; i < freq.size(); ++i)
        if (freq[i]) {
          vector<int> newFreq(freq);
          --newFreq[i];
          ans = max(ans, dp(newFreq, (r + i) % batchSize, batchSize));
        }
      if (r == 0)
        ++ans;
    }

    return memo[freq] = ans;
  }
};",21,1060,2.0,7.0,10.0,9.0,50.47619047619048,20.0,2.517142857142858
1378.0,"class Solution {
 public:
  string truncateSentence(string s, int k) {
    for (int i = 0; i < s.length(); ++i)
      if (s[i] == ' ' && --k == 0)
        return s.substr(0, i);
    return s;
  }
};",5,198,0.0,1.0,2.0,2.0,39.6,5.0,5.756
1379.0,"class Solution {
 public:
  vector<int> findingUsersActiveMinutes(vector<vector<int>>& logs, int k) {
    vector<int> ans(k);
    unordered_map<int, unordered_set<int>> idToTimes;

    for (const vector<int>& log : logs)
      idToTimes[log[0]].insert(log[1]);

    for (const auto& [_, mins] : idToTimes)
      ++ans[mins.size() - 1];

    return ans;
  }
};",6,359,0.0,2.0,2.0,2.0,59.833333333333336,10.0,3.375
1380.0,"class Solution {
 public:
  int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {
    constexpr int kMod = 1'000'000'007;
    long sumDiff = 0;
    long maxDecrement = 0;
    set<int> sorted(begin(nums1), end(nums1));

    for (int i = 0; i < nums1.size(); ++i) {
      const long currDiff = abs(nums1[i] - nums2[i]);
      sumDiff += currDiff;
      const auto it = sorted.lower_bound(nums2[i]);
      if (it != begin(sorted))
        maxDecrement = max(maxDecrement, currDiff - abs(*prev(it) - nums2[i]));
      if (it != end(sorted))
        maxDecrement = max(maxDecrement, currDiff - abs(*it - nums2[i]));
    }

    return (sumDiff - maxDecrement) % kMod;
  }
};",13,679,0.0,3.0,3.0,11.0,52.23076923076923,9.0,4.03923076923077
1381.0,"class Solution {
 public:
  int countDifferentSubsequenceGCDs(vector<int>& nums) {
    const int maxNum = *max_element(begin(nums), end(nums));
    int ans = 0;
    // factor[i] := gcd of nums having factor i
    vector<int> factor(maxNum + 1);

    for (const int num : nums)
      for (int i = 1; i * i <= num; ++i)
        if (num % i == 0) {
          const int j = num / i;
          factor[i] = __gcd(factor[i], num);
          factor[j] = __gcd(factor[j], num);
        }

    for (int i = 1; i <= maxNum; ++i)
      if (factor[i] == i)
        ++ans;

    return ans;
  }
};",13,582,1.0,5.0,3.0,6.0,44.76923076923077,13.0,4.230769230769232
1382.0,"class Solution {
 public:
  int maximumInvitations(vector<vector<int>>& grid) {
    const int m = grid.size();
    const int n = grid[0].size();
    int ans = 0;
    vector<int> mate(n, -1);  // girl's mate

    for (int i = 0; i < m; ++i)
      if (canInvite(grid, i, vector<bool>(n), mate))
        ++ans;

    return ans;
  }

 private:
  // Returns true if boy i can make an invitation.
  bool canInvite(const vector<vector<int>>& grid, int i, vector<bool>&& seen,
                 vector<int>& mate) {
    // Boy i ask each girl.
    for (int j = 0; j < seen.size(); ++j) {
      if (!grid[i][j] || seen[j])
        continue;
      seen[j] = true;
      if (mate[j] == -1 || canInvite(grid, mate[j], move(seen), mate)) {
        mate[j] = i;  // Match girl j w/ boy i.
        return true;
      }
    }

    return false;
  }
};",16,834,4.0,3.0,5.0,6.0,52.125,18.0,3.1887500000000006
1383.0,"class Solution {
 public:
  int arraySign(vector<int>& nums) {
    int sign = 1;

    for (const int num : nums) {
      if (num == 0)
        return 0;
      if (num < 0)
        sign = -sign;
    }

    return sign;
  }
};",5,224,0.0,2.0,3.0,3.0,44.8,6.0,5.0680000000000005
1384.0,"class Solution {
 public:
  int findTheWinner(int n, int k) {
    // friends[i] := true if i-th friend is left.
    vector<bool> friends(n);

    int friendCount = n;
    int fp = 0;  // friends' pointer

    while (friendCount > 1) {
      for (int i = 0; i < k; ++i, ++fp)
        while (friends[fp % n])  // The friend is not there.
          ++fp;                  // Point to the next one.
      friends[(fp - 1) % n] = true;
      --friendCount;
    }

    const auto it =
        find_if(begin(friends), end(friends), [](int f) { return !f; });
    return distance(begin(friends), it) + 1;
  }
};",12,603,4.0,3.0,4.0,5.0,50.25,10.0,4.2175
1385.0,"class Solution {
 public:
  int minSideJumps(vector<int>& obstacles) {
    constexpr int kInf = 1e6;

    // dp[i] := min jump to reach lane i
    vector<int> dp{kInf, 1, 0, 1};

    for (const int obstacle : obstacles) {
      if (obstacle > 0)
        dp[obstacle] = kInf;
      for (int i = 1; i <= 3; ++i)  // Current
        if (i != obstacle)
          for (int j = 1; j <= 3; ++j)  // Prev
            dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)});
    }

    return *min_element(begin(dp), end(dp));
  }
};",10,515,3.0,5.0,5.0,5.0,51.5,9.0,3.985
1386.0,"class Solution {
 public:
  int badSensor(vector<int>& sensor1, vector<int>& sensor2) {
    const bool oneDefect = canReplace(sensor2, sensor1);
    const bool twoDefect = canReplace(sensor1, sensor2);
    if (oneDefect && twoDefect)
      return -1;
    if (!oneDefect && !twoDefect)
      return -1;
    return oneDefect ? 1 : 2;
  }

 private:
  bool canReplace(const vector<int>& A, const vector<int>& B) {
    int i = 0;  // A's index
    int j = 0;  // B's index
    int droppedValue = -1;

    while (i < A.size())
      if (A[i] == B[j]) {
        ++i;
        ++j;
      } else {
        droppedValue = A[i];
        ++i;
      }

    return j == B.size() - 1 && B[j] != droppedValue;
  }
};",14,700,2.0,2.0,5.0,4.0,50.0,16.0,3.5600000000000005
1387.0,"class Solution {
 public:
  int minOperations(vector<int>& nums) {
    int ans = 0;
    int last = 0;

    for (const int num : nums) {
      ans += max(0, last - num + 1);
      last = max(num, last + 1);
    }

    return ans;
  }
};",6,235,0.0,1.0,3.0,1.0,39.16666666666666,7.0,5.535000000000001
1388.0,"class Solution {
 public:
  vector<int> countPoints(vector<vector<int>>& points,
                          vector<vector<int>>& queries) {
    vector<int> ans;

    for (const vector<int>& query : queries) {
      const int xj = query[0];
      const int yj = query[1];
      const int rj = query[2];
      int count = 0;
      for (const vector<int>& point : points) {
        const int xi = point[0];
        const int yi = point[1];
        if (squared(xi - xj) + squared(yi - yj) <= squared(rj))
          ++count;
      }
      ans.push_back(count);
    }

    return ans;
  }

 private:
  int squared(int x) {
    return x * x;
  }
};",12,640,0.0,2.0,5.0,3.0,53.333333333333336,22.0,2.58
1389.0,"class Solution {
 public:
  vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {
    const int max = (1 << maximumBit) - 1;
    vector<int> ans;
    int xors = 0;

    for (const int num : nums) {
      xors ^= num;
      ans.push_back(xors ^ max);
    }

    reverse(begin(ans), end(ans));
    return ans;
  }
};",8,323,0.0,1.0,3.0,1.0,40.375,10.0,5.126250000000001
1390.0,"class Solution {
 public:
  bool checkIfPangram(string sentence) {
    return unordered_set(begin(sentence), end(sentence)).size() == 26;
  }
};",2,144,0.0,0.0,2.0,1.0,72.0,3.0,3.1000000000000005
1391.0,"class Solution {
 public:
  int maxIceCream(vector<int>& costs, int coins) {
    sort(begin(costs), end(costs));

    for (int i = 0; i < costs.size(); ++i)
      if (coins >= costs[i])
        coins -= costs[i];
      else
        return i;

    return costs.size();
  }
};",7,274,0.0,2.0,2.0,2.0,39.142857142857146,5.0,5.737142857142857
1392.0,"class Solution {
 public:
  vector<int> getOrder(vector<vector<int>>& tasks) {
    const int n = tasks.size();

    // Add index information
    for (int i = 0; i < tasks.size(); ++i)
      tasks[i].push_back(i);

    vector<int> ans;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;
    int i = 0;      // tasks' pointer
    long time = 0;  // Current time

    sort(begin(tasks), end(tasks));
    while (i < n || !minHeap.empty()) {
      if (minHeap.empty())
        time = max(time, static_cast<long>(tasks[i][0]));
      while (i < n && time >= tasks[i][0]) {
        minHeap.emplace(tasks[i][1], tasks[i][2]);
        ++i;
      }
      const auto [procTime, index] = minHeap.top();
      minHeap.pop();
      time += procTime;
      ans.push_back(index);
    }

    return ans;
  }
};",18,821,3.0,4.0,4.0,5.0,45.61111111111112,13.0,4.234999999999999
1393.0,"class Solution {
 public:
  int getXORSum(vector<int>& arr1, vector<int>& arr2) {
    const int xors1 = accumulate(begin(arr1), end(arr1), 0, bit_xor<>());
    const int xors2 = accumulate(begin(arr2), end(arr2), 0, bit_xor<>());
    return xors1 & xors2;
  }
};",4,262,0.0,0.0,2.0,0.0,65.5,8.0,3.1850000000000005
1394.0,"class Solution {
 public:
  ListNode* deleteDuplicatesUnsorted(ListNode* head) {
    ListNode dummy(0, head);
    unordered_map<int, int> count;

    for (ListNode* curr = head; curr; curr = curr->next)
      ++count[curr->val];

    ListNode* curr = &dummy;

    while (curr) {
      while (curr->next && count.count(curr->next->val) &&
             count[curr->next->val] > 1)
        curr->next = curr->next->next;
      curr = curr->next;
    }

    return dummy.next;
  }
};",10,479,0.0,3.0,3.0,3.0,47.9,3.0,5.029000000000001
1395.0,"class Solution {
 public:
  int sumBase(int n, int k) {
    int ans = 0;

    while (n) {
      ans += n % k;
      n /= k;
    }

    return ans;
  }
};",5,153,0.0,1.0,3.0,1.0,30.6,5.0,6.506
1396.0,"class Solution {
 public:
  int maxFrequency(vector<int>& nums, int k) {
    int ans = 0;
    long sum = 0;

    sort(begin(nums), end(nums));

    for (int l = 0, r = 0; r < nums.size(); ++r) {
      sum += nums[r];
      while (sum + k < static_cast<long>(nums[r]) * (r - l + 1))
        sum -= nums[l++];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};",10,370,0.0,2.0,3.0,2.0,37.0,6.0,5.77
1397.0,"class Solution {
 public:
  int longestBeautifulSubstring(string word) {
    int ans = 0;
    int count = 1;

    for (int l = 0, r = 1; r < word.length(); ++r) {
      const char curr = word[r];
      const char prev = word[r - 1];
      if (curr >= prev) {
        if (curr > prev)
          ++count;
        if (count == 5)
          ans = max(ans, r - l + 1);
      } else {
        count = 1;
        l = r;
      }
    }

    return ans;
  }
};",12,450,0.0,5.0,5.0,5.0,37.5,10.0,5.025
1398.0,"class Solution {
 public:
  int maxBuilding(int n, vector<vector<int>>& restrictions) {
    vector<vector<int>> A(restrictions);

    A.push_back({1, 0});
    A.push_back({n, n - 1});
    sort(begin(A), end(A));

    for (int i = 1; i < A.size(); ++i) {
      const int dist = A[i][0] - A[i - 1][0];
      A[i][1] = min(A[i][1], A[i - 1][1] + dist);
    }

    for (int i = A.size() - 2; i >= 0; --i) {
      const int dist = A[i + 1][0] - A[i][0];
      A[i][1] = min(A[i][1], A[i + 1][1] + dist);
    }

    int ans = 0;

    for (int i = 1; i < A.size(); ++i) {
      const int l = A[i - 1][0];
      const int r = A[i][0];
      const int hL = A[i - 1][1];
      const int hR = A[i][1];
      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) / 2);
    }

    return ans;
  }
};",22,784,0.0,3.0,7.0,3.0,35.63636363636363,21.0,4.092727272727274
1399.0,"class Solution {
 public:
  string nextPalindrome(string num) {
    const int n = num.length();
    vector<int> A(n / 2);

    for (int i = 0; i < A.size(); ++i)
      A[i] = num[i] - '0';

    if (!nextPermutation(A))
      return """";

    string s;

    for (const int a : A)
      s += '0' + a;

    if (n & 1)
      return s + num[n / 2] + string(rbegin(s), rend(s));
    return s + string(rbegin(s), rend(s));
  }

 private:
  // Returns true if nums has next permutation
  bool nextPermutation(vector<int>& nums) {
    const int n = nums.size();

    // From back to front, find the first num < nums[i + 1]
    int i;
    for (i = n - 2; i >= 0; --i)
      if (nums[i] < nums[i + 1])
        break;

    if (i < 0)
      return false;

    // From back to front, find the first num > nums[i], swap it with nums[i]
    for (int j = n - 1; j > i; --j)
      if (nums[j] > nums[i]) {
        swap(nums[i], nums[j]);
        break;
      }

    // Reverse nums[i + 1..n - 1]
    reverse(nums, i + 1, n - 1);
    return true;
  }

  void reverse(vector<int>& nums, int l, int r) {
    while (l < r)
      swap(nums[l++], nums[r--]);
  }
};",24,1140,4.0,5.0,5.0,11.0,47.5,22.0,3.085000000000001
1400.0,"class Solution {
 public:
  string replaceDigits(string s) {
    for (int i = 0; i < s.length(); ++i)
      s[i] += s[i - 1] - '0';
    return s;
  }
};",5,152,0.0,1.0,2.0,1.0,30.4,4.0,6.684
1401.0,"class Solution {
 public:
  int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {
    sort(begin(arr), end(arr));
    arr[0] = 1;

    for (int i = 1; i < arr.size(); ++i)
      arr[i] = min(arr[i], arr[i - 1] + 1);

    return arr.back();
  }
};",7,262,0.0,1.0,2.0,1.0,37.42857142857143,4.0,6.051428571428572
1402.0,"class Solution {
 public:
  vector<int> closestRoom(vector<vector<int>>& rooms,
                          vector<vector<int>>& queries) {
    vector<int> ans(queries.size());
    set<int> roomIds;

    for (int i = 0; i < queries.size(); ++i)
      queries[i].push_back(i);

    auto descSize = [](const auto& a, const auto& b) { return a[1] > b[1]; };
    sort(begin(rooms), end(rooms), descSize);
    sort(begin(queries), end(queries), descSize);

    int i = 0;  // rooms' pointer
    for (const vector<int>& query : queries) {
      while (i < rooms.size() && rooms[i][1] >= query[1])
        roomIds.insert(rooms[i++][0]);
      ans[query[2]] = searchClosestRoomId(roomIds, query[0]);
    }

    return ans;
  }

 private:
  int searchClosestRoomId(set<int>& roomIds, int preferred) {
    const auto it = roomIds.lower_bound(preferred);
    const int id1 = it == cbegin(roomIds) ? -1 : *(prev(it));
    const int id2 = it == cend(roomIds) ? -1 : *it;
    if (id1 == -1)
      return id2;
    if (id2 == -1)
      return id1;
    if (abs(preferred - id1) <= abs(preferred - id2))
      return id1;
    return id2;
  }
};",21,1124,1.0,1.0,5.0,6.0,53.523809523809526,20.0,2.862857142857144
1403.0,"class Solution {
 public:
  int getMinDistance(vector<int>& nums, int target, int start) {
    int ans = INT_MAX;

    for (int i = 0; i < nums.size(); ++i)
      if (nums[i] == target)
        ans = min(ans, abs(i - start));

    return ans;
  }
};",6,249,0.0,2.0,2.0,2.0,41.5,7.0,5.325
1404.0,"class Solution {
 public:
  bool splitString(string s) {
    return isValid(s, 0, -1, 0);
  }

 private:
  bool isValid(const string& s, int start, long prev, int segment) {
    if (start == s.length() && segment > 1)
      return true;

    long curr = 0;
    for (int i = start; i < s.length(); ++i) {
      curr = curr * 10 + s[i] - '0';
      if (curr > 9999999999L)
        return false;
      if ((prev == -1 || curr == prev - 1) &&
          isValid(s, i + 1, curr, segment + 1)) {
        return true;
      }
    }

    return false;
  }
};",10,549,0.0,0.0,5.0,4.0,54.9,9.0,3.859
1405.0,"class Solution {
 public:
  int getMinSwaps(string num, int k) {
    string perm = num;

    while (k--)
      next_permutation(begin(perm), end(perm));

    return countSteps(num, perm);
  }

 private:
  int countSteps(const string& A, string& B) {
    int count = 0;

    for (int i = 0, j = 0; i < A.length(); ++i) {
      j = i;
      while (A[i] != B[j])
        ++j;
      while (i < j) {
        swap(B[j], B[j - 1]);
        --j;
        ++count;
      }
    }

    return count;
  }
};",13,494,0.0,3.0,5.0,4.0,38.0,11.0,5.000000000000001
1406.0,"struct T {
  int size;
  int right;
  T(int size, int right) : size(size), right(right) {}
};

class Solution {
 public:
  vector<int> minInterval(vector<vector<int>>& intervals,
                          vector<int>& queries) {
    vector<int> ans(queries.size(), -1);
    auto compare = [](const T& a, const T& b) { return a.size > b.size; };
    priority_queue<T, vector<T>, decltype(compare)> minHeap(compare);
    vector<vector<int>> qs;

    for (int i = 0; i < queries.size(); ++i)
      qs.push_back({queries[i], i});

    sort(begin(intervals), end(intervals));
    sort(begin(qs), end(qs));

    int i = 0;  // intervals' pointer
    for (const vector<int>& q : qs) {
      while (i < intervals.size() && intervals[i][0] <= q[0]) {
        minHeap.emplace(intervals[i][1] - intervals[i][0] + 1, intervals[i][1]);
        ++i;
      }
      while (!minHeap.empty() && minHeap.top().right < q[0])
        minHeap.pop();
      if (!minHeap.empty())
        ans[q[1]] = minHeap.top().size;
    }

    return ans;
  }
};",20,1025,1.0,4.0,8.0,5.0,51.25,17.0,3.0074999999999994
1407.0,"class Solution {
 public:
  int maxDistance(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;
    int i = 0;
    int j = 0;

    while (i < nums1.size() && j < nums2.size())
      if (nums1[i] > nums2[j])
        ++i;
      else
        ans = max(ans, j++ - i);

    return ans;
  }
};",7,294,0.0,3.0,2.0,2.0,42.0,7.0,5.220000000000001
1408.0,"class Solution {
 public:
  int maxSumMinProduct(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    long ans = 0;
    stack<int> stack;
    vector<long> prefix(nums.size() + 1);

    for (int i = 0; i < nums.size(); ++i)
      prefix[i + 1] = prefix[i] + nums[i];

    for (int i = 0; i <= nums.size(); ++i) {
      while (!stack.empty() &&
             (i == nums.size() || nums[stack.top()] > nums[i])) {
        const int minVal = nums[stack.top()];
        stack.pop();
        const long sum =
            stack.empty() ? prefix[i] : prefix[i] - prefix[stack.top() + 1];
        ans = max(ans, minVal * sum);
      }
      stack.push(i);
    }

    return ans % kMod;
  }
};",16,693,0.0,3.0,4.0,3.0,43.3125,10.0,4.681875
1409.0,"class Solution {
 public:
  int largestPathValue(string colors, vector<vector<int>>& edges) {
    const int n = colors.length();
    int ans = 0;
    int processed = 0;
    vector<vector<int>> graph(n);
    vector<int> inDegree(n);
    queue<int> q;
    vector<vector<int>> count(n, vector<int>(26));

    // Build graph
    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      graph[u].push_back(v);
      ++inDegree[v];
    }

    // Topology
    for (int i = 0; i < n; ++i)
      if (inDegree[i] == 0)
        q.push(i);

    while (!q.empty()) {
      const int out = q.front();
      q.pop();
      ++processed;
      ans = max(ans, ++count[out][colors[out] - 'a']);
      for (const int in : graph[out]) {
        for (int i = 0; i < 26; ++i)
          count[in][i] = max(count[in][i], count[out][i]);
        if (--inDegree[in] == 0)
          q.push(in);
      }
    }

    return processed == n ? ans : -1;
  }
};",24,973,2.0,7.0,5.0,7.0,40.54166666666666,25.0,3.2112500000000006
1410.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  bool isWord = false;
  TrieNode() : children(26) {}
};

class Solution {
 public:
  string longestWord(vector<string>& words) {
    string ans;

    for (const string& word : words)
      insert(word);

    for (const string& word : words) {
      if (!allPrefixed(word))
        continue;
      if (ans.length() < word.length() ||
          (ans.length() == word.length() && ans > word))
        ans = word;
    }

    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  void insert(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      if (node->children[i] == nullptr)
        node->children[i] = make_shared<TrieNode>();
      node = node->children[i];
    }
    node->isWord = true;
  }

  bool allPrefixed(const string& word) {
    shared_ptr<TrieNode> node = root;
    for (const char c : word) {
      const int i = c - 'a';
      node = node->children[i];
      if (!node->isWord)
        return false;
    }
    return true;
  }
};",20,1108,0.0,5.0,9.0,8.0,55.4,24.0,1.7739999999999991
1411.0,"class Solution {
 public:
  string sortSentence(string s) {
    vector<string> words;
    istringstream iss(s);
    string word;

    while (iss >> word)
      words.push_back(word);

    sort(begin(words), end(words),
         [](const auto& a, const auto& b) { return a.back() < b.back(); });

    string ans = trim(words[0]);

    for (int i = 1; i < words.size(); ++i)
      ans += "" "" + trim(words[i]);

    return ans;
  }

 private:
  string trim(const string& s) {
    return s.substr(0, s.length() - 1);
  }
};",13,519,0.0,0.0,4.0,2.0,39.92307692307692,12.0,4.966923076923077
1412.0,"class Solution {
 public:
  vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {
    const int m = box.size();
    const int n = box[0].size();
    vector<vector<char>> ans(n, vector<char>(m, '.'));

    for (int i = 0; i < m; ++i)
      for (int j = n - 1, k = n - 1; j >= 0; --j)
        if (box[i][j] != '.') {
          if (box[i][j] == '*')
            k = j;
          ans[k--][m - i - 1] = box[i][j];
        }

    return ans;
  }
};",11,451,0.0,4.0,3.0,4.0,41.0,11.0,4.79
1413.0,"class Solution {
 public:
  int sumOfFlooredPairs(vector<int>& nums) {
    constexpr int kMod = 1'000'000'007;
    const int kMax = *max_element(begin(nums), end(nums));
    long ans = 0;
    // count[i] := # of nums <= i
    vector<int> count(kMax + 1);

    for (const int num : nums)
      ++count[num];

    for (int i = 1; i <= kMax; ++i)
      count[i] += count[i - 1];

    for (int i = 1; i <= kMax; ++i)
      if (count[i] > count[i - 1]) {
        long sum = 0;
        for (int j = 1; i * j <= kMax; ++j) {
          const int lo = i * j - 1;
          const int hi = i * (j + 1) - 1;
          sum += (count[min(hi, kMax)] - count[lo]) * j;
        }
        ans += sum * (count[i] - count[i - 1]);
        ans %= kMod;
      }

    return ans;
  }
};",20,763,1.0,5.0,4.0,5.0,38.15,16.0,4.4665
1414.0,"class Solution {
 public:
  int subsetXORSum(vector<int>& nums) {
    return dfs(nums, 0, 0);
  }

 private:
  int dfs(const vector<int>& nums, int i, int xors) {
    if (i == nums.size())
      return xors;

    const int x = dfs(nums, i + 1, xors);
    const int y = dfs(nums, i + 1, nums[i] ^ xors);
    return x + y;
  }
};",6,327,0.0,-1.0,3.0,1.0,54.5,12.0,3.775
1415.0,"class Solution {
 public:
  int minSwaps(string s) {
    const int ones = count(begin(s), end(s), '1');
    const int zeros = s.length() - ones;
    if (abs(ones - zeros) > 1)
      return -1;
    if (ones > zeros)
      return countSwaps(s, '1');
    if (zeros > ones)
      return countSwaps(s, '0');
    return min(countSwaps(s, '1'), countSwaps(s, '0'));
  }

 private:
  int countSwaps(const string& s, char curr) {
    int swaps = 0;
    for (const char c : s) {
      if (c != curr)
        ++swaps;
      curr ^= 1;
    }
    return swaps / 2;
  }
};",11,558,0.0,1.0,4.0,5.0,50.72727272727273,14.0,3.7345454545454544
1416.0,"class Solution {
 public:
  long rearrangeSticks(int n, int k) {
    if (n == k)
      return 1;
    if (k == 0)
      return 0;
    if (dp[n][k])
      return dp[n][k];
    return dp[n][k] = (rearrangeSticks(n - 1, k - 1) +
                       rearrangeSticks(n - 1, k) * (n - 1)) %
                      kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<int>> dp = vector<vector<int>>(1001, vector<int>(1001));
};",7,450,0.0,0.0,2.0,3.0,64.28571428571429,7.0,3.394285714285713
1417.0,"class Solution {
 public:
  vector<vector<int>> findRLEArray(vector<vector<int>>& encoded1,
                                   vector<vector<int>>& encoded2) {
    vector<vector<int>> ans;
    int i = 0;  // encoded1's index
    int j = 0;  // encodes2's index

    while (i < encoded1.size() && j < encoded2.size()) {
      const int mult = encoded1[i][0] * encoded2[j][0];
      const int minFreq = min(encoded1[i][1], encoded2[j][1]);
      if (!ans.empty() && mult == ans.back()[0])
        ans.back()[1] += minFreq;
      else
        ans.push_back({mult, minFreq});
      encoded1[i][1] -= minFreq;
      encoded2[j][1] -= minFreq;
      if (encoded1[i][1] == 0)
        ++i;
      if (encoded2[j][1] == 0)
        ++j;
    }

    return ans;
  }
};",13,755,2.0,5.0,4.0,4.0,58.07692307692308,11.0,3.2130769230769234
1418.0,"class Solution {
 public:
  bool checkZeroOnes(string s) {
    int longestOnes = 0;
    int longestZeros = 0;
    int currentOnes = 0;
    int currentZeros = 0;

    for (const char c : s)
      if (c == '0') {
        currentOnes = 0;
        longestZeros = max(longestZeros, ++currentZeros);
      } else {
        currentZeros = 0;
        longestOnes = max(longestOnes, ++currentOnes);
      }

    return longestOnes > longestZeros;
  }
};",10,444,0.0,3.0,4.0,2.0,44.4,9.0,4.684
1419.0,"class Solution {
 public:
  bool canReach(string s, int minJump, int maxJump) {
    int count = 0;
    vector<bool> dp(s.length());
    dp[0] = true;

    for (int i = minJump; i < s.length(); ++i) {
      count += dp[i - minJump];
      if (i - maxJump > 0)
        count -= dp[i - maxJump - 1];
      dp[i] = count && s[i] == '0';
    }

    return dp.back();
  }
};",10,368,0.0,2.0,3.0,2.0,36.8,8.0,5.588
1420.0,"class Solution {
 public:
  int stoneGameVIII(vector<int>& stones) {
    const int n = stones.size();
    vector<int> prefix(n);
    // dp[i] := max score diff the current player can get when the game starts
    // At i, i.e., stones[0..i] are merged whose value is prefix[i]
    vector<int> dp(n, INT_MIN);

    partial_sum(begin(stones), end(stones), begin(prefix));

    // Must take all when there're only two stones left
    dp[n - 2] = prefix.back();

    for (int i = n - 3; i >= 0; --i)
      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1]);

    return dp[0];
  }
};",10,577,3.0,1.0,2.0,2.0,57.7,8.0,3.947
1421.0,"class Solution {
 public:
  int minProductSum(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;

    sort(begin(nums1), end(nums1));
    sort(begin(nums2), end(nums2), greater<>());

    for (int i = 0; i < nums1.size(); ++i)
      ans += nums1[i] * nums2[i];

    return ans;
  }
};",8,292,0.0,1.0,2.0,1.0,36.5,6.0,5.9350000000000005
1422.0,"class Solution {
 public:
  int countGoodSubstrings(string s) {
    int ans = 0;

    for (int i = 0; i + 2 < s.length(); ++i) {
      const char a = s[i];
      const char b = s[i + 1];
      const char c = s[i + 2];
      if (a == b || a == c || b == c)
        continue;
      ++ans;
    }

    return ans;
  }
};",10,316,0.0,1.0,3.0,2.0,31.6,11.0,5.816000000000001
1423.0,"class Solution {
 public:
  int minPairSum(vector<int>& nums) {
    int ans = 0;

    sort(begin(nums), end(nums));

    for (int i = 0, j = nums.size() - 1; i < j;)
      ans = max(ans, nums[i++] + nums[j--]);

    return ans;
  }
};",7,234,0.0,1.0,2.0,1.0,33.42857142857143,5.0,6.311428571428571
1424.0,"class Solution {
 public:
  int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
    return dfs(nums1, nums2, vector<int>(1 << nums2.size(), INT_MAX), 0, 0);
  }

 private:
  int dfs(const vector<int>& A, const vector<int>& B, vector<int>&& dp, int i,
          int mask) {
    if (i == A.size())
      return 0;
    if (dp[mask] < INT_MAX)
      return dp[mask];

    for (int j = 0; j < B.size(); ++j)
      if (!(mask >> j & 1))
        dp[mask] = min(dp[mask], (A[i] ^ B[j]) +
                                     dfs(A, B, move(dp), i + 1, mask | 1 << j));

    return dp[mask];
  }
};",8,597,0.0,1.0,3.0,4.0,74.625,14.0,1.6437500000000007
1425.0,"class Solution {
 public:
  string maxValue(string n, int x) {
    bool isNegative = n[0] == '-';

    for (int i = 0; i < n.length(); ++i)
      if (!isNegative && n[i] - '0' < x || isNegative && n[i] - '0' > x)
        return n.substr(0, i) + (char)('0' + x) + n.substr(i);

    return n + (char)('0' + x);
  }
};",6,315,0.0,1.0,2.0,2.0,52.5,8.0,4.295000000000001
1426.0,"struct T {
  int weight;
  int index;
  int freeTime;
  T(int weight, int index, int freeTime)
      : weight(weight), index(index), freeTime(freeTime) {}
};

class Solution {
 public:
  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {
    const int n = servers.size();
    const int m = tasks.size();
    vector<int> ans(m);
    auto compareFree = [](const T& a, const T& b) {
      return a.weight == b.weight ? a.index > b.index : a.weight > b.weight;
    };
    auto compareUsed = [](const T& a, const T& b) {
      if (a.freeTime != b.freeTime)
        return a.freeTime > b.freeTime;
      if (a.weight != b.weight)
        return a.weight > b.weight;
      return a.index > b.index;
    };
    priority_queue<T, vector<T>, decltype(compareFree)> free(compareFree);
    priority_queue<T, vector<T>, decltype(compareUsed)> used(compareUsed);

    for (int i = 0; i < n; ++i)
      free.emplace(servers[i], i, 0);

    for (int i = 0; i < m; ++i) {  // I := current time
      const int executionTime = tasks[i];
      // Pop all servers that'll be free at time i
      while (!used.empty() && used.top().freeTime <= i) {
        const T curr = used.top();
        used.pop();
        free.push(curr);
      }
      if (free.empty()) {
        T server = used.top();
        used.pop();
        ans[i] = server.index;
        server.freeTime += executionTime;
        used.push(server);
      } else {
        T server = free.top();
        free.pop();
        ans[i] = server.index;
        server.freeTime = i + executionTime;
        used.push(server);
      }
    }

    return ans;
  }
};",36,1616,2.0,3.0,10.0,6.0,44.888888888888886,25.0,2.7600000000000016
1427.0,"class Solution {
 public:
  int minSkips(vector<int>& dist, int speed, int hoursBefore) {
    constexpr double kInf = 1e7;
    constexpr double kEps = 1e-9;
    const int n = dist.size();
    // dp[i][j] := min time w/ prev i-th road and j skips
    vector<vector<double>> dp(n + 1, vector<double>(n + 1, kInf));
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i) {
      const double d = dist[i - 1];
      dp[i][0] = ceil(dp[i - 1][0] + d / speed - kEps);
      for (int j = 1; j <= i; ++j)
        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,
                       ceil(dp[i - 1][j] + d / speed - kEps));
    }

    for (int j = 0; j <= n; ++j)
      if (dp[n][j] <= hoursBefore)
        return j;

    return -1;
  }
};",17,725,1.0,3.0,3.0,6.0,42.64705882352941,16.0,4.241764705882353
1428.0,"class Solution {
 public:
  int twoEggDrop(int n) {
    return superEggDrop(2, n);
  }

 private:
  vector<vector<int>> dp;

  int superEggDrop(int k, int N) {
    // dp[k][n] := min # of moves to know F with k eggs and n floors
    dp.resize(k + 1, vector<int>(N + 1, -1));
    return drop(k, N);
  }

  int drop(int k, int n) {
    if (k == 0)  // No eggs -> done
      return 0;
    if (k == 1)  // One egg -> drop from 1-th floor to n-th floor
      return n;
    if (n == 0)  // No floor -> done
      return 0;
    if (n == 1)  // One floor -> drop from that floor
      return 1;
    if (dp[k][n] != -1)
      return dp[k][n];

    //   broken[i] := drop(k - 1, i - 1) is increasing w/ i
    // unbroken[i] := drop(k,     n - i) is decreasing w/ i
    // dp[k][n] := 1 + min(max(broken[i], unbroken[i])), 1 <= i <= n
    // Find the first index i s.t broken[i] >= unbroken[i],
    // Which minimizes max(broken[i], unbroken[i])

    int l = 1;
    int r = n + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      const int broken = drop(k - 1, m - 1);
      const int unbroken = drop(k, n - m);
      if (broken >= unbroken)
        r = m;
      else
        l = m + 1;
    }

    return dp[k][n] = 1 + drop(k - 1, l - 1);
  }
};",18,1246,10.0,1.0,5.0,7.0,69.22222222222223,19.0,1.9099999999999984
1429.0,"class Solution {
 public:
  long long countPairs(vector<int>& nums1, vector<int>& nums2) {
    long long ans = 0;
    vector<int> A(nums1.size());

    for (int i = 0; i < A.size(); ++i)
      A[i] = nums1[i] - nums2[i];

    sort(begin(A), end(A));

    for (int i = 0; i < A.size(); ++i) {
      const auto it = lower_bound(begin(A) + i + 1, end(A), -A[i] + 1);
      ans += cend(A) - it;
    }

    return ans;
  }
};",12,420,0.0,2.0,3.0,2.0,35.0,7.0,5.85
1430.0,"class Solution {
 public:
  bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {
    for (int i = 0; i < 4; ++i) {
      if (mat == target)
        return true;
      rotate(mat);
    }
    return false;
  }

 private:
  void rotate(vector<vector<int>>& M) {
    reverse(begin(M), end(M));
    for (int i = 0; i < M.size(); ++i)
      for (int j = i + 1; j < M.size(); ++j)
        swap(M[i][j], M[j][i]);
  }
};",12,434,0.0,3.0,4.0,4.0,36.16666666666666,9.0,5.425000000000001
1431.0,"class Solution {
 public:
  int reductionOperations(vector<int>& nums) {
    int ans = 0;

    sort(begin(nums), end(nums));

    for (int i = nums.size() - 1; i > 0; --i)
      if (nums[i] != nums[i - 1])
        ans += nums.size() - i;

    return ans;
  }
};",7,261,0.0,2.0,2.0,2.0,37.285714285714285,5.0,5.904285714285715
1432.0,"class Solution {
 public:
  int minFlips(string s) {
    const int n = s.length();
    // count[0][0] := # of '0' in even indices
    // count[0][1] := # of '0' in odd  indices
    // count[1][0] := # of '1' in even indices
    // count[1][1] := # of '1' in odd  indices
    vector<vector<int>> count(2, vector<int>(2));

    for (int i = 0; i < n; ++i)
      ++count[s[i] - '0'][i % 2];

    // Min(make all '0' in even indices + make all '1' in odd indices,
    //     make all '1' in even indices + make all '0' in odd indices)
    int ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1]);

    for (int i = 0; i < n; ++i) {
      --count[s[i] - '0'][i % 2];
      ++count[s[i] - '0'][(n + i) % 2];
      ans = min({ans, count[1][0] + count[0][1], count[0][0] + count[1][1]});
    }

    return ans;
  }
};",13,820,6.0,2.0,4.0,2.0,63.07692307692308,10.0,3.2030769230769227
1433.0,"class Solution {
 public:
  int minWastedSpace(vector<int>& packages, vector<vector<int>>& boxes) {
    constexpr int kMod = 1'000'000'007;
    constexpr long kInf = 1e11;
    const long packagesSum = accumulate(begin(packages), end(packages), 0L);
    long minBoxesSum = kInf;

    sort(begin(packages), end(packages));

    for (auto& box : boxes) {
      sort(begin(box), end(box));
      if (box.back() < packages.back())
        continue;
      long accu = 0;
      long i = 0;
      for (const int b : box) {
        const long j = firstGreaterEqual(packages, b + 1);
        accu += b * (j - i);
        i = j;
      }
      minBoxesSum = min(minBoxesSum, accu);
    }

    return minBoxesSum == kInf ? -1 : (minBoxesSum - packagesSum) % kMod;
  }

 private:
  int firstGreaterEqual(const vector<int>& A, int target) {
    return lower_bound(begin(A), end(A), target) - begin(A);
  }
};",16,893,0.0,1.0,5.0,3.0,55.8125,13.0,3.3168750000000014
1434.0,"class Solution {
 public:
  int maxLength(vector<int>& ribbons, int k) {
    int l = 1;
    int r = accumulate(begin(ribbons), end(ribbons), 0L) / k + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (!isCutPossible(ribbons, m, k))
        r = m;
      else
        l = m + 1;
    }

    return l - 1;
  }

 private:
  bool isCutPossible(const vector<int>& ribbons, int length, int k) {
    int count = 0;
    for (const int ribbon : ribbons)
      count += ribbon / length;
    return count >= k;
  }
};",10,521,0.0,3.0,4.0,3.0,52.1,16.0,3.2910000000000004
1435.0,"class Solution {
 public:
  int chalkReplacer(vector<int>& chalk, int k) {
    k %= accumulate(begin(chalk), end(chalk), 0L);
    if (k == 0)
      return 0;

    for (int i = 0; i < chalk.size(); ++i) {
      k -= chalk[i];
      if (k < 0)
        return i;
    }

    throw;
  }
};",8,284,0.0,1.0,3.0,3.0,35.5,5.0,6.065
1436.0,"class Solution {
 public:
  bool makeEqual(vector<string>& words) {
    vector<int> count(26);

    for (const string& word : words)
      for (const char c : word)
        ++count[c - 'a'];

    return all_of(begin(count), end(count),
                  [&](const int c) { return c % words.size() == 0; });
  }
};",5,313,0.0,1.0,3.0,2.0,62.6,10.0,3.1260000000000003
1437.0,"class Solution {
 public:
  int maximumRemovals(string s, string p, vector<int>& removable) {
    int l = 0;
    int r = removable.size() + 1;

    while (l < r) {
      const int m = (l + r) / 2;
      const string removed = remove(s, removable, m);
      if (isSubsequence(p, removed))
        l = m + 1;
      else
        r = m;
    }

    return l - 1;
  }

 private:
  string remove(const string& s, const vector<int>& removable, int k) {
    string removed(s);
    for (int i = 0; i < k; ++i)
      removed[removable[i]] = '*';
    return removed;
  }

  bool isSubsequence(const string& p, const string& s) {
    int i = 0;  // p's index
    for (int j = 0; j < s.length(); ++j)
      if (p[i] == s[j])
        if (++i == p.length())
          return true;
    return false;
  }
};",18,789,1.0,4.0,5.0,6.0,43.833333333333336,26.0,2.955
1438.0,"class Solution {
 public:
  bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
    vector<int> merged(target.size());

    for (auto& t : triplets)
      if (equal(begin(t), end(t), begin(target),
                [](int a, int b) { return a <= b; }))
        transform(begin(t), end(t), begin(merged), begin(merged),
                  [](int a, int b) { return max(a, b); });

    return merged == target;
  }
};",6,434,0.0,0.0,4.0,3.0,72.33333333333333,9.0,2.3500000000000005
1439.0,"class Solution {
 public:
  vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {
    dp.resize(n + 1, vector<vector<P>>(n + 1, vector<P>(n + 1)));
    const auto [a, b] = solve(firstPlayer, n - secondPlayer + 1, n);
    return {a, b};
  }

 private:
  typedef pair<int, int> P;
  // dp[i][j][k] := (earliest, latest) pair w/ firstPlayer is i-th player from
  // Front, secondPlayer is j-th player from end, and there're k people
  vector<vector<vector<P>>> dp;

  P solve(int l, int r, int k) {
    if (l == r)
      return {1, 1};
    if (l > r)
      swap(l, r);
    if (dp[l][r][k] != pair<int, int>(0, 0))
      return dp[l][r][k];

    int a = INT_MAX;
    int b = INT_MIN;

    // Enumerate all possible positions
    for (int i = 1; i <= l; ++i)
      for (int j = l - i + 1; j <= r - i; ++j) {
        if (i + j > (k + 1) / 2 || i + j < l + r - k / 2)
          continue;
        const auto [x, y] = solve(i, j, (k + 1) / 2);
        a = min(a, x + 1);
        b = max(b, y + 1);
      }

    return dp[l][r][k] = {a, b};
  }
};",20,1057,3.0,2.0,7.0,6.0,52.85,18.0,3.0235000000000003
1440.0,"class Solution {
 public:
  vector<int> findPeakGrid(vector<vector<int>>& mat) {
    int l = 0;
    int r = mat.size() - 1;

    while (l < r) {
      const int m = (l + r) / 2;
      if (*max_element(begin(mat[m]), end(mat[m])) >=
          *max_element(begin(mat[m + 1]), end(mat[m + 1])))
        r = m;
      else
        l = m + 1;
    }

    return {l, getMaxIndex(mat[l])};
  }

 private:
  int getMaxIndex(const vector<int>& A) {
    pair<int, int> res{0, A[0]};
    for (int i = 1; i < A.size(); ++i)
      if (A[i] > res.second)
        res = {i, A[i]};
    return res.first;
  }
};",12,592,0.0,4.0,7.0,4.0,49.333333333333336,13.0,3.6
1441.0,"class Solution {
 public:
  int maxDepthBST(vector<int>& order) {
    int ans = 1;
    map<int, int> map;  // {val: depth}
    map[order[0]] = 1;

    for (int i = 1; i < order.size(); ++i) {
      const int val = order[i];
      const auto l = map.upper_bound(val);  // Min > val
      const auto r = map.lower_bound(val);  // Min >= val
      const int leftDepth = l == cbegin(map) ? 0 : prev(l)->second;
      const int rightDepth = r == cend(map) ? 0 : r->second;
      const int depth = max(leftDepth, rightDepth) + 1;
      ans = max(ans, depth);
      map[val] = depth;
    }

    return ans;
  }
};",15,606,3.0,1.0,4.0,1.0,40.4,17.0,4.484
1442.0,"class Solution {
 public:
  string largestOddNumber(string num) {
    for (int i = num.length() - 1; i >= 0; --i)
      if ((num[i] - '0') & 1)
        return num.substr(0, i + 1);
    return """";
  }
};",5,202,0.0,1.0,2.0,2.0,40.4,4.0,5.784000000000001
1443.0,"class Solution {
 public:
  int numberOfRounds(string startTime, string finishTime) {
    const int start = getMinutes(startTime);
    int finish = getMinutes(finishTime);
    if (start > finish)
      finish += 60 * 24;
    return max(0, finish / 15 - (start + 14) / 15);
  }

 private:
  int getMinutes(const string& s) {
    return 60 * stoi(s.substr(0, 2)) + stoi(s.substr(3));
  }
};",6,388,0.0,0.0,3.0,1.0,64.66666666666667,10.0,3.0
1444.0,"class Solution {
 public:
  int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
    int ans = 0;

    for (int i = 0; i < grid2.size(); ++i)
      for (int j = 0; j < grid2[0].size(); ++j)
        if (grid2[i][j] == 1)
          ans += dfs(grid1, grid2, i, j);

    return ans;
  }

 private:
  int dfs(const vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i,
          int j) {
    if (i < 0 || i == grid1.size() || j < 0 || j == grid2[0].size())
      return 1;
    if (grid2[i][j] != 1)
      return 1;

    grid2[i][j] = 2;  // Mark 2 as visited

    return dfs(grid1, grid2, i + 1, j) & dfs(grid1, grid2, i - 1, j) &
           dfs(grid1, grid2, i, j + 1) & dfs(grid1, grid2, i, j - 1) &
           grid1[i][j];
  }
};",12,761,1.0,2.0,3.0,5.0,63.41666666666666,13.0,2.732500000000001
1445.0,"class Solution {
 public:
  vector<int> minDifference(vector<int>& nums, vector<vector<int>>& queries) {
    vector<vector<int>> numToIndices(101);

    for (int i = 0; i < nums.size(); ++i)
      numToIndices[nums[i]].push_back(i);

    if (numToIndices[nums[0]].size() == nums.size())
      return vector<int>(queries.size(), -1);

    vector<int> ans;

    for (const vector<int>& query : queries) {
      const int l = query[0];
      const int r = query[1];
      int prevNum = -1;
      int minDiff = 101;
      for (int num = 1; num <= 100; ++num) {
        const auto& indices = numToIndices[num];
        const auto it = lower_bound(begin(indices), end(indices), l);
        if (it == cend(indices) || *it > r)
          continue;
        if (prevNum != -1)
          minDiff = min(minDiff, num - prevNum);
        prevNum = num;
      }
      ans.push_back(minDiff == 101 ? -1 : minDiff);
    }

    return ans;
  }
};",20,928,0.0,4.0,4.0,12.0,46.4,19.0,3.443999999999999
1446.0,"class Solution {
 public:
  bool canBeIncreasing(vector<int>& nums) {
    bool removed = false;

    for (int i = 1; i < nums.size(); ++i)
      if (nums[i - 1] >= nums[i]) {
        if (removed)
          return false;
        removed = true;  // Remove nums[i - 1]
        if (i > 1 && nums[i - 2] >= nums[i])
          nums[i] = nums[i - 1];  // Remove nums[i] instead
      }

    return true;
  }
};",8,404,2.0,3.0,3.0,4.0,50.5,5.0,4.675000000000001
1447.0,"class Solution {
 public:
  string removeOccurrences(string s, string part) {
    const int n = s.length();
    const int k = part.length();

    string t(n, ' ');
    int j = 0;  // t's index

    for (int i = 0; i < n; ++i) {
      t[j++] = s[i];
      if (j >= k && t.substr(j - k, k) == part)
        j -= k;
    }

    return t.substr(0, j);
  }
};",10,353,1.0,2.0,3.0,2.0,35.3,11.0,5.463000000000001
1448.0,"class Solution {
 public:
  long long maxAlternatingSum(vector<int>& nums) {
    long even = 0;  // Max alternating sum ending with a even index
    long odd = 0;   // Max alternating sum ending with a odd index

    for (const int num : nums) {
      even = max(even, odd + num);
      odd = even - num;
    }

    return even;
  }
};",6,335,2.0,1.0,3.0,1.0,55.833333333333336,4.0,4.415
1449.0,"class Solution {
 public:
  int maxProductDifference(vector<int>& nums) {
    int max1 = INT_MIN;
    int max2 = INT_MIN;
    int min1 = INT_MAX;
    int min2 = INT_MAX;

    for (const int num : nums) {
      if (num > max1) {
        max2 = max1;
        max1 = num;
      } else if (num > max2) {
        max2 = num;
      }
      if (num < min1) {
        min2 = min1;
        min1 = num;
      } else if (num < min2) {
        min2 = num;
      }
    }

    return max1 * max2 - min1 * min2;
  }
};",12,503,0.0,7.0,7.0,6.0,41.91666666666666,9.0,4.487500000000001
1450.0,"class Solution {
 public:
  vector<vector<int>> rotateGrid(vector<vector<int>>& grid, int k) {
    const int m = grid.size();
    const int n = grid[0].size();
    int t = 0;      // Top
    int l = 0;      // Left
    int b = m - 1;  // Bottom
    int r = n - 1;  // Right

    while (t < b && l < r) {
      const int elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4;
      const int netRotations = k % elementInThisLayer;
      for (int rotate = 0; rotate < netRotations; ++rotate) {
        const int topLeft = grid[t][l];
        for (int j = l; j < r; ++j)
          grid[t][j] = grid[t][j + 1];
        for (int i = t; i < b; ++i)
          grid[i][r] = grid[i + 1][r];
        for (int j = r; j > l; --j)
          grid[b][j] = grid[b][j - 1];
        for (int i = b; i > t; --i)
          grid[i][l] = grid[i - 1][l];
        grid[t + 1][l] = topLeft;
      }
      ++t;
      ++l;
      --b;
      --r;
    }

    return grid;
  }
};",30,953,4.0,6.0,4.0,6.0,31.766666666666666,23.0,4.400999999999999
1451.0,"class Solution {
 public:
  long long wonderfulSubstrings(string word) {
    long long ans = 0;
    int prefix = 0;           // Binary prefix
    vector<int> count(1024);  // Binary prefix count
    count[0] = 1;             // Empty string """"

    for (const char c : word) {
      prefix ^= 1 << c - 'a';
      ans += count[prefix];         // All chars occur even times
      for (int i = 0; i < 10; ++i)  // ('a' + i) occurs odd times
        ans += count[prefix ^ 1 << i];
      ++count[prefix];
    }

    return ans;
  }
};",12,531,5.0,2.0,3.0,2.0,44.25,8.0,5.117500000000001
1452.0,"class Solution {
 public:
  vector<int> buildArray(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0; i < n; ++i)
      nums[i] += n * (nums[nums[i]] % n);

    for (int i = 0; i < n; ++i)
      nums[i] /= n;

    return nums;
  }
};",9,255,0.0,2.0,2.0,2.0,28.33333333333333,7.0,6.51
1453.0,"class Solution {
 public:
  int eliminateMaximum(vector<int>& dist, vector<int>& speed) {
    const int n = dist.size();
    vector<int> arrivalTime(n);

    for (int i = 0; i < n; ++i)
      arrivalTime[i] = (dist[i] - 1) / speed[i];

    sort(begin(arrivalTime), end(arrivalTime));

    for (int i = 0; i < n; ++i)
      if (i > arrivalTime[i])
        return i;

    return n;
  }
};",11,386,0.0,2.0,2.0,3.0,35.09090909090909,9.0,5.701818181818181
1454.0,"class Solution {
 public:
  int countGoodNumbers(long long n) {
    return myPow(4 * 5, n / 2) * (n & 1 ? 5 : 1) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long myPow(long x, long n) {
    if (n == 0)
      return 1;
    if (n & 1)
      return x * myPow(x, n - 1) % kMod;
    return myPow(x * x % kMod, n / 2);
  }
};",6,346,0.0,-1.0,3.0,2.0,57.66666666666666,3.0,4.390000000000001
1455.0,"class Solution {
 public:
  int countTriples(int n) {
    int ans = 0;
    unordered_set<int> squared;

    for (int i = 1; i <= n; ++i)
      squared.insert(i * i);

    for (const int a : squared)
      for (const int b : squared)
        if (squared.count(a + b))
          ++ans;

    return ans;
  }
};",8,307,0.0,4.0,2.0,4.0,38.375,10.0,5.18625
1456.0,"class Solution {
 public:
  int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
    const int m = maze.size();
    const int n = maze[0].size();
    const vector<int> dirs{0, 1, 0, -1, 0};
    int ans = 0;
    queue<pair<int, int>> q{{{entrance[0], entrance[1]}}};
    vector<vector<bool>> seen(m, vector<bool>(n));
    seen[entrance[0]][entrance[1]] = true;

    while (!q.empty()) {
      ++ans;
      for (int sz = q.size(); sz > 0; --sz) {
        const auto [i, j] = q.front();
        q.pop();
        for (int k = 0; k < 4; ++k) {
          const int x = i + dirs[k];
          const int y = j + dirs[k + 1];
          if (x < 0 || x == m || y < 0 || y == n)
            continue;
          if (seen[x][y] || maze[x][y] == '+')
            continue;
          if (x == 0 || x == m - 1 || y == 0 || y == n - 1)
            return ans;
          q.emplace(x, y);
          seen[x][y] = true;
        }
      }
    }

    return -1;
  }
};",23,960,0.0,3.0,9.0,6.0,41.73913043478261,22.0,3.3234782608695648
1457.0,"class Solution {
 public:
  bool sumGame(string num) {
    const int n = num.length();
    double ans = 0.0;

    for (int i = 0; i < n / 2; ++i)
      ans += getExpectation(num[i]);

    for (int i = n / 2; i < n; ++i)
      ans -= getExpectation(num[i]);

    return ans != 0.0;
  }

 private:
  double getExpectation(char c) {
    return c == '?' ? 4.5 : c - '0';
  }
};",11,373,0.0,1.0,3.0,2.0,33.90909090909091,10.0,5.70818181818182
1458.0,"class Solution {
 public:
  int minCost(int maxTime, vector<vector<int>>& edges,
              vector<int>& passingFees) {
    const int n = passingFees.size();
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& edge : edges) {
      const int u = edge[0];
      const int v = edge[1];
      const int w = edge[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1, maxTime, passingFees);
  }

 private:
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst,
               int maxTime, const vector<int>& passingFees) {
    // cost[i] := min cost to reach cities[i]
    vector<int> cost(graph.size(), INT_MAX);
    // dist[i] := min time to reach cities[i]
    vector<int> dist(graph.size(), maxTime + 1);
    using T = tuple<int, int, int>;  // (cost[u], dist[u], u)
    priority_queue<T, vector<T>, greater<>> minHeap;

    cost[src] = passingFees[0];
    dist[src] = 0;
    minHeap.emplace(cost[src], dist[src], src);

    while (!minHeap.empty()) {
      const auto [currCost, d, u] = minHeap.top();
      minHeap.pop();
      for (const auto& [v, w] : graph[u]) {
        if (d + w > maxTime)
          continue;
        // Go from u -> v.
        if (currCost + passingFees[v] < cost[v]) {
          cost[v] = currCost + passingFees[v];
          dist[v] = d + w;
          minHeap.emplace(cost[v], dist[v], v);
        } else if (d + w < dist[v]) {
          dist[v] = d + w;
          minHeap.emplace(currCost + passingFees[v], dist[v], v);
        }
      }
    }

    return cost[dst] == INT_MAX ? -1 : cost[dst];
  }
};",25,1640,4.0,5.0,8.0,6.0,65.6,33.0,0.1760000000000001
1459.0,"class Solution {
 public:
  vector<int> getConcatenation(vector<int>& nums) {
    const int n = nums.size();

    for (int i = 0; i < n; ++i)
      nums.push_back(nums[i]);

    return nums;
  }
};",6,197,0.0,1.0,2.0,1.0,32.833333333333336,6.0,6.265
1460.0,"class Solution {
 public:
  int countPalindromicSubsequence(string s) {
    int ans = 0;
    vector<int> first(26, s.length());
    vector<int> last(26);

    for (int i = 0; i < s.length(); ++i) {
      const int index = s[i] - 'a';
      first[index] = min(first[index], i);
      last[index] = i;
    }

    for (int i = 0; i < 26; ++i)
      if (first[i] < last[i])
        ans += unordered_set<int>(begin(s) + first[i] + 1, begin(s) + last[i])
                   .size();

    return ans;
  }
};",13,500,0.0,3.0,3.0,3.0,38.46153846153846,11.0,5.078461538461539
1461.0,"class Solution {
 public:
  int colorTheGrid(int m, int n) {
    this->m = m;
    this->n = n;
    return dp(0, 0, 0, 0);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  int m;
  int n;
  vector<vector<int>> memo = vector<vector<int>>(1000, vector<int>(1024));

  int dp(int r, int c, int prevColMask, int currColMask) {
    if (c == n)
      return 1;
    if (memo[c][prevColMask])
      return memo[c][prevColMask];
    if (r == m)
      return dp(0, c + 1, currColMask, 0);

    int ans = 0;

    // 1 := red, 2 := green, 3 := blue
    for (int color = 1; color <= 3; ++color) {
      if (getColor(prevColMask, r) == color)
        continue;
      if (r > 0 && getColor(currColMask, r - 1) == color)
        continue;
      ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color));
      ans %= kMod;
    }

    if (r == 0)
      memo[c][prevColMask] = ans;

    return ans;
  }

  // E.g. __ __ __ __ __
  //      01 10 11 11 11
  //      R  G  B  B  B
  // GetColor(0110111111, 3) -> G
  int getColor(int mask, int r) {
    return mask >> r * 2 & 3;
  }

  int setColor(int mask, int r, int color) {
    return mask | color << r * 2;
  }
};",22,1168,5.0,-1.0,6.0,7.0,53.09090909090909,24.0,2.721818181818181
1462.0,"class Solution {
 public:
  TreeNode* canMerge(vector<TreeNode*>& trees) {
    unordered_map<int, TreeNode*> valToNode;  // {val: node}
    unordered_map<int, int> count;            // {val: freq}

    for (TreeNode* tree : trees) {
      valToNode[tree->val] = tree;
      ++count[tree->val];
      if (tree->left)
        ++count[tree->left->val];
      if (tree->right)
        ++count[tree->right->val];
    }

    for (TreeNode* tree : trees)
      if (count[tree->val] == 1) {
        if (isValidBST(tree, nullptr, nullptr, valToNode) &&
            valToNode.size() <= 1)
          return tree;
        return nullptr;
      }

    return nullptr;
  }

 private:
  bool isValidBST(TreeNode* tree, TreeNode* minNode, TreeNode* maxNode,
                  unordered_map<int, TreeNode*>& valToNode) {
    if (tree == nullptr)
      return true;
    if (minNode && tree->val <= minNode->val)
      return false;
    if (maxNode && tree->val >= maxNode->val)
      return false;
    if (!tree->left && !tree->right && valToNode.count(tree->val)) {
      const int val = tree->val;
      tree->left = valToNode[val]->left;
      tree->right = valToNode[val]->right;
      valToNode.erase(val);
    }

    return isValidBST(tree->left, minNode, tree, valToNode) &&
           isValidBST(tree->right, tree, maxNode, valToNode);
  }
};",18,1332,2.0,4.0,8.0,10.0,74.0,8.0,1.9000000000000004
1463.0,"class Solution {
 public:
  int canBeTypedWords(string text, string brokenLetters) {
    int ans = 0;
    istringstream iss(text);
    vector<bool> broken(26);

    for (const char c : brokenLetters)
      broken[c - 'a'] = true;

    for (string word; iss >> word;)
      ans += canBeTyped(word, broken);

    return ans;
  }

 private:
  bool canBeTyped(const string& word, const vector<bool>& broken) {
    for (const char c : word)
      if (broken[c - 'a'])
        return false;
    return true;
  }
};",11,508,0.0,2.0,3.0,4.0,46.18181818181818,16.0,3.943636363636364
1464.0,"class Solution {
 public:
  int addRungs(vector<int>& rungs, int dist) {
    int ans = 0;
    int prev = 0;

    for (const int rung : rungs) {
      ans += (rung - prev - 1) / dist;
      prev = rung;
    }

    return ans;
  }
};",6,231,0.0,1.0,3.0,1.0,38.5,8.0,5.495000000000001
1465.0,"class Solution {
 public:
  long long maxPoints(vector<vector<int>>& points) {
    const int n = points[0].size();
    // dp[j] := max # points you can have if points[i][j] is the most recent
    // Cell you picked
    vector<long long> dp(n);

    for (const vector<int>& row : points) {
      vector<long long> leftToRight(n);
      long long runningMax = 0;

      for (int j = 0; j < n; ++j) {
        runningMax = max(runningMax - 1, dp[j]);
        leftToRight[j] = runningMax;
      }

      vector<long long> rightToLeft(n);
      runningMax = 0;

      for (int j = n - 1; j >= 0; --j) {
        runningMax = max(runningMax - 1, dp[j]);
        rightToLeft[j] = runningMax;
      }

      for (int j = 0; j < n; ++j)
        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j];
    }

    return *max_element(begin(dp), end(dp));
  }
};",19,846,2.0,5.0,5.0,5.0,44.526315789473685,9.0,4.572631578947369
1466.0,"struct TrieNode {
  vector<shared_ptr<TrieNode>> children;
  int count = 0;
  TrieNode() : children(2) {}
};

class Trie {
 public:
  void update(int num, int val) {
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = (num >> i) & 1;
      if (node->children[bit] == nullptr)
        node->children[bit] = make_shared<TrieNode>();
      node = node->children[bit];
      node->count += val;
    }
  }

  int query(int num) {
    int ans = 0;
    shared_ptr<TrieNode> node = root;
    for (int i = kHeight; i >= 0; --i) {
      const int bit = (num >> i) & 1;
      const int targetBit = bit ^ 1;
      if (node->children[targetBit] && node->children[targetBit]->count) {
        ans += 1 << i;
        node = node->children[targetBit];
      } else {
        node = node->children[targetBit ^ 1];
      }
    }
    return ans;
  }

 private:
  static constexpr int kHeight = 17;
  shared_ptr<TrieNode> root = make_shared<TrieNode>();
};

class Solution {
 public:
  vector<int> maxGeneticDifference(vector<int>& parents,
                                   vector<vector<int>>& queries) {
    const int n = parents.size();
    vector<int> ans(queries.size());
    int rootVal = -1;
    vector<vector<int>> tree(n);
    // {node: (index, val)}
    unordered_map<int, vector<pair<int, int>>> nodeToQueries;
    Trie trie;

    for (int i = 0; i < parents.size(); ++i)
      if (parents[i] == -1)
        rootVal = i;
      else
        tree[parents[i]].push_back(i);

    for (int i = 0; i < queries.size(); ++i) {
      const int node = queries[i][0];
      const int val = queries[i][1];
      nodeToQueries[node].emplace_back(i, val);
    }

    dfs(rootVal, trie, tree, nodeToQueries, ans);
    return ans;
  }

 private:
  void dfs(int node, Trie& trie, const vector<vector<int>>& tree,
           const unordered_map<int, vector<pair<int, int>>>& nodeToQueries,
           vector<int>& ans) {
    trie.update(node, 1);

    if (const auto it = nodeToQueries.find(node); it != cend(nodeToQueries))
      for (const auto& [i, val] : it->second)
        ans[i] = trie.query(val);

    for (const int child : tree[node])
      dfs(child, trie, tree, nodeToQueries, ans);

    trie.update(node, -1);
  }
};",46,2253,1.0,11.0,14.0,11.0,48.97826086956522,49.0,-0.7680434782608714
1467.0,"class Solution {
 public:
  int smallestChair(vector<vector<int>>& times, int targetFriend) {
    int nextUnsatChair = 0;
    priority_queue<int, vector<int>, greater<>> emptyChairs;
    using P = pair<int, int>;  // (leaving, chair)
    priority_queue<P, vector<P>, greater<>> occupied;

    for (int i = 0; i < times.size(); ++i)
      times[i].push_back(i);

    sort(begin(times), end(times));

    for (const vector<int>& time : times) {
      const int arrival = time[0];
      const int leaving = time[1];
      const int i = time[2];
      while (!occupied.empty() && occupied.top().first <= arrival)
        emptyChairs.push(occupied.top().second), occupied.pop();
      if (i == targetFriend)
        return emptyChairs.empty() ? nextUnsatChair : emptyChairs.top();
      if (emptyChairs.empty())
        occupied.emplace(leaving, nextUnsatChair++);
      else
        occupied.emplace(leaving, emptyChairs.top()), emptyChairs.pop();
    }

    throw;
  }
};",17,968,1.0,5.0,3.0,5.0,56.94117647058823,18.0,2.63529411764706
1468.0,"class Solution {
 public:
  vector<vector<long long>> splitPainting(vector<vector<int>>& segments) {
    vector<vector<long long>> ans;
    int prevIndex = 0;
    long long runningMix = 0;
    map<int, long long> timeline;

    for (const vector<int>& segment : segments) {
      const int start = segment[0];
      const int end = segment[1];
      const int color = segment[2];
      timeline[start] += color;
      timeline[end] -= color;
    }

    for (const auto& [i, mix] : timeline) {
      if (runningMix > 0)
        ans.push_back({prevIndex, i, runningMix});
      runningMix += mix;
      prevIndex = i;
    }

    return ans;
  }
};",14,645,0.0,3.0,5.0,3.0,46.07142857142857,13.0,4.073571428571429
1469.0,"class Solution {
 public:
  vector<int> canSeePersonsCount(vector<int>& heights) {
    const int n = heights.size();
    vector<int> ans(n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && heights[stack.top()] <= heights[i])
        ++ans[stack.top()], stack.pop();
      if (!stack.empty())
        ++ans[stack.top()];
      stack.push(i);
    }

    return ans;
  }
};",10,410,0.0,3.0,3.0,3.0,41.0,8.0,5.15
1470.0,"class Solution {
 public:
  string maximumNumber(string num, vector<int>& change) {
    bool mutated = false;

    for (char& c : num) {
      const int d = c - '0';
      c = '0' + max(d, change[d]);
      if (mutated && d > change[d])
        return num;
      if (d < change[d])
        mutated = true;
    }

    return num;
  }
};",7,335,0.0,2.0,3.0,3.0,47.85714285714285,8.0,4.592857142857143
1471.0,"class Solution {
 public:
  int maxCompatibilitySum(vector<vector<int>>& students,
                          vector<vector<int>>& mentors) {
    int ans = 0;
    dfs(students, mentors, 0, /*score=*/0, vector<bool>(students.size()), ans);
    return ans;
  }

 private:
  void dfs(const vector<vector<int>>& students,
           const vector<vector<int>>& mentors, int i, int scoreSum,
           vector<bool>&& used, int& ans) {
    if (i == students.size()) {
      ans = max(ans, scoreSum);
      return;
    }
    for (int j = 0; j < students.size(); ++j) {
      if (used[j])
        continue;
      used[j] = true;  // mentors[j] is used.
      dfs(students, mentors, i + 1,
          scoreSum + getScore(students[i], mentors[j]), move(used), ans);
      used[j] = false;
    }
  }

  int getScore(const vector<int>& student, const vector<int>& mentor) {
    int score = 0;
    for (int i = 0; i < student.size(); ++i)
      if (student[i] == mentor[i])
        ++score;
    return score;
  }
};",17,1000,2.0,2.0,6.0,5.0,58.8235294117647,23.0,2.0058823529411764
1472.0,"struct TrieNode {
  unordered_map<string, shared_ptr<TrieNode>> children;
  bool deleted = false;
};

class Solution {
 public:
  vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {
    vector<vector<string>> ans;
    vector<string> path;
    unordered_map<string, vector<shared_ptr<TrieNode>>> subtreeToNodes;

    sort(begin(paths), end(paths));

    for (const vector<string>& path : paths) {
      shared_ptr<TrieNode> node = root;
      for (const string& s : path) {
        if (!node->children.count(s))
          node->children[s] = make_shared<TrieNode>();
        node = node->children[s];
      }
    }

    buildSubtreeToRoots(root, subtreeToNodes);

    for (const auto& [_, nodes] : subtreeToNodes)
      if (nodes.size() > 1)
        for (shared_ptr<TrieNode> node : nodes)
          node->deleted = true;

    constructPath(root, path, ans);
    return ans;
  }

 private:
  shared_ptr<TrieNode> root = make_shared<TrieNode>();

  string buildSubtreeToRoots(
      shared_ptr<TrieNode> node,
      unordered_map<string, vector<shared_ptr<TrieNode>>>& subtreeToNodes) {
    string subtree = ""("";
    for (const auto& [s, child] : node->children)
      subtree += s + buildSubtreeToRoots(child, subtreeToNodes);
    subtree += "")"";
    if (subtree != ""()"")
      subtreeToNodes[subtree].push_back(node);
    return subtree;
  }

  void constructPath(shared_ptr<TrieNode> node, vector<string>& path,
                     vector<vector<string>>& ans) {
    for (const auto& [s, child] : node->children)
      if (!child->deleted) {
        path.push_back(s);
        constructPath(child, path, ans);
        path.pop_back();
      }
    if (!path.empty())
      ans.push_back(path);
  }
};",25,1727,0.0,10.0,8.0,11.0,69.08,22.0,0.5027999999999988
1473.0,"class Solution {
 public:
  // Similar to 1950. Maximum of Minimum Values in All Subarrays
  vector<int> findMaximums(vector<int>& nums) {
    const int n = nums.size();
    vector<int> ans(n);
    // prevMin[i] := index k s.t. nums[k] is the prev min in nums[:i]
    vector<int> prevMin(n, -1);
    // nextMin[i] := index k s.t. nums[k] is the next min in nums[i + 1:]
    vector<int> nextMin(n, n);
    stack<int> stack;

    for (int i = 0; i < n; ++i) {
      while (!stack.empty() && nums[stack.top()] > nums[i]) {
        const int index = stack.top();
        stack.pop();
        nextMin[index] = i;
      }
      if (!stack.empty())
        prevMin[i] = stack.top();
      stack.push(i);
    }

    // For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.
    // nums[i] is the minimun in nums[l..r].
    // So, the ans[r - l + 1] will be at least nums[i].
    for (int i = 0; i < n; ++i) {
      const int sz = nextMin[i] - prevMin[i] - 1;
      ans[sz - 1] = max(ans[sz - 1], nums[i]);
    }

    // ans[i] should always >= ans[i + 1:].
    for (int i = n - 2; i >= 0; --i)
      ans[i] = max(ans[i], ans[i + 1]);

    return ans;
  }
};",21,1159,7.0,5.0,5.0,6.0,55.19047619047619,16.0,3.112857142857144
1474.0,"class Solution {
 public:
  long long numberOfWeeks(vector<int>& milestones) {
    // The best strategy is to pick ""max, nonMax, max, nonMax, ..."".
    const int max = *max_element(begin(milestones), end(milestones));
    const long long sum = accumulate(begin(milestones), end(milestones), 0LL);
    const long long nonMax = sum - max;
    return min(sum, 2 * nonMax + 1);
  }
};",5,380,1.0,0.0,2.0,0.0,76.0,6.0,2.4800000000000004
1475.0,"class Solution {
 public:
  long long minimumPerimeter(long long neededApples) {
    long long l = 1;
    long long r = 100'000;  // \sqrt [3] {10^{15}}

    while (l < r) {
      const long long m = (l + r) / 2;
      if (numApples(m) >= neededApples)
        r = m;
      else
        l = m + 1;
    }

    return l * 8;
  }

 private:
  // Returns the # of apples at k-th level.
  //    k := the level making perimeter = 8k
  // p(k) := # of apples at k-th level on the perimeter
  // n(k) := # of apples at k-th level not no the perimeter
  //
  // p(1) =             1 + 2
  // p(2) =         3 + 2 + 3 + 4
  // p(3) =     5 + 4 + 3 + 4 + 5 + 6
  // p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8
  // p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k
  //      = k + 2k^2 + 2*k(k-1)/2
  //      = k + 2k^2 + k^2 - k = 3k^2
  //
  // n(k) = p(1) + p(2) + p(3) + ... + p(k)
  //      = 3*1  + 3*4  + 3*9  + ... + 3*k^2
  //      = 3 * (1 + 4 + 9 + ... + k^2)
  //      = 3 * k(k+1)(2k+1)/6 = k(k+1)(2k+1)/2
  // So, the # of apples at k-th level should be
  //   k(k+1)(2k+1)/2 * 4 = 2k(k+1)(2k+1)
  long long numApples(long long k) {
    return 2 * k * (k + 1) * (2 * k + 1);
  }
};",8,1176,20.0,2.0,6.0,2.0,147.0,2.0,-3.109999999999996
1476.0,"class Solution {
 public:
  int countSpecialSubsequences(vector<int>& nums) {
    // dp[i][j] := # of special subseqs of nums[i:] and prev + 1 = j
    dp.resize(nums.size(), vector<int>(4, -1));
    return countSpecialSubsequences(nums, 0, -1);
  }

 private:
  static constexpr int kMod = 1'000'000'007;
  vector<vector<int>> dp;

  int countSpecialSubsequences(const vector<int>& nums, int i, int prev) {
    if (i == nums.size())
      return prev == 2;
    if (dp[i][prev + 1] != -1)
      return dp[i][prev + 1];

    long ans = 0;

    // Not include nums[i]
    ans += countSpecialSubsequences(nums, i + 1, prev);

    // Include nums[i]
    if (nums[i] == prev)
      ans += countSpecialSubsequences(nums, i + 1, prev);
    if (prev == -1 && nums[i] == 0)
      ans += countSpecialSubsequences(nums, i + 1, 0);
    if (prev == 0 && nums[i] == 1)
      ans += countSpecialSubsequences(nums, i + 1, 1);
    if (prev == 1 && nums[i] == 2)
      ans += countSpecialSubsequences(nums, i + 1, 2);

    ans %= kMod;
    return dp[i][prev + 1] = ans;
  }
};",15,1057,3.0,3.0,3.0,6.0,70.46666666666667,11.0,2.3180000000000005
1477.0,"class Solution {
 public:
  bool checkMove(vector<vector<char>>& board, int rMove, int cMove,
                 char color) {
    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},
                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};

    for (const auto& [dx, dy] : dirs) {
      int cellsCount = 2;
      int i = rMove + dx;
      int j = cMove + dy;
      while (0 <= i && i < 8 && 0 <= j && j < 8) {
        // No free cells in between.
        if (board[i][j] == '.')
          break;
        // Need >= 3 cells.
        if (cellsCount == 2 && board[i][j] == color)
          break;
        // >= 3 cells.
        if (board[i][j] == color)
          return true;
        i += dx;
        j += dy;
        ++cellsCount;
      }
    }

    return false;
  }
};",12,804,3.0,2.0,13.0,5.0,67.0,13.0,1.8900000000000008
1478.0,"class Solution {
 public:
  int minSpaceWastedKResizing(vector<int>& nums, int k) {
    // dp[i][k] := min space wasted for nums[i:] if you can resize k times
    dp.resize(nums.size(), vector<int>(k + 1, -1));
    return minSpaceWasted(nums, 0, k);
  }

 private:
  static constexpr int kMax = 200'000'000;
  vector<vector<int>> dp;

  int minSpaceWasted(const vector<int>& nums, int i, int k) {
    if (i == nums.size())
      return 0;
    if (k == -1)
      return kMax;
    if (dp[i][k] != -1)
      return dp[i][k];

    int ans = kMax;
    int sum = 0;
    int maxNum = nums[i];

    for (int j = i; j < nums.size(); ++j) {
      sum += nums[j];
      maxNum = max(maxNum, nums[j]);
      const int wasted = maxNum * (j - i + 1) - sum;
      ans = min(ans, minSpaceWasted(nums, j + 1, k - 1) + wasted);
    }

    return dp[i][k] = ans;
  }
};",18,850,1.0,2.0,4.0,6.0,47.22222222222222,18.0,3.63
1479.0,"class Solution {
 public:
  long long maxProduct(string s) {
    const int n = s.length();
    long long ans = 1;
    // l[i] := max length of palindromes in s[0..i)
    vector<int> l = manacher(s, n);
    // r[i] := max length of palindromes in s[i..n)
    vector<int> r = manacher(string(rbegin(s), rend(s)), n);
    reverse(begin(r), end(r));

    for (int i = 0; i + 1 < n; ++i)
      ans = max(ans, (long long)l[i] * r[i + 1]);

    return ans;
  }

 private:
  vector<int> manacher(const string& s, int n) {
    vector<int> maxExtends(n);
    vector<int> l2r(n, 1);
    int center = 0;

    for (int i = 0; i < n; ++i) {
      const int r = center + maxExtends[center] - 1;
      const int mirrorIndex = center - (i - center);
      int extend = i > r ? 1 : min(maxExtends[mirrorIndex], r - i + 1);
      while (i - extend >= 0 && i + extend < n &&
             s[i - extend] == s[i + extend]) {
        l2r[i + extend] = 2 * extend + 1;
        ++extend;
      }
      maxExtends[i] = extend;
      if (i + maxExtends[i] >= r)
        center = i;
    }

    for (int i = 1; i < n; ++i)
      l2r[i] = max(l2r[i], l2r[i - 1]);

    return l2r;
  }
};",26,1156,2.0,4.0,5.0,5.0,44.46153846153846,22.0,3.338461538461539
1480.0,"class Solution {
 public:
  int minStoneSum(vector<int>& piles, int k) {
    int ans = accumulate(begin(piles), end(piles), 0);
    priority_queue<int> maxHeap;

    for (const int pile : piles)
      maxHeap.push(pile);

    for (int i = 0; i < k; ++i) {
      const int maxPile = maxHeap.top();
      maxHeap.pop();
      maxHeap.push(maxPile - maxPile / 2);
      ans -= maxPile / 2;
    }

    return ans;
  }
};",11,416,0.0,2.0,3.0,2.0,37.81818181818182,11.0,5.196363636363636
1481.0,"class Solution {
 public:
  int minSwaps(string s) {
    // Cancel out all the matched pairs, then we'll be left with ""]]]..[[["".
    // The answer is ceil(# of unmatched pairs / 2).
    int unmatched = 0;

    for (const char c : s)
      if (c == '[')
        ++unmatched;
      else if (unmatched > 0)  // c == ']' and there's a match.
        --unmatched;

    return (unmatched + 1) / 2;
  }
};",5,399,3.0,4.0,2.0,3.0,79.8,6.0,1.978
1482.0,"class Solution {
 public:
  vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
    vector<int> ans;
    // tail[i] := the minimum tail of all increasing subseqs having length i + 1
    // it's easy to see that tail must be an increasing array
    vector<int> tail;

    for (const int obstacle : obstacles)
      if (tail.empty() || obstacle >= tail.back()) {
        tail.push_back(obstacle);
        ans.push_back(tail.size());
      } else {
        const int index = firstGreater(tail, obstacle);
        tail[index] = obstacle;
        ans.push_back(index + 1);
      }

    return ans;
  }

 private:
  // Find the first index l s.t A[l] > target
  // Returns A.size() if can't find
  int firstGreater(const vector<int>& A, int target) {
    return upper_bound(begin(A), end(A), target) - begin(A);
  }
};",10,834,4.0,3.0,5.0,3.0,83.4,13.0,0.8739999999999988
1483.0,"class Solution {
 public:
  int binarySearchableNumbers(vector<int>& nums) {
    const int n = nums.size();
    int ans = 0;
    // prefixMaxs[i] := max(nums[0:i])
    vector<int> prefixMaxs(n);
    // suffixMins[i] := min(nums[i + 1:])
    vector<int> suffixMins(n);

    // Fill `prefixMaxs`.
    prefixMaxs[0] = INT_MIN;
    for (int i = 1; i < n; ++i)
      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1]);

    // Fill `suffixMins`.
    suffixMins[n - 1] = INT_MAX;
    for (int i = n - 2; i >= 0; --i)
      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1]);

    for (int i = 0; i < n; ++i)
      if (prefixMaxs[i] < nums[i] && nums[i] < suffixMins[i])
        ++ans;

    return ans;
  }
};",17,704,4.0,4.0,2.0,4.0,41.41176470588236,11.0,4.972941176470588
1484.0,"class Solution {
 public:
  vector<int> rearrangeArray(vector<int>& nums) {
    sort(begin(nums), end(nums));
    for (int i = 1; i < nums.size(); i += 2)
      swap(nums[i], nums[i - 1]);
    return nums;
  }
};",6,212,0.0,1.0,2.0,1.0,35.333333333333336,4.0,6.24
1485.0,"class Solution {
 public:
  int minNonZeroProduct(int p) {
    // Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].
    const long n = 1L << p;
    const long halfCount = n / 2 - 1;
    return myPow(n - 2, halfCount) * ((n - 1) % kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  long myPow(long x, long n) {
    if (n == 0)
      return 1L;
    x %= kMod;
    if (n & 1)
      return x * myPow(x, n - 1) % kMod;
    return myPow(x * x, n / 2) % kMod;
  }
};",9,507,1.0,-1.0,3.0,2.0,56.333333333333336,6.0,4.25
1486.0,"class Solution {
 public:
  int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
    int ans = 0;
    int l = 1;
    int r = cells.size() - 1;

    while (l <= r) {
      const int m = (l + r) / 2;
      if (canWalk(m, row, col, cells)) {
        ans = m;
        l = m + 1;
      } else {
        r = m - 1;
      }
    }

    return ans;
  }

 private:
  const vector<int> dirs{0, 1, 0, -1, 0};

  bool canWalk(int day, int row, int col, const vector<vector<int>>& cells) {
    vector<vector<int>> matrix(row, vector<int>(col));
    for (int i = 0; i < day; ++i) {
      const int x = cells[i][0] - 1;
      const int y = cells[i][1] - 1;
      matrix[x][y] = 1;
    }

    queue<pair<int, int>> q;

    for (int j = 0; j < col; ++j)
      if (matrix[0][j] == 0) {
        q.emplace(0, j);
        matrix[0][j] = 1;
      }

    while (!q.empty()) {
      const auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        const int x = i + dirs[k];
        const int y = j + dirs[k + 1];
        if (x < 0 || x == row || y < 0 || y == col)
          continue;
        if (matrix[x][y] == 1)
          continue;
        if (x == row - 1)
          return true;
        q.emplace(x, y);
        matrix[x][y] = 1;
      }
    }

    return false;
  }
};",33,1292,0.0,7.0,11.0,10.0,39.15151515151515,34.0,1.996363636363636
1487.0,"struct T {
  long long sum;
  int count;
};

class Solution {
 public:
  int equalToDescendants(TreeNode* root) {
    return dfs(root).count;
  }

 private:
  T dfs(TreeNode* root) {
    if (root == nullptr)
      return T{.sum = 0, .count = 0};
    T left = dfs(root->left);
    T right = dfs(root->right);
    return T{.sum = root->val + left.sum + right.sum,
             .count = left.count + right.count +
                      (root->val == left.sum + right.sum ? 1 : 0)};
  }
};",9,485,0.0,-1.0,6.0,1.0,53.888888888888886,4.0,4.449999999999999
1488.0,"class Solution {
 public:
  long long maxMatrixSum(vector<vector<int>>& matrix) {
    long long absSum = 0;
    int minAbs = INT_MAX;
    int oddNeg = 0;  // 0 := even neg, 1 := odd neg

    for (const vector<int>& row : matrix)
      for (const int num : row) {
        absSum += abs(num);
        minAbs = min(minAbs, abs(num));
        if (num < 0)
          oddNeg ^= 1;
      }

    return absSum - oddNeg * minAbs * 2;
  }
};",8,431,1.0,3.0,3.0,3.0,53.875,8.0,4.031250000000001
1489.0,"class Solution {
 public:
  int countPaths(int n, vector<vector<int>>& roads) {
    vector<vector<pair<int, int>>> graph(n);

    for (const vector<int>& road : roads) {
      const int u = road[0];
      const int v = road[1];
      const int w = road[2];
      graph[u].emplace_back(v, w);
      graph[v].emplace_back(u, w);
    }

    return dijkstra(graph, 0, n - 1);
  }

 private:
  // Similar to 1786. Number of Restricted Paths From First to Last Node
  int dijkstra(const vector<vector<pair<int, int>>>& graph, int src, int dst) {
    constexpr int kMod = 1'000'000'007;
    vector<long long> dist(graph.size(), LLONG_MAX);
    vector<long long> ways(graph.size());
    using P = pair<long long, int>;  // (d, u)
    priority_queue<P, vector<P>, greater<>> minHeap;

    dist[src] = 0;
    ways[src] = 1;
    minHeap.emplace(dist[src], src);

    while (!minHeap.empty()) {
      const auto [d, u] = minHeap.top();
      minHeap.pop();
      if (d > dist[u])
        continue;
      for (const auto& [v, w] : graph[u])
        if (d + w < dist[v]) {
          dist[v] = d + w;
          ways[v] = ways[u];
          minHeap.emplace(dist[v], v);
        } else if (d + w == dist[v]) {
          ways[v] += ways[u];
          ways[v] %= kMod;
        }
    }

    return ways[dst];
  }
};",25,1295,2.0,5.0,7.0,6.0,51.8,24.0,2.298
1490.0,"class Solution {
 public:
  string findDifferentBinaryString(vector<string>& nums) {
    const int bitSize = nums[0].length();
    const int maxNum = 1 << bitSize;
    unordered_set<int> numsSet;

    for (const string& num : nums)
      numsSet.insert(stoi(num, nullptr, 2));

    for (int num = 0; num < maxNum; ++num)
      if (!numsSet.count(num))
        return std::bitset<16>(num).to_string().substr(16 - bitSize);

    throw;
  }
};",9,440,0.0,2.0,2.0,4.0,48.888888888888886,11.0,4.26
1491.0,"class Solution {
 public:
  int minimizeTheDifference(vector<vector<int>>& mat, int target) {
    const int minSum = getMinSum(mat);
    if (minSum >= target)  // No need to consider any larger combination.
      return minSum - target;

    const int maxSum = getMaxSum(mat);
    dp.resize(mat.size(), vector<int>(maxSum + 1, -1));
    return minimizeTheDifference(mat, 0, 0, target);
  }

 private:
  vector<vector<int>> dp;

  int minimizeTheDifference(const vector<vector<int>>& mat, int i, int sum,
                            int target) {
    if (i == mat.size())
      return abs(sum - target);
    if (dp[i][sum] != -1)
      return dp[i][sum];
    int ans = INT_MAX;
    for (const int num : mat[i])
      ans = min(ans, minimizeTheDifference(mat, i + 1, sum + num, target));
    return dp[i][sum] = ans;
  }

  int getMinSum(const vector<vector<int>>& mat) {
    return accumulate(begin(mat), end(mat), 0,
                      [](int subtotal, const vector<int>& row) {
      return subtotal + *min_element(begin(row), end(row));
    });
  }

  int getMaxSum(const vector<vector<int>>& mat) {
    return accumulate(begin(mat), end(mat), 0,
                      [](int subtotal, const vector<int>& row) {
      return subtotal + *max_element(begin(row), end(row));
    });
  }
};",16,1291,1.0,-4.0,7.0,8.0,80.6875,31.0,-0.5018750000000001
1492.0,"class Solution {
 public:
  vector<int> recoverArray(int n, vector<int>& sums) {
    sort(begin(sums), end(sums));
    return recover(sums);
  }

 private:
  vector<int> recover(const vector<int>& sums) {
    if (sums.size() == 1)  // sums[0] must be 0.
      return {};

    // Either num or -num must be in the final array.
    //  num + sumsExcludingNum = sumsIncludingNum
    // -num + sumsIncludingNum = sumsExcludingNum
    unordered_map<int, int> count;
    for (const int sum : sums)
      ++count[sum];

    const int num = sums[1] - sums[0];
    vector<int> sumsExcludingNum;
    vector<int> sumsIncludingNum;
    bool chooseSumsIncludingNum = false;

    for (const int sum : sums) {
      if (count[sum] == 0)
        continue;
      --count[sum];
      --count[sum + num];
      sumsExcludingNum.push_back(sum);
      sumsIncludingNum.push_back(sum + num);
      if (sum + num == 0)
        chooseSumsIncludingNum = true;
    }

    // Choose `sumsExludingNum` by default since we want to gradually strip
    // `num` from each sum in `sums` to have the final array. However, we should
    // always choose the group of sums with 0 since it's a must-have.
    vector<int> recovered =
        recover(chooseSumsIncludingNum ? sumsIncludingNum : sumsExcludingNum);
    recovered.push_back(chooseSumsIncludingNum ? -num : num);
    return recovered;
  }
};",19,1366,7.0,2.0,5.0,5.0,71.89473684210526,19.0,1.4894736842105267
1493.0,"class Solution {
 public:
  int widestPairOfIndices(vector<int>& nums1, vector<int>& nums2) {
    int ans = 0;
    int prefix = 0;
    unordered_map<int, int> prefixToIndex{{0, -1}};

    for (int i = 0; i < nums1.size(); ++i) {
      prefix += nums1[i] - nums2[i];
      if (const auto it = prefixToIndex.find(prefix); it != cend(prefixToIndex))
        ans = max(ans, i - it->second);
      else
        prefixToIndex[prefix] = i;
    }

    return ans;
  }
};",11,462,0.0,3.0,5.0,2.0,42.0,10.0,4.740000000000001
1494.0,"class Solution {
 public:
  // Similar to 215. Kth Largest Element in an Array
  string kthLargestNumber(vector<string>& nums, int k) {
    auto compare = [](const string& a, const string& b) {
      return a.length() == b.length() ? a > b : a.length() > b.length();
    };
    priority_queue<string, vector<string>, decltype(compare)> minHeap(compare);

    for (const string& num : nums) {
      minHeap.push(num);
      if (minHeap.size() > k)
        minHeap.pop();
    }

    return minHeap.top();
  }
};",7,509,1.0,1.0,4.0,2.0,72.71428571428571,12.0,1.9957142857142856
1495.0,"class Solution {
 public:
  int minSessions(vector<int>& tasks, int sessionTime) {
    for (int numSessions = 1; numSessions <= tasks.size(); ++numSessions)
      if (dfs(tasks, 0, vector<int>(numSessions), sessionTime))
        return numSessions;
    throw;
  }

  // Returns true if we can assign tasks[s:] to `sessions`. Note that `sessions`
  // may be occupied by some tasks.
  bool dfs(const vector<int>& tasks, int s, vector<int>&& sessions,
           const int& sessionTime) {
    if (s == tasks.size())
      return true;

    for (int& session : sessions) {
      // Can't assign tasks[s] to this session.
      if (session + tasks[s] > sessionTime)
        continue;
      // Assign tasks[s] to this session.
      session += tasks[s];
      if (dfs(tasks, s + 1, move(sessions), sessionTime))
        return true;
      // Backtracking.
      session -= tasks[s];
      // If it's the first time we assign tasks[s] to this session. Then, future
      // `session`s can't satisfy either.
      if (session == 0)
        return false;
    }

    return false;
  }
};",12,1078,7.0,2.0,4.0,9.0,89.83333333333333,14.0,0.4350000000000005
1496.0,"class Solution {
 public:
  // Similar to 940. Distinct Subsequences II
  int numberOfUniqueGoodSubsequences(string binary) {
    constexpr int kMod = 1'000'000'007;
    // endsWith[i] := # of subseqs ends with '0' + i
    vector<int> endsWith(2);

    for (const char c : binary) {
      endsWith[c - '0'] = (endsWith[0] + endsWith[1]) % kMod;
      // Don't cound '0' since we want to avoid the leading zeros case.
      // However, we can always count '1'.
      if (c == '1')
        ++endsWith[1];
    }

    // Count '0' in the end.
    return (endsWith[0] + endsWith[1] +
            (binary.find('0') == string::npos ? 0 : 1)) %
           kMod;
  }
};",6,660,5.0,3.0,3.0,2.0,110.0,8.0,-0.8600000000000012
1497.0,"class Solution {
 public:
  int catchMaximumAmountofPeople(vector<int>& team, int dist) {
    int ans = 0;
    int i = 0;  // 0's index
    int j = 0;  // 1's index

    while (i < team.size() && j < team.size())
      if (i + dist < j || team[i] != 0) {
        // Find the next 0 that can be caught by 1.
        ++i;
      } else if (j + dist < i || team[j] != 1) {
        // Find the next 1 that can catch 0.
        ++j;
      } else {
        // team[j] catches team[i], so move both.
        ++ans;
        ++i;
        ++j;
      }

    return ans;
  }
};",10,564,5.0,6.0,5.0,3.0,56.4,7.0,3.764
1498.0,"class Solution {
 public:
  vector<vector<int>> findFarmland(vector<vector<int>>& land) {
    vector<vector<int>> ans;

    for (int i = 0; i < land.size(); ++i)
      for (int j = 0; j < land[0].size(); ++j)
        if (land[i][j] == 1) {
          int x = i;
          int y = j;
          dfs(land, i, j, x, y);
          ans.push_back({i, j, x, y});
        }

    return ans;
  }

 private:
  void dfs(vector<vector<int>>& land, int i, int j, int& x, int& y) {
    if (i < 0 || i == land.size() || j < 0 || j == land[0].size())
      return;
    if (land[i][j] != 1)
      return;
    land[i][j] = 2;  // Mark as visited.
    x = max(x, i);
    y = max(y, j);
    dfs(land, i + 1, j, x, y);
    dfs(land, i, j + 1, x, y);
  }
};",18,733,1.0,3.0,5.0,5.0,40.72222222222222,14.0,4.495000000000001
1499.0,"class Solution {
 public:
  int numberOfGoodSubsets(vector<int>& nums) {
    const vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    const int n = 1 << primes.size();
    const int maxNum = *max_element(begin(nums), end(nums));
    vector<long> dp(n);
    vector<int> count(maxNum + 1);

    dp[0] = 1;

    for (const int num : nums)
      ++count[num];

    for (int num = 2; num <= maxNum; ++num) {
      if (count[num] == 0)
        continue;
      if (num % 4 == 0 || num % 9 == 0 || num % 25 == 0)
        continue;
      const int numPrimesMask = getPrimesMask(num, primes);
      for (int primesMask = 0; primesMask < n; ++primesMask) {
        if ((primesMask & numPrimesMask) > 0)
          continue;
        const int nextPrimesMask = primesMask | numPrimesMask;
        dp[nextPrimesMask] += dp[primesMask] * count[num];
        dp[nextPrimesMask] %= kMod;
      }
    }

    return myPow(2, count[1]) *
           (accumulate(begin(dp) + 1, end(dp), 0L) % kMod) % kMod;
  }

 private:
  static constexpr int kMod = 1'000'000'007;

  int getPrimesMask(int num, const vector<int>& primes) {
    int primesMask = 0;
    for (int i = 0; i < primes.size(); ++i)
      if (num % primes[i] == 0)
        primesMask |= 1 << i;
    return primesMask;
  }

  int myPow(long x, int n) {
    if (n == 0)
      return 1;
    if (n & 1)
      return x * myPow(x, n - 1) % kMod;
    return myPow(x * x % kMod, n / 2);
  }
};",29,1432,0.0,3.0,7.0,10.0,49.37931034482759,27.0,2.2558620689655173
1500.0,"class Solution {
 public:
  int numberOfWeakCharacters(vector<vector<int>>& properties) {
    // Sort properties by attack descendingly, then by defense ascendingly
    sort(begin(properties), end(properties),
         [](const vector<int>& a, const vector<int>& b) {
      return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0];
    });

    int ans = 0;
    int maxDefense = 0;

    for (const vector<int>& property : properties) {
      const int defense = property[1];
      if (defense < maxDefense)
        ++ans;
      maxDefense = max(maxDefense, defense);
    }

    return ans;
  }
};",9,587,1.0,1.0,4.0,2.0,65.22222222222223,13.0,2.5700000000000003
1501.0,"class Solution {
 public:
  int firstDayBeenInAllRooms(vector<int>& nextVisit) {
    constexpr int kMod = 1'000'000'007;
    const int n = nextVisit.size();
    // dp[i] := # of days to visit room i for first time
    vector<int> dp(n);

    // Whenever we visit i, visit times of room[0..i - 1] are all even.
    // Therefore, rooms before i can be seen as reset and we can safely reuse
    // dp[0..i - 1] as first-time visit to get second-time visit
    for (int i = 1; i < n; ++i)
      // The total days to visit room[i] is the sum of
      //   * dp[i - 1]: 1st-time visit room[i - 1]
      //   * 1: visit room[nextVisit[i - 1]]
      //   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]
      //   * 1: visit room[i]
      dp[i] = (2L * dp[i - 1] - dp[nextVisit[i - 1]] + 2 + kMod) % kMod;

    return dp.back();
  }
};",8,840,9.0,2.0,2.0,4.0,105.0,8.0,-0.129999999999999
1502.0,"class UnionFind {
 public:
  UnionFind(int n) : id(n), rank(n) {
    iota(begin(id), end(id), 0);
  }

  void unionByRank(int u, int v) {
    const int i = find(u);
    const int j = find(v);
    if (i == j)
      return;
    if (rank[i] < rank[j]) {
      id[i] = id[j];
    } else if (rank[i] > rank[j]) {
      id[j] = id[i];
    } else {
      id[i] = id[j];
      ++rank[j];
    }
  }

  int find(int u) {
    return id[u] == u ? u : id[u] = find(id[u]);
  }

 private:
  vector<int> id;
  vector<int> rank;
};

class Solution {
 public:
  bool gcdSort(vector<int>& nums) {
    const int maxNum = *max_element(begin(nums), end(nums));
    const vector<int> minPrimeFactor = sieveEratosthenes(maxNum + 1);
    UnionFind uf(maxNum + 1);

    for (const int num : nums)
      for (const int primeFactor : getPrimeFactors(num, minPrimeFactor))
        uf.unionByRank(num, primeFactor);

    vector<int> sortedNums(nums);
    sort(begin(sortedNums), end(sortedNums));

    for (int i = 0; i < nums.size(); ++i)
      // Can't swap nums[i] with sortedNums[i].
      if (uf.find(nums[i]) != uf.find(sortedNums[i]))
        return false;

    return true;
  }

 private:
  // Gets min prime factor of i, where 1 < i <= n.
  vector<int> sieveEratosthenes(int n) {
    vector<int> minPrimeFactor(n + 1);
    iota(begin(minPrimeFactor) + 2, end(minPrimeFactor), 2);
    for (int i = 2; i * i < n; ++i)
      if (minPrimeFactor[i] == i)  // `i` is prime.
        for (int j = i * i; j < n; j += i)
          minPrimeFactor[j] = min(minPrimeFactor[j], i);
    return minPrimeFactor;
  }

  vector<int> getPrimeFactors(int num, const vector<int>& minPrimeFactor) {
    vector<int> primeFactors;
    while (num > 1) {
      const int divisor = minPrimeFactor[num];
      primeFactors.push_back(divisor);
      while (num % divisor == 0)
        num /= divisor;
    }
    return primeFactors;
  }
};",36,1888,3.0,9.0,12.0,12.0,52.44444444444444,38.0,0.3399999999999998
1503.0,"class Solution {
 public:
  int findInteger(int k, int digit1, int digit2) {
    const int minDigit = min(digit1, digit2);
    const int maxDigit = max(digit1, digit2);
    const vector<int> digits = minDigit == maxDigit
                                   ? vector<int>{minDigit}
                                   : vector<int>{minDigit, maxDigit};
    queue<int> q;

    for (const int digit : digits)
      q.push(digit);

    while (!q.empty()) {
      const int u = q.front();
      q.pop();
      if (u > k && u % k == 0)
        return u;
      if (u == 0)
        continue;
      for (const int digit : digits) {
        const long nextNum = u * 10L + digit;
        if (nextNum > INT_MAX)
          continue;
        q.push(nextNum);
      }
    }

    return -1;
  }
};",14,779,0.0,3.0,6.0,6.0,55.642857142857146,21.0,2.3521428571428578
,"#include <iostream>
using namespace std;

int main() {
    int arr[] = {1,2,3,4,5};
    int sum = 0;
    for(int i=0; i<5; i++) sum += arr[i];
    cout << sum;
    return 0;
}",10,175,,,,,,,
,"#include <iostream>
using namespace std;

int main() {
    int arr[] = {1,2,3,4,5};
    int sum = 0;
    for(int i=0; i<5; i++) sum += arr[i];
    cout << sum;
    return 0;
}",10,175,,,,,,,
